// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.26;

import { console } from "forge-std/console.sol";

import {
    AccessControlUpgradeable
} from "../../../lib/common/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol";

import { IERC20 } from "../../../lib/common/src/interfaces/IERC20.sol";

import { ContinuousIndexingMath } from "../../../lib/common/src/libs/ContinuousIndexingMath.sol";
import { UIntMath } from "../../../lib/common/src/libs/UIntMath.sol";

import { IndexingMath } from "../../libs/IndexingMath.sol";

import { IMExtension } from "../../interfaces/IMExtension.sol";
import { IMTokenLike } from "../../interfaces/IMTokenLike.sol";
import { ISwapFacility } from "../../swap/interfaces/ISwapFacility.sol";

import { IMDualBackedFee } from "./interfaces/IMDualBackedFee.sol";
import { IContinuousIndexing } from "./interfaces/IContinuousIndexing.sol";

import { MExtension } from "../../MExtension.sol";

abstract contract MDualBackedFeeStorageLayout {
    /// @custom:storage-location erc7201:M0.storage.MYieldFee
    struct MDualBackedFeeStorageStruct {
        // NOTE: Slot 1
        uint256 totalSupply;
        // NOTE: Slot 2
        uint112 totalPrincipal;
        uint128 latestIndex;
        uint16 feeRate;
        // NOTE: Slot 3
        address feeRecipient;
        uint40 latestUpdateTimestamp;
        uint32 latestRate;
        bool isEarningEnabled;
        // NOTE: Slot 4
        uint112 secondaryIndex;
        uint96 secondarySupply;
        // NOTE: Slot 5
        IERC20 secondaryBacker;
        // NOTE: Slot 6
        mapping(address account => uint256 balance) balanceOf;
        // NOTE: Slot 7
        mapping(address account => uint112 principal) principalOf;
        // NOTE: Slot 8
        mapping(address account => address claimRecipient) claimRecipients;
    }

    // keccak256(abi.encode(uint256(keccak256("M0.storage.MDualBackedFee")) - 1)) & ~bytes32(uint256(0xff))
    bytes32 private constant _M_DUAL_BACKED_FEE_STORAGE_LOCATION =
        0x9d728c135b5b2cd0ace61885d69c4f72215f10f82e77822fb7c6bf472237dd00;

    function _getMDualBackedFeeStorageLocation() internal pure returns (MDualBackedFeeStorageStruct storage $) {
        assembly {
            $.slot := _M_DUAL_BACKED_FEE_STORAGE_LOCATION
        }
    }
}

/**
 * @title MYieldFee
 * @notice Upgradeable ERC20 Token contract for wrapping M into a non-rebasing token.
 *         Extended to take a fee from the yield generated by M.
 * @dev    All holders of this ERC20 token are earners.
 * @author M0 Labs
 */
contract MDualBackedFee is
    IContinuousIndexing,
    IMDualBackedFee,
    AccessControlUpgradeable,
    MDualBackedFeeStorageLayout,
    MExtension
{
    /* ============ Variables ============ */

    /// @inheritdoc IMDualBackedFee
    uint16 public constant ONE_HUNDRED_PERCENT = 10_000;

    /// @inheritdoc IMDualBackedFee
    bytes32 public constant FEE_MANAGER_ROLE = keccak256("FEE_MANAGER_ROLE");

    /// @inheritdoc IMDualBackedFee
    bytes32 public constant CLAIM_RECIPIENT_MANAGER_ROLE = keccak256("CLAIM_RECIPIENT_MANAGER_ROLE");

    /// @inheritdoc IMDualBackedFee
    bytes32 public constant COLLATERAL_MANAGER_ROLE = keccak256("COLLATERAL_MANAGER_ROLE");

    /* ============ Constructor ============ */

    /**
     * @custom:oz-upgrades-unsafe-allow constructor
     * @notice Constructs MYieldFee Implementation contract
     * @dev    Sets immutable storage.
     * @param  mToken       The address of $M token.
     * @param  swapFacility The address of Swap Facility.
     */
    constructor(address mToken, address swapFacility) MExtension(mToken, swapFacility) {}

    /* ============ Initializer ============ */

    /**
     * @notice Initializes the generic M Yield Fee extension token.
     * @param name                  The name of the token (e.g. "M Yield Fee").
     * @param symbol                The symbol of the token (e.g. "MYF").
     * @param feeRate_              The fee rate, in bps, that will be taken from the yield generated by M.
     * @param feeRecipient_         The address of the recipient of the yield fee.
     * @param admin                 The address administrating the M extension. Can grant and revoke roles.
     * @param feeManager            The address managing the fee rate and recipient.
     * @param claimRecipientManager The address managing claim recipients for accounts.
     */
    function initialize(
        string memory name,
        string memory symbol,
        uint16 feeRate_,
        address feeRecipient_,
        address admin,
        address feeManager,
        address claimRecipientManager,
        address collateralManager,
        IERC20 secondarySupply
    ) public virtual initializer {
        if (admin == address(0)) revert ZeroAdmin();
        if (feeManager == address(0)) revert ZeroFeeManager();
        if (claimRecipientManager == address(0)) revert ZeroClaimRecipientManager();

        __MExtension_init(name, symbol);

        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(FEE_MANAGER_ROLE, feeManager);
        _grantRole(CLAIM_RECIPIENT_MANAGER_ROLE, claimRecipientManager);
        _grantRole(COLLATERAL_MANAGER_ROLE, collateralManager);

        _setFeeRate(feeRate_);
        _setFeeRecipient(feeRecipient_);

        _getMDualBackedFeeStorageLocation().latestIndex = ContinuousIndexingMath.EXP_SCALED_ONE;
        _getMDualBackedFeeStorageLocation().secondaryIndex = ContinuousIndexingMath.EXP_SCALED_ONE;

        _getMDualBackedFeeStorageLocation().secondaryBacker = secondarySupply;
    }

    /* ============ Interactive Functions ============ */

    /// @inheritdoc IMDualBackedFee
    function claimYieldFor(address account) public returns (uint256) {
        if (account == address(0)) revert ZeroAccount();

        uint256 yield_ = accruedYieldOf(account);

        if (yield_ == 0) return 0;

        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        // NOTE: No change in principal, only the balance is updated to include the newly claimed yield.
        unchecked {
            $.balanceOf[account] += yield_;
            $.totalSupply += yield_;
        }

        $.secondaryIndex = uint112(
            (($.totalSupply - $.secondarySupply) * ContinuousIndexingMath.EXP_SCALED_ONE) / totalSupply()
        );

        address claimRecipient_ = claimRecipientFor(account);

        // Emit the appropriate `YieldClaimed` and `Transfer` events, depending on the claim override recipient
        emit YieldClaimed(account, claimRecipient_, yield_);
        emit Transfer(address(0), claimRecipient_, yield_);

        if (claimRecipient_ == account) return yield_;

        // Distribute the yield to the claim recipient.
        _update(account, claimRecipient_, yield_);

        return yield_;
    }

    /// @inheritdoc IMDualBackedFee
    function claimFee() public returns (uint256) {
        uint256 yieldFee_ = totalAccruedFee();

        console.log("yieldFee_", yieldFee_);

        if (yieldFee_ == 0) return 0;

        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        address recipient_ = $.feeRecipient;

        emit FeeClaimed(msg.sender, recipient_, yieldFee_);

        uint256 mFee_ = (yieldFee_ * $.secondaryIndex) / ContinuousIndexingMath.EXP_SCALED_ONE;

        // NOTE: Round up to allow claiming the whole amount of yield fee.
        _mint(recipient_, mFee_, IndexingMath.getPrincipalAmountRoundedUp(mFee_, currentIndex()));
        _mint(recipient_, yieldFee_ - mFee_, 0);

        $.secondaryIndex = uint112(
            ((totalSupply() - secondarySupply()) * ContinuousIndexingMath.EXP_SCALED_ONE) / totalSupply()
        );

        return yieldFee_;
    }

    /// @inheritdoc IMExtension
    function enableEarning() external override {
        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        if ($.isEarningEnabled) revert EarningIsEnabled();

        $.isEarningEnabled = true;

        // NOTE: update the index to store the latest state, current index won't accrue since `latestRate` is 0.
        emit EarningEnabled(updateIndex());

        IMTokenLike(mToken).startEarning();
    }

    /// @inheritdoc IMExtension
    function disableEarning() external override {
        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        if (!$.isEarningEnabled) revert EarningIsDisabled();

        // NOTE: update the index to store the latest state.
        emit EarningDisabled(updateIndex());

        // NOTE: disable earning by resetting values to their defaults.
        delete $.isEarningEnabled;
        delete $.latestRate;

        IMTokenLike(mToken).stopEarning(address(this));
    }

    /// @inheritdoc IContinuousIndexing
    function updateIndex() public virtual returns (uint128 currentIndex_) {
        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        // NOTE: return early if earning is disabled, no need to update the index.
        if (!$.isEarningEnabled) return $.latestIndex;

        // NOTE: Read the current M token rate adjusted by fee rate split.
        uint32 rate_ = earnerRate();
        uint40 latestAccrualTimestamp_ = _latestEarnerRateAccrualTimestamp();

        // NOTE: Return early if the index has already been updated in the current block and the rate has not changed.
        if ($.latestUpdateTimestamp == latestAccrualTimestamp_ && $.latestRate == rate_) return $.latestIndex;

        // NOTE: `currentIndex()` depends on `_latestRate`, so only update it after this.
        $.latestIndex = currentIndex_ = currentIndex();
        $.latestRate = rate_;
        $.latestUpdateTimestamp = latestAccrualTimestamp_;

        emit IndexUpdated(currentIndex_, rate_);
    }

    /// @inheritdoc IMDualBackedFee
    function setFeeRate(uint16 feeRate_) external onlyRole(FEE_MANAGER_ROLE) {
        _setFeeRate(feeRate_);

        // NOTE: Update the index to store the new adjusted rate.
        if (isEarningEnabled()) updateIndex();
    }

    /// @inheritdoc IMDualBackedFee
    function setFeeRecipient(address feeRecipient_) external onlyRole(FEE_MANAGER_ROLE) {
        // Claim fee for the previous fee recipient.
        claimFee();

        _setFeeRecipient(feeRecipient_);
    }

    /// @inheritdoc IMDualBackedFee
    function setClaimRecipient(
        address account,
        address claimRecipient
    ) external onlyRole(CLAIM_RECIPIENT_MANAGER_ROLE) {
        if (account == address(0)) revert ZeroAccount();
        if (claimRecipient == address(0)) revert ZeroClaimRecipient();

        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        if ($.claimRecipients[account] == claimRecipient) return;

        // NOTE: Optionally consider not claiming yield for the previous claim recipient.
        claimYieldFor(account);

        $.claimRecipients[account] = claimRecipient;

        emit ClaimRecipientSet(account, claimRecipient);
    }

    /* ============ External/Public view functions ============ */

    /// @inheritdoc IMDualBackedFee
    function accruedYieldOf(address account) public view returns (uint256) {
        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        uint256 mBalance = ($.balanceOf[account] * $.secondaryIndex) / ContinuousIndexingMath.EXP_SCALED_ONE;

        console.log("_ _ _mBalance", mBalance);

        return _getAccruedYield(mBalance, $.principalOf[account], currentIndex());
    }

    /// @inheritdoc IERC20
    function balanceOf(address account) public view override returns (uint256) {
        return _getMDualBackedFeeStorageLocation().balanceOf[account];
    }

    /// @inheritdoc IMDualBackedFee
    function balanceWithYieldOf(address account) external view returns (uint256) {
        unchecked {
            return balanceOf(account) + accruedYieldOf(account);
        }
    }

    /// @inheritdoc IMDualBackedFee
    function principalOf(address account) public view returns (uint112) {
        return _getMDualBackedFeeStorageLocation().principalOf[account];
    }

    /// @inheritdoc IContinuousIndexing
    function currentIndex() public view virtual override(IContinuousIndexing, MExtension) returns (uint128) {
        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        if (!$.isEarningEnabled) return $.latestIndex;

        // NOTE: Safe to use unchecked here, since `block.timestamp` is always greater than `latestUpdateTimestamp`.
        unchecked {
            return
                // NOTE: Cap the index to `type(uint128).max` to prevent overflow in present value math.
                UIntMath.bound128(
                    ContinuousIndexingMath.multiplyIndicesDown(
                        $.latestIndex,
                        ContinuousIndexingMath.getContinuousIndex(
                            ContinuousIndexingMath.convertFromBasisPoints($.latestRate),
                            uint32(_latestEarnerRateAccrualTimestamp() - $.latestUpdateTimestamp)
                        )
                    )
                );
        }
    }

    /// @inheritdoc IMDualBackedFee
    function earnerRate() public view virtual returns (uint32) {
        return
            isEarningEnabled()
                ? UIntMath.safe32(
                    (uint256(ONE_HUNDRED_PERCENT - feeRate()) * _currentEarnerRate()) / ONE_HUNDRED_PERCENT
                )
                : 0;
    }

    /// @inheritdoc IMExtension
    function isEarningEnabled() public view override returns (bool) {
        return _getMDualBackedFeeStorageLocation().isEarningEnabled;
    }

    /// @inheritdoc IContinuousIndexing
    function latestIndex() public view returns (uint128) {
        return _getMDualBackedFeeStorageLocation().latestIndex;
    }

    /// @inheritdoc IContinuousIndexing
    function latestRate() public view returns (uint32) {
        return _getMDualBackedFeeStorageLocation().latestRate;
    }

    /// @inheritdoc IContinuousIndexing
    function latestUpdateTimestamp() public view returns (uint40) {
        return _getMDualBackedFeeStorageLocation().latestUpdateTimestamp;
    }

    function secondaryIndex() public view returns (uint112) {
        return _getMDualBackedFeeStorageLocation().secondaryIndex;
    }

    function secondarySupply() public view returns (uint112) {
        return _getMDualBackedFeeStorageLocation().secondarySupply;
    }

    function mBacking(address account) public view returns (uint256) {
        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();
        return ($.balanceOf[account] * $.secondaryIndex) / ContinuousIndexingMath.EXP_SCALED_ONE;
    }

    function secondaryBacking(address account) public view returns (uint256) {
        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();
        return $.balanceOf[account] - mBacking(account);
    }

    /// @inheritdoc IMDualBackedFee

    function projectedTotalSupply() public view returns (uint256) {
        return projectedMBacking() + _getMDualBackedFeeStorageLocation().secondarySupply;
    }

    function projectedMBacking() public view returns (uint256) {
        return
            IndexingMath.getPresentAmountRoundedUp(_getMDualBackedFeeStorageLocation().totalPrincipal, currentIndex());
    }

    /// @inheritdoc IMDualBackedFee
    function totalAccruedYield() public view returns (uint256) {
        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();
        uint256 _mBacking = $.totalSupply - $.secondarySupply;
        return _getAccruedYield(_mBacking, $.totalPrincipal, currentIndex());
    }

    /// @inheritdoc IMDualBackedFee
    function totalAccruedFee() public view returns (uint256) {
        uint256 mBalance_ = _mBalanceOf(address(this));
        uint256 projectedMBacking_ = projectedMBacking();

        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();
        console.log("mBalance", mBalance_);
        console.log("mBacking", $.totalSupply - $.secondarySupply);
        console.log("projectedMBacking", projectedMBacking_);

        unchecked {
            return mBalance_ > projectedMBacking_ ? mBalance_ - projectedMBacking_ : 0;
        }
    }

    /// @inheritdoc IMDualBackedFee
    function totalPrincipal() public view returns (uint112) {
        return _getMDualBackedFeeStorageLocation().totalPrincipal;
    }

    /// @inheritdoc IERC20
    function totalSupply() public view returns (uint256) {
        return _getMDualBackedFeeStorageLocation().totalSupply;
    }

    /// @inheritdoc IMDualBackedFee
    function feeRate() public view returns (uint16) {
        return _getMDualBackedFeeStorageLocation().feeRate;
    }

    /// @inheritdoc IMDualBackedFee
    function feeRecipient() public view returns (address) {
        return _getMDualBackedFeeStorageLocation().feeRecipient;
    }

    /// @inheritdoc IMDualBackedFee
    function claimRecipientFor(address account) public view returns (address) {
        address recipient_ = _getMDualBackedFeeStorageLocation().claimRecipients[account];

        // If no claim recipient is set, return the account itself.
        return recipient_ == address(0) ? account : recipient_;
    }

    function wrapSecondary(address recipient, uint256 amount) public {
        // NOTE: `msg.sender` is always SwapFacility contract.
        //       `ISwapFacility.msgSender()` is used to ensure that the original caller is passed to `_beforeWrap`.
        _wrapSecondary(ISwapFacility(msg.sender).msgSender(), recipient, amount);
    }

    /* ============ Internal Interactive Functions ============ */

    function _wrapSecondary(address account, address recipient, uint256 amount) internal {
        _revertIfInvalidRecipient(recipient);
        _revertIfInsufficientAmount(amount);

        // NOTE: `msg.sender` is always SwapFacility contract.
        // NOTE: The behavior of `IMTokenLike.transferFrom` is known, so its return can be ignored.
        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        $.secondaryBacker.transferFrom(msg.sender, address(this), amount);

        unchecked {
            $.secondarySupply += uint96(amount);
        }

        // call mint() with zero principal
        _mint(recipient, amount, 0);

        $.secondaryIndex = uint112(
            ((totalSupply() - $.secondarySupply) * ContinuousIndexingMath.EXP_SCALED_ONE) / totalSupply()
        );
    }

    /**
     * @dev   Mints `amount` tokens to `recipient`.
     * @param recipient The address that will receive tokens.
     * @param amount    The amount of tokens to mint.
     */
    function _mint(address recipient, uint256 amount) internal override {
        _mint(recipient, amount, IndexingMath.getPrincipalAmountRoundedDown(amount, currentIndex()));
    }

    /**
     * @dev   Mints `amount` tokens to `recipient` with a specified principal.
     * @param recipient The address that will receive tokens.
     * @param amount    The amount of tokens to mint.
     * @param principal The principal amount to be associated with the minted tokens.
     */
    function _mint(address recipient, uint256 amount, uint112 principal) internal {
        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        // NOTE: Can be `unchecked` because the max amount of  M is never greater than `type(uint240).max`.
        //       Can be `unchecked` because UIntMath.safe112 is used for principal addition safety for `totalPrincipal`
        unchecked {
            $.balanceOf[recipient] += amount;
            $.totalSupply += amount;

            $.totalPrincipal = UIntMath.safe112(uint256($.totalPrincipal) + principal);
            // No need for `UIntMath.safe112`, `principalOf[recipient]` cannot be greater than `totalPrincipal`.
            $.principalOf[recipient] += principal;
        }

        emit Transfer(address(0), recipient, amount);
    }

    /**
     * @dev   Burns `amount` tokens from `account`.
     * @param account The address whose account balance will be decremented.
     * @param amount  The present amount of tokens to burn.
     */
    function _burn(address account, uint256 amount) internal override {
        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        // Slightly overestimate the principal amount to be burned and use safe value to avoid underflow in unchecked block
        uint112 fromPrincipal_ = $.principalOf[account];

        uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);

        if (amount > $.totalSupply - $.secondarySupply) revert InsufficientMBacking();

        // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` is used.
        //       Can be `unchecked` because safety adjustment to `principal_` is applied above, and
        //       `principalOf[account]` cannot be greater than `totalPrincipal`.
        unchecked {
            $.balanceOf[account] -= amount;
            $.totalSupply -= amount;

            $.principalOf[account] = fromPrincipal_ - principal_;
            $.totalPrincipal -= principal_;
        }

        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev   Internal balance update function called on transfer.
     * @param sender    The sender's address.
     * @param recipient The recipient's address.
     * @param amount    The amount to be transferred.
     */
    function _update(address sender, address recipient, uint256 amount) internal override {
        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        // Slightly overestimate the principal amount to be moved on transfer
        uint112 fromPrincipal_ = $.principalOf[sender];
        uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);

        // NOTE: Can be `unchecked` because we check for insufficient sender balance above.
        //       Can be `unchecked` because safety adjustment to `principal_` is applied above, and
        unchecked {
            $.balanceOf[sender] -= amount;
            $.balanceOf[recipient] += amount;

            $.principalOf[sender] = fromPrincipal_ - principal_;
            $.principalOf[recipient] += principal_;
        }
    }

    /**
     * @notice Sets the yield fee rate, in bps, that will be taken from the yield generated by M.
     * @dev    Reverts if the yield fee rate is greater than ONE_HUNDRED_PERCENT.
     * @dev    Returns early if the yield fee rate is the same as the current one.
     * @param  feeRate_ The yield fee rate.
     */
    function _setFeeRate(uint16 feeRate_) internal {
        if (feeRate_ > ONE_HUNDRED_PERCENT) revert FeeRateTooHigh(feeRate_, ONE_HUNDRED_PERCENT);

        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        if ($.feeRate == feeRate_) return;

        $.feeRate = feeRate_;

        emit FeeRateSet(feeRate_);
    }

    /**
     * @notice Sets the yield fee recipient that will receive part of the yield generated by M.
     * @dev    Reverts if the yield fee recipient is address zero.
     * @dev    Returns early if the yield fee recipient is the same as the current one.
     * @param  feeRecipient_ The yield fee recipient address.
     */
    function _setFeeRecipient(address feeRecipient_) internal {
        if (feeRecipient_ == address(0)) revert ZeroFeeRecipient();

        MDualBackedFeeStorageStruct storage $ = _getMDualBackedFeeStorageLocation();

        if ($.feeRecipient == feeRecipient_) return;

        $.feeRecipient = feeRecipient_;

        emit FeeRecipientSet(feeRecipient_);
    }

    /* ============ Internal View/Pure Functions ============ */

    /**
     * @dev   Returns the timestamp when the earner rate was last accrued to accounts.
     *        For L1: returns the current `block.timestamp` as the rate accrues continuously.
     *        For L2: returns the `latestUpdateTimestamp` from the M token when the index was propagated from L1.
     *        Can be overridden by the inheriting contract (for EVM L2 contracts with index propagation).
     *        MUST return the current block timestamp for an M extension token deployed on the mainnet.
     *        MUST return spoke M token's `latestUpdateTimestamp` for an M extension token deployed on a spoke chain.
     * @return The current block timestamp.
     */
    function _latestEarnerRateAccrualTimestamp() internal view virtual returns (uint40) {
        return uint40(block.timestamp);
    }

    /**
     * @dev    Returns the current earner rate.
     *         Needs to be overridden by the inheriting contract.
     *         MUST return M token's earner rate for an M extension token deployed on the mainnet.
     *         MUST return a rate oracle's earner rate for an M extension token deployed on a spoke chain.
     * @return The current earner rate.
     */
    function _currentEarnerRate() internal view virtual returns (uint32) {
        // NOTE: The behavior of M is known, so we can safely retrieve the earner rate.
        return IMTokenLike(mToken).earnerRate();
    }

    /**
     * @dev    Compute the yield given a balance, principal and index.
     * @param  balance   The current balance of the account.
     * @param  principal The principal of the account.
     * @param  index     The current index.
     * @return The yield accrued since the last claim.
     */
    function _getAccruedYield(uint256 balance, uint112 principal, uint128 index) internal pure returns (uint256) {
        uint256 balanceWithYield_ = IndexingMath.getPresentAmountRoundedDown(principal, index);

        console.log("balance with yield", balanceWithYield_);
        console.log("balance", balance);

        unchecked {
            return balanceWithYield_ > balance ? balanceWithYield_ - balance : 0;
        }
    }
}
