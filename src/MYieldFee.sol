// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.26;
import { console } from "../../lib/forge-std/src/console.sol";
import { IERC20 } from "../lib/common/src/interfaces/IERC20.sol";

import { AccessControl } from "../lib/openzeppelin-contracts/contracts/access/AccessControl.sol";

import { ContinuousIndexingMath } from "../lib/common/src/libs/ContinuousIndexingMath.sol";
import { IndexingMath } from "../lib/common/src/libs/IndexingMath.sol";
import { UIntMath } from "../lib/common/src/libs/UIntMath.sol";

import { IContinuousIndexing } from "./interfaces/IContinuousIndexing.sol";
import { IMExtension } from "./interfaces/IMExtension.sol";
import { IMTokenLike } from "./interfaces/IMTokenLike.sol";
import { IMYieldFee } from "./interfaces/IMYieldFee.sol";
import { MExtension } from "./abstract/MExtension.sol";

/**
 * @title  ERC20 Token contract for wrapping M into a non-rebasing token.
 *         Extended to take a fee from the yield generated by M.
 * @dev    All holders of this ERC20 token are earners.
 * @author M0 Labs
 */
contract MYieldFee is IContinuousIndexing, IMYieldFee, AccessControl, MExtension {
    /* ============ Variables ============ */

    /// @inheritdoc IMYieldFee
    uint16 public constant HUNDRED_PERCENT = 10_000;

    /// @inheritdoc IMYieldFee
    bytes32 public constant YIELD_FEE_MANAGER_ROLE = keccak256("YIELD_FEE_MANAGER_ROLE");

    /// @inheritdoc IERC20
    uint256 public totalSupply;

    /// @inheritdoc IMYieldFee
    uint112 public totalPrincipal;

    /// @inheritdoc IContinuousIndexing
    uint128 public latestIndex;

    /// @inheritdoc IMYieldFee
    uint16 public yieldFeeRate;

    /// @inheritdoc IMYieldFee
    address public yieldFeeRecipient;

    /// @inheritdoc IContinuousIndexing
    uint40 public latestUpdateTimestamp;

    /// @inheritdoc IContinuousIndexing
    uint32 public latestRate;

    /// @inheritdoc IERC20
    mapping(address account => uint256 balance) public balanceOf;

    /// @inheritdoc IMYieldFee
    mapping(address account => uint112 principal) public principalOf;

    /* ============ Constructor ============ */

    /**
     * @dev   Constructs the M Yield Fee token.
     * @param name               The name of the token (e.g. "M Yield Fee").
     * @param symbol             The symbol of the token (e.g. "MYF").
     * @param mToken             The address of an M Token.
     * @param yieldFeeRate_      The fee rate, in bps, that will be taken from the yield generated by M.
     * @param yieldFeeRecipient_ The address of the recipient of the yield fee.
     * @param admin              The address administrating the M extension. Can grant and revoke roles.
     * @param yieldFeeManager    The address managing the fee rate and recipient.
     */
    constructor(
        string memory name,
        string memory symbol,
        address mToken,
        uint16 yieldFeeRate_,
        address yieldFeeRecipient_,
        address admin,
        address yieldFeeManager
    ) MExtension(name, symbol, mToken) {
        if (admin == address(0)) revert ZeroAdmin();
        if (yieldFeeManager == address(0)) revert ZeroYieldFeeManager();

        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(YIELD_FEE_MANAGER_ROLE, yieldFeeManager);

        _setYieldFeeRate(yieldFeeRate_);
        _setYieldFeeRecipient(yieldFeeRecipient_);

        latestIndex = ContinuousIndexingMath.EXP_SCALED_ONE;
    }

    /* ============ Interactive Functions ============ */

    /// @inheritdoc IMYieldFee
    function claimYieldFor(address recipient) external returns (uint256) {
        if (recipient == address(0)) revert ZeroYieldRecipient();

        uint256 yield_ = accruedYieldOf(recipient);

        if (yield_ == 0) return 0;

        // NOTE: No change in principal, only the balance is updated.
        unchecked {
            balanceOf[recipient] += yield_;
        }

        emit YieldClaimed(msg.sender, recipient, yield_);

        return yield_;
    }

    /// @inheritdoc IMYieldFee
    function claimYieldFee() external returns (uint256) {
        uint256 yieldFee_ = totalAccruedYieldFee();

        if (yieldFee_ == 0) return 0;

        address recipient_ = yieldFeeRecipient;

        emit YieldFeeClaimed(msg.sender, recipient_, yieldFee_);

        _mint(recipient_, yieldFee_);

        return yieldFee_;
    }

    /// @inheritdoc IMExtension
    function enableEarning() external override {
        if (isEarningEnabled()) revert EarningIsEnabled();

        // NOTE: update the index to store the latest state, current index won't accrue since `latestRate` is 0.
        emit EarningEnabled(updateIndex());

        IMTokenLike(mToken).startEarning();
    }

    /// @inheritdoc IMExtension
    function disableEarning() external override {
        if (!isEarningEnabled()) revert EarningIsDisabled();

        // NOTE: update the index to store the latest state.
        emit EarningDisabled(updateIndex());

        // NOTE: `latestRate` is set to 0 to indicate that earning is disabled.
        delete latestRate;

        IMTokenLike(mToken).stopEarning(address(this));
    }

    /// @inheritdoc IContinuousIndexing
    function updateIndex() public virtual returns (uint128 currentIndex_) {
        // Read the latest M token rate adjusted by fee rate split
        uint32 rate_ = _rate();

        if (latestUpdateTimestamp == block.timestamp && latestRate == rate_) return latestIndex;

        // NOTE: `currentIndex()` depends on `_latestRate`, so only update it after this.
        latestIndex = currentIndex_ = currentIndex();
        latestRate = rate_;
        latestUpdateTimestamp = uint40(block.timestamp);

        emit IndexUpdated(currentIndex_, rate_);
    }

    /// @inheritdoc IMYieldFee
    function setYieldFeeRate(uint16 yieldFeeRate_) external onlyRole(YIELD_FEE_MANAGER_ROLE) {
        _setYieldFeeRate(yieldFeeRate_);

        // NOTE: Update the index to store the new adjusted rate.
        if (isEarningEnabled()) updateIndex();
    }

    /// @inheritdoc IMYieldFee
    function setYieldFeeRecipient(address yieldFeeRecipient_) external onlyRole(YIELD_FEE_MANAGER_ROLE) {
        // TODO: consider claiming yield fee for the previous recipient
        _setYieldFeeRecipient(yieldFeeRecipient_);
    }

    /* ============ External/Public view functions ============ */

    /// @inheritdoc IMYieldFee
    function accruedYieldOf(address account) public view returns (uint256) {
        return _getAccruedYield(balanceOf[account], principalOf[account], currentIndex());
    }

    /// @inheritdoc IMYieldFee
    function balanceWithYieldOf(address account) external view returns (uint256) {
        unchecked {
            return balanceOf[account] + accruedYieldOf(account);
        }
    }

    /// @inheritdoc IContinuousIndexing
    function currentIndex() public view virtual returns (uint128) {
        if (!isEarningEnabled()) return latestIndex;

        // NOTE: Safe to use unchecked here, since `block.timestamp` is always greater than `latestUpdateTimestamp`.
        unchecked {
            return
                // NOTE: Cap the index to `type(uint128).max` to prevent overflow in present value math.
                UIntMath.bound128(
                    ContinuousIndexingMath.multiplyIndicesDown(
                        latestIndex,
                        ContinuousIndexingMath.getContinuousIndex(
                            ContinuousIndexingMath.convertFromBasisPoints(latestRate),
                            uint32(block.timestamp - latestUpdateTimestamp)
                        )
                    )
                );
        }
    }

    /// @inheritdoc IMExtension
    function isEarningEnabled() public view override returns (bool) {
        return latestRate != 0;
    }

    function projectedTotalSupply() public view returns (uint256) {
        return IndexingMath.getPresentAmountRoundedUp(totalPrincipal, currentIndex());
    }

    /// @inheritdoc IMYieldFee
    function totalAccruedYield() public view returns (uint256) {
        return _getAccruedYield(totalSupply, totalPrincipal, currentIndex());
    }

    /// @inheritdoc IMYieldFee
    function totalAccruedYieldFee() public view returns (uint256) {
        uint256 mBalance_ = _mBalanceOf(address(this));
        uint256 projectedTotalSupply_ = projectedTotalSupply();

        unchecked {
            return mBalance_ > projectedTotalSupply_ ? mBalance_ - projectedTotalSupply_ : 0;
        }
    }

    /* ============ Internal Interactive Functions ============ */

    /**
     * @dev   Mints `amount` tokens to `recipient`.
     * @param recipient The address whose account balance will be incremented.
     * @param amount    The present amount of tokens to mint.
     */
    function _mint(address recipient, uint256 amount) internal override {
        _revertIfInsufficientAmount(amount);
        _revertIfInvalidRecipient(recipient);

        // TODO: fix tomorrow
        uint112 principal_ = IndexingMath.getPrincipalAmountRoundedDown(uint240(amount), currentIndex());

        // NOTE: Can be `unchecked` because the max amount of M is never greater than `type(uint240).max`.
        // NOTE: Can be `unchecked` because UIntMath.safe112 is used for principal addition safety
        unchecked {
            balanceOf[recipient] += amount;
            totalSupply += amount;

            principalOf[recipient] = UIntMath.safe112(uint256(principalOf[recipient]) + principal_);
            totalPrincipal = UIntMath.safe112(uint256(totalPrincipal) + principal_);
        }

        emit Transfer(address(0), recipient, amount);
    }

    /**
     * @dev   Burns `amount` tokens from `account`.
     * @param account The address whose account balance will be decremented.
     * @param amount  The present amount of tokens to burn.
     */
    function _burn(address account, uint256 amount) internal override {
        _revertIfInsufficientAmount(amount);

        uint256 balance_ = balanceOf[account];

        _revertIfInsufficientBalance(account, balance_, amount);

        uint112 principal_ = (balance_ == amount)
            ? principalOf[account]
            : IndexingMath.getPrincipalAmountRoundedUp(uint240(amount), currentIndex()); // fix tomorrow

        unchecked {
            balanceOf[account] = balance_ - amount;
            totalSupply -= amount;

            principalOf[account] -= principal_;
            totalPrincipal -= principal_;
        }

        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.
     * @param sender    The sender's address.
     * @param recipient The recipient's address.
     * @param amount    The amount to be transferred.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal override {
        _revertIfInvalidRecipient(recipient);

        emit Transfer(sender, recipient, amount);

        if (amount == 0) return;

        uint256 balance_ = balanceOf[sender];

        _revertIfInsufficientBalance(sender, balance_, amount);

        if (sender == recipient) return;

        uint112 principal_ = (balance_ == amount)
            ? principalOf[sender]
            : IndexingMath.getPrincipalAmountRoundedDown(uint240(amount), currentIndex()); // fix tomorrow

        // NOTE: Can be `unchecked` because UIntMath.safe112 is used for principal addition safety
        unchecked {
            balanceOf[sender] = balance_ - amount;
            balanceOf[recipient] += amount;

            principalOf[sender] -= principal_;
            principalOf[recipient] = UIntMath.safe112(uint256(principalOf[recipient]) + principal_);
        }
    }

    /**
     * @notice Sets the yield fee rate, in bps, that will be taken from the yield generated by M.
     * @dev    Reverts if the yield fee rate is greater than HUNDRED_PERCENT.
     * @dev    Returns early if the yield fee rate is the same as the current one.
     * @param  yieldFeeRate_ The yield fee rate.
     */
    function _setYieldFeeRate(uint16 yieldFeeRate_) internal {
        if (yieldFeeRate_ > HUNDRED_PERCENT) revert YieldFeeRateTooHigh(yieldFeeRate_, HUNDRED_PERCENT);
        if (yieldFeeRate == yieldFeeRate_) return;

        yieldFeeRate = yieldFeeRate_;

        emit YieldFeeRateSet(yieldFeeRate_);
    }

    /**
     * @notice Sets the yield fee recipient that will receive part of the yield generated by M.
     * @dev    Reverts if the yield fee recipient is address zero.
     * @dev    Returns early if the yield fee recipient is the same as the current one.
     * @param  yieldFeeRecipient_ The yield fee recipient address.
     */
    function _setYieldFeeRecipient(address yieldFeeRecipient_) internal {
        if (yieldFeeRecipient_ == address(0)) revert ZeroYieldFeeRecipient();
        if (yieldFeeRecipient == yieldFeeRecipient_) return;

        yieldFeeRecipient = yieldFeeRecipient_;

        emit YieldFeeRecipientSet(yieldFeeRecipient_);
    }

    /* ============ Internal View/Pure Functions ============ */

    function _rate() internal view returns (uint32) {
        // NOTE: the behavior of M is known, so we can safely retrieve the earner rate.
        unchecked {
            return
                // UIntMath.safe32(
                uint32((uint256(HUNDRED_PERCENT - yieldFeeRate) * IMTokenLike(mToken).earnerRate()) / HUNDRED_PERCENT);
            // );
        }
    }

    /**
     * @dev    Compute the yield given a balance, principal and index.
     * @param  balance   The current balance of the account.
     * @param  principal The principal of the account.
     * @param  index     The current index.
     * @return The yield accrued since the last claim.
     */
    function _getAccruedYield(uint256 balance, uint112 principal, uint128 index) internal pure returns (uint256) {
        uint256 balanceWithYield_ = IndexingMath.getPresentAmountRoundedDown(principal, index);
        unchecked {
            return balanceWithYield_ > balance ? balanceWithYield_ - balance : 0;
        }
    }

    function _mBalanceOf(address account) public view returns (uint256) {
        return IERC20(mToken).balanceOf(account);
    }

    /**
     * @dev   Reverts if `amount` is equal to 0.
     * @param amount Amount of token.
     */
    function _revertIfInsufficientAmount(uint256 amount) internal pure {
        if (amount == 0) revert InsufficientAmount(amount);
    }

    /**
     * @dev   Reverts if `account` is address(0).
     * @param account Address of an account.
     */
    function _revertIfInvalidRecipient(address account) internal pure {
        if (account == address(0)) revert InvalidRecipient(account);
    }

    /**
     * @dev   Reverts if `account` balance is below `balance`.
     * @param account Address of an account.
     * @param balance Balance of an account.
     * @param amount Amount to transfer or burn.
     */
    function _revertIfInsufficientBalance(address account, uint256 balance, uint256 amount) internal pure {
        if (balance < amount) revert InsufficientBalance(account, balance, amount);
    }

    // /**
    //  * @dev    Returns the present amount (rounded down) given the principal amount and an index.
    //  * @param  principal The principal amount.
    //  * @param  index     An index.
    //  * @return The present amount rounded down.
    //  */
    // function _getPresentAmountRoundedDown(uint112 principal, uint128 index) internal pure returns (uint256) {
    //     unchecked {
    //         return (uint256(principal) * index) / EXP_SCALED_ONE;
    //     }
    // }

    // /**
    //  * @dev    Returns the present amount (rounded up) given the principal amount and an index.
    //  * @param  principal The principal amount.
    //  * @param  index     An index.
    //  * @return The present amount rounded up.
    //  */
    // function _getPresentAmountRoundedUp(uint112 principal, uint128 index) internal pure returns (uint256) {
    //     unchecked {
    //         return ((principal * index) + (EXP_SCALED_ONE - 1)) / EXP_SCALED_ONE;
    //     }
    // }

    // /**
    //  * @dev    Returns the principal amount given the present amount, using the current index.
    //  * @param  amount The present amount.
    //  * @param  index  An index.
    //  * @return The principal amount rounded down.
    //  */
    // function _getPrincipalAmountRoundedDown(uint256 amount, uint128 index) internal pure returns (uint112) {
    //     return divide240By128Down(presentAmount, index);
    // }

    // /**
    //  * @dev    Returns the principal amount given the present amount, using the current index.
    //  * @param  amount The present amount.
    //  * @param  index  An index.
    //  * @return The principal amount rounded up.
    //  */
    // function _getPrincipalAmountRoundedUp(uint256 amount, uint128 index) internal pure returns (uint112) {
    //     return divide240By128Up(presentAmount, index);
    // }
}
