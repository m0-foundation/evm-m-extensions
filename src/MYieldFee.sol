// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.26;
import { console } from "../../lib/forge-std/src/console.sol";
import { IERC20 } from "../lib/common/src/interfaces/IERC20.sol";

import { ContinuousIndexingMath } from "../lib/common/src/libs/ContinuousIndexingMath.sol";
import { IndexingMath } from "../lib/common/src/libs/IndexingMath.sol";
import { UIntMath } from "../lib/common/src/libs/UIntMath.sol";

import { IContinuousIndexing } from "./interfaces/IContinuousIndexing.sol";
import { IMExtension } from "./interfaces/IMExtension.sol";
import { IMTokenLike } from "./interfaces/IMTokenLike.sol";
import { IMYieldFee } from "./interfaces/IMYieldFee.sol";
import { IRateOracle } from "./interfaces/IRateOracle.sol";

import { MExtension } from "./abstract/MExtension.sol";
import { YieldFee } from "./abstract/components/YieldFee.sol";

/**
 * @title  ERC20 Token contract for wrapping M into a non-rebasing token.
 *         Extended to take a fee from the yield generated by M.
 * @dev    All holders of this ERC20 token are earners.
 * @author M0 Labs
 */
contract MYieldFee is IMYieldFee, MExtension, YieldFee {
    /* ============ Structs ============ */

    /**
     * @dev   Struct to represent an account's balance and principal.
     * @param balance        The present amount of tokens held by the account.
     * @param principal      The earning principal of the account.
     */
    struct Account {
        // First slot
        uint240 balance;
        // Second slot
        uint112 principal;
    }

    /* ============ Variables ============ */

    /// @inheritdoc IMYieldFee
    uint128 public latestIndex;

    /// @inheritdoc IMYieldFee
    uint128 public latestUpdateTimestamp;

    /// @inheritdoc IMYieldFee
    uint256 public latestRate;

    /// @inheritdoc IERC20
    uint256 public totalSupply;

    /// @inheritdoc IMYieldFee
    uint112 public totalPrincipal;

    /// @dev Mapping of accounts to their respective `Account` info structs.
    mapping(address account => Account accountInfo) internal _accounts;

    /* ============ Constructor ============ */

    /**
     * @dev   Constructs the M Yield Fee token.
     * @param name              The name of the token (e.g. "M Yield Fee").
     * @param symbol            The symbol of the token (e.g. "MYF").
     * @param mToken            The address of an M Token.
     * @param yieldFeeRate      The fee rate, in bps, that will be taken from the yield generated by M.
     * @param yieldFeeRecipient The address of the recipient of the yield fee.
     * @param admin             The address administrating the M extension. Can grant and revoke roles.
     * @param yieldFeeManager   The address managing the fee rate and recipient.
     */
    constructor(
        string memory name,
        string memory symbol,
        address mToken,
        uint16 yieldFeeRate,
        address yieldFeeRecipient,
        address admin,
        address yieldFeeManager
    ) MExtension(name, symbol, mToken) YieldFee(yieldFeeRate, yieldFeeRecipient, admin, yieldFeeManager) {
        latestIndex = ContinuousIndexingMath.EXP_SCALED_ONE;
    }

    /* ============ Interactive Functions ============ */

    /// @inheritdoc IMYieldFee
    function claimYieldFor(address recipient_) external returns (uint256) {
        if (recipient_ == address(0)) revert ZeroYieldRecipient();

        Account storage accountInfo_ = _accounts[recipient_];

        uint240 yield_ = accruedYieldOf(recipient_);

        if (yield_ == 0) return 0;

        // NOTE: No change in principal, only the balance is updated and the yield captured by updating the lastClaimIndex.
        unchecked {
            accountInfo_.balance += yield_;
        }

        emit YieldClaimed(msg.sender, recipient_, yield_);

        return yield_;
    }

    /// @inheritdoc IMYieldFee
    function claimYieldFee() external returns (uint256) {
        uint256 yieldFee_ = totalAccruedYieldFee();

        if (yieldFee_ == 0) return 0;

        address recipient_ = yieldFeeRecipient;

        emit YieldFeeClaimed(msg.sender, recipient_, yieldFee_);

        _mint(recipient_, yieldFee_);

        return yieldFee_;
    }

    /// @inheritdoc IMExtension
    function enableEarning() external override {
        if (isEarningEnabled()) revert EarningIsEnabled();

        // Store variables necessary to calculate the index.
        latestUpdateTimestamp = block.timestamp;
        latestRate = extensionRate();

        emit EarningEnabled(latestIndex);

        IMTokenLike(mToken).startEarning();
    }

    /// @inheritdoc IMExtension
    function disableEarning() external override {
        if (!isEarningEnabled()) revert EarningIsDisabled();

        // Accrue index before stopping earning
        latestUpdateTimestamp = block.timestamp;
        latestIndex = currentIndex();
        latestRate = 0;

        emit EarningDisabled(latestIndex);

        IMTokenLike(mToken).stopEarning();
    }

    // Expected to be called when `rate` in M token changes
    function updateIndex() public override {
        latestUpdateTimestamp = block.timestamp;

        // NOTE: `currentIndex()` depends on `latestRate`, so only update it after this.
        latestIndex = currentIndex();
        latestRate = extensionRate();
    }

    /* ============ External/Public view functions ============ */

    /// @inheritdoc IMYieldFee
    function accruedYieldOf(address account_) public view returns (uint240) {
        Account memory accountInfo_ = _accounts[account_];
        return _getAccruedYield(accountInfo_.balance, accountInfo_.principal, currentIndex());
    }

    /// @inheritdoc IERC20
    function balanceOf(address account_) public view returns (uint256) {
        return _accounts[account_].balance;
    }

    /// @inheritdoc IMYieldFee
    function balanceWithYieldOf(address account) external view returns (uint256) {
        // NOTE: Claiming yield does not necessarily result in the account's new balance equaling the value returned
        //       by `balanceWithYieldOf`, as the yield may be directed to a recipient different from the `account`.
        unchecked {
            return balanceOf(account) + accruedYieldOf(account);
        }
    }

    /// @inheritdoc IMYieldFee
    function currentIndex() public view virtual override returns (uint128) {
        if (latestRate == 0) return latestIndex;

        // NOTE: Safe to use unchecked here, since `block.timestamp` is always greater than `latestUpdateTimestamp`.
        unchecked {
            return
                // NOTE: Cap the index to `type(uint128).max` to prevent overflow in present value math.
                UIntMath.bound128(
                    ContinuousIndexingMath.multiplyIndicesDown(
                        latestIndex,
                        ContinuousIndexingMath.getContinuousIndex(
                            ContinuousIndexingMath.convertFromBasisPoints(latestRate),
                            uint32(block.timestamp - latestUpdateTimestamp)
                        )
                    )
                );
        }
    }

    /// @inheritdoc IMExtension
    function isEarningEnabled() public view override returns (bool) {
        return latestRate != 0;
    }

    /// @inheritdoc IMYieldFee
    function principalOf(address account_) external view returns (uint112) {
        return _accounts[account_].principal;
    }

    /// @inheritdoc IMYieldFee
    function projectedSupply() public view returns (uint240) {
        // NOTE: all holders are earners and MYieldFee is redeemable 1:1 for M,
        //       so the projected supply is the M balance of MYieldFee.
        //       M Token balance are limited to `uint240`.
        return uint240(IERC20(mToken).balanceOf(address(this)));
    }

    /// @inheritdoc IMYieldFee
    function totalAccruedYield() public view returns (uint240) {
        unchecked {
            return _getAccruedYield(UIntMath.safe240(totalSupply), totalPrincipal, currentIndex());
        }
    }

    /// @inheritdoc IMYieldFee
    function totalAccruedYieldFee() public view returns (uint240) {
        uint240 projectedSupply_ = projectedSupply();
        uint240 projectedHoldersSupply_ = UIntMath.safe240(totalSupply) + totalAccruedYield();

        unchecked {
            return projectedSupply_ > projectedHoldersSupply_ ? projectedSupply_ - projectedHoldersSupply_ : 0;
        }
    }

    // TODO: rate types are all mixed here, fix this
    function extensionRate() public view returns (uint256) {
        return (uint256(yieldFeeRate) * IMTokenLike(mToken).earnerRate()) / HUNDRED_PERCENT;
    }

    /* ============ Internal Interactive Functions ============ */

    /**
     * @dev    Hooks called before wrapping M into M Extension token.
     * @param  account_   The account from which M is deposited.
     */
    function _beforeWrap(address account_, address /* recipient_ */, uint256 /* amount_ */) internal override {}

    /**
     * @dev   Mints `amount` tokens to `recipient`.
     * @param recipient_ The address whose account balance will be incremented.
     * @param amount_    The present amount of tokens to mint.
     */
    function _mint(address recipient_, uint256 amount_) internal override {
        uint240 safeAmount_ = UIntMath.safe240(amount_);

        _revertIfInsufficientAmount(safeAmount_);
        _revertIfInvalidRecipient(recipient_);

        _addAmount(recipient_, safeAmount_, currentIndex());

        emit Transfer(address(0), recipient_, safeAmount_);
    }

    /**
     * @dev   Increments the token balance of `account_` by `amount_`.
     * @param account_      The address whose account balance will be incremented.
     * @param amount_       The present amount of tokens to increment by.
     * @param currentIndex_ The current index to use to compute the principal amount.
     */
    function _addAmount(address account_, uint240 amount_, uint128 currentIndex_) internal {
        Account storage accountInfo_ = _accounts[account_];

        // NOTE: Tracks two principal amounts: rounded up and rounded down.
        //       Slightly overestimates the principal of total supply to provide extra safety in `totalAccruedYieldFee` calculations.
        uint112 principalUp_ = IndexingMath.getPrincipalAmountRoundedUp(amount_, currentIndex_);
        uint112 principalDown_ = IndexingMath.getPrincipalAmountRoundedDown(amount_, currentIndex_);

        // NOTE: Can be `unchecked` because the max amount of wrappable M is never greater than `type(uint240).max`.
        unchecked {
            accountInfo_.balance += amount_;
            accountInfo_.principal = UIntMath.safe112(uint256(accountInfo_.principal) + principalDown_);
        }

        _addTotalSupply(amount_, principalUp_);
    }

    /**
     * @dev   Increments total supply by `amount_` of tokens.
     * @param amount_    The present amount of tokens to increment total supply by.
     * @param principal_ The principal amount of tokens to increment total principal by.
     */
    function _addTotalSupply(uint240 amount_, uint112 principal_) internal {
        unchecked {
            // Increment the total supply and principal proportionally.
            totalSupply += amount_;
            totalPrincipal = UIntMath.safe112(uint256(totalPrincipal) + principal_);
        }
    }

    /**
     * @dev   Decrements the token balance of `account_` by `amount_`.
     * @param account_      The address whose account balance will be decremented.
     * @param amount_       The present amount of tokens to decrement by.
     * @param currentIndex_ The current index to use to compute the principal amount.
     */
    function _subtractAmount(address account_, uint240 amount_, uint128 currentIndex_) internal {
        Account storage accountInfo_ = _accounts[account_];
        uint240 balance_ = accountInfo_.balance;

        if (balance_ < amount_) revert InsufficientBalance(account_, balance_, amount_);

        // NOTE: Tracks two principal amounts: rounded up and rounded down.
        //       Slightly overestimates the principal of total supply to provide extra safety in `totalAccruedYieldFee` calculations.
        uint112 principalUp_ = IndexingMath.getPrincipalAmountRoundedUp(amount_, currentIndex_);
        uint112 principalDown_ = IndexingMath.getPrincipalAmountRoundedDown(amount_, currentIndex_);

        unchecked {
            accountInfo_.balance -= amount_;
            accountInfo_.principal -= principalUp_;
        }

        _subtractTotalSupply(amount_, principalDown_);
    }

    /**
     * @dev   Decrements total supply by `amount_` tokens.
     * @param amount_    The present amount of tokens to decrement total supply by.
     * @param principal_ The principal amount of tokens to decrement total principal by.
     */
    function _subtractTotalSupply(uint240 amount_, uint112 principal_) internal {
        uint240 totalSupply_ = UIntMath.safe240(totalSupply);
        uint112 totalPrincipal_ = totalPrincipal;

        unchecked {
            // `min240` and `min112` prevent `totalSupply` and `totalPrincipal` underflow respectively.
            totalSupply = totalSupply_ - UIntMath.min240(amount_, totalSupply_);
            totalPrincipal = totalPrincipal_ - UIntMath.min112(principal_, totalPrincipal_);
        }
    }

    /**
     * @dev   Burns `amount_` tokens from `account_`.
     * @param account_ The address whose account balance will be decremented.
     * @param amount_  The present amount of tokens to burn.
     */
    function _burn(address account_, uint256 amount_) internal override {
        uint240 safeAmount_ = UIntMath.safe240(amount_);

        _revertIfInsufficientAmount(safeAmount_);

        _subtractAmount(account_, safeAmount_, currentIndex());

        emit Transfer(account_, address(0), safeAmount_);
    }

    /**
     * @dev   Transfers `amount_` tokens from `sender_` to `recipient_` given some current index.
     * @param sender_       The sender's address.
     * @param recipient_    The recipient's address.
     * @param amount_       The amount to be transferred.
     * @param currentIndex_ The current index.
     */
    function _transfer(address sender_, address recipient_, uint240 amount_, uint128 currentIndex_) internal {
        _revertIfInvalidRecipient(recipient_);

        emit Transfer(sender_, recipient_, amount_);

        if (amount_ == 0) return;

        Account storage senderInfo_ = _accounts[sender_];

        if (senderInfo_.balance < amount_) revert InsufficientBalance(sender_, senderInfo_.balance, amount_);
        if (sender_ == recipient_) return;

        _subtractAmount(sender_, amount_, currentIndex_);
        _addAmount(recipient_, amount_, currentIndex_);
    }

    /**
     * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.
     * @param sender_    The sender's address.
     * @param recipient_ The recipient's address.
     * @param amount_    The amount to be transferred.
     */
    function _transfer(address sender_, address recipient_, uint256 amount_) internal override {
        _transfer(sender_, recipient_, UIntMath.safe240(amount_), currentIndex());
    }

    /* ============ Internal View/Pure Functions ============ */

    /**
     * @dev   Reverts if `amount` is equal to 0.
     * @param amount Amount of token.
     */
    function _revertIfInsufficientAmount(uint256 amount) internal pure {
        if (amount == 0) revert InsufficientAmount(amount);
    }

    /**
     * @dev   Reverts if `account` is address(0).
     * @param account Address of an account.
     */
    function _revertIfInvalidRecipient(address account) internal pure {
        if (account == address(0)) revert InvalidRecipient(account);
    }
}
