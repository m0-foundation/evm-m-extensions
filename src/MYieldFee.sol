// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.26;

import { IERC20 } from "../lib/common/src/interfaces/IERC20.sol";
import { IndexingMath } from "../lib/common/src/libs/IndexingMath.sol";
import { UIntMath } from "../lib/common/src/libs/UIntMath.sol";

import { IMTokenLike } from "./interfaces/IMTokenLike.sol";
import { IMYieldFee } from "./interfaces/IMYieldFee.sol";

import { MExtension } from "./abstract/MExtension.sol";
import { YieldFeeComponent } from "./abstract/YieldFeeComponent.sol";
/**
 * @title  ERC20 Token contract for wrapping M into a non-rebasing token.
 *         Extended to take a fee from the yield generated by M.
 * @dev    All holders of this ERC20 token are earners.
 * @author M^0 Labs
 */
contract MYieldFee is IMYieldFee, MExtension, YieldFeeComponent {
    /* ============ Structs ============ */

    /**
     * @dev   Struct to represent an account's balance and principal.
     * @param balance   The present amount of tokens held by the account.
     * @param principal The earning principal of the account.
     */
    struct Account {
        // First slot
        uint240 balance;
        // Second slot
        uint112 principal;
    }

    /* ============ Variables ============ */

    /// @inheritdoc IERC20
    uint256 public totalSupply;

    /// @inheritdoc IMYieldFee
    uint112 public totalPrincipal;

    /// @dev Mapping of accounts to their respective `Account` info structs.
    mapping(address account => Account accountInfo) internal _accounts;

    /* ============ Constructor ============ */

    /**
     * @dev   Constructs the M Yield Fee token.
     * @param name_              The name of the token (e.g. "M Yield Fee").
     * @param symbol_            The symbol of the token (e.g. "MYF").
     * @param mToken_            The address of an M Token.
     * @param registrar_         The address of a registrar.
     * @param yieldFeeRate_      The fee rate, in bps, that will be taken from the yield generated by M.
     * @param yieldFeeRecipient_ The address of the recipient of the yield fee.
     * @param admin_             The address admnistrating the M extension. Can grant and revoke roles.
     * @param yieldFeeManager_   The address managing the fee rate and recipient.
     */
    constructor(
        string memory name_,
        string memory symbol_,
        address mToken_,
        address registrar_,
        uint16 yieldFeeRate_,
        address yieldFeeRecipient_,
        address admin_,
        address yieldFeeManager_
    )
        MExtension(name_, symbol_, mToken, registrar)
        YieldFeeComponent(yieldFeeRate_, yieldFeeRecipient_, admin_, yieldFeeManager_)
    {}

    /* ============ Interactive Functions ============ */

    /// @inheritdoc IMYieldFee
    function claimYieldFor(address recipient_) external returns (uint256) {
        Account storage accountInfo_ = _accounts[recipient_];
        (uint240 yield_, ) = _getAccruedYield(accountInfo_.balance, accountInfo_.principal, _currentMIndex());

        if (yield_ == 0) return 0;

        emit YieldClaimed(msg.sender, recipient_, yield_);

        // NOTE: The behavior of `IMTokenLike.transfer` is known, so its return can be ignored.
        IMTokenLike(mToken).transfer(recipient_, yield_);

        return yield_;
    }

    /// @inheritdoc IMYieldFee
    function claimYieldFeeFor(address recipient_) external returns (uint256) {
        if (recipient_ == address(0)) revert ZeroYieldFeeRecipient();

        uint256 yieldFee_ = _getAccruedYieldFee(recipient_);

        if (yieldFee_ == 0) return 0;

        emit YieldFeeClaimed(msg.sender, recipient_, yieldFee_);

        // NOTE: The behavior of `IMTokenLike.transfer` is known, so its return can be ignored.
        IMTokenLike(mToken).transfer(recipient_, yieldFee_);

        return yieldFee_;
    }

    /* ============ External/Public view functions ============ */

    /// @inheritdoc IMYieldFee
    function accruedYieldOf(address account_) public view returns (uint240) {
        Account storage accountInfo_ = _accounts[account_];

        (uint240 yield_, ) = _getAccruedYield(accountInfo_.balance, accountInfo_.principal, _currentMIndex());

        return yield_;
    }

    /// @inheritdoc IERC20
    function balanceOf(address account_) public view returns (uint256) {
        return _accounts[account_].balance;
    }

    /// @inheritdoc IMYieldFee
    function balanceWithYieldOf(address account_) external view returns (uint256) {
        // NOTE: The returned amount includes the total accrued yield.
        //       Claiming yield does not necessarily result in the account's new balance equaling the value returned
        //       by `balanceWithYieldOf`, as the yield may be directed to a recipient different from the `account_`.
        unchecked {
            return balanceOf(account_) + accruedYieldOf(account_);
        }
    }

    /// @inheritdoc IMYieldFee
    function principalOf(address account_) external view returns (uint112) {
        return _accounts[account_].principal;
    }

    /// @inheritdoc IMYieldFee
    function projectedSupply() public view returns (uint240 supply_) {
        return
            UIntMath.max240(
                IndexingMath.getPresentAmountRoundedUp(totalPrincipal, _currentMIndex()),
                UIntMath.safe240(totalSupply)
            );
    }

    /// @inheritdoc IMYieldFee
    function totalAccruedYield() external view returns (uint240) {
        unchecked {
            return projectedSupply() - UIntMath.safe240(totalSupply);
        }
    }

    /* ============ Internal Interactive Functions ============ */

    function _mint(address recipient_, uint256 amount_) internal override {
        uint240 safeAmount_ = UIntMath.safe240(amount_);

        _revertIfInsufficientAmount(safeAmount_);
        _revertIfInvalidRecipient(recipient_);
        _addAmount(recipient_, safeAmount_, _currentMIndex());

        emit Transfer(address(0), recipient_, safeAmount_);
    }

    /**
     * @dev   Increments the token balance of `account_` by `amount_`.
     * @param account_      The address whose account balance will be incremented.
     * @param amount_       The present amount of tokens to increment by.
     * @param currentIndex_ The current index to use to compute the principal amount.
     */
    function _addAmount(address account_, uint240 amount_, uint128 currentIndex_) internal {
        Account storage accountInfo_ = _accounts[account_];

        // NOTE: Tracks two principal amounts: rounded up and rounded down.
        //       Slightly overestimates the principal of total supply to provide extra safety in `excess` calculations.
        uint112 principalUp_ = IndexingMath.getPrincipalAmountRoundedUp(amount_, currentIndex_);
        uint112 principalDown_ = IndexingMath.getPrincipalAmountRoundedDown(amount_, currentIndex_);

        // NOTE: Can be `unchecked` because the max amount of wrappable M is never greater than `type(uint240).max`.
        unchecked {
            accountInfo_.balance += amount_;
            accountInfo_.principal = UIntMath.safe112(uint256(accountInfo_.principal) + principalDown_);
        }

        _addTotalSupply(amount_, principalUp_);
    }

    /**
     * @dev   Increments total supply by `amount_` of tokens.
     * @param amount_    The present amount of tokens to increment total supply by.
     * @param principal_ The principal amount of tokens to increment total principal by.
     */
    function _addTotalSupply(uint240 amount_, uint112 principal_) internal {
        unchecked {
            // Increment the total supply and principal proportionally.
            totalSupply += amount_;
            totalPrincipal = UIntMath.safe112(uint256(totalPrincipal) + principal_);
        }
    }

    /**
     * @dev   Decrements the token balance of `account_` by `amount_`.
     * @param account_      The address whose account balance will be decremented.
     * @param amount_       The present amount of tokens to decrement by.
     * @param currentIndex_ The current index to use to compute the principal amount.
     */
    function _subtractAmount(address account_, uint240 amount_, uint128 currentIndex_) internal {
        Account storage accountInfo_ = _accounts[account_];
        uint240 balance_ = accountInfo_.balance;

        if (balance_ < amount_) revert InsufficientBalance(account_, balance_, amount_);

        uint112 principal_ = accountInfo_.principal;

        // NOTE: Tracks two principal amounts: rounded up and rounded down.
        //       Slightly overestimates the principal of total earning supply to provide extra safety in `excess` calculations.
        uint112 principalUp_ = IndexingMath.getPrincipalAmountRoundedUp(amount_, currentIndex_);
        uint112 principalDown_ = IndexingMath.getPrincipalAmountRoundedDown(amount_, currentIndex_);

        unchecked {
            accountInfo_.balance = balance_ - amount_;
            // `min112` prevents `principal` underflow.
            accountInfo_.principal = principal_ - UIntMath.min112(principalUp_, principal_);
        }

        _subtractTotalSupply(amount_, principalDown_);
    }

    /**
     * @dev   Decrements total supply by `amount_` tokens.
     * @param amount_    The present amount of tokens to decrement total supply by.
     * @param principal_ The principal amount of tokens to decrement total principal by.
     */
    function _subtractTotalSupply(uint240 amount_, uint112 principal_) internal {
        uint240 totalSupply_ = UIntMath.safe240(totalSupply);
        uint112 totalPrincipal_ = totalPrincipal;

        unchecked {
            // `min240` and `min112` prevent `totalSupply` and `totalPrincipal` underflow respectively.
            totalSupply = totalSupply_ - UIntMath.min240(amount_, totalSupply_);
            totalPrincipal = totalPrincipal_ - UIntMath.min112(principal_, totalPrincipal_);
        }
    }

    /**
     * @dev   Burns `amount_` tokens from `account_`.
     * @param account_ The address whose account balance will be decremented.
     * @param amount_  The present amount of tokens to burn.
     */
    function _burn(address account_, uint256 amount_) internal override {
        uint240 safeAmount_ = UIntMath.safe240(amount_);

        _revertIfInsufficientAmount(safeAmount_);
        _subtractAmount(account_, safeAmount_, _currentMIndex());

        emit Transfer(account_, address(0), safeAmount_);
    }

    /**
     * @dev   Transfers `amount_` tokens from `sender_` to `recipient_` given some current index.
     * @param sender_       The sender's address.
     * @param recipient_    The recipient's address.
     * @param amount_       The amount to be transferred.
     * @param currentIndex_ The current index.
     */
    function _transfer(address sender_, address recipient_, uint240 amount_, uint128 currentIndex_) internal {
        _revertIfInvalidRecipient(recipient_);

        emit Transfer(sender_, recipient_, amount_);

        if (amount_ == 0) return;

        Account storage senderInfo_ = _accounts[sender_];

        if (senderInfo_.balance < amount_) revert InsufficientBalance(sender_, senderInfo_.balance, amount_);

        _subtractAmount(sender_, amount_, currentIndex_);
        _addAmount(recipient_, amount_, currentIndex_);
    }

    /**
     * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.
     * @param sender_    The sender's address.
     * @param recipient_ The recipient's address.
     * @param amount_    The amount to be transferred.
     */
    function _transfer(address sender_, address recipient_, uint256 amount_) internal override {
        _transfer(sender_, recipient_, UIntMath.safe240(amount_), _currentMIndex());
    }

    /* ============ Internal View/Pure Functions ============ */

    /**
     * @dev    Returns the M Token balance of `account`.
     * @param  account The account being queried.
     * @return balance_ The M Token balance of the account.
     */
    function _mBalanceOf(address account) internal view returns (uint256) {
        return IMTokenLike(mToken).balanceOf(account);
    }

    /**
     * @dev   Reverts if `amount` is equal to 0.
     * @param amount Amount of token.
     */
    function _revertIfInsufficientAmount(uint256 amount) internal pure {
        if (amount == 0) revert InsufficientAmount(amount);
    }

    /**
     * @dev   Reverts if `account` is address(0).
     * @param account Address of an account.
     */
    function _revertIfInvalidRecipient(address account) internal pure {
        if (account == address(0)) revert InvalidRecipient(account);
    }
}
