// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.26;
import { console } from "../lib/forge-std/src/console.sol";
import { IERC20 } from "../lib/common/src/interfaces/IERC20.sol";
import { IndexingMath } from "../lib/common/src/libs/IndexingMath.sol";
import { UIntMath } from "../lib/common/src/libs/UIntMath.sol";

import { IMExtension } from "./interfaces/IMExtension.sol";
import { IMTokenLike } from "./interfaces/IMTokenLike.sol";
import { IMYieldFee } from "./interfaces/IMYieldFee.sol";

import { MExtension } from "./abstract/MExtension.sol";
import { YieldFee } from "./abstract/components/YieldFee.sol";

/**
 * @title  ERC20 Token contract for wrapping M into a non-rebasing token.
 *         Extended to take a fee from the yield generated by M.
 * @dev    All holders of this ERC20 token are earners.
 * @author M^0 Labs
 */
contract MYieldFee is IMYieldFee, MExtension, YieldFee {
    /* ============ Structs ============ */

    /**
     * @dev   Struct to represent an account's balance and principal.
     * @param balance        The present amount of tokens held by the account.
     * @param principal      The earning principal of the account.
     * @param lastClaimIndex The last index at which the account claimed yield.
     */
    struct Account {
        // First slot
        uint240 balance;
        // Second slot
        uint112 principal;
        uint128 lastClaimIndex;
    }

    /* ============ Variables ============ */

    /// @inheritdoc IMYieldFee
    uint128 public enableMIndex;

    /// @inheritdoc IMYieldFee
    uint128 public disableIndex;

    /// @inheritdoc IERC20
    uint256 public totalSupply;

    /// @inheritdoc IMYieldFee
    uint112 public totalPrincipal;

    /// @inheritdoc IMYieldFee
    uint128 public lastYieldFeeClaimIndex;

    /// @dev Mapping of accounts to their respective `Account` info structs.
    mapping(address account => Account accountInfo) internal _accounts;

    /* ============ Constructor ============ */

    /**
     * @dev   Constructs the M Yield Fee token.
     * @param name_              The name of the token (e.g. "M Yield Fee").
     * @param symbol_            The symbol of the token (e.g. "MYF").
     * @param mToken_            The address of an M Token.
     * @param registrar_         The address of a registrar.
     * @param yieldFeeRate_      The fee rate, in bps, that will be taken from the yield generated by M.
     * @param yieldFeeRecipient_ The address of the recipient of the yield fee.
     * @param admin_             The address admnistrating the M extension. Can grant and revoke roles.
     * @param yieldFeeManager_   The address managing the fee rate and recipient.
     */
    constructor(
        string memory name_,
        string memory symbol_,
        address mToken_,
        address registrar_,
        uint16 yieldFeeRate_,
        address yieldFeeRecipient_,
        address admin_,
        address yieldFeeManager_
    )
        MExtension(name_, symbol_, mToken_, registrar_)
        YieldFee(yieldFeeRate_, yieldFeeRecipient_, admin_, yieldFeeManager_)
    {
        _setLastYieldFeeClaimIndex(yieldFeeIndex());
    }

    /* ============ Interactive Functions ============ */

    /// @inheritdoc IMYieldFee
    function claimYieldFor(address recipient_) external returns (uint256) {
        if (recipient_ == address(0)) revert ZeroYieldRecipient();

        Account storage accountInfo_ = _accounts[recipient_];
        uint128 yieldIndex_ = yieldIndex();

        uint240 yield_ = _getAccruedYield(
            accountInfo_.balance,
            accountInfo_.principal,
            yieldIndex_,
            accountInfo_.lastClaimIndex
        );

        if (yield_ == 0) return 0;

        // NOTE: No change in principal, only the balance is updated and the yield captured by updating the lastClaimIndex.
        unchecked {
            accountInfo_.balance += yield_;
            accountInfo_.lastClaimIndex = yieldIndex_;
        }

        emit YieldClaimed(msg.sender, recipient_, yield_);
        emit LastClaimIndexSet(recipient_, yieldIndex_);

        return yield_;
    }

    /// @inheritdoc IMYieldFee
    function claimYieldFee() external returns (uint256) {
        uint128 yieldFeeIndex_ = yieldFeeIndex();
        uint256 yieldFee_ = _accruedYieldFee(yieldFeeIndex_);

        if (yieldFee_ == 0) return 0;

        address recipient_ = yieldFeeRecipient;

        emit YieldFeeClaimed(msg.sender, recipient_, yieldFee_);

        _mint(recipient_, yieldFee_);

        // Update lastYieldFeeClaimIndex to capture the yield that has accumulated since the last claim.
        _setLastYieldFeeClaimIndex(yieldFeeIndex_);

        return yieldFee_;
    }

    /// @inheritdoc IMExtension
    function enableEarning() external override {
        if (!_isThisApprovedEarner()) revert NotApprovedEarner(address(this));
        if (isEarningEnabled()) revert EarningIsEnabled();

        emit EarningEnabled(enableMIndex = _currentMIndex());

        IMTokenLike(mToken).startEarning();
    }

    /// @inheritdoc IMExtension
    function disableEarning() external override {
        if (_isThisApprovedEarner()) revert IsApprovedEarner(address(this));
        if (!isEarningEnabled()) revert EarningIsDisabled();

        emit EarningDisabled(disableIndex = currentIndex());

        delete enableMIndex;

        IMTokenLike(mToken).stopEarning();
    }

    /* ============ External/Public view functions ============ */

    /// @inheritdoc IMYieldFee
    function accruedYieldOf(address account_) public view returns (uint240) {
        Account memory accountInfo_ = _accounts[account_];
        console.log("yieldIndex", yieldIndex());
        return
            _getAccruedYield(accountInfo_.balance, accountInfo_.principal, yieldIndex(), accountInfo_.lastClaimIndex);
    }

    /// @inheritdoc IMYieldFee
    function accruedYieldFee() public view returns (uint256) {
        return _accruedYieldFee(yieldFeeIndex());
    }

    /// @inheritdoc IERC20
    function balanceOf(address account_) public view returns (uint256) {
        return _accounts[account_].balance;
    }

    /// @inheritdoc IMYieldFee
    function balanceWithYieldOf(address account_) external view returns (uint256) {
        // NOTE: The returned amount includes the total accrued yield.
        //       Claiming yield does not necessarily result in the account's new balance equaling the value returned
        //       by `balanceWithYieldOf`, as the yield may be directed to a recipient different from the `account_`.
        unchecked {
            return balanceOf(account_) + accruedYieldOf(account_);
        }
    }

    /// @inheritdoc IMYieldFee
    function currentIndex() public view virtual returns (uint128) {
        uint128 disableIndex_ = disableIndex == 0 ? IndexingMath.EXP_SCALED_ONE : disableIndex;

        unchecked {
            return
                enableMIndex == 0
                    ? disableIndex_
                    : UIntMath.safe128((uint256(disableIndex_) * _currentMIndex()) / enableMIndex);
        }
    }

    /// @inheritdoc IMYieldFee
    function yieldIndex() public view returns (uint128) {
        unchecked {
            // Current index * effective rate / 10_000
            // i.e. for a 20% yield fee, the effective rate in basis points is 10_000 - 2_000 = 8_000
            return UIntMath.safe128((uint256(currentIndex()) * (HUNDRED_PERCENT - yieldFeeRate)) / HUNDRED_PERCENT);
        }
    }

    /// @inheritdoc IMYieldFee
    function yieldFeeIndex() public view returns (uint128) {
        unchecked {
            return UIntMath.safe128((uint256(currentIndex()) * (yieldFeeRate)) / HUNDRED_PERCENT);
        }
    }

    /// @inheritdoc IMExtension
    function isEarningEnabled() public view override returns (bool) {
        return enableMIndex != 0;
    }

    /// @inheritdoc IMYieldFee
    function principalOf(address account_) external view returns (uint112) {
        return _accounts[account_].principal;
    }

    /// @inheritdoc IMYieldFee
    function projectedSupply() public view returns (uint240) {
        return
            UIntMath.max240(
                IndexingMath.getPresentAmountRoundedUp(totalPrincipal, currentIndex()),
                UIntMath.safe240(totalSupply)
            );
    }

    /// @inheritdoc IMYieldFee
    function totalAccruedYield() public view returns (uint240) {
        console.log("projectedSupply", projectedSupply());
        console.log("totalSupply", totalSupply);
        unchecked {
            return projectedSupply() - UIntMath.safe240(totalSupply);
        }
    }

    /* ============ Internal Interactive Functions ============ */

    /**
     * @dev    Hooks called before wrapping M into M Extension token.
     * @param  account_   The account from which M is deposited.
     */
    function _beforeWrap(address account_, address /* recipient_ */, uint256 /* amount_ */) internal override {}

    /**
     * @dev   Mints `amount` tokens to `recipient`.
     * @param recipient_ The address whose account balance will be incremented.
     * @param amount_    The present amount of tokens to mint.
     */
    function _mint(address recipient_, uint256 amount_) internal override {
        uint240 safeAmount_ = UIntMath.safe240(amount_);

        _revertIfInsufficientAmount(safeAmount_);
        _revertIfInvalidRecipient(recipient_);
        _addAmount(recipient_, safeAmount_, currentIndex());

        emit Transfer(address(0), recipient_, safeAmount_);
    }

    /**
     * @dev   Increments the token balance of `account_` by `amount_`.
     * @param account_      The address whose account balance will be incremented.
     * @param amount_       The present amount of tokens to increment by.
     * @param currentIndex_ The current index to use to compute the principal amount.
     */
    function _addAmount(address account_, uint240 amount_, uint128 currentIndex_) internal {
        Account storage accountInfo_ = _accounts[account_];

        if (accountInfo_.lastClaimIndex == 0) {
            uint128 yieldIndex_ = yieldIndex();

            // NOTE: The last claim index is set to the current index when the account is first initialized.
            //       The yield is tracked per account and based on the difference in indices since they last claimed.
            accountInfo_.lastClaimIndex = yieldIndex();

            emit LastClaimIndexSet(account_, yieldIndex_);
        }

        // NOTE: all holders are earners, so there is no excess and all principal balances can be rounded down.
        uint112 principal_ = IndexingMath.getPrincipalAmountRoundedDown(amount_, currentIndex_);

        // NOTE: Can be `unchecked` because the max amount of wrappable M is never greater than `type(uint240).max`.
        unchecked {
            accountInfo_.balance += amount_;
            accountInfo_.principal = UIntMath.safe112(uint256(accountInfo_.principal) + principal_);
        }

        _addTotalSupply(amount_, principal_);
    }

    /**
     * @dev   Increments total supply by `amount_` of tokens.
     * @param amount_    The present amount of tokens to increment total supply by.
     * @param principal_ The principal amount of tokens to increment total principal by.
     */
    function _addTotalSupply(uint240 amount_, uint112 principal_) internal {
        unchecked {
            // Increment the total supply and principal proportionally.
            totalSupply += amount_;
            totalPrincipal = UIntMath.safe112(uint256(totalPrincipal) + principal_);
        }
    }

    /**
     * @dev   Decrements the token balance of `account_` by `amount_`.
     * @param account_      The address whose account balance will be decremented.
     * @param amount_       The present amount of tokens to decrement by.
     * @param currentIndex_ The current index to use to compute the principal amount.
     */
    function _subtractAmount(address account_, uint240 amount_, uint128 currentIndex_) internal {
        Account storage accountInfo_ = _accounts[account_];
        uint240 balance_ = accountInfo_.balance;

        if (balance_ < amount_) revert InsufficientBalance(account_, balance_, amount_);

        // NOTE: all holders are earners, so there is no excess and all principal balances can be rounded down.
        uint112 principal_ = IndexingMath.getPrincipalAmountRoundedDown(amount_, currentIndex_);

        unchecked {
            accountInfo_.balance -= amount_;
            accountInfo_.principal -= principal_;
        }

        _subtractTotalSupply(amount_, principal_);
    }

    /**
     * @dev   Decrements total supply by `amount_` tokens.
     * @param amount_    The present amount of tokens to decrement total supply by.
     * @param principal_ The principal amount of tokens to decrement total principal by.
     */
    function _subtractTotalSupply(uint240 amount_, uint112 principal_) internal {
        uint240 totalSupply_ = UIntMath.safe240(totalSupply);
        uint112 totalPrincipal_ = totalPrincipal;

        unchecked {
            // `min240` and `min112` prevent `totalSupply` and `totalPrincipal` underflow respectively.
            totalSupply = totalSupply_ - UIntMath.min240(amount_, totalSupply_);
            totalPrincipal = totalPrincipal_ - UIntMath.min112(principal_, totalPrincipal_);
        }
    }

    /**
     * @dev   Burns `amount_` tokens from `account_`.
     * @param account_ The address whose account balance will be decremented.
     * @param amount_  The present amount of tokens to burn.
     */
    function _burn(address account_, uint256 amount_) internal override {
        uint240 safeAmount_ = UIntMath.safe240(amount_);

        _revertIfInsufficientAmount(safeAmount_);
        _subtractAmount(account_, safeAmount_, currentIndex());

        emit Transfer(account_, address(0), safeAmount_);
    }

    /**
     * @dev   Transfers `amount_` tokens from `sender_` to `recipient_` given some current index.
     * @param sender_       The sender's address.
     * @param recipient_    The recipient's address.
     * @param amount_       The amount to be transferred.
     * @param currentIndex_ The current index.
     */
    function _transfer(address sender_, address recipient_, uint240 amount_, uint128 currentIndex_) internal {
        _revertIfInvalidRecipient(recipient_);

        emit Transfer(sender_, recipient_, amount_);

        if (amount_ == 0) return;

        Account storage senderInfo_ = _accounts[sender_];

        if (senderInfo_.balance < amount_) revert InsufficientBalance(sender_, senderInfo_.balance, amount_);
        if (sender_ == recipient_) return;

        _subtractAmount(sender_, amount_, currentIndex_);
        _addAmount(recipient_, amount_, currentIndex_);
    }

    /**
     * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.
     * @param sender_    The sender's address.
     * @param recipient_ The recipient's address.
     * @param amount_    The amount to be transferred.
     */
    function _transfer(address sender_, address recipient_, uint256 amount_) internal override {
        _transfer(sender_, recipient_, UIntMath.safe240(amount_), currentIndex());
    }

    /**
     * @dev   Sets the yield fee claim index.
     * @param index_ The new yield fee claim index.
     */
    function _setLastYieldFeeClaimIndex(uint128 index_) internal {
        lastYieldFeeClaimIndex = index_;
        emit LastYieldFeeClaimIndexSet(index_);
    }

    /* ============ Internal View/Pure Functions ============ */

    /**
     * @dev    Returns the current accrued yield fee.
     * @param  yieldFeeIndex_ The current yield fee index.
     * @return The accrued yield fee since the last claim.
     */
    function _accruedYieldFee(uint128 yieldFeeIndex_) internal view returns (uint256) {
        console.log("yieldFeeIndex()", yieldFeeIndex_);
        console.log("lastYieldFeeClaimIndex", lastYieldFeeClaimIndex);
        console.log("totalPrincipal", totalPrincipal);
        return
            yieldFeeRate != 0 && totalAccruedYield() != 0
                ? IndexingMath.getPresentAmountRoundedDown(totalPrincipal, yieldFeeIndex_ - lastYieldFeeClaimIndex)
                : 0;
    }

    /**
     * @dev   Reverts if `amount` is equal to 0.
     * @param amount Amount of token.
     */
    function _revertIfInsufficientAmount(uint256 amount) internal pure {
        if (amount == 0) revert InsufficientAmount(amount);
    }

    /**
     * @dev   Reverts if `account` is address(0).
     * @param account Address of an account.
     */
    function _revertIfInvalidRecipient(address account) internal pure {
        if (account == address(0)) revert InvalidRecipient(account);
    }
}
