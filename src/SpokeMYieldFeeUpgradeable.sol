// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.26;

import { MYieldFeeExtensionUpgradeable } from "./abstract/MYieldFeeExtensionUpgradeable.sol";

import { IContinuousIndexing } from "./interfaces/IContinuousIndexing.sol";
import { IRateOracle } from "./interfaces/IRateOracle.sol";
import { ISpokeMYieldFee } from "./interfaces/ISpokeMYieldFee.sol";

abstract contract SpokeMYieldFeeUpgradeableStorageLayout {
    /// @custom:storage-location erc7201:M0.storage.SpokeMYieldFee
    struct SpokeMYieldFeeStorageStruct {
        address rateOracle;
    }

    // keccak256(abi.encode(uint256(keccak256("M0.storage.SpokeMYieldFee")) - 1)) & ~bytes32(uint256(0xff))
    bytes32 private constant _SPOKE_M_YIELD_FEE_STORAGE_LOCATION =
        0xe9a07539918cdd0d6f42b501c9c93a2648c779985ee4e296943c976889219c00;

    function _getSpokeMYieldFeeStorageLocation() internal pure returns (SpokeMYieldFeeStorageStruct storage $) {
        assembly {
            $.slot := _SPOKE_M_YIELD_FEE_STORAGE_LOCATION
        }
    }
}

/**
 * @title  SpokeMYieldFeeUpgradeable
 * @notice Upgradeable ERC20 Token contract for wrapping M into a non-rebasing token.
 *         Extended to take a fee from the yield generated by M.
 * @dev    All holders of this ERC20 token are earners.
 * @dev    This M extension must only be deployed on Spoke chains.
 *         Check MYieldFeeUpgradeable for the Mainnet version.
 * @author M0 Labs
 */
contract SpokeMYieldFeeUpgradeable is
    ISpokeMYieldFee,
    SpokeMYieldFeeUpgradeableStorageLayout,
    MYieldFeeExtensionUpgradeable
{
    /* ============ Initializer ============ */

    /**
     * @dev   Constructs the M Yield Fee token.
     * @param name              The name of the token (e.g. "M Yield Fee").
     * @param symbol            The symbol of the token (e.g. "MYF").
     * @param mToken            The address of a Spoke M Token.
     * @param yieldFeeRate      The fee rate, in bps, that will be taken from the yield generated by M.
     * @param yieldFeeRecipient The address of the recipient of the yield fee.
     * @param admin             The address administrating the M extension. Can grant and revoke roles.
     * @param yieldFeeManager   The address managing the fee rate and recipient.
     * @param rateOracle_       The address of a rate oracle.
     */
    function initialize(
        string memory name,
        string memory symbol,
        address mToken,
        uint16 yieldFeeRate,
        address yieldFeeRecipient,
        address admin,
        address yieldFeeManager,
        address rateOracle_
    ) public virtual initializer {
        if ((_getSpokeMYieldFeeStorageLocation().rateOracle = rateOracle_) == address(0)) revert ZeroRateOracle();

        __MYieldFeeExtensionUpgradeable_init(
            name,
            symbol,
            mToken,
            yieldFeeRate,
            yieldFeeRecipient,
            admin,
            yieldFeeManager
        );
    }

    /* ============ View/Pure Functions ============ */

    /// @inheritdoc ISpokeMYieldFee
    function rateOracle() public view returns (address) {
        return _getSpokeMYieldFeeStorageLocation().rateOracle;
    }

    /* ============ Internal View/Pure Functions ============ */

    /**
     * @dev    Returns the current block timestamp.
     * @dev    Uses `latestUpdateTimestamp` from Spoke M to cap `currentIndex` to the timestamp
     *         when Spoke M's index was last updated and thus avoid overprinting M extension tokens.
     * @return The current block timestamp.
     */
    function _currentBlockTimestamp() internal view override returns (uint40) {
        return IContinuousIndexing(mToken()).latestUpdateTimestamp();
    }

    /// @dev Returns the current earner rate.
    function _currentEarnerRate() internal view override returns (uint32) {
        // NOTE: The behavior of Rate Oracle is known, so we can safely retrieve the earner rate.
        return IRateOracle(rateOracle()).earnerRate();
    }
}
