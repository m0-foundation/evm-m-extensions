/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IAccessControl} from "@openzeppelin/contracts/access/IAccessControl.sol";
   7 |     | import {ContextUpgradeable} from "../utils/ContextUpgradeable.sol";
   8 |     | import {ERC165Upgradeable} from "../utils/introspection/ERC165Upgradeable.sol";
   9 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Contract module that allows children to implement role-based access
  13 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  14 |     |  * members except through off-chain means by accessing the contract event logs. Some
  15 |     |  * applications may benefit from on-chain enumerability, for those cases see
  16 |     |  * {AccessControlEnumerable}.
  17 |     |  *
  18 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  19 |     |  * in the external API and be unique. The best way to achieve this is by
  20 |     |  * using `public constant` hash digests:
  21 |     |  *
  22 |     |  * ```solidity
  23 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  24 |     |  * ```
  25 |     |  *
  26 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  27 |     |  * function call, use {hasRole}:
  28 |     |  *
  29 |     |  * ```solidity
  30 |     |  * function foo() public {
  31 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  32 |     |  *     ...
  33 |     |  * }
  34 |     |  * ```
  35 |     |  *
  36 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  37 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  38 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  39 |     |  *
  40 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  41 |     |  * that only accounts with this role will be able to grant or revoke other
  42 |     |  * roles. More complex role relationships can be created by using
  43 |     |  * {_setRoleAdmin}.
  44 |     |  *
  45 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  46 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  47 |     |  * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
  48 |     |  * to enforce additional security measures for this role.
  49 |     |  */
  50 |     | abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {
  51 |     |     struct RoleData {
  52 |     |         mapping(address account => bool) hasRole;
  53 |     |         bytes32 adminRole;
  54 |     |     }
  55 |     | 
  56 | *   |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  57 |     | 
  58 |     | 
  59 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl
  60 |     |     struct AccessControlStorage {
  61 |     |         mapping(bytes32 role => RoleData) _roles;
  62 |     |     }
  63 |     | 
  64 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))
  65 |     |     bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;
  66 |     | 
  67 | *   |     function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {
  68 |     |         assembly {
  69 | *   |             $.slot := AccessControlStorageLocation
  70 |     |         }
  71 |     |     }
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  75 |     |      * with an {AccessControlUnauthorizedAccount} error including the required role.
  76 |     |      */
  77 |     |     modifier onlyRole(bytes32 role) {
  78 | *   |         _checkRole(role);
  79 | *   |         _;
  80 |     |     }
  81 |     | 
  82 |     |     function __AccessControl_init() internal onlyInitializing {
  83 |     |     }
  84 |     | 
  85 |     |     function __AccessControl_init_unchained() internal onlyInitializing {
  86 |     |     }
  87 |     |     /**
  88 |     |      * @dev See {IERC165-supportsInterface}.
  89 |     |      */
  90 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  91 |     |         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Returns `true` if `account` has been granted `role`.
  96 |     |      */
  97 | *   |     function hasRole(bytes32 role, address account) public view virtual returns (bool) {
  98 | *   |         AccessControlStorage storage $ = _getAccessControlStorage();
  99 | *   |         return $._roles[role].hasRole[account];
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
 104 |     |      * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
 105 |     |      */
 106 | *   |     function _checkRole(bytes32 role) internal view virtual {
 107 | *   |         _checkRole(role, _msgSender());
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
 112 |     |      * is missing `role`.
 113 |     |      */
 114 | *   |     function _checkRole(bytes32 role, address account) internal view virtual {
 115 | *   |         if (!hasRole(role, account)) {
 116 | *   |             revert AccessControlUnauthorizedAccount(account, role);
 117 |     |         }
 118 |     |     }
 119 |     | 
 120 |     |     /**
 121 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 122 |     |      * {revokeRole}.
 123 |     |      *
 124 |     |      * To change a role's admin, use {_setRoleAdmin}.
 125 |     |      */
 126 | *   |     function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
 127 | *   |         AccessControlStorage storage $ = _getAccessControlStorage();
 128 | *   |         return $._roles[role].adminRole;
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Grants `role` to `account`.
 133 |     |      *
 134 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 135 |     |      * event.
 136 |     |      *
 137 |     |      * Requirements:
 138 |     |      *
 139 |     |      * - the caller must have ``role``'s admin role.
 140 |     |      *
 141 |     |      * May emit a {RoleGranted} event.
 142 |     |      */
 143 | *   |     function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 144 | *   |         _grantRole(role, account);
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev Revokes `role` from `account`.
 149 |     |      *
 150 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 151 |     |      *
 152 |     |      * Requirements:
 153 |     |      *
 154 |     |      * - the caller must have ``role``'s admin role.
 155 |     |      *
 156 |     |      * May emit a {RoleRevoked} event.
 157 |     |      */
 158 |     |     function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 159 |     |         _revokeRole(role, account);
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @dev Revokes `role` from the calling account.
 164 |     |      *
 165 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 166 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 167 |     |      * if they are compromised (such as when a trusted device is misplaced).
 168 |     |      *
 169 |     |      * If the calling account had been revoked `role`, emits a {RoleRevoked}
 170 |     |      * event.
 171 |     |      *
 172 |     |      * Requirements:
 173 |     |      *
 174 |     |      * - the caller must be `callerConfirmation`.
 175 |     |      *
 176 |     |      * May emit a {RoleRevoked} event.
 177 |     |      */
 178 |     |     function renounceRole(bytes32 role, address callerConfirmation) public virtual {
 179 |     |         if (callerConfirmation != _msgSender()) {
 180 |     |             revert AccessControlBadConfirmation();
 181 |     |         }
 182 |     | 
 183 |     |         _revokeRole(role, callerConfirmation);
 184 |     |     }
 185 |     | 
 186 |     |     /**
 187 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 188 |     |      *
 189 |     |      * Emits a {RoleAdminChanged} event.
 190 |     |      */
 191 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 192 |     |         AccessControlStorage storage $ = _getAccessControlStorage();
 193 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 194 |     |         $._roles[role].adminRole = adminRole;
 195 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 196 |     |     }
 197 |     | 
 198 |     |     /**
 199 |     |      * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
 200 |     |      *
 201 |     |      * Internal function without access restriction.
 202 |     |      *
 203 |     |      * May emit a {RoleGranted} event.
 204 |     |      */
 205 | *   |     function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
 206 | *   |         AccessControlStorage storage $ = _getAccessControlStorage();
 207 | *   |         if (!hasRole(role, account)) {
 208 | *   |             $._roles[role].hasRole[account] = true;
 209 | *   |             emit RoleGranted(role, account, _msgSender());
 210 | *   |             return true;
 211 |     |         } else {
 212 |     |             return false;
 213 |     |         }
 214 |     |     }
 215 |     | 
 216 |     |     /**
 217 |     |      * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.
 218 |     |      *
 219 |     |      * Internal function without access restriction.
 220 |     |      *
 221 |     |      * May emit a {RoleRevoked} event.
 222 |     |      */
 223 |     |     function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
 224 |     |         AccessControlStorage storage $ = _getAccessControlStorage();
 225 |     |         if (hasRole(role, account)) {
 226 |     |             $._roles[role].hasRole[account] = false;
 227 |     |             emit RoleRevoked(role, account, _msgSender());
 228 |     |             return true;
 229 |     |         } else {
 230 |     |             return false;
 231 |     |         }
 232 |     |     }
 233 |     | }
 234 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
   8 |     |  * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
   9 |     |  * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
  10 |     |  * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
  11 |     |  *
  12 |     |  * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
  13 |     |  * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
  14 |     |  * case an upgrade adds a module that needs to be initialized.
  15 |     |  *
  16 |     |  * For example:
  17 |     |  *
  18 |     |  * [.hljs-theme-light.nopadding]
  19 |     |  * ```solidity
  20 |     |  * contract MyToken is ERC20Upgradeable {
  21 |     |  *     function initialize() initializer public {
  22 |     |  *         __ERC20_init("MyToken", "MTK");
  23 |     |  *     }
  24 |     |  * }
  25 |     |  *
  26 |     |  * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
  27 |     |  *     function initializeV2() reinitializer(2) public {
  28 |     |  *         __ERC20Permit_init("MyToken");
  29 |     |  *     }
  30 |     |  * }
  31 |     |  * ```
  32 |     |  *
  33 |     |  * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
  34 |     |  * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
  35 |     |  *
  36 |     |  * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
  37 |     |  * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
  38 |     |  *
  39 |     |  * [CAUTION]
  40 |     |  * ====
  41 |     |  * Avoid leaving a contract uninitialized.
  42 |     |  *
  43 |     |  * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
  44 |     |  * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
  45 |     |  * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
  46 |     |  *
  47 |     |  * [.hljs-theme-light.nopadding]
  48 |     |  * ```
  49 |     |  * /// @custom:oz-upgrades-unsafe-allow constructor
  50 |     |  * constructor() {
  51 |     |  *     _disableInitializers();
  52 |     |  * }
  53 |     |  * ```
  54 |     |  * ====
  55 |     |  */
  56 |     | abstract contract Initializable {
  57 |     |     /**
  58 |     |      * @dev Storage of the initializable contract.
  59 |     |      *
  60 |     |      * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions
  61 |     |      * when using with upgradeable contracts.
  62 |     |      *
  63 |     |      * @custom:storage-location erc7201:openzeppelin.storage.Initializable
  64 |     |      */
  65 |     |     struct InitializableStorage {
  66 |     |         /**
  67 |     |          * @dev Indicates that the contract has been initialized.
  68 |     |          */
  69 |     |         uint64 _initialized;
  70 |     |         /**
  71 |     |          * @dev Indicates that the contract is in the process of being initialized.
  72 |     |          */
  73 |     |         bool _initializing;
  74 |     |     }
  75 |     | 
  76 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))
  77 | *   |     bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev The contract is already initialized.
  81 |     |      */
  82 |     |     error InvalidInitialization();
  83 |     | 
  84 |     |     /**
  85 |     |      * @dev The contract is not initializing.
  86 |     |      */
  87 |     |     error NotInitializing();
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Triggered when the contract has been initialized or reinitialized.
  91 |     |      */
  92 |     |     event Initialized(uint64 version);
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
  96 |     |      * `onlyInitializing` functions can be used to initialize parent contracts.
  97 |     |      *
  98 |     |      * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any
  99 |     |      * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in
 100 |     |      * production.
 101 |     |      *
 102 |     |      * Emits an {Initialized} event.
 103 |     |      */
 104 | *   |     modifier initializer() {
 105 |     |         // solhint-disable-next-line var-name-mixedcase
 106 | *   |         InitializableStorage storage $ = _getInitializableStorage();
 107 |     | 
 108 |     |         // Cache values to avoid duplicated sloads
 109 | *   |         bool isTopLevelCall = !$._initializing;
 110 | *   |         uint64 initialized = $._initialized;
 111 |     | 
 112 |     |         // Allowed calls:
 113 |     |         // - initialSetup: the contract is not in the initializing state and no previous version was
 114 |     |         //                 initialized
 115 |     |         // - construction: the contract is initialized at version 1 (no reinitialization) and the
 116 |     |         //                 current contract is just being deployed
 117 | *   |         bool initialSetup = initialized == 0 && isTopLevelCall;
 118 | *   |         bool construction = initialized == 1 && address(this).code.length == 0;
 119 |     | 
 120 | *   |         if (!initialSetup && !construction) {
 121 |     |             revert InvalidInitialization();
 122 |     |         }
 123 | *   |         $._initialized = 1;
 124 | *   |         if (isTopLevelCall) {
 125 | *   |             $._initializing = true;
 126 |     |         }
 127 |     |         _;
 128 | *   |         if (isTopLevelCall) {
 129 | *   |             $._initializing = false;
 130 | *   |             emit Initialized(1);
 131 |     |         }
 132 |     |     }
 133 |     | 
 134 |     |     /**
 135 |     |      * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
 136 |     |      * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
 137 |     |      * used to initialize parent contracts.
 138 |     |      *
 139 |     |      * A reinitializer may be used after the original initialization step. This is essential to configure modules that
 140 |     |      * are added through upgrades and that require initialization.
 141 |     |      *
 142 |     |      * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
 143 |     |      * cannot be nested. If one is invoked in the context of another, execution will revert.
 144 |     |      *
 145 |     |      * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
 146 |     |      * a contract, executing them in the right order is up to the developer or operator.
 147 |     |      *
 148 |     |      * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.
 149 |     |      *
 150 |     |      * Emits an {Initialized} event.
 151 |     |      */
 152 |     |     modifier reinitializer(uint64 version) {
 153 |     |         // solhint-disable-next-line var-name-mixedcase
 154 |     |         InitializableStorage storage $ = _getInitializableStorage();
 155 |     | 
 156 |     |         if ($._initializing || $._initialized >= version) {
 157 |     |             revert InvalidInitialization();
 158 |     |         }
 159 |     |         $._initialized = version;
 160 |     |         $._initializing = true;
 161 |     |         _;
 162 |     |         $._initializing = false;
 163 |     |         emit Initialized(version);
 164 |     |     }
 165 |     | 
 166 |     |     /**
 167 |     |      * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
 168 |     |      * {initializer} and {reinitializer} modifiers, directly or indirectly.
 169 |     |      */
 170 |     |     modifier onlyInitializing() {
 171 | *   |         _checkInitializing();
 172 |     |         _;
 173 |     |     }
 174 |     | 
 175 |     |     /**
 176 |     |      * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.
 177 |     |      */
 178 | *   |     function _checkInitializing() internal view virtual {
 179 | *   |         if (!_isInitializing()) {
 180 |     |             revert NotInitializing();
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
 186 |     |      * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
 187 |     |      * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
 188 |     |      * through proxies.
 189 |     |      *
 190 |     |      * Emits an {Initialized} event the first time it is successfully executed.
 191 |     |      */
 192 | *   |     function _disableInitializers() internal virtual {
 193 |     |         // solhint-disable-next-line var-name-mixedcase
 194 | *   |         InitializableStorage storage $ = _getInitializableStorage();
 195 |     | 
 196 | *   |         if ($._initializing) {
 197 |     |             revert InvalidInitialization();
 198 |     |         }
 199 | *   |         if ($._initialized != type(uint64).max) {
 200 | *   |             $._initialized = type(uint64).max;
 201 | *   |             emit Initialized(type(uint64).max);
 202 |     |         }
 203 |     |     }
 204 |     | 
 205 |     |     /**
 206 |     |      * @dev Returns the highest version that has been initialized. See {reinitializer}.
 207 |     |      */
 208 |     |     function _getInitializedVersion() internal view returns (uint64) {
 209 |     |         return _getInitializableStorage()._initialized;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.
 214 |     |      */
 215 | *   |     function _isInitializing() internal view returns (bool) {
 216 | *   |         return _getInitializableStorage()._initializing;
 217 |     |     }
 218 |     | 
 219 |     |     /**
 220 |     |      * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.
 221 |     |      *
 222 |     |      * NOTE: Consider following the ERC-7201 formula to derive storage locations.
 223 |     |      */
 224 | *   |     function _initializableStorageSlot() internal pure virtual returns (bytes32) {
 225 | *   |         return INITIALIZABLE_STORAGE;
 226 |     |     }
 227 |     | 
 228 |     |     /**
 229 |     |      * @dev Returns a pointer to the storage namespace.
 230 |     |      */
 231 |     |     // solhint-disable-next-line var-name-mixedcase
 232 | *   |     function _getInitializableStorage() private pure returns (InitializableStorage storage $) {
 233 | *   |         bytes32 slot = _initializableStorageSlot();
 234 | *   |         assembly {
 235 | *   |             $.slot := slot
 236 |     |         }
 237 |     |     }
 238 |     | }
 239 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Provides information about the current execution context, including the
  9 |     |  * sender of the transaction and its data. While these are generally available
 10 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 11 |     |  * manner, since when dealing with meta-transactions the account sending and
 12 |     |  * paying for execution may not be the actual sender (as far as an application
 13 |     |  * is concerned).
 14 |     |  *
 15 |     |  * This contract is only required for intermediate, library-like contracts.
 16 |     |  */
 17 |     | abstract contract ContextUpgradeable is Initializable {
 18 |     |     function __Context_init() internal onlyInitializing {
 19 |     |     }
 20 |     | 
 21 |     |     function __Context_init_unchained() internal onlyInitializing {
 22 |     |     }
 23 | *   |     function _msgSender() internal view virtual returns (address) {
 24 | *   |         return msg.sender;
 25 |     |     }
 26 |     | 
 27 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 28 |     |         return msg.data;
 29 |     |     }
 30 |     | 
 31 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 32 |     |         return 0;
 33 |     |     }
 34 |     | }
 35 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/contracts/utils/PausableUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {ContextUpgradeable} from "../utils/ContextUpgradeable.sol";
   7 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev Contract module which allows children to implement an emergency stop
  11 |     |  * mechanism that can be triggered by an authorized account.
  12 |     |  *
  13 |     |  * This module is used through inheritance. It will make available the
  14 |     |  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
  15 |     |  * the functions of your contract. Note that they will not be pausable by
  16 |     |  * simply including this module, only once the modifiers are put in place.
  17 |     |  */
  18 |     | abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {
  19 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.Pausable
  20 |     |     struct PausableStorage {
  21 |     |         bool _paused;
  22 |     |     }
  23 |     | 
  24 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))
  25 |     |     bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;
  26 |     | 
  27 | *   |     function _getPausableStorage() private pure returns (PausableStorage storage $) {
  28 |     |         assembly {
  29 | *   |             $.slot := PausableStorageLocation
  30 |     |         }
  31 |     |     }
  32 |     | 
  33 |     |     /**
  34 |     |      * @dev Emitted when the pause is triggered by `account`.
  35 |     |      */
  36 |     |     event Paused(address account);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Emitted when the pause is lifted by `account`.
  40 |     |      */
  41 |     |     event Unpaused(address account);
  42 |     | 
  43 |     |     /**
  44 |     |      * @dev The operation failed because the contract is paused.
  45 |     |      */
  46 |     |     error EnforcedPause();
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev The operation failed because the contract is not paused.
  50 |     |      */
  51 |     |     error ExpectedPause();
  52 |     | 
  53 |     |     /**
  54 |     |      * @dev Modifier to make a function callable only when the contract is not paused.
  55 |     |      *
  56 |     |      * Requirements:
  57 |     |      *
  58 |     |      * - The contract must not be paused.
  59 |     |      */
  60 |     |     modifier whenNotPaused() {
  61 |     |         _requireNotPaused();
  62 |     |         _;
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Modifier to make a function callable only when the contract is paused.
  67 |     |      *
  68 |     |      * Requirements:
  69 |     |      *
  70 |     |      * - The contract must be paused.
  71 |     |      */
  72 |     |     modifier whenPaused() {
  73 |     |         _requirePaused();
  74 |     |         _;
  75 |     |     }
  76 |     | 
  77 |     |     function __Pausable_init() internal onlyInitializing {
  78 |     |     }
  79 |     | 
  80 |     |     function __Pausable_init_unchained() internal onlyInitializing {
  81 |     |     }
  82 |     |     /**
  83 |     |      * @dev Returns true if the contract is paused, and false otherwise.
  84 |     |      */
  85 | *   |     function paused() public view virtual returns (bool) {
  86 | *   |         PausableStorage storage $ = _getPausableStorage();
  87 | *   |         return $._paused;
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Throws if the contract is paused.
  92 |     |      */
  93 | *   |     function _requireNotPaused() internal view virtual {
  94 | *   |         if (paused()) {
  95 |     |             revert EnforcedPause();
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Throws if the contract is not paused.
 101 |     |      */
 102 |     |     function _requirePaused() internal view virtual {
 103 |     |         if (!paused()) {
 104 |     |             revert ExpectedPause();
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev Triggers stopped state.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - The contract must not be paused.
 114 |     |      */
 115 |     |     function _pause() internal virtual whenNotPaused {
 116 |     |         PausableStorage storage $ = _getPausableStorage();
 117 |     |         $._paused = true;
 118 |     |         emit Paused(_msgSender());
 119 |     |     }
 120 |     | 
 121 |     |     /**
 122 |     |      * @dev Returns to normal state.
 123 |     |      *
 124 |     |      * Requirements:
 125 |     |      *
 126 |     |      * - The contract must be paused.
 127 |     |      */
 128 |     |     function _unpause() internal virtual whenPaused {
 129 |     |         PausableStorage storage $ = _getPausableStorage();
 130 |     |         $._paused = false;
 131 |     |         emit Unpaused(_msgSender());
 132 |     |     }
 133 |     | }
 134 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
  7 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Implementation of the {IERC165} interface.
 11 |     |  *
 12 |     |  * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check
 13 |     |  * for the additional interface id that will be supported. For example:
 14 |     |  *
 15 |     |  * ```solidity
 16 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 17 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 18 |     |  * }
 19 |     |  * ```
 20 |     |  */
 21 |     | abstract contract ERC165Upgradeable is Initializable, IERC165 {
 22 |     |     function __ERC165_init() internal onlyInitializing {
 23 |     |     }
 24 |     | 
 25 |     |     function __ERC165_init_unchained() internal onlyInitializing {
 26 |     |     }
 27 |     |     /**
 28 |     |      * @dev See {IERC165-supportsInterface}.
 29 |     |      */
 30 |     |     function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
 31 |     |         return interfaceId == type(IERC165).interfaceId;
 32 |     |     }
 33 |     | }
 34 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/AccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IAccessControl} from "./IAccessControl.sol";
   7 |     | import {Context} from "../utils/Context.sol";
   8 |     | import {ERC165} from "../utils/introspection/ERC165.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Contract module that allows children to implement role-based access
  12 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  13 |     |  * members except through off-chain means by accessing the contract event logs. Some
  14 |     |  * applications may benefit from on-chain enumerability, for those cases see
  15 |     |  * {AccessControlEnumerable}.
  16 |     |  *
  17 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  18 |     |  * in the external API and be unique. The best way to achieve this is by
  19 |     |  * using `public constant` hash digests:
  20 |     |  *
  21 |     |  * ```solidity
  22 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  23 |     |  * ```
  24 |     |  *
  25 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  26 |     |  * function call, use {hasRole}:
  27 |     |  *
  28 |     |  * ```solidity
  29 |     |  * function foo() public {
  30 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  31 |     |  *     ...
  32 |     |  * }
  33 |     |  * ```
  34 |     |  *
  35 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  36 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  37 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  38 |     |  *
  39 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  40 |     |  * that only accounts with this role will be able to grant or revoke other
  41 |     |  * roles. More complex role relationships can be created by using
  42 |     |  * {_setRoleAdmin}.
  43 |     |  *
  44 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  45 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  46 |     |  * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
  47 |     |  * to enforce additional security measures for this role.
  48 |     |  */
  49 |     | abstract contract AccessControl is Context, IAccessControl, ERC165 {
  50 |     |     struct RoleData {
  51 |     |         mapping(address account => bool) hasRole;
  52 |     |         bytes32 adminRole;
  53 |     |     }
  54 |     | 
  55 |     |     mapping(bytes32 role => RoleData) private _roles;
  56 |     | 
  57 | *   |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  61 |     |      * with an {AccessControlUnauthorizedAccount} error including the required role.
  62 |     |      */
  63 |     |     modifier onlyRole(bytes32 role) {
  64 |     |         _checkRole(role);
  65 |     |         _;
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev See {IERC165-supportsInterface}.
  70 |     |      */
  71 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  72 |     |         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Returns `true` if `account` has been granted `role`.
  77 |     |      */
  78 | *   |     function hasRole(bytes32 role, address account) public view virtual returns (bool) {
  79 | *   |         return _roles[role].hasRole[account];
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
  84 |     |      * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
  85 |     |      */
  86 |     |     function _checkRole(bytes32 role) internal view virtual {
  87 |     |         _checkRole(role, _msgSender());
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
  92 |     |      * is missing `role`.
  93 |     |      */
  94 |     |     function _checkRole(bytes32 role, address account) internal view virtual {
  95 |     |         if (!hasRole(role, account)) {
  96 |     |             revert AccessControlUnauthorizedAccount(account, role);
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 102 |     |      * {revokeRole}.
 103 |     |      *
 104 |     |      * To change a role's admin, use {_setRoleAdmin}.
 105 |     |      */
 106 |     |     function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
 107 |     |         return _roles[role].adminRole;
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev Grants `role` to `account`.
 112 |     |      *
 113 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 114 |     |      * event.
 115 |     |      *
 116 |     |      * Requirements:
 117 |     |      *
 118 |     |      * - the caller must have ``role``'s admin role.
 119 |     |      *
 120 |     |      * May emit a {RoleGranted} event.
 121 |     |      */
 122 |     |     function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 123 |     |         _grantRole(role, account);
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Revokes `role` from `account`.
 128 |     |      *
 129 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 130 |     |      *
 131 |     |      * Requirements:
 132 |     |      *
 133 |     |      * - the caller must have ``role``'s admin role.
 134 |     |      *
 135 |     |      * May emit a {RoleRevoked} event.
 136 |     |      */
 137 |     |     function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 138 |     |         _revokeRole(role, account);
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @dev Revokes `role` from the calling account.
 143 |     |      *
 144 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 145 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 146 |     |      * if they are compromised (such as when a trusted device is misplaced).
 147 |     |      *
 148 |     |      * If the calling account had been revoked `role`, emits a {RoleRevoked}
 149 |     |      * event.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - the caller must be `callerConfirmation`.
 154 |     |      *
 155 |     |      * May emit a {RoleRevoked} event.
 156 |     |      */
 157 |     |     function renounceRole(bytes32 role, address callerConfirmation) public virtual {
 158 |     |         if (callerConfirmation != _msgSender()) {
 159 |     |             revert AccessControlBadConfirmation();
 160 |     |         }
 161 |     | 
 162 |     |         _revokeRole(role, callerConfirmation);
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 167 |     |      *
 168 |     |      * Emits a {RoleAdminChanged} event.
 169 |     |      */
 170 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 171 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 172 |     |         _roles[role].adminRole = adminRole;
 173 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 174 |     |     }
 175 |     | 
 176 |     |     /**
 177 |     |      * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
 178 |     |      *
 179 |     |      * Internal function without access restriction.
 180 |     |      *
 181 |     |      * May emit a {RoleGranted} event.
 182 |     |      */
 183 | *   |     function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
 184 | *   |         if (!hasRole(role, account)) {
 185 | *   |             _roles[role].hasRole[account] = true;
 186 | *   |             emit RoleGranted(role, account, _msgSender());
 187 | *   |             return true;
 188 |     |         } else {
 189 |     |             return false;
 190 |     |         }
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.
 195 |     |      *
 196 |     |      * Internal function without access restriction.
 197 |     |      *
 198 |     |      * May emit a {RoleRevoked} event.
 199 |     |      */
 200 |     |     function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
 201 |     |         if (hasRole(role, account)) {
 202 |     |             _roles[role].hasRole[account] = false;
 203 |     |             emit RoleRevoked(role, account, _msgSender());
 204 |     |             return true;
 205 |     |         } else {
 206 |     |             return false;
 207 |     |         }
 208 |     |     }
 209 |     | }
 210 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev External interface of AccessControl declared to support ERC-165 detection.
   8 |     |  */
   9 |     | interface IAccessControl {
  10 |     |     /**
  11 |     |      * @dev The `account` is missing a role.
  12 |     |      */
  13 |     |     error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev The caller of a function is not the expected one.
  17 |     |      *
  18 |     |      * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
  19 |     |      */
  20 |     |     error AccessControlBadConfirmation();
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
  24 |     |      *
  25 |     |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
  26 |     |      * {RoleAdminChanged} not being emitted to signal this.
  27 |     |      */
  28 |     |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Emitted when `account` is granted `role`.
  32 |     |      *
  33 |     |      * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).
  34 |     |      * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.
  35 |     |      */
  36 |     |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Emitted when `account` is revoked `role`.
  40 |     |      *
  41 |     |      * `sender` is the account that originated the contract call:
  42 |     |      *   - if using `revokeRole`, it is the admin role bearer
  43 |     |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
  44 |     |      */
  45 |     |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Returns `true` if `account` has been granted `role`.
  49 |     |      */
  50 |     |     function hasRole(bytes32 role, address account) external view returns (bool);
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
  54 |     |      * {revokeRole}.
  55 |     |      *
  56 |     |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
  57 |     |      */
  58 |     |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Grants `role` to `account`.
  62 |     |      *
  63 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
  64 |     |      * event.
  65 |     |      *
  66 |     |      * Requirements:
  67 |     |      *
  68 |     |      * - the caller must have ``role``'s admin role.
  69 |     |      */
  70 |     |     function grantRole(bytes32 role, address account) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Revokes `role` from `account`.
  74 |     |      *
  75 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
  76 |     |      *
  77 |     |      * Requirements:
  78 |     |      *
  79 |     |      * - the caller must have ``role``'s admin role.
  80 |     |      */
  81 |     |     function revokeRole(bytes32 role, address account) external;
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Revokes `role` from the calling account.
  85 |     |      *
  86 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
  87 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
  88 |     |      * if they are compromised (such as when a trusted device is misplaced).
  89 |     |      *
  90 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
  91 |     |      * event.
  92 |     |      *
  93 |     |      * Requirements:
  94 |     |      *
  95 |     |      * - the caller must be `callerConfirmation`.
  96 |     |      */
  97 |     |     function renounceRole(bytes32 role, address callerConfirmation) external;
  98 |     | }
  99 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/Ownable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Context} from "../utils/Context.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Contract module which provides a basic access control mechanism, where
  10 |     |  * there is an account (an owner) that can be granted exclusive access to
  11 |     |  * specific functions.
  12 |     |  *
  13 |     |  * The initial owner is set to the address provided by the deployer. This can
  14 |     |  * later be changed with {transferOwnership}.
  15 |     |  *
  16 |     |  * This module is used through inheritance. It will make available the modifier
  17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
  18 |     |  * the owner.
  19 |     |  */
  20 |     | abstract contract Ownable is Context {
  21 |     |     address private _owner;
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev The caller account is not authorized to perform an operation.
  25 |     |      */
  26 |     |     error OwnableUnauthorizedAccount(address account);
  27 |     | 
  28 |     |     /**
  29 |     |      * @dev The owner is not a valid owner account. (eg. `address(0)`)
  30 |     |      */
  31 |     |     error OwnableInvalidOwner(address owner);
  32 |     | 
  33 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev Initializes the contract setting the address provided by the deployer as the initial owner.
  37 |     |      */
  38 |     |     constructor(address initialOwner) {
  39 |     |         if (initialOwner == address(0)) {
  40 |     |             revert OwnableInvalidOwner(address(0));
  41 |     |         }
  42 |     |         _transferOwnership(initialOwner);
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Throws if called by any account other than the owner.
  47 |     |      */
  48 |     |     modifier onlyOwner() {
  49 |     |         _checkOwner();
  50 |     |         _;
  51 |     |     }
  52 |     | 
  53 |     |     /**
  54 |     |      * @dev Returns the address of the current owner.
  55 |     |      */
  56 |     |     function owner() public view virtual returns (address) {
  57 |     |         return _owner;
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Throws if the sender is not the owner.
  62 |     |      */
  63 |     |     function _checkOwner() internal view virtual {
  64 |     |         if (owner() != _msgSender()) {
  65 |     |             revert OwnableUnauthorizedAccount(_msgSender());
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Leaves the contract without owner. It will not be possible to call
  71 |     |      * `onlyOwner` functions. Can only be called by the current owner.
  72 |     |      *
  73 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
  74 |     |      * thereby disabling any functionality that is only available to the owner.
  75 |     |      */
  76 |     |     function renounceOwnership() public virtual onlyOwner {
  77 |     |         _transferOwnership(address(0));
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  82 |     |      * Can only be called by the current owner.
  83 |     |      */
  84 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
  85 |     |         if (newOwner == address(0)) {
  86 |     |             revert OwnableInvalidOwner(address(0));
  87 |     |         }
  88 |     |         _transferOwnership(newOwner);
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  93 |     |      * Internal function without access restriction.
  94 |     |      */
  95 |     |     function _transferOwnership(address newOwner) internal virtual {
  96 |     |         address oldOwner = _owner;
  97 |     |         _owner = newOwner;
  98 |     |         emit OwnershipTransferred(oldOwner, newOwner);
  99 |     |     }
 100 |     | }
 101 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC20} from "./IERC20.sol";
  7 |     | import {IERC165} from "./IERC165.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title IERC1363
 11 |     |  * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].
 12 |     |  *
 13 |     |  * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract
 14 |     |  * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.
 15 |     |  */
 16 |     | interface IERC1363 is IERC20, IERC165 {
 17 |     |     /*
 18 |     |      * Note: the ERC-165 identifier for this interface is 0xb0202a11.
 19 |     |      * 0xb0202a11 ===
 20 |     |      *   bytes4(keccak256('transferAndCall(address,uint256)')) ^
 21 |     |      *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^
 22 |     |      *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^
 23 |     |      *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^
 24 |     |      *   bytes4(keccak256('approveAndCall(address,uint256)')) ^
 25 |     |      *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))
 26 |     |      */
 27 |     | 
 28 |     |     /**
 29 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`
 30 |     |      * and then calls {IERC1363Receiver-onTransferReceived} on `to`.
 31 |     |      * @param to The address which you want to transfer to.
 32 |     |      * @param value The amount of tokens to be transferred.
 33 |     |      * @return A boolean value indicating whether the operation succeeded unless throwing.
 34 |     |      */
 35 |     |     function transferAndCall(address to, uint256 value) external returns (bool);
 36 |     | 
 37 |     |     /**
 38 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`
 39 |     |      * and then calls {IERC1363Receiver-onTransferReceived} on `to`.
 40 |     |      * @param to The address which you want to transfer to.
 41 |     |      * @param value The amount of tokens to be transferred.
 42 |     |      * @param data Additional data with no specified format, sent in call to `to`.
 43 |     |      * @return A boolean value indicating whether the operation succeeded unless throwing.
 44 |     |      */
 45 |     |     function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism
 49 |     |      * and then calls {IERC1363Receiver-onTransferReceived} on `to`.
 50 |     |      * @param from The address which you want to send tokens from.
 51 |     |      * @param to The address which you want to transfer to.
 52 |     |      * @param value The amount of tokens to be transferred.
 53 |     |      * @return A boolean value indicating whether the operation succeeded unless throwing.
 54 |     |      */
 55 |     |     function transferFromAndCall(address from, address to, uint256 value) external returns (bool);
 56 |     | 
 57 |     |     /**
 58 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism
 59 |     |      * and then calls {IERC1363Receiver-onTransferReceived} on `to`.
 60 |     |      * @param from The address which you want to send tokens from.
 61 |     |      * @param to The address which you want to transfer to.
 62 |     |      * @param value The amount of tokens to be transferred.
 63 |     |      * @param data Additional data with no specified format, sent in call to `to`.
 64 |     |      * @return A boolean value indicating whether the operation succeeded unless throwing.
 65 |     |      */
 66 |     |     function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 70 |     |      * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.
 71 |     |      * @param spender The address which will spend the funds.
 72 |     |      * @param value The amount of tokens to be spent.
 73 |     |      * @return A boolean value indicating whether the operation succeeded unless throwing.
 74 |     |      */
 75 |     |     function approveAndCall(address spender, uint256 value) external returns (bool);
 76 |     | 
 77 |     |     /**
 78 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 79 |     |      * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.
 80 |     |      * @param spender The address which will spend the funds.
 81 |     |      * @param value The amount of tokens to be spent.
 82 |     |      * @param data Additional data with no specified format, sent in call to `spender`.
 83 |     |      * @return A boolean value indicating whether the operation succeeded unless throwing.
 84 |     |      */
 85 |     |     function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);
 86 |     | }
 87 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)
 3 |     | 
 4 |     | pragma solidity ^0.8.20;
 5 |     | 
 6 |     | import {IERC165} from "../utils/introspection/IERC165.sol";
 7 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.
  8 |     |  */
  9 |     | interface IERC1967 {
 10 |     |     /**
 11 |     |      * @dev Emitted when the implementation is upgraded.
 12 |     |      */
 13 |     |     event Upgraded(address indexed implementation);
 14 |     | 
 15 |     |     /**
 16 |     |      * @dev Emitted when the admin account has changed.
 17 |     |      */
 18 |     |     event AdminChanged(address previousAdmin, address newAdmin);
 19 |     | 
 20 |     |     /**
 21 |     |      * @dev Emitted when the beacon is changed.
 22 |     |      */
 23 |     |     event BeaconUpgraded(address indexed beacon);
 24 |     | }
 25 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)
 3 |     | 
 4 |     | pragma solidity ^0.8.20;
 5 |     | 
 6 |     | import {IERC20} from "../token/ERC20/IERC20.sol";
 7 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Proxy.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.22;
  5 |     | 
  6 |     | import {Proxy} from "../Proxy.sol";
  7 |     | import {ERC1967Utils} from "./ERC1967Utils.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an
 11 |     |  * implementation address that can be changed. This address is stored in storage in the location specified by
 12 |     |  * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967], so that it doesn't conflict with the storage layout of the
 13 |     |  * implementation behind the proxy.
 14 |     |  */
 15 | *   | contract ERC1967Proxy is Proxy {
 16 |     |     /**
 17 |     |      * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.
 18 |     |      *
 19 |     |      * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an
 20 |     |      * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.
 21 |     |      *
 22 |     |      * Requirements:
 23 |     |      *
 24 |     |      * - If `data` is empty, `msg.value` must be zero.
 25 |     |      */
 26 | *   |     constructor(address implementation, bytes memory _data) payable {
 27 | *   |         ERC1967Utils.upgradeToAndCall(implementation, _data);
 28 |     |     }
 29 |     | 
 30 |     |     /**
 31 |     |      * @dev Returns the current implementation address.
 32 |     |      *
 33 |     |      * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using
 34 |     |      * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
 35 |     |      * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`
 36 |     |      */
 37 | *   |     function _implementation() internal view virtual override returns (address) {
 38 | *   |         return ERC1967Utils.getImplementation();
 39 |     |     }
 40 |     | }
 41 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Utils.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.22;
   5 |     | 
   6 |     | import {IBeacon} from "../beacon/IBeacon.sol";
   7 |     | import {IERC1967} from "../../interfaces/IERC1967.sol";
   8 |     | import {Address} from "../../utils/Address.sol";
   9 |     | import {StorageSlot} from "../../utils/StorageSlot.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev This library provides getters and event emitting update functions for
  13 |     |  * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.
  14 |     |  */
  15 |     | library ERC1967Utils {
  16 |     |     /**
  17 |     |      * @dev Storage slot with the address of the current implementation.
  18 |     |      * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.
  19 |     |      */
  20 |     |     // solhint-disable-next-line private-vars-leading-underscore
  21 | *   |     bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev The `implementation` of the proxy is invalid.
  25 |     |      */
  26 |     |     error ERC1967InvalidImplementation(address implementation);
  27 |     | 
  28 |     |     /**
  29 |     |      * @dev The `admin` of the proxy is invalid.
  30 |     |      */
  31 |     |     error ERC1967InvalidAdmin(address admin);
  32 |     | 
  33 |     |     /**
  34 |     |      * @dev The `beacon` of the proxy is invalid.
  35 |     |      */
  36 |     |     error ERC1967InvalidBeacon(address beacon);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev An upgrade function sees `msg.value > 0` that may be lost.
  40 |     |      */
  41 |     |     error ERC1967NonPayable();
  42 |     | 
  43 |     |     /**
  44 |     |      * @dev Returns the current implementation address.
  45 |     |      */
  46 | *   |     function getImplementation() internal view returns (address) {
  47 | *   |         return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @dev Stores a new address in the ERC-1967 implementation slot.
  52 |     |      */
  53 | *   |     function _setImplementation(address newImplementation) private {
  54 | *   |         if (newImplementation.code.length == 0) {
  55 |     |             revert ERC1967InvalidImplementation(newImplementation);
  56 |     |         }
  57 | *   |         StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Performs implementation upgrade with additional setup call if data is nonempty.
  62 |     |      * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected
  63 |     |      * to avoid stuck value in the contract.
  64 |     |      *
  65 |     |      * Emits an {IERC1967-Upgraded} event.
  66 |     |      */
  67 | *   |     function upgradeToAndCall(address newImplementation, bytes memory data) internal {
  68 | *   |         _setImplementation(newImplementation);
  69 | *   |         emit IERC1967.Upgraded(newImplementation);
  70 |     | 
  71 | *   |         if (data.length > 0) {
  72 | *   |             Address.functionDelegateCall(newImplementation, data);
  73 |     |         } else {
  74 |     |             _checkNonPayable();
  75 |     |         }
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev Storage slot with the admin of the contract.
  80 |     |      * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.
  81 |     |      */
  82 |     |     // solhint-disable-next-line private-vars-leading-underscore
  83 |     |     bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
  84 |     | 
  85 |     |     /**
  86 |     |      * @dev Returns the current admin.
  87 |     |      *
  88 |     |      * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using
  89 |     |      * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
  90 |     |      * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`
  91 |     |      */
  92 |     |     function getAdmin() internal view returns (address) {
  93 |     |         return StorageSlot.getAddressSlot(ADMIN_SLOT).value;
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Stores a new address in the ERC-1967 admin slot.
  98 |     |      */
  99 |     |     function _setAdmin(address newAdmin) private {
 100 |     |         if (newAdmin == address(0)) {
 101 |     |             revert ERC1967InvalidAdmin(address(0));
 102 |     |         }
 103 |     |         StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev Changes the admin of the proxy.
 108 |     |      *
 109 |     |      * Emits an {IERC1967-AdminChanged} event.
 110 |     |      */
 111 |     |     function changeAdmin(address newAdmin) internal {
 112 |     |         emit IERC1967.AdminChanged(getAdmin(), newAdmin);
 113 |     |         _setAdmin(newAdmin);
 114 |     |     }
 115 |     | 
 116 |     |     /**
 117 |     |      * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.
 118 |     |      * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.
 119 |     |      */
 120 |     |     // solhint-disable-next-line private-vars-leading-underscore
 121 |     |     bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Returns the current beacon.
 125 |     |      */
 126 |     |     function getBeacon() internal view returns (address) {
 127 |     |         return StorageSlot.getAddressSlot(BEACON_SLOT).value;
 128 |     |     }
 129 |     | 
 130 |     |     /**
 131 |     |      * @dev Stores a new beacon in the ERC-1967 beacon slot.
 132 |     |      */
 133 |     |     function _setBeacon(address newBeacon) private {
 134 |     |         if (newBeacon.code.length == 0) {
 135 |     |             revert ERC1967InvalidBeacon(newBeacon);
 136 |     |         }
 137 |     | 
 138 |     |         StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;
 139 |     | 
 140 |     |         address beaconImplementation = IBeacon(newBeacon).implementation();
 141 |     |         if (beaconImplementation.code.length == 0) {
 142 |     |             revert ERC1967InvalidImplementation(beaconImplementation);
 143 |     |         }
 144 |     |     }
 145 |     | 
 146 |     |     /**
 147 |     |      * @dev Change the beacon and trigger a setup call if data is nonempty.
 148 |     |      * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected
 149 |     |      * to avoid stuck value in the contract.
 150 |     |      *
 151 |     |      * Emits an {IERC1967-BeaconUpgraded} event.
 152 |     |      *
 153 |     |      * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since
 154 |     |      * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for
 155 |     |      * efficiency.
 156 |     |      */
 157 |     |     function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {
 158 |     |         _setBeacon(newBeacon);
 159 |     |         emit IERC1967.BeaconUpgraded(newBeacon);
 160 |     | 
 161 |     |         if (data.length > 0) {
 162 |     |             Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);
 163 |     |         } else {
 164 |     |             _checkNonPayable();
 165 |     |         }
 166 |     |     }
 167 |     | 
 168 |     |     /**
 169 |     |      * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract
 170 |     |      * if an upgrade doesn't perform an initialization call.
 171 |     |      */
 172 |     |     function _checkNonPayable() private {
 173 |     |         if (msg.value > 0) {
 174 |     |             revert ERC1967NonPayable();
 175 |     |         }
 176 |     |     }
 177 |     | }
 178 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/Proxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
  8 |     |  * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
  9 |     |  * be specified by overriding the virtual {_implementation} function.
 10 |     |  *
 11 |     |  * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 12 |     |  * different contract through the {_delegate} function.
 13 |     |  *
 14 |     |  * The success and return data of the delegated call will be returned back to the caller of the proxy.
 15 |     |  */
 16 |     | abstract contract Proxy {
 17 |     |     /**
 18 |     |      * @dev Delegates the current call to `implementation`.
 19 |     |      *
 20 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 21 |     |      */
 22 | *   |     function _delegate(address implementation) internal virtual {
 23 |     |         assembly {
 24 |     |             // Copy msg.data. We take full control of memory in this inline assembly
 25 |     |             // block because it will not return to Solidity code. We overwrite the
 26 |     |             // Solidity scratch pad at memory position 0.
 27 | *   |             calldatacopy(0, 0, calldatasize())
 28 |     | 
 29 |     |             // Call the implementation.
 30 |     |             // out and outsize are 0 because we don't know the size yet.
 31 | *   |             let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
 32 |     | 
 33 |     |             // Copy the returned data.
 34 | *   |             returndatacopy(0, 0, returndatasize())
 35 |     | 
 36 | *   |             switch result
 37 |     |             // delegatecall returns 0 on error.
 38 | *   |             case 0 {
 39 | *   |                 revert(0, returndatasize())
 40 |     |             }
 41 |     |             default {
 42 | *   |                 return(0, returndatasize())
 43 |     |             }
 44 |     |         }
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev This is a virtual function that should be overridden so it returns the address to which the fallback
 49 |     |      * function and {_fallback} should delegate.
 50 |     |      */
 51 |     |     function _implementation() internal view virtual returns (address);
 52 |     | 
 53 |     |     /**
 54 |     |      * @dev Delegates the current call to the address returned by `_implementation()`.
 55 |     |      *
 56 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 57 |     |      */
 58 | *   |     function _fallback() internal virtual {
 59 | *   |         _delegate(_implementation());
 60 |     |     }
 61 |     | 
 62 |     |     /**
 63 |     |      * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
 64 |     |      * function in the contract matches the call data.
 65 |     |      */
 66 |     |     fallback() external payable virtual {
 67 | *   |         _fallback();
 68 |     |     }
 69 |     | }
 70 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/beacon/BeaconProxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.2.0) (proxy/beacon/BeaconProxy.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.22;
  5 |     | 
  6 |     | import {IBeacon} from "./IBeacon.sol";
  7 |     | import {Proxy} from "../Proxy.sol";
  8 |     | import {ERC1967Utils} from "../ERC1967/ERC1967Utils.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.
 12 |     |  *
 13 |     |  * The beacon address can only be set once during construction, and cannot be changed afterwards. It is stored in an
 14 |     |  * immutable variable to avoid unnecessary storage reads, and also in the beacon storage slot specified by
 15 |     |  * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] so that it can be accessed externally.
 16 |     |  *
 17 |     |  * CAUTION: Since the beacon address can never be changed, you must ensure that you either control the beacon, or trust
 18 |     |  * the beacon to not upgrade the implementation maliciously.
 19 |     |  *
 20 |     |  * IMPORTANT: Do not use the implementation logic to modify the beacon storage slot. Doing so would leave the proxy in
 21 |     |  * an inconsistent state where the beacon storage slot does not match the beacon address.
 22 |     |  */
 23 |     | contract BeaconProxy is Proxy {
 24 |     |     // An immutable address for the beacon to avoid unnecessary SLOADs before each delegate call.
 25 |     |     address private immutable _beacon;
 26 |     | 
 27 |     |     /**
 28 |     |      * @dev Initializes the proxy with `beacon`.
 29 |     |      *
 30 |     |      * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This
 31 |     |      * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity
 32 |     |      * constructor.
 33 |     |      *
 34 |     |      * Requirements:
 35 |     |      *
 36 |     |      * - `beacon` must be a contract with the interface {IBeacon}.
 37 |     |      * - If `data` is empty, `msg.value` must be zero.
 38 |     |      */
 39 |     |     constructor(address beacon, bytes memory data) payable {
 40 |     |         ERC1967Utils.upgradeBeaconToAndCall(beacon, data);
 41 |     |         _beacon = beacon;
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Returns the current implementation address of the associated beacon.
 46 |     |      */
 47 |     |     function _implementation() internal view virtual override returns (address) {
 48 |     |         return IBeacon(_getBeacon()).implementation();
 49 |     |     }
 50 |     | 
 51 |     |     /**
 52 |     |      * @dev Returns the beacon.
 53 |     |      */
 54 |     |     function _getBeacon() internal view virtual returns (address) {
 55 |     |         return _beacon;
 56 |     |     }
 57 |     | }
 58 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This is the interface that {BeaconProxy} expects of its beacon.
  8 |     |  */
  9 |     | interface IBeacon {
 10 |     |     /**
 11 |     |      * @dev Must return an address that can be used as a delegate call target.
 12 |     |      *
 13 |     |      * {UpgradeableBeacon} will check that this address is a contract.
 14 |     |      */
 15 |     |     function implementation() external view returns (address);
 16 |     | }
 17 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/beacon/UpgradeableBeacon.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/UpgradeableBeacon.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IBeacon} from "./IBeacon.sol";
  7 |     | import {Ownable} from "../../access/Ownable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their
 11 |     |  * implementation contract, which is where they will delegate all function calls.
 12 |     |  *
 13 |     |  * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.
 14 |     |  */
 15 |     | contract UpgradeableBeacon is IBeacon, Ownable {
 16 |     |     address private _implementation;
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev The `implementation` of the beacon is invalid.
 20 |     |      */
 21 |     |     error BeaconInvalidImplementation(address implementation);
 22 |     | 
 23 |     |     /**
 24 |     |      * @dev Emitted when the implementation returned by the beacon is changed.
 25 |     |      */
 26 |     |     event Upgraded(address indexed implementation);
 27 |     | 
 28 |     |     /**
 29 |     |      * @dev Sets the address of the initial implementation, and the initial owner who can upgrade the beacon.
 30 |     |      */
 31 |     |     constructor(address implementation_, address initialOwner) Ownable(initialOwner) {
 32 |     |         _setImplementation(implementation_);
 33 |     |     }
 34 |     | 
 35 |     |     /**
 36 |     |      * @dev Returns the current implementation address.
 37 |     |      */
 38 |     |     function implementation() public view virtual returns (address) {
 39 |     |         return _implementation;
 40 |     |     }
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Upgrades the beacon to a new implementation.
 44 |     |      *
 45 |     |      * Emits an {Upgraded} event.
 46 |     |      *
 47 |     |      * Requirements:
 48 |     |      *
 49 |     |      * - msg.sender must be the owner of the contract.
 50 |     |      * - `newImplementation` must be a contract.
 51 |     |      */
 52 |     |     function upgradeTo(address newImplementation) public virtual onlyOwner {
 53 |     |         _setImplementation(newImplementation);
 54 |     |     }
 55 |     | 
 56 |     |     /**
 57 |     |      * @dev Sets the implementation contract address for this beacon
 58 |     |      *
 59 |     |      * Requirements:
 60 |     |      *
 61 |     |      * - `newImplementation` must be a contract.
 62 |     |      */
 63 |     |     function _setImplementation(address newImplementation) private {
 64 |     |         if (newImplementation.code.length == 0) {
 65 |     |             revert BeaconInvalidImplementation(newImplementation);
 66 |     |         }
 67 |     |         _implementation = newImplementation;
 68 |     |         emit Upgraded(newImplementation);
 69 |     |     }
 70 |     | }
 71 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/transparent/ProxyAdmin.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.2.0) (proxy/transparent/ProxyAdmin.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.22;
  5 |     | 
  6 |     | import {ITransparentUpgradeableProxy} from "./TransparentUpgradeableProxy.sol";
  7 |     | import {Ownable} from "../../access/Ownable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an
 11 |     |  * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.
 12 |     |  */
 13 |     | contract ProxyAdmin is Ownable {
 14 |     |     /**
 15 |     |      * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgrade(address,address)`
 16 |     |      * and `upgradeAndCall(address,address,bytes)` are present, and `upgrade` must be used if no function should be called,
 17 |     |      * while `upgradeAndCall` will invoke the `receive` function if the third argument is the empty byte string.
 18 |     |      * If the getter returns `"5.0.0"`, only `upgradeAndCall(address,address,bytes)` is present, and the third argument must
 19 |     |      * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function
 20 |     |      * during an upgrade.
 21 |     |      */
 22 |     |     string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Sets the initial owner who can perform upgrades.
 26 |     |      */
 27 |     |     constructor(address initialOwner) Ownable(initialOwner) {}
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation.
 31 |     |      * See {TransparentUpgradeableProxy-_dispatchUpgradeToAndCall}.
 32 |     |      *
 33 |     |      * Requirements:
 34 |     |      *
 35 |     |      * - This contract must be the admin of `proxy`.
 36 |     |      * - If `data` is empty, `msg.value` must be zero.
 37 |     |      */
 38 |     |     function upgradeAndCall(
 39 |     |         ITransparentUpgradeableProxy proxy,
 40 |     |         address implementation,
 41 |     |         bytes memory data
 42 |     |     ) public payable virtual onlyOwner {
 43 |     |         proxy.upgradeToAndCall{value: msg.value}(implementation, data);
 44 |     |     }
 45 |     | }
 46 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.2.0) (proxy/transparent/TransparentUpgradeableProxy.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.22;
   5 |     | 
   6 |     | import {ERC1967Utils} from "../ERC1967/ERC1967Utils.sol";
   7 |     | import {ERC1967Proxy} from "../ERC1967/ERC1967Proxy.sol";
   8 |     | import {IERC1967} from "../../interfaces/IERC1967.sol";
   9 |     | import {ProxyAdmin} from "./ProxyAdmin.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}
  13 |     |  * does not implement this interface directly, and its upgradeability mechanism is implemented by an internal dispatch
  14 |     |  * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not
  15 |     |  * include them in the ABI so this interface must be used to interact with it.
  16 |     |  */
  17 |     | interface ITransparentUpgradeableProxy is IERC1967 {
  18 |     |     /// @dev See {UUPSUpgradeable-upgradeToAndCall}
  19 |     |     function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;
  20 |     | }
  21 |     | 
  22 |     | /**
  23 |     |  * @dev This contract implements a proxy that is upgradeable through an associated {ProxyAdmin} instance.
  24 |     |  *
  25 |     |  * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector
  26 |     |  * clashing], which can potentially be used in an attack, this contract uses the
  27 |     |  * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two
  28 |     |  * things that go hand in hand:
  29 |     |  *
  30 |     |  * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if
  31 |     |  * that call matches the {ITransparentUpgradeableProxy-upgradeToAndCall} function exposed by the proxy itself.
  32 |     |  * 2. If the admin calls the proxy, it can call the `upgradeToAndCall` function but any other call won't be forwarded to
  33 |     |  * the implementation. If the admin tries to call a function on the implementation it will fail with an error indicating
  34 |     |  * the proxy admin cannot fallback to the target implementation.
  35 |     |  *
  36 |     |  * These properties mean that the admin account can only be used for upgrading the proxy, so it's best if it's a
  37 |     |  * dedicated account that is not used for anything else. This will avoid headaches due to sudden errors when trying to
  38 |     |  * call a function from the proxy implementation. For this reason, the proxy deploys an instance of {ProxyAdmin} and
  39 |     |  * allows upgrades only if they come through it. You should think of the `ProxyAdmin` instance as the administrative
  40 |     |  * interface of the proxy, including the ability to change who can trigger upgrades by transferring ownership.
  41 |     |  *
  42 |     |  * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not
  43 |     |  * inherit from that interface, and instead `upgradeToAndCall` is implicitly implemented using a custom dispatch
  44 |     |  * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to
  45 |     |  * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the
  46 |     |  * implementation.
  47 |     |  *
  48 |     |  * NOTE: This proxy does not inherit from {Context} deliberately. The {ProxyAdmin} of this contract won't send a
  49 |     |  * meta-transaction in any way, and any other meta-transaction setup should be made in the implementation contract.
  50 |     |  *
  51 |     |  * IMPORTANT: This contract avoids unnecessary storage reads by setting the admin only during construction as an
  52 |     |  * immutable variable, preventing any changes thereafter. However, the admin slot defined in ERC-1967 can still be
  53 |     |  * overwritten by the implementation logic pointed to by this proxy. In such cases, the contract may end up in an
  54 |     |  * undesirable state where the admin slot is different from the actual admin. Relying on the value of the admin slot
  55 |     |  * is generally fine if the implementation is trusted.
  56 |     |  *
  57 |     |  * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the
  58 |     |  * compiler will not check that there are no selector conflicts, due to the note above. A selector clash between any new
  59 |     |  * function and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This
  60 |     |  * could render the `upgradeToAndCall` function inaccessible, preventing upgradeability and compromising transparency.
  61 |     |  */
  62 |     | contract TransparentUpgradeableProxy is ERC1967Proxy {
  63 |     |     // An immutable address for the admin to avoid unnecessary SLOADs before each call
  64 |     |     // at the expense of removing the ability to change the admin once it's set.
  65 |     |     // This is acceptable if the admin is always a ProxyAdmin instance or similar contract
  66 |     |     // with its own ability to transfer the permissions to another account.
  67 |     |     address private immutable _admin;
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev The proxy caller is the current admin, and can't fallback to the proxy target.
  71 |     |      */
  72 |     |     error ProxyDeniedAdminAccess();
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Initializes an upgradeable proxy managed by an instance of a {ProxyAdmin} with an `initialOwner`,
  76 |     |      * backed by the implementation at `_logic`, and optionally initialized with `_data` as explained in
  77 |     |      * {ERC1967Proxy-constructor}.
  78 |     |      */
  79 |     |     constructor(address _logic, address initialOwner, bytes memory _data) payable ERC1967Proxy(_logic, _data) {
  80 |     |         _admin = address(new ProxyAdmin(initialOwner));
  81 |     |         // Set the storage value and emit an event for ERC-1967 compatibility
  82 |     |         ERC1967Utils.changeAdmin(_proxyAdmin());
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @dev Returns the admin of this proxy.
  87 |     |      */
  88 |     |     function _proxyAdmin() internal view virtual returns (address) {
  89 |     |         return _admin;
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior.
  94 |     |      */
  95 |     |     function _fallback() internal virtual override {
  96 |     |         if (msg.sender == _proxyAdmin()) {
  97 |     |             if (msg.sig != ITransparentUpgradeableProxy.upgradeToAndCall.selector) {
  98 |     |                 revert ProxyDeniedAdminAccess();
  99 |     |             } else {
 100 |     |                 _dispatchUpgradeToAndCall();
 101 |     |             }
 102 |     |         } else {
 103 |     |             super._fallback();
 104 |     |         }
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Upgrade the implementation of the proxy. See {ERC1967Utils-upgradeToAndCall}.
 109 |     |      *
 110 |     |      * Requirements:
 111 |     |      *
 112 |     |      * - If `data` is empty, `msg.value` must be zero.
 113 |     |      */
 114 |     |     function _dispatchUpgradeToAndCall() private {
 115 |     |         (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));
 116 |     |         ERC1967Utils.upgradeToAndCall(newImplementation, data);
 117 |     |     }
 118 |     | }
 119 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
   8 |     |  * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
   9 |     |  * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
  10 |     |  * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
  11 |     |  *
  12 |     |  * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
  13 |     |  * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
  14 |     |  * case an upgrade adds a module that needs to be initialized.
  15 |     |  *
  16 |     |  * For example:
  17 |     |  *
  18 |     |  * [.hljs-theme-light.nopadding]
  19 |     |  * ```solidity
  20 |     |  * contract MyToken is ERC20Upgradeable {
  21 |     |  *     function initialize() initializer public {
  22 |     |  *         __ERC20_init("MyToken", "MTK");
  23 |     |  *     }
  24 |     |  * }
  25 |     |  *
  26 |     |  * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
  27 |     |  *     function initializeV2() reinitializer(2) public {
  28 |     |  *         __ERC20Permit_init("MyToken");
  29 |     |  *     }
  30 |     |  * }
  31 |     |  * ```
  32 |     |  *
  33 |     |  * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
  34 |     |  * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
  35 |     |  *
  36 |     |  * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
  37 |     |  * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
  38 |     |  *
  39 |     |  * [CAUTION]
  40 |     |  * ====
  41 |     |  * Avoid leaving a contract uninitialized.
  42 |     |  *
  43 |     |  * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
  44 |     |  * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
  45 |     |  * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
  46 |     |  *
  47 |     |  * [.hljs-theme-light.nopadding]
  48 |     |  * ```
  49 |     |  * /// @custom:oz-upgrades-unsafe-allow constructor
  50 |     |  * constructor() {
  51 |     |  *     _disableInitializers();
  52 |     |  * }
  53 |     |  * ```
  54 |     |  * ====
  55 |     |  */
  56 |     | abstract contract Initializable {
  57 |     |     /**
  58 |     |      * @dev Storage of the initializable contract.
  59 |     |      *
  60 |     |      * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions
  61 |     |      * when using with upgradeable contracts.
  62 |     |      *
  63 |     |      * @custom:storage-location erc7201:openzeppelin.storage.Initializable
  64 |     |      */
  65 |     |     struct InitializableStorage {
  66 |     |         /**
  67 |     |          * @dev Indicates that the contract has been initialized.
  68 |     |          */
  69 |     |         uint64 _initialized;
  70 |     |         /**
  71 |     |          * @dev Indicates that the contract is in the process of being initialized.
  72 |     |          */
  73 |     |         bool _initializing;
  74 |     |     }
  75 |     | 
  76 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))
  77 |     |     bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev The contract is already initialized.
  81 |     |      */
  82 |     |     error InvalidInitialization();
  83 |     | 
  84 |     |     /**
  85 |     |      * @dev The contract is not initializing.
  86 |     |      */
  87 |     |     error NotInitializing();
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Triggered when the contract has been initialized or reinitialized.
  91 |     |      */
  92 |     |     event Initialized(uint64 version);
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
  96 |     |      * `onlyInitializing` functions can be used to initialize parent contracts.
  97 |     |      *
  98 |     |      * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any
  99 |     |      * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in
 100 |     |      * production.
 101 |     |      *
 102 |     |      * Emits an {Initialized} event.
 103 |     |      */
 104 |     |     modifier initializer() {
 105 |     |         // solhint-disable-next-line var-name-mixedcase
 106 |     |         InitializableStorage storage $ = _getInitializableStorage();
 107 |     | 
 108 |     |         // Cache values to avoid duplicated sloads
 109 |     |         bool isTopLevelCall = !$._initializing;
 110 |     |         uint64 initialized = $._initialized;
 111 |     | 
 112 |     |         // Allowed calls:
 113 |     |         // - initialSetup: the contract is not in the initializing state and no previous version was
 114 |     |         //                 initialized
 115 |     |         // - construction: the contract is initialized at version 1 (no reinitialization) and the
 116 |     |         //                 current contract is just being deployed
 117 |     |         bool initialSetup = initialized == 0 && isTopLevelCall;
 118 |     |         bool construction = initialized == 1 && address(this).code.length == 0;
 119 |     | 
 120 |     |         if (!initialSetup && !construction) {
 121 |     |             revert InvalidInitialization();
 122 |     |         }
 123 |     |         $._initialized = 1;
 124 |     |         if (isTopLevelCall) {
 125 |     |             $._initializing = true;
 126 |     |         }
 127 |     |         _;
 128 |     |         if (isTopLevelCall) {
 129 |     |             $._initializing = false;
 130 |     |             emit Initialized(1);
 131 |     |         }
 132 |     |     }
 133 |     | 
 134 |     |     /**
 135 |     |      * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
 136 |     |      * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
 137 |     |      * used to initialize parent contracts.
 138 |     |      *
 139 |     |      * A reinitializer may be used after the original initialization step. This is essential to configure modules that
 140 |     |      * are added through upgrades and that require initialization.
 141 |     |      *
 142 |     |      * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
 143 |     |      * cannot be nested. If one is invoked in the context of another, execution will revert.
 144 |     |      *
 145 |     |      * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
 146 |     |      * a contract, executing them in the right order is up to the developer or operator.
 147 |     |      *
 148 |     |      * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.
 149 |     |      *
 150 |     |      * Emits an {Initialized} event.
 151 |     |      */
 152 |     |     modifier reinitializer(uint64 version) {
 153 |     |         // solhint-disable-next-line var-name-mixedcase
 154 |     |         InitializableStorage storage $ = _getInitializableStorage();
 155 |     | 
 156 |     |         if ($._initializing || $._initialized >= version) {
 157 |     |             revert InvalidInitialization();
 158 |     |         }
 159 |     |         $._initialized = version;
 160 |     |         $._initializing = true;
 161 |     |         _;
 162 |     |         $._initializing = false;
 163 |     |         emit Initialized(version);
 164 |     |     }
 165 |     | 
 166 |     |     /**
 167 |     |      * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
 168 |     |      * {initializer} and {reinitializer} modifiers, directly or indirectly.
 169 |     |      */
 170 |     |     modifier onlyInitializing() {
 171 |     |         _checkInitializing();
 172 |     |         _;
 173 |     |     }
 174 |     | 
 175 |     |     /**
 176 |     |      * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.
 177 |     |      */
 178 |     |     function _checkInitializing() internal view virtual {
 179 |     |         if (!_isInitializing()) {
 180 |     |             revert NotInitializing();
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
 186 |     |      * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
 187 |     |      * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
 188 |     |      * through proxies.
 189 |     |      *
 190 |     |      * Emits an {Initialized} event the first time it is successfully executed.
 191 |     |      */
 192 |     |     function _disableInitializers() internal virtual {
 193 |     |         // solhint-disable-next-line var-name-mixedcase
 194 |     |         InitializableStorage storage $ = _getInitializableStorage();
 195 |     | 
 196 |     |         if ($._initializing) {
 197 |     |             revert InvalidInitialization();
 198 |     |         }
 199 |     |         if ($._initialized != type(uint64).max) {
 200 |     |             $._initialized = type(uint64).max;
 201 |     |             emit Initialized(type(uint64).max);
 202 |     |         }
 203 |     |     }
 204 |     | 
 205 |     |     /**
 206 |     |      * @dev Returns the highest version that has been initialized. See {reinitializer}.
 207 |     |      */
 208 |     |     function _getInitializedVersion() internal view returns (uint64) {
 209 |     |         return _getInitializableStorage()._initialized;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.
 214 |     |      */
 215 |     |     function _isInitializing() internal view returns (bool) {
 216 |     |         return _getInitializableStorage()._initializing;
 217 |     |     }
 218 |     | 
 219 |     |     /**
 220 |     |      * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.
 221 |     |      *
 222 |     |      * NOTE: Consider following the ERC-7201 formula to derive storage locations.
 223 |     |      */
 224 |     |     function _initializableStorageSlot() internal pure virtual returns (bytes32) {
 225 |     |         return INITIALIZABLE_STORAGE;
 226 |     |     }
 227 |     | 
 228 |     |     /**
 229 |     |      * @dev Returns a pointer to the storage namespace.
 230 |     |      */
 231 |     |     // solhint-disable-next-line var-name-mixedcase
 232 |     |     function _getInitializableStorage() private pure returns (InitializableStorage storage $) {
 233 |     |         bytes32 slot = _initializableStorageSlot();
 234 |     |         assembly {
 235 |     |             $.slot := slot
 236 |     |         }
 237 |     |     }
 238 |     | }
 239 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC-20 standard as defined in the ERC.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the value of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the value of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 value) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 54 |     |      * caller's tokens.
 55 |     |      *
 56 |     |      * Returns a boolean value indicating whether the operation succeeded.
 57 |     |      *
 58 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 59 |     |      * that someone may use both the old and the new allowance by unfortunate
 60 |     |      * transaction ordering. One possible solution to mitigate this race
 61 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 62 |     |      * desired value afterwards:
 63 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 64 |     |      *
 65 |     |      * Emits an {Approval} event.
 66 |     |      */
 67 |     |     function approve(address spender, uint256 value) external returns (bool);
 68 |     | 
 69 |     |     /**
 70 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the
 71 |     |      * allowance mechanism. `value` is then deducted from the caller's
 72 |     |      * allowance.
 73 |     |      *
 74 |     |      * Returns a boolean value indicating whether the operation succeeded.
 75 |     |      *
 76 |     |      * Emits a {Transfer} event.
 77 |     |      */
 78 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 79 |     | }
 80 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC20} from "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC-20 standard.
 10 |     |  */
 11 |     | interface IERC20Metadata is IERC20 {
 12 |     |     /**
 13 |     |      * @dev Returns the name of the token.
 14 |     |      */
 15 |     |     function name() external view returns (string memory);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the symbol of the token.
 19 |     |      */
 20 |     |     function symbol() external view returns (string memory);
 21 |     | 
 22 |     |     /**
 23 |     |      * @dev Returns the decimals places of the token.
 24 |     |      */
 25 |     |     function decimals() external view returns (uint8);
 26 |     | }
 27 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "../IERC20.sol";
   7 |     | import {IERC1363} from "../../../interfaces/IERC1363.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title SafeERC20
  11 |     |  * @dev Wrappers around ERC-20 operations that throw on failure (when the token
  12 |     |  * contract returns false). Tokens that return no value (and instead revert or
  13 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  14 |     |  * successful.
  15 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  16 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  17 |     |  */
  18 |     | library SafeERC20 {
  19 |     |     /**
  20 |     |      * @dev An operation with an ERC-20 token failed.
  21 |     |      */
  22 |     |     error SafeERC20FailedOperation(address token);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev Indicates a failed `decreaseAllowance` request.
  26 |     |      */
  27 |     |     error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);
  28 |     | 
  29 |     |     /**
  30 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  31 |     |      * non-reverting calls are assumed to be successful.
  32 |     |      */
  33 |     |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  34 |     |         _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));
  35 |     |     }
  36 |     | 
  37 |     |     /**
  38 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  39 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  40 |     |      */
  41 | *   |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  42 | *   |         _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.
  47 |     |      */
  48 |     |     function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {
  49 |     |         return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.
  54 |     |      */
  55 |     |     function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {
  56 |     |         return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  61 |     |      * non-reverting calls are assumed to be successful.
  62 |     |      *
  63 |     |      * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the "client"
  64 |     |      * smart contract uses ERC-7674 to set temporary allowances, then the "client" smart contract should avoid using
  65 |     |      * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract
  66 |     |      * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.
  67 |     |      */
  68 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  69 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  70 |     |         forceApprove(token, spender, oldAllowance + value);
  71 |     |     }
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no
  75 |     |      * value, non-reverting calls are assumed to be successful.
  76 |     |      *
  77 |     |      * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the "client"
  78 |     |      * smart contract uses ERC-7674 to set temporary allowances, then the "client" smart contract should avoid using
  79 |     |      * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract
  80 |     |      * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.
  81 |     |      */
  82 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {
  83 |     |         unchecked {
  84 |     |             uint256 currentAllowance = token.allowance(address(this), spender);
  85 |     |             if (currentAllowance < requestedDecrease) {
  86 |     |                 revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);
  87 |     |             }
  88 |     |             forceApprove(token, spender, currentAllowance - requestedDecrease);
  89 |     |         }
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  94 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  95 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  96 |     |      *
  97 |     |      * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function
  98 |     |      * only sets the "standard" allowance. Any temporary allowance will remain active, in addition to the value being
  99 |     |      * set here.
 100 |     |      */
 101 | *   |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
 102 | *   |         bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));
 103 |     | 
 104 | *   |         if (!_callOptionalReturnBool(token, approvalCall)) {
 105 |     |             _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
 106 |     |             _callOptionalReturn(token, approvalCall);
 107 |     |         }
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no
 112 |     |      * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when
 113 |     |      * targeting contracts.
 114 |     |      *
 115 |     |      * Reverts if the returned value is other than `true`.
 116 |     |      */
 117 |     |     function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {
 118 |     |         if (to.code.length == 0) {
 119 |     |             safeTransfer(token, to, value);
 120 |     |         } else if (!token.transferAndCall(to, value, data)) {
 121 |     |             revert SafeERC20FailedOperation(address(token));
 122 |     |         }
 123 |     |     }
 124 |     | 
 125 |     |     /**
 126 |     |      * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target
 127 |     |      * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when
 128 |     |      * targeting contracts.
 129 |     |      *
 130 |     |      * Reverts if the returned value is other than `true`.
 131 |     |      */
 132 |     |     function transferFromAndCallRelaxed(
 133 |     |         IERC1363 token,
 134 |     |         address from,
 135 |     |         address to,
 136 |     |         uint256 value,
 137 |     |         bytes memory data
 138 |     |     ) internal {
 139 |     |         if (to.code.length == 0) {
 140 |     |             safeTransferFrom(token, from, to, value);
 141 |     |         } else if (!token.transferFromAndCall(from, to, value, data)) {
 142 |     |             revert SafeERC20FailedOperation(address(token));
 143 |     |         }
 144 |     |     }
 145 |     | 
 146 |     |     /**
 147 |     |      * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no
 148 |     |      * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when
 149 |     |      * targeting contracts.
 150 |     |      *
 151 |     |      * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.
 152 |     |      * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}
 153 |     |      * once without retrying, and relies on the returned value to be true.
 154 |     |      *
 155 |     |      * Reverts if the returned value is other than `true`.
 156 |     |      */
 157 |     |     function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {
 158 |     |         if (to.code.length == 0) {
 159 |     |             forceApprove(token, to, value);
 160 |     |         } else if (!token.approveAndCall(to, value, data)) {
 161 |     |             revert SafeERC20FailedOperation(address(token));
 162 |     |         }
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 167 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 168 |     |      * @param token The token targeted by the call.
 169 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 170 |     |      *
 171 |     |      * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.
 172 |     |      */
 173 | *   |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
 174 | *   |         uint256 returnSize;
 175 | *   |         uint256 returnValue;
 176 | *   |         assembly ("memory-safe") {
 177 | *   |             let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)
 178 |     |             // bubble errors
 179 | *   |             if iszero(success) {
 180 |     |                 let ptr := mload(0x40)
 181 |     |                 returndatacopy(ptr, 0, returndatasize())
 182 |     |                 revert(ptr, returndatasize())
 183 |     |             }
 184 | *   |             returnSize := returndatasize()
 185 | *   |             returnValue := mload(0)
 186 |     |         }
 187 |     | 
 188 | *   |         if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {
 189 |     |             revert SafeERC20FailedOperation(address(token));
 190 |     |         }
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 195 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 196 |     |      * @param token The token targeted by the call.
 197 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 198 |     |      *
 199 |     |      * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.
 200 |     |      */
 201 | *   |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 202 | *   |         bool success;
 203 | *   |         uint256 returnSize;
 204 | *   |         uint256 returnValue;
 205 |     |         assembly ("memory-safe") {
 206 | *   |             success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)
 207 | *   |             returnSize := returndatasize()
 208 | *   |             returnValue := mload(0)
 209 |     |         }
 210 | *   |         return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);
 211 |     |     }
 212 |     | }
 213 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Errors} from "./Errors.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Collection of functions related to the address type
  10 |     |  */
  11 |     | library Address {
  12 |     |     /**
  13 |     |      * @dev There's no code at `target` (it is not a contract).
  14 |     |      */
  15 |     |     error AddressEmptyCode(address target);
  16 |     | 
  17 |     |     /**
  18 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  19 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  20 |     |      *
  21 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  22 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  23 |     |      * imposed by `transfer`, making them unable to receive funds via
  24 |     |      * `transfer`. {sendValue} removes this limitation.
  25 |     |      *
  26 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  27 |     |      *
  28 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  29 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  30 |     |      * {ReentrancyGuard} or the
  31 |     |      * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  32 |     |      */
  33 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  34 |     |         if (address(this).balance < amount) {
  35 |     |             revert Errors.InsufficientBalance(address(this).balance, amount);
  36 |     |         }
  37 |     | 
  38 |     |         (bool success, bytes memory returndata) = recipient.call{value: amount}("");
  39 |     |         if (!success) {
  40 |     |             _revert(returndata);
  41 |     |         }
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  46 |     |      * plain `call` is an unsafe replacement for a function call: use this
  47 |     |      * function instead.
  48 |     |      *
  49 |     |      * If `target` reverts with a revert reason or custom error, it is bubbled
  50 |     |      * up by this function (like regular Solidity function calls). However, if
  51 |     |      * the call reverted with no returned reason, this function reverts with a
  52 |     |      * {Errors.FailedCall} error.
  53 |     |      *
  54 |     |      * Returns the raw returned data. To convert to the expected return value,
  55 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  56 |     |      *
  57 |     |      * Requirements:
  58 |     |      *
  59 |     |      * - `target` must be a contract.
  60 |     |      * - calling `target` with `data` must not revert.
  61 |     |      */
  62 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  63 |     |         return functionCallWithValue(target, data, 0);
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  68 |     |      * but also transferring `value` wei to `target`.
  69 |     |      *
  70 |     |      * Requirements:
  71 |     |      *
  72 |     |      * - the calling contract must have an ETH balance of at least `value`.
  73 |     |      * - the called Solidity function must be `payable`.
  74 |     |      */
  75 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
  76 |     |         if (address(this).balance < value) {
  77 |     |             revert Errors.InsufficientBalance(address(this).balance, value);
  78 |     |         }
  79 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
  80 |     |         return verifyCallResultFromTarget(target, success, returndata);
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  85 |     |      * but performing a static call.
  86 |     |      */
  87 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
  88 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
  89 |     |         return verifyCallResultFromTarget(target, success, returndata);
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  94 |     |      * but performing a delegate call.
  95 |     |      */
  96 | *   |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
  97 | *   |         (bool success, bytes memory returndata) = target.delegatecall(data);
  98 | *   |         return verifyCallResultFromTarget(target, success, returndata);
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
 103 |     |      * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case
 104 |     |      * of an unsuccessful call.
 105 |     |      */
 106 | *   |     function verifyCallResultFromTarget(
 107 |     |         address target,
 108 |     |         bool success,
 109 |     |         bytes memory returndata
 110 | *   |     ) internal view returns (bytes memory) {
 111 | *   |         if (!success) {
 112 |     |             _revert(returndata);
 113 |     |         } else {
 114 |     |             // only check if target is a contract if the call was successful and the return data is empty
 115 |     |             // otherwise we already know that it was a contract
 116 | *   |             if (returndata.length == 0 && target.code.length == 0) {
 117 |     |                 revert AddressEmptyCode(target);
 118 |     |             }
 119 | *   |             return returndata;
 120 |     |         }
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
 125 |     |      * revert reason or with a default {Errors.FailedCall} error.
 126 |     |      */
 127 |     |     function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {
 128 |     |         if (!success) {
 129 |     |             _revert(returndata);
 130 |     |         } else {
 131 |     |             return returndata;
 132 |     |         }
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.
 137 |     |      */
 138 |     |     function _revert(bytes memory returndata) private pure {
 139 |     |         // Look for revert reason and bubble it up if present
 140 |     |         if (returndata.length > 0) {
 141 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 142 |     |             assembly ("memory-safe") {
 143 |     |                 let returndata_size := mload(returndata)
 144 |     |                 revert(add(32, returndata), returndata_size)
 145 |     |             }
 146 |     |         } else {
 147 |     |             revert Errors.FailedCall();
 148 |     |         }
 149 |     |     }
 150 |     | }
 151 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Errors.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Collection of common custom errors used in multiple contracts
  8 |     |  *
  9 |     |  * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.
 10 |     |  * It is recommended to avoid relying on the error API for critical functionality.
 11 |     |  *
 12 |     |  * _Available since v5.1._
 13 |     |  */
 14 |     | library Errors {
 15 |     |     /**
 16 |     |      * @dev The ETH balance of the account is not enough to perform the operation.
 17 |     |      */
 18 |     |     error InsufficientBalance(uint256 balance, uint256 needed);
 19 |     | 
 20 |     |     /**
 21 |     |      * @dev A call to an address target failed. The target may have reverted.
 22 |     |      */
 23 |     |     error FailedCall();
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev The deployment failed.
 27 |     |      */
 28 |     |     error FailedDeployment();
 29 |     | 
 30 |     |     /**
 31 |     |      * @dev A necessary precompile is missing.
 32 |     |      */
 33 |     |     error MissingPrecompile(address);
 34 |     | }
 35 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Panic.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Helper library for emitting standardized panic codes.
  8 |     |  *
  9 |     |  * ```solidity
 10 |     |  * contract Example {
 11 |     |  *      using Panic for uint256;
 12 |     |  *
 13 |     |  *      // Use any of the declared internal constants
 14 |     |  *      function foo() { Panic.GENERIC.panic(); }
 15 |     |  *
 16 |     |  *      // Alternatively
 17 |     |  *      function foo() { Panic.panic(Panic.GENERIC); }
 18 |     |  * }
 19 |     |  * ```
 20 |     |  *
 21 |     |  * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].
 22 |     |  *
 23 |     |  * _Available since v5.1._
 24 |     |  */
 25 |     | // slither-disable-next-line unused-state
 26 |     | library Panic {
 27 |     |     /// @dev generic / unspecified error
 28 |     |     uint256 internal constant GENERIC = 0x00;
 29 |     |     /// @dev used by the assert() builtin
 30 |     |     uint256 internal constant ASSERT = 0x01;
 31 |     |     /// @dev arithmetic underflow or overflow
 32 |     |     uint256 internal constant UNDER_OVERFLOW = 0x11;
 33 |     |     /// @dev division or modulo by zero
 34 |     |     uint256 internal constant DIVISION_BY_ZERO = 0x12;
 35 |     |     /// @dev enum conversion error
 36 |     |     uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;
 37 |     |     /// @dev invalid encoding in storage
 38 |     |     uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;
 39 |     |     /// @dev empty array pop
 40 |     |     uint256 internal constant EMPTY_ARRAY_POP = 0x31;
 41 |     |     /// @dev array out of bounds access
 42 |     |     uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;
 43 |     |     /// @dev resource error (too large allocation or too large array)
 44 |     |     uint256 internal constant RESOURCE_ERROR = 0x41;
 45 |     |     /// @dev calling invalid internal function
 46 |     |     uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;
 47 |     | 
 48 |     |     /// @dev Reverts with a panic code. Recommended to use with
 49 |     |     /// the internal constants with predefined codes.
 50 |     |     function panic(uint256 code) internal pure {
 51 |     |         assembly ("memory-safe") {
 52 |     |             mstore(0x00, 0x4e487b71)
 53 |     |             mstore(0x20, code)
 54 |     |             revert(0x1c, 0x24)
 55 |     |         }
 56 |     |     }
 57 |     | }
 58 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/StorageSlot.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Library for reading and writing primitive types to specific storage slots.
   9 |     |  *
  10 |     |  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
  11 |     |  * This library helps with reading and writing to such slots without the need for inline assembly.
  12 |     |  *
  13 |     |  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
  14 |     |  *
  15 |     |  * Example usage to set ERC-1967 implementation slot:
  16 |     |  * ```solidity
  17 |     |  * contract ERC1967 {
  18 |     |  *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.
  19 |     |  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  20 |     |  *
  21 |     |  *     function _getImplementation() internal view returns (address) {
  22 |     |  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
  23 |     |  *     }
  24 |     |  *
  25 |     |  *     function _setImplementation(address newImplementation) internal {
  26 |     |  *         require(newImplementation.code.length > 0);
  27 |     |  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
  28 |     |  *     }
  29 |     |  * }
  30 |     |  * ```
  31 |     |  *
  32 |     |  * TIP: Consider using this library along with {SlotDerivation}.
  33 |     |  */
  34 |     | library StorageSlot {
  35 |     |     struct AddressSlot {
  36 |     |         address value;
  37 |     |     }
  38 |     | 
  39 |     |     struct BooleanSlot {
  40 |     |         bool value;
  41 |     |     }
  42 |     | 
  43 |     |     struct Bytes32Slot {
  44 |     |         bytes32 value;
  45 |     |     }
  46 |     | 
  47 |     |     struct Uint256Slot {
  48 |     |         uint256 value;
  49 |     |     }
  50 |     | 
  51 |     |     struct Int256Slot {
  52 |     |         int256 value;
  53 |     |     }
  54 |     | 
  55 |     |     struct StringSlot {
  56 |     |         string value;
  57 |     |     }
  58 |     | 
  59 |     |     struct BytesSlot {
  60 |     |         bytes value;
  61 |     |     }
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
  65 |     |      */
  66 | *   |     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
  67 |     |         assembly ("memory-safe") {
  68 | *   |             r.slot := slot
  69 |     |         }
  70 |     |     }
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Returns a `BooleanSlot` with member `value` located at `slot`.
  74 |     |      */
  75 |     |     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
  76 |     |         assembly ("memory-safe") {
  77 |     |             r.slot := slot
  78 |     |         }
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.
  83 |     |      */
  84 |     |     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
  85 |     |         assembly ("memory-safe") {
  86 |     |             r.slot := slot
  87 |     |         }
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Returns a `Uint256Slot` with member `value` located at `slot`.
  92 |     |      */
  93 |     |     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
  94 |     |         assembly ("memory-safe") {
  95 |     |             r.slot := slot
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Returns a `Int256Slot` with member `value` located at `slot`.
 101 |     |      */
 102 |     |     function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {
 103 |     |         assembly ("memory-safe") {
 104 |     |             r.slot := slot
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev Returns a `StringSlot` with member `value` located at `slot`.
 110 |     |      */
 111 |     |     function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {
 112 |     |         assembly ("memory-safe") {
 113 |     |             r.slot := slot
 114 |     |         }
 115 |     |     }
 116 |     | 
 117 |     |     /**
 118 |     |      * @dev Returns an `StringSlot` representation of the string storage pointer `store`.
 119 |     |      */
 120 |     |     function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {
 121 |     |         assembly ("memory-safe") {
 122 |     |             r.slot := store.slot
 123 |     |         }
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Returns a `BytesSlot` with member `value` located at `slot`.
 128 |     |      */
 129 |     |     function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {
 130 |     |         assembly ("memory-safe") {
 131 |     |             r.slot := slot
 132 |     |         }
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.
 137 |     |      */
 138 |     |     function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {
 139 |     |         assembly ("memory-safe") {
 140 |     |             r.slot := store.slot
 141 |     |         }
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Strings.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (utils/Strings.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Math} from "./math/Math.sol";
   7 |     | import {SafeCast} from "./math/SafeCast.sol";
   8 |     | import {SignedMath} from "./math/SignedMath.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev String operations.
  12 |     |  */
  13 |     | library Strings {
  14 |     |     using SafeCast for *;
  15 |     | 
  16 |     |     bytes16 private constant HEX_DIGITS = "0123456789abcdef";
  17 |     |     uint8 private constant ADDRESS_LENGTH = 20;
  18 |     |     uint256 private constant SPECIAL_CHARS_LOOKUP =
  19 |     |         (1 << 0x08) | // backspace
  20 |     |             (1 << 0x09) | // tab
  21 |     |             (1 << 0x0a) | // newline
  22 |     |             (1 << 0x0c) | // form feed
  23 |     |             (1 << 0x0d) | // carriage return
  24 |     |             (1 << 0x22) | // double quote
  25 |     |             (1 << 0x5c); // backslash
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev The `value` string doesn't fit in the specified `length`.
  29 |     |      */
  30 |     |     error StringsInsufficientHexLength(uint256 value, uint256 length);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev The string being parsed contains characters that are not in scope of the given base.
  34 |     |      */
  35 |     |     error StringsInvalidChar();
  36 |     | 
  37 |     |     /**
  38 |     |      * @dev The string being parsed is not a properly formatted address.
  39 |     |      */
  40 |     |     error StringsInvalidAddressFormat();
  41 |     | 
  42 |     |     /**
  43 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
  44 |     |      */
  45 |     |     function toString(uint256 value) internal pure returns (string memory) {
  46 |     |         unchecked {
  47 |     |             uint256 length = Math.log10(value) + 1;
  48 |     |             string memory buffer = new string(length);
  49 |     |             uint256 ptr;
  50 |     |             assembly ("memory-safe") {
  51 |     |                 ptr := add(buffer, add(32, length))
  52 |     |             }
  53 |     |             while (true) {
  54 |     |                 ptr--;
  55 |     |                 assembly ("memory-safe") {
  56 |     |                     mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))
  57 |     |                 }
  58 |     |                 value /= 10;
  59 |     |                 if (value == 0) break;
  60 |     |             }
  61 |     |             return buffer;
  62 |     |         }
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Converts a `int256` to its ASCII `string` decimal representation.
  67 |     |      */
  68 |     |     function toStringSigned(int256 value) internal pure returns (string memory) {
  69 |     |         return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));
  70 |     |     }
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
  74 |     |      */
  75 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
  76 |     |         unchecked {
  77 |     |             return toHexString(value, Math.log256(value) + 1);
  78 |     |         }
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
  83 |     |      */
  84 |     |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
  85 |     |         uint256 localValue = value;
  86 |     |         bytes memory buffer = new bytes(2 * length + 2);
  87 |     |         buffer[0] = "0";
  88 |     |         buffer[1] = "x";
  89 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
  90 |     |             buffer[i] = HEX_DIGITS[localValue & 0xf];
  91 |     |             localValue >>= 4;
  92 |     |         }
  93 |     |         if (localValue != 0) {
  94 |     |             revert StringsInsufficientHexLength(value, length);
  95 |     |         }
  96 |     |         return string(buffer);
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal
 101 |     |      * representation.
 102 |     |      */
 103 |     |     function toHexString(address addr) internal pure returns (string memory) {
 104 |     |         return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal
 109 |     |      * representation, according to EIP-55.
 110 |     |      */
 111 |     |     function toChecksumHexString(address addr) internal pure returns (string memory) {
 112 |     |         bytes memory buffer = bytes(toHexString(addr));
 113 |     | 
 114 |     |         // hash the hex part of buffer (skip length + 2 bytes, length 40)
 115 |     |         uint256 hashValue;
 116 |     |         assembly ("memory-safe") {
 117 |     |             hashValue := shr(96, keccak256(add(buffer, 0x22), 40))
 118 |     |         }
 119 |     | 
 120 |     |         for (uint256 i = 41; i > 1; --i) {
 121 |     |             // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)
 122 |     |             if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {
 123 |     |                 // case shift by xoring with 0x20
 124 |     |                 buffer[i] ^= 0x20;
 125 |     |             }
 126 |     |             hashValue >>= 4;
 127 |     |         }
 128 |     |         return string(buffer);
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Returns true if the two strings are equal.
 133 |     |      */
 134 |     |     function equal(string memory a, string memory b) internal pure returns (bool) {
 135 |     |         return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev Parse a decimal string and returns the value as a `uint256`.
 140 |     |      *
 141 |     |      * Requirements:
 142 |     |      * - The string must be formatted as `[0-9]*`
 143 |     |      * - The result must fit into an `uint256` type
 144 |     |      */
 145 |     |     function parseUint(string memory input) internal pure returns (uint256) {
 146 |     |         return parseUint(input, 0, bytes(input).length);
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and
 151 |     |      * `end` (excluded).
 152 |     |      *
 153 |     |      * Requirements:
 154 |     |      * - The substring must be formatted as `[0-9]*`
 155 |     |      * - The result must fit into an `uint256` type
 156 |     |      */
 157 |     |     function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {
 158 |     |         (bool success, uint256 value) = tryParseUint(input, begin, end);
 159 |     |         if (!success) revert StringsInvalidChar();
 160 |     |         return value;
 161 |     |     }
 162 |     | 
 163 |     |     /**
 164 |     |      * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.
 165 |     |      *
 166 |     |      * NOTE: This function will revert if the result does not fit in a `uint256`.
 167 |     |      */
 168 |     |     function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {
 169 |     |         return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid
 174 |     |      * character.
 175 |     |      *
 176 |     |      * NOTE: This function will revert if the result does not fit in a `uint256`.
 177 |     |      */
 178 |     |     function tryParseUint(
 179 |     |         string memory input,
 180 |     |         uint256 begin,
 181 |     |         uint256 end
 182 |     |     ) internal pure returns (bool success, uint256 value) {
 183 |     |         if (end > bytes(input).length || begin > end) return (false, 0);
 184 |     |         return _tryParseUintUncheckedBounds(input, begin, end);
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that
 189 |     |      * `begin <= end <= input.length`. Other inputs would result in undefined behavior.
 190 |     |      */
 191 |     |     function _tryParseUintUncheckedBounds(
 192 |     |         string memory input,
 193 |     |         uint256 begin,
 194 |     |         uint256 end
 195 |     |     ) private pure returns (bool success, uint256 value) {
 196 |     |         bytes memory buffer = bytes(input);
 197 |     | 
 198 |     |         uint256 result = 0;
 199 |     |         for (uint256 i = begin; i < end; ++i) {
 200 |     |             uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));
 201 |     |             if (chr > 9) return (false, 0);
 202 |     |             result *= 10;
 203 |     |             result += chr;
 204 |     |         }
 205 |     |         return (true, result);
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Parse a decimal string and returns the value as a `int256`.
 210 |     |      *
 211 |     |      * Requirements:
 212 |     |      * - The string must be formatted as `[-+]?[0-9]*`
 213 |     |      * - The result must fit in an `int256` type.
 214 |     |      */
 215 |     |     function parseInt(string memory input) internal pure returns (int256) {
 216 |     |         return parseInt(input, 0, bytes(input).length);
 217 |     |     }
 218 |     | 
 219 |     |     /**
 220 |     |      * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and
 221 |     |      * `end` (excluded).
 222 |     |      *
 223 |     |      * Requirements:
 224 |     |      * - The substring must be formatted as `[-+]?[0-9]*`
 225 |     |      * - The result must fit in an `int256` type.
 226 |     |      */
 227 |     |     function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {
 228 |     |         (bool success, int256 value) = tryParseInt(input, begin, end);
 229 |     |         if (!success) revert StringsInvalidChar();
 230 |     |         return value;
 231 |     |     }
 232 |     | 
 233 |     |     /**
 234 |     |      * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if
 235 |     |      * the result does not fit in a `int256`.
 236 |     |      *
 237 |     |      * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.
 238 |     |      */
 239 |     |     function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {
 240 |     |         return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);
 241 |     |     }
 242 |     | 
 243 |     |     uint256 private constant ABS_MIN_INT256 = 2 ** 255;
 244 |     | 
 245 |     |     /**
 246 |     |      * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid
 247 |     |      * character or if the result does not fit in a `int256`.
 248 |     |      *
 249 |     |      * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.
 250 |     |      */
 251 |     |     function tryParseInt(
 252 |     |         string memory input,
 253 |     |         uint256 begin,
 254 |     |         uint256 end
 255 |     |     ) internal pure returns (bool success, int256 value) {
 256 |     |         if (end > bytes(input).length || begin > end) return (false, 0);
 257 |     |         return _tryParseIntUncheckedBounds(input, begin, end);
 258 |     |     }
 259 |     | 
 260 |     |     /**
 261 |     |      * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that
 262 |     |      * `begin <= end <= input.length`. Other inputs would result in undefined behavior.
 263 |     |      */
 264 |     |     function _tryParseIntUncheckedBounds(
 265 |     |         string memory input,
 266 |     |         uint256 begin,
 267 |     |         uint256 end
 268 |     |     ) private pure returns (bool success, int256 value) {
 269 |     |         bytes memory buffer = bytes(input);
 270 |     | 
 271 |     |         // Check presence of a negative sign.
 272 |     |         bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty
 273 |     |         bool positiveSign = sign == bytes1("+");
 274 |     |         bool negativeSign = sign == bytes1("-");
 275 |     |         uint256 offset = (positiveSign || negativeSign).toUint();
 276 |     | 
 277 |     |         (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);
 278 |     | 
 279 |     |         if (absSuccess && absValue < ABS_MIN_INT256) {
 280 |     |             return (true, negativeSign ? -int256(absValue) : int256(absValue));
 281 |     |         } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {
 282 |     |             return (true, type(int256).min);
 283 |     |         } else return (false, 0);
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Parse a hexadecimal string (with or without "0x" prefix), and returns the value as a `uint256`.
 288 |     |      *
 289 |     |      * Requirements:
 290 |     |      * - The string must be formatted as `(0x)?[0-9a-fA-F]*`
 291 |     |      * - The result must fit in an `uint256` type.
 292 |     |      */
 293 |     |     function parseHexUint(string memory input) internal pure returns (uint256) {
 294 |     |         return parseHexUint(input, 0, bytes(input).length);
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and
 299 |     |      * `end` (excluded).
 300 |     |      *
 301 |     |      * Requirements:
 302 |     |      * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`
 303 |     |      * - The result must fit in an `uint256` type.
 304 |     |      */
 305 |     |     function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {
 306 |     |         (bool success, uint256 value) = tryParseHexUint(input, begin, end);
 307 |     |         if (!success) revert StringsInvalidChar();
 308 |     |         return value;
 309 |     |     }
 310 |     | 
 311 |     |     /**
 312 |     |      * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.
 313 |     |      *
 314 |     |      * NOTE: This function will revert if the result does not fit in a `uint256`.
 315 |     |      */
 316 |     |     function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {
 317 |     |         return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);
 318 |     |     }
 319 |     | 
 320 |     |     /**
 321 |     |      * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an
 322 |     |      * invalid character.
 323 |     |      *
 324 |     |      * NOTE: This function will revert if the result does not fit in a `uint256`.
 325 |     |      */
 326 |     |     function tryParseHexUint(
 327 |     |         string memory input,
 328 |     |         uint256 begin,
 329 |     |         uint256 end
 330 |     |     ) internal pure returns (bool success, uint256 value) {
 331 |     |         if (end > bytes(input).length || begin > end) return (false, 0);
 332 |     |         return _tryParseHexUintUncheckedBounds(input, begin, end);
 333 |     |     }
 334 |     | 
 335 |     |     /**
 336 |     |      * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that
 337 |     |      * `begin <= end <= input.length`. Other inputs would result in undefined behavior.
 338 |     |      */
 339 |     |     function _tryParseHexUintUncheckedBounds(
 340 |     |         string memory input,
 341 |     |         uint256 begin,
 342 |     |         uint256 end
 343 |     |     ) private pure returns (bool success, uint256 value) {
 344 |     |         bytes memory buffer = bytes(input);
 345 |     | 
 346 |     |         // skip 0x prefix if present
 347 |     |         bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2("0x"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty
 348 |     |         uint256 offset = hasPrefix.toUint() * 2;
 349 |     | 
 350 |     |         uint256 result = 0;
 351 |     |         for (uint256 i = begin + offset; i < end; ++i) {
 352 |     |             uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));
 353 |     |             if (chr > 15) return (false, 0);
 354 |     |             result *= 16;
 355 |     |             unchecked {
 356 |     |                 // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).
 357 |     |                 // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.
 358 |     |                 result += chr;
 359 |     |             }
 360 |     |         }
 361 |     |         return (true, result);
 362 |     |     }
 363 |     | 
 364 |     |     /**
 365 |     |      * @dev Parse a hexadecimal string (with or without "0x" prefix), and returns the value as an `address`.
 366 |     |      *
 367 |     |      * Requirements:
 368 |     |      * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`
 369 |     |      */
 370 |     |     function parseAddress(string memory input) internal pure returns (address) {
 371 |     |         return parseAddress(input, 0, bytes(input).length);
 372 |     |     }
 373 |     | 
 374 |     |     /**
 375 |     |      * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and
 376 |     |      * `end` (excluded).
 377 |     |      *
 378 |     |      * Requirements:
 379 |     |      * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`
 380 |     |      */
 381 |     |     function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {
 382 |     |         (bool success, address value) = tryParseAddress(input, begin, end);
 383 |     |         if (!success) revert StringsInvalidAddressFormat();
 384 |     |         return value;
 385 |     |     }
 386 |     | 
 387 |     |     /**
 388 |     |      * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly
 389 |     |      * formatted address. See {parseAddress-string} requirements.
 390 |     |      */
 391 |     |     function tryParseAddress(string memory input) internal pure returns (bool success, address value) {
 392 |     |         return tryParseAddress(input, 0, bytes(input).length);
 393 |     |     }
 394 |     | 
 395 |     |     /**
 396 |     |      * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly
 397 |     |      * formatted address. See {parseAddress-string-uint256-uint256} requirements.
 398 |     |      */
 399 |     |     function tryParseAddress(
 400 |     |         string memory input,
 401 |     |         uint256 begin,
 402 |     |         uint256 end
 403 |     |     ) internal pure returns (bool success, address value) {
 404 |     |         if (end > bytes(input).length || begin > end) return (false, address(0));
 405 |     | 
 406 |     |         bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2("0x"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty
 407 |     |         uint256 expectedLength = 40 + hasPrefix.toUint() * 2;
 408 |     | 
 409 |     |         // check that input is the correct length
 410 |     |         if (end - begin == expectedLength) {
 411 |     |             // length guarantees that this does not overflow, and value is at most type(uint160).max
 412 |     |             (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);
 413 |     |             return (s, address(uint160(v)));
 414 |     |         } else {
 415 |     |             return (false, address(0));
 416 |     |         }
 417 |     |     }
 418 |     | 
 419 |     |     function _tryParseChr(bytes1 chr) private pure returns (uint8) {
 420 |     |         uint8 value = uint8(chr);
 421 |     | 
 422 |     |         // Try to parse `chr`:
 423 |     |         // - Case 1: [0-9]
 424 |     |         // - Case 2: [a-f]
 425 |     |         // - Case 3: [A-F]
 426 |     |         // - otherwise not supported
 427 |     |         unchecked {
 428 |     |             if (value > 47 && value < 58) value -= 48;
 429 |     |             else if (value > 96 && value < 103) value -= 87;
 430 |     |             else if (value > 64 && value < 71) value -= 55;
 431 |     |             else return type(uint8).max;
 432 |     |         }
 433 |     | 
 434 |     |         return value;
 435 |     |     }
 436 |     | 
 437 |     |     /**
 438 |     |      * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.
 439 |     |      *
 440 |     |      * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.
 441 |     |      *
 442 |     |      * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of
 443 |     |      * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode
 444 |     |      * characters that are not in this range, but other tooling may provide different results.
 445 |     |      */
 446 |     |     function escapeJSON(string memory input) internal pure returns (string memory) {
 447 |     |         bytes memory buffer = bytes(input);
 448 |     |         bytes memory output = new bytes(2 * buffer.length); // worst case scenario
 449 |     |         uint256 outputLength = 0;
 450 |     | 
 451 |     |         for (uint256 i; i < buffer.length; ++i) {
 452 |     |             bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));
 453 |     |             if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {
 454 |     |                 output[outputLength++] = "\\";
 455 |     |                 if (char == 0x08) output[outputLength++] = "b";
 456 |     |                 else if (char == 0x09) output[outputLength++] = "t";
 457 |     |                 else if (char == 0x0a) output[outputLength++] = "n";
 458 |     |                 else if (char == 0x0c) output[outputLength++] = "f";
 459 |     |                 else if (char == 0x0d) output[outputLength++] = "r";
 460 |     |                 else if (char == 0x5c) output[outputLength++] = "\\";
 461 |     |                 else if (char == 0x22) {
 462 |     |                     // solhint-disable-next-line quotes
 463 |     |                     output[outputLength++] = '"';
 464 |     |                 }
 465 |     |             } else {
 466 |     |                 output[outputLength++] = char;
 467 |     |             }
 468 |     |         }
 469 |     |         // write the actual length and deallocate unused memory
 470 |     |         assembly ("memory-safe") {
 471 |     |             mstore(output, outputLength)
 472 |     |             mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))
 473 |     |         }
 474 |     | 
 475 |     |         return string(output);
 476 |     |     }
 477 |     | 
 478 |     |     /**
 479 |     |      * @dev Reads a bytes32 from a bytes array without bounds checking.
 480 |     |      *
 481 |     |      * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the
 482 |     |      * assembly block as such would prevent some optimizations.
 483 |     |      */
 484 |     |     function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {
 485 |     |         // This is not memory safe in the general case, but all calls to this private function are within bounds.
 486 |     |         assembly ("memory-safe") {
 487 |     |             value := mload(add(buffer, add(0x20, offset)))
 488 |     |         }
 489 |     |     }
 490 |     | }
 491 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC165} from "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  */
 20 |     | abstract contract ERC165 is IERC165 {
 21 |     |     /**
 22 |     |      * @dev See {IERC165-supportsInterface}.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
 25 |     |         return interfaceId == type(IERC165).interfaceId;
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC-165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[ERC].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Panic} from "../Panic.sol";
   7 |     | import {SafeCast} from "./SafeCast.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev Standard math utilities missing in the Solidity language.
  11 |     |  */
  12 |     | library Math {
  13 |     |     enum Rounding {
  14 |     |         Floor, // Toward negative infinity
  15 |     |         Ceil, // Toward positive infinity
  16 |     |         Trunc, // Toward zero
  17 |     |         Expand // Away from zero
  18 |     |     }
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev Return the 512-bit addition of two uint256.
  22 |     |      *
  23 |     |      * The result is stored in two 256 variables such that sum = high * 2 + low.
  24 |     |      */
  25 |     |     function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {
  26 |     |         assembly ("memory-safe") {
  27 |     |             low := add(a, b)
  28 |     |             high := lt(low, a)
  29 |     |         }
  30 |     |     }
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Return the 512-bit multiplication of two uint256.
  34 |     |      *
  35 |     |      * The result is stored in two 256 variables such that product = high * 2 + low.
  36 |     |      */
  37 |     |     function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {
  38 |     |         // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use
  39 |     |         // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
  40 |     |         // variables such that product = high * 2 + low.
  41 |     |         assembly ("memory-safe") {
  42 |     |             let mm := mulmod(a, b, not(0))
  43 |     |             low := mul(a, b)
  44 |     |             high := sub(sub(mm, low), lt(mm, low))
  45 |     |         }
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).
  50 |     |      */
  51 |     |     function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  52 |     |         unchecked {
  53 |     |             uint256 c = a + b;
  54 |     |             success = c >= a;
  55 |     |             result = c * SafeCast.toUint(success);
  56 |     |         }
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).
  61 |     |      */
  62 |     |     function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  63 |     |         unchecked {
  64 |     |             uint256 c = a - b;
  65 |     |             success = c <= a;
  66 |     |             result = c * SafeCast.toUint(success);
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).
  72 |     |      */
  73 |     |     function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  74 |     |         unchecked {
  75 |     |             uint256 c = a * b;
  76 |     |             assembly ("memory-safe") {
  77 |     |                 // Only true when the multiplication doesn't overflow
  78 |     |                 // (c / a == b) || (a == 0)
  79 |     |                 success := or(eq(div(c, a), b), iszero(a))
  80 |     |             }
  81 |     |             // equivalent to: success ? c : 0
  82 |     |             result = c * SafeCast.toUint(success);
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).
  88 |     |      */
  89 |     |     function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  90 |     |         unchecked {
  91 |     |             success = b > 0;
  92 |     |             assembly ("memory-safe") {
  93 |     |                 // The `DIV` opcode returns zero when the denominator is 0.
  94 |     |                 result := div(a, b)
  95 |     |             }
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).
 101 |     |      */
 102 |     |     function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
 103 |     |         unchecked {
 104 |     |             success = b > 0;
 105 |     |             assembly ("memory-safe") {
 106 |     |                 // The `MOD` opcode returns zero when the denominator is 0.
 107 |     |                 result := mod(a, b)
 108 |     |             }
 109 |     |         }
 110 |     |     }
 111 |     | 
 112 |     |     /**
 113 |     |      * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.
 114 |     |      */
 115 |     |     function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {
 116 |     |         (bool success, uint256 result) = tryAdd(a, b);
 117 |     |         return ternary(success, result, type(uint256).max);
 118 |     |     }
 119 |     | 
 120 |     |     /**
 121 |     |      * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.
 122 |     |      */
 123 |     |     function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {
 124 |     |         (, uint256 result) = trySub(a, b);
 125 |     |         return result;
 126 |     |     }
 127 |     | 
 128 |     |     /**
 129 |     |      * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.
 130 |     |      */
 131 |     |     function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {
 132 |     |         (bool success, uint256 result) = tryMul(a, b);
 133 |     |         return ternary(success, result, type(uint256).max);
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.
 138 |     |      *
 139 |     |      * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.
 140 |     |      * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute
 141 |     |      * one branch when needed, making this function more expensive.
 142 |     |      */
 143 |     |     function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {
 144 |     |         unchecked {
 145 |     |             // branchless ternary works because:
 146 |     |             // b ^ (a ^ b) == a
 147 |     |             // b ^ 0 == b
 148 |     |             return b ^ ((a ^ b) * SafeCast.toUint(condition));
 149 |     |         }
 150 |     |     }
 151 |     | 
 152 |     |     /**
 153 |     |      * @dev Returns the largest of two numbers.
 154 |     |      */
 155 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
 156 |     |         return ternary(a > b, a, b);
 157 |     |     }
 158 |     | 
 159 |     |     /**
 160 |     |      * @dev Returns the smallest of two numbers.
 161 |     |      */
 162 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
 163 |     |         return ternary(a < b, a, b);
 164 |     |     }
 165 |     | 
 166 |     |     /**
 167 |     |      * @dev Returns the average of two numbers. The result is rounded towards
 168 |     |      * zero.
 169 |     |      */
 170 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
 171 |     |         // (a + b) / 2 can overflow.
 172 |     |         return (a & b) + (a ^ b) / 2;
 173 |     |     }
 174 |     | 
 175 |     |     /**
 176 |     |      * @dev Returns the ceiling of the division of two numbers.
 177 |     |      *
 178 |     |      * This differs from standard division with `/` in that it rounds towards infinity instead
 179 |     |      * of rounding towards zero.
 180 |     |      */
 181 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
 182 |     |         if (b == 0) {
 183 |     |             // Guarantee the same behavior as in a regular Solidity division.
 184 |     |             Panic.panic(Panic.DIVISION_BY_ZERO);
 185 |     |         }
 186 |     | 
 187 |     |         // The following calculation ensures accurate ceiling division without overflow.
 188 |     |         // Since a is non-zero, (a - 1) / b will not overflow.
 189 |     |         // The largest possible result occurs when (a - 1) / b is type(uint256).max,
 190 |     |         // but the largest value we can obtain is type(uint256).max - 1, which happens
 191 |     |         // when a = type(uint256).max and b = 1.
 192 |     |         unchecked {
 193 |     |             return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);
 194 |     |         }
 195 |     |     }
 196 |     | 
 197 |     |     /**
 198 |     |      * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or
 199 |     |      * denominator == 0.
 200 |     |      *
 201 |     |      * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by
 202 |     |      * Uniswap Labs also under MIT license.
 203 |     |      */
 204 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
 205 |     |         unchecked {
 206 |     |             (uint256 high, uint256 low) = mul512(x, y);
 207 |     | 
 208 |     |             // Handle non-overflow cases, 256 by 256 division.
 209 |     |             if (high == 0) {
 210 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
 211 |     |                 // The surrounding unchecked block does not change this fact.
 212 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
 213 |     |                 return low / denominator;
 214 |     |             }
 215 |     | 
 216 |     |             // Make sure the result is less than 2. Also prevents denominator == 0.
 217 |     |             if (denominator <= high) {
 218 |     |                 Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));
 219 |     |             }
 220 |     | 
 221 |     |             ///////////////////////////////////////////////
 222 |     |             // 512 by 256 division.
 223 |     |             ///////////////////////////////////////////////
 224 |     | 
 225 |     |             // Make division exact by subtracting the remainder from [high low].
 226 |     |             uint256 remainder;
 227 |     |             assembly ("memory-safe") {
 228 |     |                 // Compute remainder using mulmod.
 229 |     |                 remainder := mulmod(x, y, denominator)
 230 |     | 
 231 |     |                 // Subtract 256 bit number from 512 bit number.
 232 |     |                 high := sub(high, gt(remainder, low))
 233 |     |                 low := sub(low, remainder)
 234 |     |             }
 235 |     | 
 236 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator.
 237 |     |             // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.
 238 |     | 
 239 |     |             uint256 twos = denominator & (0 - denominator);
 240 |     |             assembly ("memory-safe") {
 241 |     |                 // Divide denominator by twos.
 242 |     |                 denominator := div(denominator, twos)
 243 |     | 
 244 |     |                 // Divide [high low] by twos.
 245 |     |                 low := div(low, twos)
 246 |     | 
 247 |     |                 // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.
 248 |     |                 twos := add(div(sub(0, twos), twos), 1)
 249 |     |             }
 250 |     | 
 251 |     |             // Shift in bits from high into low.
 252 |     |             low |= high * twos;
 253 |     | 
 254 |     |             // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such
 255 |     |             // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for
 256 |     |             // four bits. That is, denominator * inv  1 mod 2.
 257 |     |             uint256 inverse = (3 * denominator) ^ 2;
 258 |     | 
 259 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also
 260 |     |             // works in modular arithmetic, doubling the correct bits in each step.
 261 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 262 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 263 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 264 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 265 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 266 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 267 |     | 
 268 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 269 |     |             // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is
 270 |     |             // less than 2, this is the final result. We don't need to compute the high bits of the result and high
 271 |     |             // is no longer required.
 272 |     |             result = low * inverse;
 273 |     |             return result;
 274 |     |         }
 275 |     |     }
 276 |     | 
 277 |     |     /**
 278 |     |      * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.
 279 |     |      */
 280 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 281 |     |         return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);
 282 |     |     }
 283 |     | 
 284 |     |     /**
 285 |     |      * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.
 286 |     |      */
 287 |     |     function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {
 288 |     |         unchecked {
 289 |     |             (uint256 high, uint256 low) = mul512(x, y);
 290 |     |             if (high >= 1 << n) {
 291 |     |                 Panic.panic(Panic.UNDER_OVERFLOW);
 292 |     |             }
 293 |     |             return (high << (256 - n)) | (low >> n);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Calculates x * y >> n with full precision, following the selected rounding direction.
 299 |     |      */
 300 |     |     function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {
 301 |     |         return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);
 302 |     |     }
 303 |     | 
 304 |     |     /**
 305 |     |      * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.
 306 |     |      *
 307 |     |      * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.
 308 |     |      * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.
 309 |     |      *
 310 |     |      * If the input value is not inversible, 0 is returned.
 311 |     |      *
 312 |     |      * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the
 313 |     |      * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.
 314 |     |      */
 315 |     |     function invMod(uint256 a, uint256 n) internal pure returns (uint256) {
 316 |     |         unchecked {
 317 |     |             if (n == 0) return 0;
 318 |     | 
 319 |     |             // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)
 320 |     |             // Used to compute integers x and y such that: ax + ny = gcd(a, n).
 321 |     |             // When the gcd is 1, then the inverse of a modulo n exists and it's x.
 322 |     |             // ax + ny = 1
 323 |     |             // ax = 1 + (-y)n
 324 |     |             // ax  1 (mod n) # x is the inverse of a modulo n
 325 |     | 
 326 |     |             // If the remainder is 0 the gcd is n right away.
 327 |     |             uint256 remainder = a % n;
 328 |     |             uint256 gcd = n;
 329 |     | 
 330 |     |             // Therefore the initial coefficients are:
 331 |     |             // ax + ny = gcd(a, n) = n
 332 |     |             // 0a + 1n = n
 333 |     |             int256 x = 0;
 334 |     |             int256 y = 1;
 335 |     | 
 336 |     |             while (remainder != 0) {
 337 |     |                 uint256 quotient = gcd / remainder;
 338 |     | 
 339 |     |                 (gcd, remainder) = (
 340 |     |                     // The old remainder is the next gcd to try.
 341 |     |                     remainder,
 342 |     |                     // Compute the next remainder.
 343 |     |                     // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd
 344 |     |                     // where gcd is at most n (capped to type(uint256).max)
 345 |     |                     gcd - remainder * quotient
 346 |     |                 );
 347 |     | 
 348 |     |                 (x, y) = (
 349 |     |                     // Increment the coefficient of a.
 350 |     |                     y,
 351 |     |                     // Decrement the coefficient of n.
 352 |     |                     // Can overflow, but the result is casted to uint256 so that the
 353 |     |                     // next value of y is "wrapped around" to a value between 0 and n - 1.
 354 |     |                     x - y * int256(quotient)
 355 |     |                 );
 356 |     |             }
 357 |     | 
 358 |     |             if (gcd != 1) return 0; // No inverse exists.
 359 |     |             return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.
 360 |     |         }
 361 |     |     }
 362 |     | 
 363 |     |     /**
 364 |     |      * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.
 365 |     |      *
 366 |     |      * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is
 367 |     |      * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that
 368 |     |      * `a**(p-2)` is the modular multiplicative inverse of a in Fp.
 369 |     |      *
 370 |     |      * NOTE: this function does NOT check that `p` is a prime greater than `2`.
 371 |     |      */
 372 |     |     function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {
 373 |     |         unchecked {
 374 |     |             return Math.modExp(a, p - 2, p);
 375 |     |         }
 376 |     |     }
 377 |     | 
 378 |     |     /**
 379 |     |      * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)
 380 |     |      *
 381 |     |      * Requirements:
 382 |     |      * - modulus can't be zero
 383 |     |      * - underlying staticcall to precompile must succeed
 384 |     |      *
 385 |     |      * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make
 386 |     |      * sure the chain you're using it on supports the precompiled contract for modular exponentiation
 387 |     |      * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,
 388 |     |      * the underlying function will succeed given the lack of a revert, but the result may be incorrectly
 389 |     |      * interpreted as 0.
 390 |     |      */
 391 |     |     function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {
 392 |     |         (bool success, uint256 result) = tryModExp(b, e, m);
 393 |     |         if (!success) {
 394 |     |             Panic.panic(Panic.DIVISION_BY_ZERO);
 395 |     |         }
 396 |     |         return result;
 397 |     |     }
 398 |     | 
 399 |     |     /**
 400 |     |      * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).
 401 |     |      * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying
 402 |     |      * to operate modulo 0 or if the underlying precompile reverted.
 403 |     |      *
 404 |     |      * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain
 405 |     |      * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in
 406 |     |      * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack
 407 |     |      * of a revert, but the result may be incorrectly interpreted as 0.
 408 |     |      */
 409 |     |     function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {
 410 |     |         if (m == 0) return (false, 0);
 411 |     |         assembly ("memory-safe") {
 412 |     |             let ptr := mload(0x40)
 413 |     |             // | Offset    | Content    | Content (Hex)                                                      |
 414 |     |             // |-----------|------------|--------------------------------------------------------------------|
 415 |     |             // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |
 416 |     |             // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |
 417 |     |             // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |
 418 |     |             // | 0x60:0x7f | value of b | 0x<.............................................................b> |
 419 |     |             // | 0x80:0x9f | value of e | 0x<.............................................................e> |
 420 |     |             // | 0xa0:0xbf | value of m | 0x<.............................................................m> |
 421 |     |             mstore(ptr, 0x20)
 422 |     |             mstore(add(ptr, 0x20), 0x20)
 423 |     |             mstore(add(ptr, 0x40), 0x20)
 424 |     |             mstore(add(ptr, 0x60), b)
 425 |     |             mstore(add(ptr, 0x80), e)
 426 |     |             mstore(add(ptr, 0xa0), m)
 427 |     | 
 428 |     |             // Given the result < m, it's guaranteed to fit in 32 bytes,
 429 |     |             // so we can use the memory scratch space located at offset 0.
 430 |     |             success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)
 431 |     |             result := mload(0x00)
 432 |     |         }
 433 |     |     }
 434 |     | 
 435 |     |     /**
 436 |     |      * @dev Variant of {modExp} that supports inputs of arbitrary length.
 437 |     |      */
 438 |     |     function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {
 439 |     |         (bool success, bytes memory result) = tryModExp(b, e, m);
 440 |     |         if (!success) {
 441 |     |             Panic.panic(Panic.DIVISION_BY_ZERO);
 442 |     |         }
 443 |     |         return result;
 444 |     |     }
 445 |     | 
 446 |     |     /**
 447 |     |      * @dev Variant of {tryModExp} that supports inputs of arbitrary length.
 448 |     |      */
 449 |     |     function tryModExp(
 450 |     |         bytes memory b,
 451 |     |         bytes memory e,
 452 |     |         bytes memory m
 453 |     |     ) internal view returns (bool success, bytes memory result) {
 454 |     |         if (_zeroBytes(m)) return (false, new bytes(0));
 455 |     | 
 456 |     |         uint256 mLen = m.length;
 457 |     | 
 458 |     |         // Encode call args in result and move the free memory pointer
 459 |     |         result = abi.encodePacked(b.length, e.length, mLen, b, e, m);
 460 |     | 
 461 |     |         assembly ("memory-safe") {
 462 |     |             let dataPtr := add(result, 0x20)
 463 |     |             // Write result on top of args to avoid allocating extra memory.
 464 |     |             success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)
 465 |     |             // Overwrite the length.
 466 |     |             // result.length > returndatasize() is guaranteed because returndatasize() == m.length
 467 |     |             mstore(result, mLen)
 468 |     |             // Set the memory pointer after the returned data.
 469 |     |             mstore(0x40, add(dataPtr, mLen))
 470 |     |         }
 471 |     |     }
 472 |     | 
 473 |     |     /**
 474 |     |      * @dev Returns whether the provided byte array is zero.
 475 |     |      */
 476 |     |     function _zeroBytes(bytes memory byteArray) private pure returns (bool) {
 477 |     |         for (uint256 i = 0; i < byteArray.length; ++i) {
 478 |     |             if (byteArray[i] != 0) {
 479 |     |                 return false;
 480 |     |             }
 481 |     |         }
 482 |     |         return true;
 483 |     |     }
 484 |     | 
 485 |     |     /**
 486 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded
 487 |     |      * towards zero.
 488 |     |      *
 489 |     |      * This method is based on Newton's method for computing square roots; the algorithm is restricted to only
 490 |     |      * using integer operations.
 491 |     |      */
 492 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 493 |     |         unchecked {
 494 |     |             // Take care of easy edge cases when a == 0 or a == 1
 495 |     |             if (a <= 1) {
 496 |     |                 return a;
 497 |     |             }
 498 |     | 
 499 |     |             // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a
 500 |     |             // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between
 501 |     |             // the current value as `_n = | x_n - sqrt(a) |`.
 502 |     |             //
 503 |     |             // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root
 504 |     |             // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is
 505 |     |             // bigger than any uint256.
 506 |     |             //
 507 |     |             // By noticing that
 508 |     |             // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`
 509 |     |             // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar
 510 |     |             // to the msb function.
 511 |     |             uint256 aa = a;
 512 |     |             uint256 xn = 1;
 513 |     | 
 514 |     |             if (aa >= (1 << 128)) {
 515 |     |                 aa >>= 128;
 516 |     |                 xn <<= 64;
 517 |     |             }
 518 |     |             if (aa >= (1 << 64)) {
 519 |     |                 aa >>= 64;
 520 |     |                 xn <<= 32;
 521 |     |             }
 522 |     |             if (aa >= (1 << 32)) {
 523 |     |                 aa >>= 32;
 524 |     |                 xn <<= 16;
 525 |     |             }
 526 |     |             if (aa >= (1 << 16)) {
 527 |     |                 aa >>= 16;
 528 |     |                 xn <<= 8;
 529 |     |             }
 530 |     |             if (aa >= (1 << 8)) {
 531 |     |                 aa >>= 8;
 532 |     |                 xn <<= 4;
 533 |     |             }
 534 |     |             if (aa >= (1 << 4)) {
 535 |     |                 aa >>= 4;
 536 |     |                 xn <<= 2;
 537 |     |             }
 538 |     |             if (aa >= (1 << 2)) {
 539 |     |                 xn <<= 1;
 540 |     |             }
 541 |     | 
 542 |     |             // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).
 543 |     |             //
 544 |     |             // We can refine our estimation by noticing that the middle of that interval minimizes the error.
 545 |     |             // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).
 546 |     |             // This is going to be our x_0 (and _0)
 547 |     |             xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)
 548 |     | 
 549 |     |             // From here, Newton's method give us:
 550 |     |             // x_{n+1} = (x_n + a / x_n) / 2
 551 |     |             //
 552 |     |             // One should note that:
 553 |     |             // x_{n+1} - a = ((x_n + a / x_n) / 2) - a
 554 |     |             //              = ((x_n + a) / (2 * x_n)) - a
 555 |     |             //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a
 556 |     |             //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)
 557 |     |             //              = (x_n - 2 * a * x_n + a) / (4 * x_n)
 558 |     |             //              = (x_n - a) / (2 * x_n)
 559 |     |             //              = ((x_n - a) / (2 * x_n))
 560 |     |             //               0
 561 |     |             // Which proves that for all n  1, sqrt(a)  x_n
 562 |     |             //
 563 |     |             // This gives us the proof of quadratic convergence of the sequence:
 564 |     |             // _{n+1} = | x_{n+1} - sqrt(a) |
 565 |     |             //         = | (x_n + a / x_n) / 2 - sqrt(a) |
 566 |     |             //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |
 567 |     |             //         = | (x_n - sqrt(a)) / (2 * x_n) |
 568 |     |             //         = | _n / (2 * x_n) |
 569 |     |             //         = _n / | (2 * x_n) |
 570 |     |             //
 571 |     |             // For the first iteration, we have a special case where x_0 is known:
 572 |     |             // _1 = _0 / | (2 * x_0) |
 573 |     |             //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))
 574 |     |             //      2**(2*e-4) / (3 * 2**(e-1))
 575 |     |             //      2**(e-3) / 3
 576 |     |             //      2**(e-3-log2(3))
 577 |     |             //      2**(e-4.5)
 578 |     |             //
 579 |     |             // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:
 580 |     |             // _{n+1} = _n / | (2 * x_n) |
 581 |     |             //          (2**(e-k)) / (2 * 2**(e-1))
 582 |     |             //          2**(2*e-2*k) / 2**e
 583 |     |             //          2**(e-2*k)
 584 |     |             xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above
 585 |     |             xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5
 586 |     |             xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9
 587 |     |             xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18
 588 |     |             xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36
 589 |     |             xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72
 590 |     | 
 591 |     |             // Because e  128 (as discussed during the first estimation phase), we know have reached a precision
 592 |     |             // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either
 593 |     |             // sqrt(a) or sqrt(a) + 1.
 594 |     |             return xn - SafeCast.toUint(xn > a / xn);
 595 |     |         }
 596 |     |     }
 597 |     | 
 598 |     |     /**
 599 |     |      * @dev Calculates sqrt(a), following the selected rounding direction.
 600 |     |      */
 601 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 602 |     |         unchecked {
 603 |     |             uint256 result = sqrt(a);
 604 |     |             return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);
 605 |     |         }
 606 |     |     }
 607 |     | 
 608 |     |     /**
 609 |     |      * @dev Return the log in base 2 of a positive value rounded towards zero.
 610 |     |      * Returns 0 if given 0.
 611 |     |      */
 612 |     |     function log2(uint256 x) internal pure returns (uint256 r) {
 613 |     |         // If value has upper 128 bits set, log2 result is at least 128
 614 |     |         r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;
 615 |     |         // If upper 64 bits of 128-bit half set, add 64 to result
 616 |     |         r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;
 617 |     |         // If upper 32 bits of 64-bit half set, add 32 to result
 618 |     |         r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;
 619 |     |         // If upper 16 bits of 32-bit half set, add 16 to result
 620 |     |         r |= SafeCast.toUint((x >> r) > 0xffff) << 4;
 621 |     |         // If upper 8 bits of 16-bit half set, add 8 to result
 622 |     |         r |= SafeCast.toUint((x >> r) > 0xff) << 3;
 623 |     |         // If upper 4 bits of 8-bit half set, add 4 to result
 624 |     |         r |= SafeCast.toUint((x >> r) > 0xf) << 2;
 625 |     | 
 626 |     |         // Shifts value right by the current result and use it as an index into this lookup table:
 627 |     |         //
 628 |     |         // | x (4 bits) |  index  | table[index] = MSB position |
 629 |     |         // |------------|---------|-----------------------------|
 630 |     |         // |    0000    |    0    |        table[0] = 0         |
 631 |     |         // |    0001    |    1    |        table[1] = 0         |
 632 |     |         // |    0010    |    2    |        table[2] = 1         |
 633 |     |         // |    0011    |    3    |        table[3] = 1         |
 634 |     |         // |    0100    |    4    |        table[4] = 2         |
 635 |     |         // |    0101    |    5    |        table[5] = 2         |
 636 |     |         // |    0110    |    6    |        table[6] = 2         |
 637 |     |         // |    0111    |    7    |        table[7] = 2         |
 638 |     |         // |    1000    |    8    |        table[8] = 3         |
 639 |     |         // |    1001    |    9    |        table[9] = 3         |
 640 |     |         // |    1010    |   10    |        table[10] = 3        |
 641 |     |         // |    1011    |   11    |        table[11] = 3        |
 642 |     |         // |    1100    |   12    |        table[12] = 3        |
 643 |     |         // |    1101    |   13    |        table[13] = 3        |
 644 |     |         // |    1110    |   14    |        table[14] = 3        |
 645 |     |         // |    1111    |   15    |        table[15] = 3        |
 646 |     |         //
 647 |     |         // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.
 648 |     |         assembly ("memory-safe") {
 649 |     |             r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))
 650 |     |         }
 651 |     |     }
 652 |     | 
 653 |     |     /**
 654 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 655 |     |      * Returns 0 if given 0.
 656 |     |      */
 657 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 658 |     |         unchecked {
 659 |     |             uint256 result = log2(value);
 660 |     |             return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);
 661 |     |         }
 662 |     |     }
 663 |     | 
 664 |     |     /**
 665 |     |      * @dev Return the log in base 10 of a positive value rounded towards zero.
 666 |     |      * Returns 0 if given 0.
 667 |     |      */
 668 |     |     function log10(uint256 value) internal pure returns (uint256) {
 669 |     |         uint256 result = 0;
 670 |     |         unchecked {
 671 |     |             if (value >= 10 ** 64) {
 672 |     |                 value /= 10 ** 64;
 673 |     |                 result += 64;
 674 |     |             }
 675 |     |             if (value >= 10 ** 32) {
 676 |     |                 value /= 10 ** 32;
 677 |     |                 result += 32;
 678 |     |             }
 679 |     |             if (value >= 10 ** 16) {
 680 |     |                 value /= 10 ** 16;
 681 |     |                 result += 16;
 682 |     |             }
 683 |     |             if (value >= 10 ** 8) {
 684 |     |                 value /= 10 ** 8;
 685 |     |                 result += 8;
 686 |     |             }
 687 |     |             if (value >= 10 ** 4) {
 688 |     |                 value /= 10 ** 4;
 689 |     |                 result += 4;
 690 |     |             }
 691 |     |             if (value >= 10 ** 2) {
 692 |     |                 value /= 10 ** 2;
 693 |     |                 result += 2;
 694 |     |             }
 695 |     |             if (value >= 10 ** 1) {
 696 |     |                 result += 1;
 697 |     |             }
 698 |     |         }
 699 |     |         return result;
 700 |     |     }
 701 |     | 
 702 |     |     /**
 703 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 704 |     |      * Returns 0 if given 0.
 705 |     |      */
 706 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 707 |     |         unchecked {
 708 |     |             uint256 result = log10(value);
 709 |     |             return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);
 710 |     |         }
 711 |     |     }
 712 |     | 
 713 |     |     /**
 714 |     |      * @dev Return the log in base 256 of a positive value rounded towards zero.
 715 |     |      * Returns 0 if given 0.
 716 |     |      *
 717 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 718 |     |      */
 719 |     |     function log256(uint256 x) internal pure returns (uint256 r) {
 720 |     |         // If value has upper 128 bits set, log2 result is at least 128
 721 |     |         r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;
 722 |     |         // If upper 64 bits of 128-bit half set, add 64 to result
 723 |     |         r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;
 724 |     |         // If upper 32 bits of 64-bit half set, add 32 to result
 725 |     |         r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;
 726 |     |         // If upper 16 bits of 32-bit half set, add 16 to result
 727 |     |         r |= SafeCast.toUint((x >> r) > 0xffff) << 4;
 728 |     |         // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8
 729 |     |         return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);
 730 |     |     }
 731 |     | 
 732 |     |     /**
 733 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 734 |     |      * Returns 0 if given 0.
 735 |     |      */
 736 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 737 |     |         unchecked {
 738 |     |             uint256 result = log256(value);
 739 |     |             return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);
 740 |     |         }
 741 |     |     }
 742 |     | 
 743 |     |     /**
 744 |     |      * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.
 745 |     |      */
 746 |     |     function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {
 747 |     |         return uint8(rounding) % 2 == 1;
 748 |     |     }
 749 |     | }
 750 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)
    3 |     | // This file was procedurally generated from scripts/generate/templates/SafeCast.js.
    4 |     | 
    5 |     | pragma solidity ^0.8.20;
    6 |     | 
    7 |     | /**
    8 |     |  * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow
    9 |     |  * checks.
   10 |     |  *
   11 |     |  * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
   12 |     |  * easily result in undesired exploitation or bugs, since developers usually
   13 |     |  * assume that overflows raise errors. `SafeCast` restores this intuition by
   14 |     |  * reverting the transaction when such an operation overflows.
   15 |     |  *
   16 |     |  * Using this library instead of the unchecked operations eliminates an entire
   17 |     |  * class of bugs, so it's recommended to use it always.
   18 |     |  */
   19 |     | library SafeCast {
   20 |     |     /**
   21 |     |      * @dev Value doesn't fit in an uint of `bits` size.
   22 |     |      */
   23 |     |     error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
   24 |     | 
   25 |     |     /**
   26 |     |      * @dev An int value doesn't fit in an uint of `bits` size.
   27 |     |      */
   28 |     |     error SafeCastOverflowedIntToUint(int256 value);
   29 |     | 
   30 |     |     /**
   31 |     |      * @dev Value doesn't fit in an int of `bits` size.
   32 |     |      */
   33 |     |     error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);
   34 |     | 
   35 |     |     /**
   36 |     |      * @dev An uint value doesn't fit in an int of `bits` size.
   37 |     |      */
   38 |     |     error SafeCastOverflowedUintToInt(uint256 value);
   39 |     | 
   40 |     |     /**
   41 |     |      * @dev Returns the downcasted uint248 from uint256, reverting on
   42 |     |      * overflow (when the input is greater than largest uint248).
   43 |     |      *
   44 |     |      * Counterpart to Solidity's `uint248` operator.
   45 |     |      *
   46 |     |      * Requirements:
   47 |     |      *
   48 |     |      * - input must fit into 248 bits
   49 |     |      */
   50 |     |     function toUint248(uint256 value) internal pure returns (uint248) {
   51 |     |         if (value > type(uint248).max) {
   52 |     |             revert SafeCastOverflowedUintDowncast(248, value);
   53 |     |         }
   54 |     |         return uint248(value);
   55 |     |     }
   56 |     | 
   57 |     |     /**
   58 |     |      * @dev Returns the downcasted uint240 from uint256, reverting on
   59 |     |      * overflow (when the input is greater than largest uint240).
   60 |     |      *
   61 |     |      * Counterpart to Solidity's `uint240` operator.
   62 |     |      *
   63 |     |      * Requirements:
   64 |     |      *
   65 |     |      * - input must fit into 240 bits
   66 |     |      */
   67 |     |     function toUint240(uint256 value) internal pure returns (uint240) {
   68 |     |         if (value > type(uint240).max) {
   69 |     |             revert SafeCastOverflowedUintDowncast(240, value);
   70 |     |         }
   71 |     |         return uint240(value);
   72 |     |     }
   73 |     | 
   74 |     |     /**
   75 |     |      * @dev Returns the downcasted uint232 from uint256, reverting on
   76 |     |      * overflow (when the input is greater than largest uint232).
   77 |     |      *
   78 |     |      * Counterpart to Solidity's `uint232` operator.
   79 |     |      *
   80 |     |      * Requirements:
   81 |     |      *
   82 |     |      * - input must fit into 232 bits
   83 |     |      */
   84 |     |     function toUint232(uint256 value) internal pure returns (uint232) {
   85 |     |         if (value > type(uint232).max) {
   86 |     |             revert SafeCastOverflowedUintDowncast(232, value);
   87 |     |         }
   88 |     |         return uint232(value);
   89 |     |     }
   90 |     | 
   91 |     |     /**
   92 |     |      * @dev Returns the downcasted uint224 from uint256, reverting on
   93 |     |      * overflow (when the input is greater than largest uint224).
   94 |     |      *
   95 |     |      * Counterpart to Solidity's `uint224` operator.
   96 |     |      *
   97 |     |      * Requirements:
   98 |     |      *
   99 |     |      * - input must fit into 224 bits
  100 |     |      */
  101 |     |     function toUint224(uint256 value) internal pure returns (uint224) {
  102 |     |         if (value > type(uint224).max) {
  103 |     |             revert SafeCastOverflowedUintDowncast(224, value);
  104 |     |         }
  105 |     |         return uint224(value);
  106 |     |     }
  107 |     | 
  108 |     |     /**
  109 |     |      * @dev Returns the downcasted uint216 from uint256, reverting on
  110 |     |      * overflow (when the input is greater than largest uint216).
  111 |     |      *
  112 |     |      * Counterpart to Solidity's `uint216` operator.
  113 |     |      *
  114 |     |      * Requirements:
  115 |     |      *
  116 |     |      * - input must fit into 216 bits
  117 |     |      */
  118 |     |     function toUint216(uint256 value) internal pure returns (uint216) {
  119 |     |         if (value > type(uint216).max) {
  120 |     |             revert SafeCastOverflowedUintDowncast(216, value);
  121 |     |         }
  122 |     |         return uint216(value);
  123 |     |     }
  124 |     | 
  125 |     |     /**
  126 |     |      * @dev Returns the downcasted uint208 from uint256, reverting on
  127 |     |      * overflow (when the input is greater than largest uint208).
  128 |     |      *
  129 |     |      * Counterpart to Solidity's `uint208` operator.
  130 |     |      *
  131 |     |      * Requirements:
  132 |     |      *
  133 |     |      * - input must fit into 208 bits
  134 |     |      */
  135 |     |     function toUint208(uint256 value) internal pure returns (uint208) {
  136 |     |         if (value > type(uint208).max) {
  137 |     |             revert SafeCastOverflowedUintDowncast(208, value);
  138 |     |         }
  139 |     |         return uint208(value);
  140 |     |     }
  141 |     | 
  142 |     |     /**
  143 |     |      * @dev Returns the downcasted uint200 from uint256, reverting on
  144 |     |      * overflow (when the input is greater than largest uint200).
  145 |     |      *
  146 |     |      * Counterpart to Solidity's `uint200` operator.
  147 |     |      *
  148 |     |      * Requirements:
  149 |     |      *
  150 |     |      * - input must fit into 200 bits
  151 |     |      */
  152 |     |     function toUint200(uint256 value) internal pure returns (uint200) {
  153 |     |         if (value > type(uint200).max) {
  154 |     |             revert SafeCastOverflowedUintDowncast(200, value);
  155 |     |         }
  156 |     |         return uint200(value);
  157 |     |     }
  158 |     | 
  159 |     |     /**
  160 |     |      * @dev Returns the downcasted uint192 from uint256, reverting on
  161 |     |      * overflow (when the input is greater than largest uint192).
  162 |     |      *
  163 |     |      * Counterpart to Solidity's `uint192` operator.
  164 |     |      *
  165 |     |      * Requirements:
  166 |     |      *
  167 |     |      * - input must fit into 192 bits
  168 |     |      */
  169 |     |     function toUint192(uint256 value) internal pure returns (uint192) {
  170 |     |         if (value > type(uint192).max) {
  171 |     |             revert SafeCastOverflowedUintDowncast(192, value);
  172 |     |         }
  173 |     |         return uint192(value);
  174 |     |     }
  175 |     | 
  176 |     |     /**
  177 |     |      * @dev Returns the downcasted uint184 from uint256, reverting on
  178 |     |      * overflow (when the input is greater than largest uint184).
  179 |     |      *
  180 |     |      * Counterpart to Solidity's `uint184` operator.
  181 |     |      *
  182 |     |      * Requirements:
  183 |     |      *
  184 |     |      * - input must fit into 184 bits
  185 |     |      */
  186 |     |     function toUint184(uint256 value) internal pure returns (uint184) {
  187 |     |         if (value > type(uint184).max) {
  188 |     |             revert SafeCastOverflowedUintDowncast(184, value);
  189 |     |         }
  190 |     |         return uint184(value);
  191 |     |     }
  192 |     | 
  193 |     |     /**
  194 |     |      * @dev Returns the downcasted uint176 from uint256, reverting on
  195 |     |      * overflow (when the input is greater than largest uint176).
  196 |     |      *
  197 |     |      * Counterpart to Solidity's `uint176` operator.
  198 |     |      *
  199 |     |      * Requirements:
  200 |     |      *
  201 |     |      * - input must fit into 176 bits
  202 |     |      */
  203 |     |     function toUint176(uint256 value) internal pure returns (uint176) {
  204 |     |         if (value > type(uint176).max) {
  205 |     |             revert SafeCastOverflowedUintDowncast(176, value);
  206 |     |         }
  207 |     |         return uint176(value);
  208 |     |     }
  209 |     | 
  210 |     |     /**
  211 |     |      * @dev Returns the downcasted uint168 from uint256, reverting on
  212 |     |      * overflow (when the input is greater than largest uint168).
  213 |     |      *
  214 |     |      * Counterpart to Solidity's `uint168` operator.
  215 |     |      *
  216 |     |      * Requirements:
  217 |     |      *
  218 |     |      * - input must fit into 168 bits
  219 |     |      */
  220 |     |     function toUint168(uint256 value) internal pure returns (uint168) {
  221 |     |         if (value > type(uint168).max) {
  222 |     |             revert SafeCastOverflowedUintDowncast(168, value);
  223 |     |         }
  224 |     |         return uint168(value);
  225 |     |     }
  226 |     | 
  227 |     |     /**
  228 |     |      * @dev Returns the downcasted uint160 from uint256, reverting on
  229 |     |      * overflow (when the input is greater than largest uint160).
  230 |     |      *
  231 |     |      * Counterpart to Solidity's `uint160` operator.
  232 |     |      *
  233 |     |      * Requirements:
  234 |     |      *
  235 |     |      * - input must fit into 160 bits
  236 |     |      */
  237 |     |     function toUint160(uint256 value) internal pure returns (uint160) {
  238 |     |         if (value > type(uint160).max) {
  239 |     |             revert SafeCastOverflowedUintDowncast(160, value);
  240 |     |         }
  241 |     |         return uint160(value);
  242 |     |     }
  243 |     | 
  244 |     |     /**
  245 |     |      * @dev Returns the downcasted uint152 from uint256, reverting on
  246 |     |      * overflow (when the input is greater than largest uint152).
  247 |     |      *
  248 |     |      * Counterpart to Solidity's `uint152` operator.
  249 |     |      *
  250 |     |      * Requirements:
  251 |     |      *
  252 |     |      * - input must fit into 152 bits
  253 |     |      */
  254 |     |     function toUint152(uint256 value) internal pure returns (uint152) {
  255 |     |         if (value > type(uint152).max) {
  256 |     |             revert SafeCastOverflowedUintDowncast(152, value);
  257 |     |         }
  258 |     |         return uint152(value);
  259 |     |     }
  260 |     | 
  261 |     |     /**
  262 |     |      * @dev Returns the downcasted uint144 from uint256, reverting on
  263 |     |      * overflow (when the input is greater than largest uint144).
  264 |     |      *
  265 |     |      * Counterpart to Solidity's `uint144` operator.
  266 |     |      *
  267 |     |      * Requirements:
  268 |     |      *
  269 |     |      * - input must fit into 144 bits
  270 |     |      */
  271 |     |     function toUint144(uint256 value) internal pure returns (uint144) {
  272 |     |         if (value > type(uint144).max) {
  273 |     |             revert SafeCastOverflowedUintDowncast(144, value);
  274 |     |         }
  275 |     |         return uint144(value);
  276 |     |     }
  277 |     | 
  278 |     |     /**
  279 |     |      * @dev Returns the downcasted uint136 from uint256, reverting on
  280 |     |      * overflow (when the input is greater than largest uint136).
  281 |     |      *
  282 |     |      * Counterpart to Solidity's `uint136` operator.
  283 |     |      *
  284 |     |      * Requirements:
  285 |     |      *
  286 |     |      * - input must fit into 136 bits
  287 |     |      */
  288 |     |     function toUint136(uint256 value) internal pure returns (uint136) {
  289 |     |         if (value > type(uint136).max) {
  290 |     |             revert SafeCastOverflowedUintDowncast(136, value);
  291 |     |         }
  292 |     |         return uint136(value);
  293 |     |     }
  294 |     | 
  295 |     |     /**
  296 |     |      * @dev Returns the downcasted uint128 from uint256, reverting on
  297 |     |      * overflow (when the input is greater than largest uint128).
  298 |     |      *
  299 |     |      * Counterpart to Solidity's `uint128` operator.
  300 |     |      *
  301 |     |      * Requirements:
  302 |     |      *
  303 |     |      * - input must fit into 128 bits
  304 |     |      */
  305 |     |     function toUint128(uint256 value) internal pure returns (uint128) {
  306 |     |         if (value > type(uint128).max) {
  307 |     |             revert SafeCastOverflowedUintDowncast(128, value);
  308 |     |         }
  309 |     |         return uint128(value);
  310 |     |     }
  311 |     | 
  312 |     |     /**
  313 |     |      * @dev Returns the downcasted uint120 from uint256, reverting on
  314 |     |      * overflow (when the input is greater than largest uint120).
  315 |     |      *
  316 |     |      * Counterpart to Solidity's `uint120` operator.
  317 |     |      *
  318 |     |      * Requirements:
  319 |     |      *
  320 |     |      * - input must fit into 120 bits
  321 |     |      */
  322 |     |     function toUint120(uint256 value) internal pure returns (uint120) {
  323 |     |         if (value > type(uint120).max) {
  324 |     |             revert SafeCastOverflowedUintDowncast(120, value);
  325 |     |         }
  326 |     |         return uint120(value);
  327 |     |     }
  328 |     | 
  329 |     |     /**
  330 |     |      * @dev Returns the downcasted uint112 from uint256, reverting on
  331 |     |      * overflow (when the input is greater than largest uint112).
  332 |     |      *
  333 |     |      * Counterpart to Solidity's `uint112` operator.
  334 |     |      *
  335 |     |      * Requirements:
  336 |     |      *
  337 |     |      * - input must fit into 112 bits
  338 |     |      */
  339 |     |     function toUint112(uint256 value) internal pure returns (uint112) {
  340 |     |         if (value > type(uint112).max) {
  341 |     |             revert SafeCastOverflowedUintDowncast(112, value);
  342 |     |         }
  343 |     |         return uint112(value);
  344 |     |     }
  345 |     | 
  346 |     |     /**
  347 |     |      * @dev Returns the downcasted uint104 from uint256, reverting on
  348 |     |      * overflow (when the input is greater than largest uint104).
  349 |     |      *
  350 |     |      * Counterpart to Solidity's `uint104` operator.
  351 |     |      *
  352 |     |      * Requirements:
  353 |     |      *
  354 |     |      * - input must fit into 104 bits
  355 |     |      */
  356 |     |     function toUint104(uint256 value) internal pure returns (uint104) {
  357 |     |         if (value > type(uint104).max) {
  358 |     |             revert SafeCastOverflowedUintDowncast(104, value);
  359 |     |         }
  360 |     |         return uint104(value);
  361 |     |     }
  362 |     | 
  363 |     |     /**
  364 |     |      * @dev Returns the downcasted uint96 from uint256, reverting on
  365 |     |      * overflow (when the input is greater than largest uint96).
  366 |     |      *
  367 |     |      * Counterpart to Solidity's `uint96` operator.
  368 |     |      *
  369 |     |      * Requirements:
  370 |     |      *
  371 |     |      * - input must fit into 96 bits
  372 |     |      */
  373 |     |     function toUint96(uint256 value) internal pure returns (uint96) {
  374 |     |         if (value > type(uint96).max) {
  375 |     |             revert SafeCastOverflowedUintDowncast(96, value);
  376 |     |         }
  377 |     |         return uint96(value);
  378 |     |     }
  379 |     | 
  380 |     |     /**
  381 |     |      * @dev Returns the downcasted uint88 from uint256, reverting on
  382 |     |      * overflow (when the input is greater than largest uint88).
  383 |     |      *
  384 |     |      * Counterpart to Solidity's `uint88` operator.
  385 |     |      *
  386 |     |      * Requirements:
  387 |     |      *
  388 |     |      * - input must fit into 88 bits
  389 |     |      */
  390 |     |     function toUint88(uint256 value) internal pure returns (uint88) {
  391 |     |         if (value > type(uint88).max) {
  392 |     |             revert SafeCastOverflowedUintDowncast(88, value);
  393 |     |         }
  394 |     |         return uint88(value);
  395 |     |     }
  396 |     | 
  397 |     |     /**
  398 |     |      * @dev Returns the downcasted uint80 from uint256, reverting on
  399 |     |      * overflow (when the input is greater than largest uint80).
  400 |     |      *
  401 |     |      * Counterpart to Solidity's `uint80` operator.
  402 |     |      *
  403 |     |      * Requirements:
  404 |     |      *
  405 |     |      * - input must fit into 80 bits
  406 |     |      */
  407 |     |     function toUint80(uint256 value) internal pure returns (uint80) {
  408 |     |         if (value > type(uint80).max) {
  409 |     |             revert SafeCastOverflowedUintDowncast(80, value);
  410 |     |         }
  411 |     |         return uint80(value);
  412 |     |     }
  413 |     | 
  414 |     |     /**
  415 |     |      * @dev Returns the downcasted uint72 from uint256, reverting on
  416 |     |      * overflow (when the input is greater than largest uint72).
  417 |     |      *
  418 |     |      * Counterpart to Solidity's `uint72` operator.
  419 |     |      *
  420 |     |      * Requirements:
  421 |     |      *
  422 |     |      * - input must fit into 72 bits
  423 |     |      */
  424 |     |     function toUint72(uint256 value) internal pure returns (uint72) {
  425 |     |         if (value > type(uint72).max) {
  426 |     |             revert SafeCastOverflowedUintDowncast(72, value);
  427 |     |         }
  428 |     |         return uint72(value);
  429 |     |     }
  430 |     | 
  431 |     |     /**
  432 |     |      * @dev Returns the downcasted uint64 from uint256, reverting on
  433 |     |      * overflow (when the input is greater than largest uint64).
  434 |     |      *
  435 |     |      * Counterpart to Solidity's `uint64` operator.
  436 |     |      *
  437 |     |      * Requirements:
  438 |     |      *
  439 |     |      * - input must fit into 64 bits
  440 |     |      */
  441 |     |     function toUint64(uint256 value) internal pure returns (uint64) {
  442 |     |         if (value > type(uint64).max) {
  443 |     |             revert SafeCastOverflowedUintDowncast(64, value);
  444 |     |         }
  445 |     |         return uint64(value);
  446 |     |     }
  447 |     | 
  448 |     |     /**
  449 |     |      * @dev Returns the downcasted uint56 from uint256, reverting on
  450 |     |      * overflow (when the input is greater than largest uint56).
  451 |     |      *
  452 |     |      * Counterpart to Solidity's `uint56` operator.
  453 |     |      *
  454 |     |      * Requirements:
  455 |     |      *
  456 |     |      * - input must fit into 56 bits
  457 |     |      */
  458 |     |     function toUint56(uint256 value) internal pure returns (uint56) {
  459 |     |         if (value > type(uint56).max) {
  460 |     |             revert SafeCastOverflowedUintDowncast(56, value);
  461 |     |         }
  462 |     |         return uint56(value);
  463 |     |     }
  464 |     | 
  465 |     |     /**
  466 |     |      * @dev Returns the downcasted uint48 from uint256, reverting on
  467 |     |      * overflow (when the input is greater than largest uint48).
  468 |     |      *
  469 |     |      * Counterpart to Solidity's `uint48` operator.
  470 |     |      *
  471 |     |      * Requirements:
  472 |     |      *
  473 |     |      * - input must fit into 48 bits
  474 |     |      */
  475 |     |     function toUint48(uint256 value) internal pure returns (uint48) {
  476 |     |         if (value > type(uint48).max) {
  477 |     |             revert SafeCastOverflowedUintDowncast(48, value);
  478 |     |         }
  479 |     |         return uint48(value);
  480 |     |     }
  481 |     | 
  482 |     |     /**
  483 |     |      * @dev Returns the downcasted uint40 from uint256, reverting on
  484 |     |      * overflow (when the input is greater than largest uint40).
  485 |     |      *
  486 |     |      * Counterpart to Solidity's `uint40` operator.
  487 |     |      *
  488 |     |      * Requirements:
  489 |     |      *
  490 |     |      * - input must fit into 40 bits
  491 |     |      */
  492 |     |     function toUint40(uint256 value) internal pure returns (uint40) {
  493 |     |         if (value > type(uint40).max) {
  494 |     |             revert SafeCastOverflowedUintDowncast(40, value);
  495 |     |         }
  496 |     |         return uint40(value);
  497 |     |     }
  498 |     | 
  499 |     |     /**
  500 |     |      * @dev Returns the downcasted uint32 from uint256, reverting on
  501 |     |      * overflow (when the input is greater than largest uint32).
  502 |     |      *
  503 |     |      * Counterpart to Solidity's `uint32` operator.
  504 |     |      *
  505 |     |      * Requirements:
  506 |     |      *
  507 |     |      * - input must fit into 32 bits
  508 |     |      */
  509 |     |     function toUint32(uint256 value) internal pure returns (uint32) {
  510 |     |         if (value > type(uint32).max) {
  511 |     |             revert SafeCastOverflowedUintDowncast(32, value);
  512 |     |         }
  513 |     |         return uint32(value);
  514 |     |     }
  515 |     | 
  516 |     |     /**
  517 |     |      * @dev Returns the downcasted uint24 from uint256, reverting on
  518 |     |      * overflow (when the input is greater than largest uint24).
  519 |     |      *
  520 |     |      * Counterpart to Solidity's `uint24` operator.
  521 |     |      *
  522 |     |      * Requirements:
  523 |     |      *
  524 |     |      * - input must fit into 24 bits
  525 |     |      */
  526 |     |     function toUint24(uint256 value) internal pure returns (uint24) {
  527 |     |         if (value > type(uint24).max) {
  528 |     |             revert SafeCastOverflowedUintDowncast(24, value);
  529 |     |         }
  530 |     |         return uint24(value);
  531 |     |     }
  532 |     | 
  533 |     |     /**
  534 |     |      * @dev Returns the downcasted uint16 from uint256, reverting on
  535 |     |      * overflow (when the input is greater than largest uint16).
  536 |     |      *
  537 |     |      * Counterpart to Solidity's `uint16` operator.
  538 |     |      *
  539 |     |      * Requirements:
  540 |     |      *
  541 |     |      * - input must fit into 16 bits
  542 |     |      */
  543 |     |     function toUint16(uint256 value) internal pure returns (uint16) {
  544 |     |         if (value > type(uint16).max) {
  545 |     |             revert SafeCastOverflowedUintDowncast(16, value);
  546 |     |         }
  547 |     |         return uint16(value);
  548 |     |     }
  549 |     | 
  550 |     |     /**
  551 |     |      * @dev Returns the downcasted uint8 from uint256, reverting on
  552 |     |      * overflow (when the input is greater than largest uint8).
  553 |     |      *
  554 |     |      * Counterpart to Solidity's `uint8` operator.
  555 |     |      *
  556 |     |      * Requirements:
  557 |     |      *
  558 |     |      * - input must fit into 8 bits
  559 |     |      */
  560 |     |     function toUint8(uint256 value) internal pure returns (uint8) {
  561 |     |         if (value > type(uint8).max) {
  562 |     |             revert SafeCastOverflowedUintDowncast(8, value);
  563 |     |         }
  564 |     |         return uint8(value);
  565 |     |     }
  566 |     | 
  567 |     |     /**
  568 |     |      * @dev Converts a signed int256 into an unsigned uint256.
  569 |     |      *
  570 |     |      * Requirements:
  571 |     |      *
  572 |     |      * - input must be greater than or equal to 0.
  573 |     |      */
  574 |     |     function toUint256(int256 value) internal pure returns (uint256) {
  575 |     |         if (value < 0) {
  576 |     |             revert SafeCastOverflowedIntToUint(value);
  577 |     |         }
  578 |     |         return uint256(value);
  579 |     |     }
  580 |     | 
  581 |     |     /**
  582 |     |      * @dev Returns the downcasted int248 from int256, reverting on
  583 |     |      * overflow (when the input is less than smallest int248 or
  584 |     |      * greater than largest int248).
  585 |     |      *
  586 |     |      * Counterpart to Solidity's `int248` operator.
  587 |     |      *
  588 |     |      * Requirements:
  589 |     |      *
  590 |     |      * - input must fit into 248 bits
  591 |     |      */
  592 |     |     function toInt248(int256 value) internal pure returns (int248 downcasted) {
  593 |     |         downcasted = int248(value);
  594 |     |         if (downcasted != value) {
  595 |     |             revert SafeCastOverflowedIntDowncast(248, value);
  596 |     |         }
  597 |     |     }
  598 |     | 
  599 |     |     /**
  600 |     |      * @dev Returns the downcasted int240 from int256, reverting on
  601 |     |      * overflow (when the input is less than smallest int240 or
  602 |     |      * greater than largest int240).
  603 |     |      *
  604 |     |      * Counterpart to Solidity's `int240` operator.
  605 |     |      *
  606 |     |      * Requirements:
  607 |     |      *
  608 |     |      * - input must fit into 240 bits
  609 |     |      */
  610 |     |     function toInt240(int256 value) internal pure returns (int240 downcasted) {
  611 |     |         downcasted = int240(value);
  612 |     |         if (downcasted != value) {
  613 |     |             revert SafeCastOverflowedIntDowncast(240, value);
  614 |     |         }
  615 |     |     }
  616 |     | 
  617 |     |     /**
  618 |     |      * @dev Returns the downcasted int232 from int256, reverting on
  619 |     |      * overflow (when the input is less than smallest int232 or
  620 |     |      * greater than largest int232).
  621 |     |      *
  622 |     |      * Counterpart to Solidity's `int232` operator.
  623 |     |      *
  624 |     |      * Requirements:
  625 |     |      *
  626 |     |      * - input must fit into 232 bits
  627 |     |      */
  628 |     |     function toInt232(int256 value) internal pure returns (int232 downcasted) {
  629 |     |         downcasted = int232(value);
  630 |     |         if (downcasted != value) {
  631 |     |             revert SafeCastOverflowedIntDowncast(232, value);
  632 |     |         }
  633 |     |     }
  634 |     | 
  635 |     |     /**
  636 |     |      * @dev Returns the downcasted int224 from int256, reverting on
  637 |     |      * overflow (when the input is less than smallest int224 or
  638 |     |      * greater than largest int224).
  639 |     |      *
  640 |     |      * Counterpart to Solidity's `int224` operator.
  641 |     |      *
  642 |     |      * Requirements:
  643 |     |      *
  644 |     |      * - input must fit into 224 bits
  645 |     |      */
  646 |     |     function toInt224(int256 value) internal pure returns (int224 downcasted) {
  647 |     |         downcasted = int224(value);
  648 |     |         if (downcasted != value) {
  649 |     |             revert SafeCastOverflowedIntDowncast(224, value);
  650 |     |         }
  651 |     |     }
  652 |     | 
  653 |     |     /**
  654 |     |      * @dev Returns the downcasted int216 from int256, reverting on
  655 |     |      * overflow (when the input is less than smallest int216 or
  656 |     |      * greater than largest int216).
  657 |     |      *
  658 |     |      * Counterpart to Solidity's `int216` operator.
  659 |     |      *
  660 |     |      * Requirements:
  661 |     |      *
  662 |     |      * - input must fit into 216 bits
  663 |     |      */
  664 |     |     function toInt216(int256 value) internal pure returns (int216 downcasted) {
  665 |     |         downcasted = int216(value);
  666 |     |         if (downcasted != value) {
  667 |     |             revert SafeCastOverflowedIntDowncast(216, value);
  668 |     |         }
  669 |     |     }
  670 |     | 
  671 |     |     /**
  672 |     |      * @dev Returns the downcasted int208 from int256, reverting on
  673 |     |      * overflow (when the input is less than smallest int208 or
  674 |     |      * greater than largest int208).
  675 |     |      *
  676 |     |      * Counterpart to Solidity's `int208` operator.
  677 |     |      *
  678 |     |      * Requirements:
  679 |     |      *
  680 |     |      * - input must fit into 208 bits
  681 |     |      */
  682 |     |     function toInt208(int256 value) internal pure returns (int208 downcasted) {
  683 |     |         downcasted = int208(value);
  684 |     |         if (downcasted != value) {
  685 |     |             revert SafeCastOverflowedIntDowncast(208, value);
  686 |     |         }
  687 |     |     }
  688 |     | 
  689 |     |     /**
  690 |     |      * @dev Returns the downcasted int200 from int256, reverting on
  691 |     |      * overflow (when the input is less than smallest int200 or
  692 |     |      * greater than largest int200).
  693 |     |      *
  694 |     |      * Counterpart to Solidity's `int200` operator.
  695 |     |      *
  696 |     |      * Requirements:
  697 |     |      *
  698 |     |      * - input must fit into 200 bits
  699 |     |      */
  700 |     |     function toInt200(int256 value) internal pure returns (int200 downcasted) {
  701 |     |         downcasted = int200(value);
  702 |     |         if (downcasted != value) {
  703 |     |             revert SafeCastOverflowedIntDowncast(200, value);
  704 |     |         }
  705 |     |     }
  706 |     | 
  707 |     |     /**
  708 |     |      * @dev Returns the downcasted int192 from int256, reverting on
  709 |     |      * overflow (when the input is less than smallest int192 or
  710 |     |      * greater than largest int192).
  711 |     |      *
  712 |     |      * Counterpart to Solidity's `int192` operator.
  713 |     |      *
  714 |     |      * Requirements:
  715 |     |      *
  716 |     |      * - input must fit into 192 bits
  717 |     |      */
  718 |     |     function toInt192(int256 value) internal pure returns (int192 downcasted) {
  719 |     |         downcasted = int192(value);
  720 |     |         if (downcasted != value) {
  721 |     |             revert SafeCastOverflowedIntDowncast(192, value);
  722 |     |         }
  723 |     |     }
  724 |     | 
  725 |     |     /**
  726 |     |      * @dev Returns the downcasted int184 from int256, reverting on
  727 |     |      * overflow (when the input is less than smallest int184 or
  728 |     |      * greater than largest int184).
  729 |     |      *
  730 |     |      * Counterpart to Solidity's `int184` operator.
  731 |     |      *
  732 |     |      * Requirements:
  733 |     |      *
  734 |     |      * - input must fit into 184 bits
  735 |     |      */
  736 |     |     function toInt184(int256 value) internal pure returns (int184 downcasted) {
  737 |     |         downcasted = int184(value);
  738 |     |         if (downcasted != value) {
  739 |     |             revert SafeCastOverflowedIntDowncast(184, value);
  740 |     |         }
  741 |     |     }
  742 |     | 
  743 |     |     /**
  744 |     |      * @dev Returns the downcasted int176 from int256, reverting on
  745 |     |      * overflow (when the input is less than smallest int176 or
  746 |     |      * greater than largest int176).
  747 |     |      *
  748 |     |      * Counterpart to Solidity's `int176` operator.
  749 |     |      *
  750 |     |      * Requirements:
  751 |     |      *
  752 |     |      * - input must fit into 176 bits
  753 |     |      */
  754 |     |     function toInt176(int256 value) internal pure returns (int176 downcasted) {
  755 |     |         downcasted = int176(value);
  756 |     |         if (downcasted != value) {
  757 |     |             revert SafeCastOverflowedIntDowncast(176, value);
  758 |     |         }
  759 |     |     }
  760 |     | 
  761 |     |     /**
  762 |     |      * @dev Returns the downcasted int168 from int256, reverting on
  763 |     |      * overflow (when the input is less than smallest int168 or
  764 |     |      * greater than largest int168).
  765 |     |      *
  766 |     |      * Counterpart to Solidity's `int168` operator.
  767 |     |      *
  768 |     |      * Requirements:
  769 |     |      *
  770 |     |      * - input must fit into 168 bits
  771 |     |      */
  772 |     |     function toInt168(int256 value) internal pure returns (int168 downcasted) {
  773 |     |         downcasted = int168(value);
  774 |     |         if (downcasted != value) {
  775 |     |             revert SafeCastOverflowedIntDowncast(168, value);
  776 |     |         }
  777 |     |     }
  778 |     | 
  779 |     |     /**
  780 |     |      * @dev Returns the downcasted int160 from int256, reverting on
  781 |     |      * overflow (when the input is less than smallest int160 or
  782 |     |      * greater than largest int160).
  783 |     |      *
  784 |     |      * Counterpart to Solidity's `int160` operator.
  785 |     |      *
  786 |     |      * Requirements:
  787 |     |      *
  788 |     |      * - input must fit into 160 bits
  789 |     |      */
  790 |     |     function toInt160(int256 value) internal pure returns (int160 downcasted) {
  791 |     |         downcasted = int160(value);
  792 |     |         if (downcasted != value) {
  793 |     |             revert SafeCastOverflowedIntDowncast(160, value);
  794 |     |         }
  795 |     |     }
  796 |     | 
  797 |     |     /**
  798 |     |      * @dev Returns the downcasted int152 from int256, reverting on
  799 |     |      * overflow (when the input is less than smallest int152 or
  800 |     |      * greater than largest int152).
  801 |     |      *
  802 |     |      * Counterpart to Solidity's `int152` operator.
  803 |     |      *
  804 |     |      * Requirements:
  805 |     |      *
  806 |     |      * - input must fit into 152 bits
  807 |     |      */
  808 |     |     function toInt152(int256 value) internal pure returns (int152 downcasted) {
  809 |     |         downcasted = int152(value);
  810 |     |         if (downcasted != value) {
  811 |     |             revert SafeCastOverflowedIntDowncast(152, value);
  812 |     |         }
  813 |     |     }
  814 |     | 
  815 |     |     /**
  816 |     |      * @dev Returns the downcasted int144 from int256, reverting on
  817 |     |      * overflow (when the input is less than smallest int144 or
  818 |     |      * greater than largest int144).
  819 |     |      *
  820 |     |      * Counterpart to Solidity's `int144` operator.
  821 |     |      *
  822 |     |      * Requirements:
  823 |     |      *
  824 |     |      * - input must fit into 144 bits
  825 |     |      */
  826 |     |     function toInt144(int256 value) internal pure returns (int144 downcasted) {
  827 |     |         downcasted = int144(value);
  828 |     |         if (downcasted != value) {
  829 |     |             revert SafeCastOverflowedIntDowncast(144, value);
  830 |     |         }
  831 |     |     }
  832 |     | 
  833 |     |     /**
  834 |     |      * @dev Returns the downcasted int136 from int256, reverting on
  835 |     |      * overflow (when the input is less than smallest int136 or
  836 |     |      * greater than largest int136).
  837 |     |      *
  838 |     |      * Counterpart to Solidity's `int136` operator.
  839 |     |      *
  840 |     |      * Requirements:
  841 |     |      *
  842 |     |      * - input must fit into 136 bits
  843 |     |      */
  844 |     |     function toInt136(int256 value) internal pure returns (int136 downcasted) {
  845 |     |         downcasted = int136(value);
  846 |     |         if (downcasted != value) {
  847 |     |             revert SafeCastOverflowedIntDowncast(136, value);
  848 |     |         }
  849 |     |     }
  850 |     | 
  851 |     |     /**
  852 |     |      * @dev Returns the downcasted int128 from int256, reverting on
  853 |     |      * overflow (when the input is less than smallest int128 or
  854 |     |      * greater than largest int128).
  855 |     |      *
  856 |     |      * Counterpart to Solidity's `int128` operator.
  857 |     |      *
  858 |     |      * Requirements:
  859 |     |      *
  860 |     |      * - input must fit into 128 bits
  861 |     |      */
  862 |     |     function toInt128(int256 value) internal pure returns (int128 downcasted) {
  863 |     |         downcasted = int128(value);
  864 |     |         if (downcasted != value) {
  865 |     |             revert SafeCastOverflowedIntDowncast(128, value);
  866 |     |         }
  867 |     |     }
  868 |     | 
  869 |     |     /**
  870 |     |      * @dev Returns the downcasted int120 from int256, reverting on
  871 |     |      * overflow (when the input is less than smallest int120 or
  872 |     |      * greater than largest int120).
  873 |     |      *
  874 |     |      * Counterpart to Solidity's `int120` operator.
  875 |     |      *
  876 |     |      * Requirements:
  877 |     |      *
  878 |     |      * - input must fit into 120 bits
  879 |     |      */
  880 |     |     function toInt120(int256 value) internal pure returns (int120 downcasted) {
  881 |     |         downcasted = int120(value);
  882 |     |         if (downcasted != value) {
  883 |     |             revert SafeCastOverflowedIntDowncast(120, value);
  884 |     |         }
  885 |     |     }
  886 |     | 
  887 |     |     /**
  888 |     |      * @dev Returns the downcasted int112 from int256, reverting on
  889 |     |      * overflow (when the input is less than smallest int112 or
  890 |     |      * greater than largest int112).
  891 |     |      *
  892 |     |      * Counterpart to Solidity's `int112` operator.
  893 |     |      *
  894 |     |      * Requirements:
  895 |     |      *
  896 |     |      * - input must fit into 112 bits
  897 |     |      */
  898 |     |     function toInt112(int256 value) internal pure returns (int112 downcasted) {
  899 |     |         downcasted = int112(value);
  900 |     |         if (downcasted != value) {
  901 |     |             revert SafeCastOverflowedIntDowncast(112, value);
  902 |     |         }
  903 |     |     }
  904 |     | 
  905 |     |     /**
  906 |     |      * @dev Returns the downcasted int104 from int256, reverting on
  907 |     |      * overflow (when the input is less than smallest int104 or
  908 |     |      * greater than largest int104).
  909 |     |      *
  910 |     |      * Counterpart to Solidity's `int104` operator.
  911 |     |      *
  912 |     |      * Requirements:
  913 |     |      *
  914 |     |      * - input must fit into 104 bits
  915 |     |      */
  916 |     |     function toInt104(int256 value) internal pure returns (int104 downcasted) {
  917 |     |         downcasted = int104(value);
  918 |     |         if (downcasted != value) {
  919 |     |             revert SafeCastOverflowedIntDowncast(104, value);
  920 |     |         }
  921 |     |     }
  922 |     | 
  923 |     |     /**
  924 |     |      * @dev Returns the downcasted int96 from int256, reverting on
  925 |     |      * overflow (when the input is less than smallest int96 or
  926 |     |      * greater than largest int96).
  927 |     |      *
  928 |     |      * Counterpart to Solidity's `int96` operator.
  929 |     |      *
  930 |     |      * Requirements:
  931 |     |      *
  932 |     |      * - input must fit into 96 bits
  933 |     |      */
  934 |     |     function toInt96(int256 value) internal pure returns (int96 downcasted) {
  935 |     |         downcasted = int96(value);
  936 |     |         if (downcasted != value) {
  937 |     |             revert SafeCastOverflowedIntDowncast(96, value);
  938 |     |         }
  939 |     |     }
  940 |     | 
  941 |     |     /**
  942 |     |      * @dev Returns the downcasted int88 from int256, reverting on
  943 |     |      * overflow (when the input is less than smallest int88 or
  944 |     |      * greater than largest int88).
  945 |     |      *
  946 |     |      * Counterpart to Solidity's `int88` operator.
  947 |     |      *
  948 |     |      * Requirements:
  949 |     |      *
  950 |     |      * - input must fit into 88 bits
  951 |     |      */
  952 |     |     function toInt88(int256 value) internal pure returns (int88 downcasted) {
  953 |     |         downcasted = int88(value);
  954 |     |         if (downcasted != value) {
  955 |     |             revert SafeCastOverflowedIntDowncast(88, value);
  956 |     |         }
  957 |     |     }
  958 |     | 
  959 |     |     /**
  960 |     |      * @dev Returns the downcasted int80 from int256, reverting on
  961 |     |      * overflow (when the input is less than smallest int80 or
  962 |     |      * greater than largest int80).
  963 |     |      *
  964 |     |      * Counterpart to Solidity's `int80` operator.
  965 |     |      *
  966 |     |      * Requirements:
  967 |     |      *
  968 |     |      * - input must fit into 80 bits
  969 |     |      */
  970 |     |     function toInt80(int256 value) internal pure returns (int80 downcasted) {
  971 |     |         downcasted = int80(value);
  972 |     |         if (downcasted != value) {
  973 |     |             revert SafeCastOverflowedIntDowncast(80, value);
  974 |     |         }
  975 |     |     }
  976 |     | 
  977 |     |     /**
  978 |     |      * @dev Returns the downcasted int72 from int256, reverting on
  979 |     |      * overflow (when the input is less than smallest int72 or
  980 |     |      * greater than largest int72).
  981 |     |      *
  982 |     |      * Counterpart to Solidity's `int72` operator.
  983 |     |      *
  984 |     |      * Requirements:
  985 |     |      *
  986 |     |      * - input must fit into 72 bits
  987 |     |      */
  988 |     |     function toInt72(int256 value) internal pure returns (int72 downcasted) {
  989 |     |         downcasted = int72(value);
  990 |     |         if (downcasted != value) {
  991 |     |             revert SafeCastOverflowedIntDowncast(72, value);
  992 |     |         }
  993 |     |     }
  994 |     | 
  995 |     |     /**
  996 |     |      * @dev Returns the downcasted int64 from int256, reverting on
  997 |     |      * overflow (when the input is less than smallest int64 or
  998 |     |      * greater than largest int64).
  999 |     |      *
 1000 |     |      * Counterpart to Solidity's `int64` operator.
 1001 |     |      *
 1002 |     |      * Requirements:
 1003 |     |      *
 1004 |     |      * - input must fit into 64 bits
 1005 |     |      */
 1006 |     |     function toInt64(int256 value) internal pure returns (int64 downcasted) {
 1007 |     |         downcasted = int64(value);
 1008 |     |         if (downcasted != value) {
 1009 |     |             revert SafeCastOverflowedIntDowncast(64, value);
 1010 |     |         }
 1011 |     |     }
 1012 |     | 
 1013 |     |     /**
 1014 |     |      * @dev Returns the downcasted int56 from int256, reverting on
 1015 |     |      * overflow (when the input is less than smallest int56 or
 1016 |     |      * greater than largest int56).
 1017 |     |      *
 1018 |     |      * Counterpart to Solidity's `int56` operator.
 1019 |     |      *
 1020 |     |      * Requirements:
 1021 |     |      *
 1022 |     |      * - input must fit into 56 bits
 1023 |     |      */
 1024 |     |     function toInt56(int256 value) internal pure returns (int56 downcasted) {
 1025 |     |         downcasted = int56(value);
 1026 |     |         if (downcasted != value) {
 1027 |     |             revert SafeCastOverflowedIntDowncast(56, value);
 1028 |     |         }
 1029 |     |     }
 1030 |     | 
 1031 |     |     /**
 1032 |     |      * @dev Returns the downcasted int48 from int256, reverting on
 1033 |     |      * overflow (when the input is less than smallest int48 or
 1034 |     |      * greater than largest int48).
 1035 |     |      *
 1036 |     |      * Counterpart to Solidity's `int48` operator.
 1037 |     |      *
 1038 |     |      * Requirements:
 1039 |     |      *
 1040 |     |      * - input must fit into 48 bits
 1041 |     |      */
 1042 |     |     function toInt48(int256 value) internal pure returns (int48 downcasted) {
 1043 |     |         downcasted = int48(value);
 1044 |     |         if (downcasted != value) {
 1045 |     |             revert SafeCastOverflowedIntDowncast(48, value);
 1046 |     |         }
 1047 |     |     }
 1048 |     | 
 1049 |     |     /**
 1050 |     |      * @dev Returns the downcasted int40 from int256, reverting on
 1051 |     |      * overflow (when the input is less than smallest int40 or
 1052 |     |      * greater than largest int40).
 1053 |     |      *
 1054 |     |      * Counterpart to Solidity's `int40` operator.
 1055 |     |      *
 1056 |     |      * Requirements:
 1057 |     |      *
 1058 |     |      * - input must fit into 40 bits
 1059 |     |      */
 1060 |     |     function toInt40(int256 value) internal pure returns (int40 downcasted) {
 1061 |     |         downcasted = int40(value);
 1062 |     |         if (downcasted != value) {
 1063 |     |             revert SafeCastOverflowedIntDowncast(40, value);
 1064 |     |         }
 1065 |     |     }
 1066 |     | 
 1067 |     |     /**
 1068 |     |      * @dev Returns the downcasted int32 from int256, reverting on
 1069 |     |      * overflow (when the input is less than smallest int32 or
 1070 |     |      * greater than largest int32).
 1071 |     |      *
 1072 |     |      * Counterpart to Solidity's `int32` operator.
 1073 |     |      *
 1074 |     |      * Requirements:
 1075 |     |      *
 1076 |     |      * - input must fit into 32 bits
 1077 |     |      */
 1078 |     |     function toInt32(int256 value) internal pure returns (int32 downcasted) {
 1079 |     |         downcasted = int32(value);
 1080 |     |         if (downcasted != value) {
 1081 |     |             revert SafeCastOverflowedIntDowncast(32, value);
 1082 |     |         }
 1083 |     |     }
 1084 |     | 
 1085 |     |     /**
 1086 |     |      * @dev Returns the downcasted int24 from int256, reverting on
 1087 |     |      * overflow (when the input is less than smallest int24 or
 1088 |     |      * greater than largest int24).
 1089 |     |      *
 1090 |     |      * Counterpart to Solidity's `int24` operator.
 1091 |     |      *
 1092 |     |      * Requirements:
 1093 |     |      *
 1094 |     |      * - input must fit into 24 bits
 1095 |     |      */
 1096 |     |     function toInt24(int256 value) internal pure returns (int24 downcasted) {
 1097 |     |         downcasted = int24(value);
 1098 |     |         if (downcasted != value) {
 1099 |     |             revert SafeCastOverflowedIntDowncast(24, value);
 1100 |     |         }
 1101 |     |     }
 1102 |     | 
 1103 |     |     /**
 1104 |     |      * @dev Returns the downcasted int16 from int256, reverting on
 1105 |     |      * overflow (when the input is less than smallest int16 or
 1106 |     |      * greater than largest int16).
 1107 |     |      *
 1108 |     |      * Counterpart to Solidity's `int16` operator.
 1109 |     |      *
 1110 |     |      * Requirements:
 1111 |     |      *
 1112 |     |      * - input must fit into 16 bits
 1113 |     |      */
 1114 |     |     function toInt16(int256 value) internal pure returns (int16 downcasted) {
 1115 |     |         downcasted = int16(value);
 1116 |     |         if (downcasted != value) {
 1117 |     |             revert SafeCastOverflowedIntDowncast(16, value);
 1118 |     |         }
 1119 |     |     }
 1120 |     | 
 1121 |     |     /**
 1122 |     |      * @dev Returns the downcasted int8 from int256, reverting on
 1123 |     |      * overflow (when the input is less than smallest int8 or
 1124 |     |      * greater than largest int8).
 1125 |     |      *
 1126 |     |      * Counterpart to Solidity's `int8` operator.
 1127 |     |      *
 1128 |     |      * Requirements:
 1129 |     |      *
 1130 |     |      * - input must fit into 8 bits
 1131 |     |      */
 1132 |     |     function toInt8(int256 value) internal pure returns (int8 downcasted) {
 1133 |     |         downcasted = int8(value);
 1134 |     |         if (downcasted != value) {
 1135 |     |             revert SafeCastOverflowedIntDowncast(8, value);
 1136 |     |         }
 1137 |     |     }
 1138 |     | 
 1139 |     |     /**
 1140 |     |      * @dev Converts an unsigned uint256 into a signed int256.
 1141 |     |      *
 1142 |     |      * Requirements:
 1143 |     |      *
 1144 |     |      * - input must be less than or equal to maxInt256.
 1145 |     |      */
 1146 |     |     function toInt256(uint256 value) internal pure returns (int256) {
 1147 |     |         // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive
 1148 |     |         if (value > uint256(type(int256).max)) {
 1149 |     |             revert SafeCastOverflowedUintToInt(value);
 1150 |     |         }
 1151 |     |         return int256(value);
 1152 |     |     }
 1153 |     | 
 1154 |     |     /**
 1155 |     |      * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.
 1156 |     |      */
 1157 |     |     function toUint(bool b) internal pure returns (uint256 u) {
 1158 |     |         assembly ("memory-safe") {
 1159 |     |             u := iszero(iszero(b))
 1160 |     |         }
 1161 |     |     }
 1162 |     | }
 1163 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {SafeCast} from "./SafeCast.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Standard signed math utilities missing in the Solidity language.
 10 |     |  */
 11 |     | library SignedMath {
 12 |     |     /**
 13 |     |      * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.
 14 |     |      *
 15 |     |      * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.
 16 |     |      * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute
 17 |     |      * one branch when needed, making this function more expensive.
 18 |     |      */
 19 |     |     function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {
 20 |     |         unchecked {
 21 |     |             // branchless ternary works because:
 22 |     |             // b ^ (a ^ b) == a
 23 |     |             // b ^ 0 == b
 24 |     |             return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));
 25 |     |         }
 26 |     |     }
 27 |     | 
 28 |     |     /**
 29 |     |      * @dev Returns the largest of two signed numbers.
 30 |     |      */
 31 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 32 |     |         return ternary(a > b, a, b);
 33 |     |     }
 34 |     | 
 35 |     |     /**
 36 |     |      * @dev Returns the smallest of two signed numbers.
 37 |     |      */
 38 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 39 |     |         return ternary(a < b, a, b);
 40 |     |     }
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Returns the average of two signed numbers without overflow.
 44 |     |      * The result is rounded towards zero.
 45 |     |      */
 46 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 47 |     |         // Formula from the book "Hacker's Delight"
 48 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 49 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 50 |     |     }
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Returns the absolute unsigned value of a signed value.
 54 |     |      */
 55 |     |     function abs(int256 n) internal pure returns (uint256) {
 56 |     |         unchecked {
 57 |     |             // Formula from the "Bit Twiddling Hacks" by Sean Eron Anderson.
 58 |     |             // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,
 59 |     |             // taking advantage of the most significant (or "sign" bit) in two's complement representation.
 60 |     |             // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,
 61 |     |             // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).
 62 |     |             int256 mask = n >> 255;
 63 |     | 
 64 |     |             // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.
 65 |     |             return uint256((n + mask) ^ mask);
 66 |     |         }
 67 |     |     }
 68 |     | }
 69 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/ERC20Extended.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity >=0.8.20 <0.9.0;
   4 |     | 
   5 |     | import { IERC20 } from "./interfaces/IERC20.sol";
   6 |     | import { IERC20Extended } from "./interfaces/IERC20Extended.sol";
   7 |     | 
   8 |     | import { Bytes32String } from "./libs/Bytes32String.sol";
   9 |     | 
  10 |     | import { ERC3009 } from "./ERC3009.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @title  An ERC20 token extended with EIP-2612 permits for signed approvals (via EIP-712 and with EIP-1271
  14 |     |  *         and EIP-5267 compatibility), and extended with EIP-3009 transfer with authorization (via EIP-712).
  15 |     |  * @author M^0 Labs
  16 |     |  */
  17 |     | abstract contract ERC20Extended is IERC20Extended, ERC3009 {
  18 |     |     /* ============ Variables ============ */
  19 |     | 
  20 |     |     /**
  21 |     |      * @inheritdoc IERC20Extended
  22 |     |      * @dev Keeping this constant, despite `permit` parameter name differences, to ensure max EIP-2612 compatibility.
  23 |     |      *      keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")
  24 |     |      */
  25 |     |     bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
  26 |     | 
  27 |     |     /// @inheritdoc IERC20
  28 |     |     uint8 public immutable decimals;
  29 |     | 
  30 |     |     /// @dev The symbol of the token (stored as a bytes32 instead of a string in order to be immutable).
  31 |     |     bytes32 internal immutable _symbol;
  32 |     | 
  33 |     |     /// @inheritdoc IERC20
  34 |     |     mapping(address account => mapping(address spender => uint256 allowance)) public allowance;
  35 |     | 
  36 |     |     /* ============ Constructor ============ */
  37 |     | 
  38 |     |     /**
  39 |     |      * @notice Constructs the ERC20Extended contract.
  40 |     |      * @param  name_     The name of the token.
  41 |     |      * @param  symbol_   The symbol of the token.
  42 |     |      * @param  decimals_ The number of decimals the token uses.
  43 |     |      */
  44 | *   |     constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC3009(name_) {
  45 | *   |         _symbol = Bytes32String.toBytes32(symbol_);
  46 | *   |         decimals = decimals_;
  47 |     |     }
  48 |     | 
  49 |     |     /* ============ Interactive Functions ============ */
  50 |     | 
  51 |     |     /// @inheritdoc IERC20
  52 | *   |     function approve(address spender_, uint256 amount_) external returns (bool success_) {
  53 | *   |         _approve(msg.sender, spender_, amount_);
  54 | *   |         return true;
  55 |     |     }
  56 |     | 
  57 |     |     /// @inheritdoc IERC20Extended
  58 |     |     function permit(
  59 |     |         address owner_,
  60 |     |         address spender_,
  61 |     |         uint256 value_,
  62 |     |         uint256 deadline_,
  63 |     |         uint8 v_,
  64 |     |         bytes32 r_,
  65 |     |         bytes32 s_
  66 |     |     ) external {
  67 |     |         _revertIfInvalidSignature(owner_, _permitAndGetDigest(owner_, spender_, value_, deadline_), v_, r_, s_);
  68 |     |     }
  69 |     | 
  70 |     |     /// @inheritdoc IERC20Extended
  71 |     |     function permit(
  72 |     |         address owner_,
  73 |     |         address spender_,
  74 |     |         uint256 value_,
  75 |     |         uint256 deadline_,
  76 |     |         bytes memory signature_
  77 |     |     ) external {
  78 |     |         _revertIfInvalidSignature(owner_, _permitAndGetDigest(owner_, spender_, value_, deadline_), signature_);
  79 |     |     }
  80 |     | 
  81 |     |     /// @inheritdoc IERC20
  82 | *   |     function transfer(address recipient_, uint256 amount_) external returns (bool success_) {
  83 | *   |         _transfer(msg.sender, recipient_, amount_);
  84 | *   |         return true;
  85 |     |     }
  86 |     | 
  87 |     |     /// @inheritdoc IERC20
  88 | *   |     function transferFrom(address sender_, address recipient_, uint256 amount_) external returns (bool success_) {
  89 | *   |         uint256 spenderAllowance_ = allowance[sender_][msg.sender]; // Cache `spenderAllowance_` to stack.
  90 |     | 
  91 | *   |         if (spenderAllowance_ != type(uint256).max) {
  92 | *   |             if (spenderAllowance_ < amount_) revert InsufficientAllowance(msg.sender, spenderAllowance_, amount_);
  93 |     | 
  94 |     |             unchecked {
  95 | *   |                 _setAllowance(sender_, msg.sender, spenderAllowance_ - amount_);
  96 |     |             }
  97 |     |         }
  98 |     | 
  99 | *   |         _transfer(sender_, recipient_, amount_);
 100 |     | 
 101 | *   |         return true;
 102 |     |     }
 103 |     | 
 104 |     |     /* ============ View/Pure Functions ============ */
 105 |     | 
 106 |     |     /// @inheritdoc IERC20
 107 |     |     function name() external view virtual returns (string memory) {
 108 |     |         return Bytes32String.toString(_name);
 109 |     |     }
 110 |     | 
 111 |     |     /// @inheritdoc IERC20
 112 |     |     function symbol() external view virtual returns (string memory) {
 113 |     |         return Bytes32String.toString(_symbol);
 114 |     |     }
 115 |     | 
 116 |     |     /* ============ Internal Interactive Functions ============ */
 117 |     | 
 118 |     |     /**
 119 |     |      * @dev Approve `spender_` to spend `amount_` of tokens from `account_`.
 120 |     |      * @param  account_ The address approving the allowance.
 121 |     |      * @param  spender_ The address approved to spend the tokens.
 122 |     |      * @param  amount_  The amount of tokens being approved for spending.
 123 |     |      */
 124 | *   |     function _approve(address account_, address spender_, uint256 amount_) internal virtual {
 125 | *   |         _setAllowance(account_, spender_, amount_);
 126 | *   |         emit Approval(account_, spender_, amount_);
 127 |     |     }
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Set the `amount_` of tokens `spender_` is allowed to spend from `account_`.
 131 |     |      * @param  account_ The address for which the allowance is set.
 132 |     |      * @param  spender_ The address allowed to spend the tokens.
 133 |     |      * @param  amount_  The amount of tokens being allowed for spending.
 134 |     |      */
 135 | *   |     function _setAllowance(address account_, address spender_, uint256 amount_) internal virtual {
 136 | *   |         allowance[account_][spender_] = amount_;
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev    Performs the approval based on the permit info, validates the deadline, and returns the digest.
 141 |     |      * @param  owner_    The address of the account approving the allowance.
 142 |     |      * @param  spender_  The address of the account being allowed to spend the tokens.
 143 |     |      * @param  amount_   The amount of tokens being approved for spending.
 144 |     |      * @param  deadline_ The deadline by which the signature must be used.
 145 |     |      * @return digest_   The EIP-712 digest of the permit.
 146 |     |      */
 147 |     |     function _permitAndGetDigest(
 148 |     |         address owner_,
 149 |     |         address spender_,
 150 |     |         uint256 amount_,
 151 |     |         uint256 deadline_
 152 |     |     ) internal virtual returns (bytes32 digest_) {
 153 |     |         _revertIfExpired(deadline_);
 154 |     | 
 155 |     |         _approve(owner_, spender_, amount_);
 156 |     | 
 157 |     |         unchecked {
 158 |     |             // Nonce realistically cannot overflow.
 159 |     |             return
 160 |     |                 _getDigest(
 161 |     |                     keccak256(abi.encode(PERMIT_TYPEHASH, owner_, spender_, amount_, nonces[owner_]++, deadline_))
 162 |     |                 );
 163 |     |         }
 164 |     |     }
 165 |     | }
 166 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/ERC20ExtendedUpgradeable.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity >=0.8.20 <0.9.0;
   4 |     | 
   5 |     | import { ERC3009Upgradeable } from "./ERC3009Upgradeable.sol";
   6 |     | 
   7 |     | import { IERC20 } from "./interfaces/IERC20.sol";
   8 |     | import { IERC20Extended } from "./interfaces/IERC20Extended.sol";
   9 |     | 
  10 |     | abstract contract ERC20ExtendedUpgradeableStorageLayout {
  11 |     |     /// @custom:storage-location erc7201:M0.storage.ERC20Extended
  12 |     |     struct ERC20ExtendedStorageStruct {
  13 |     |         mapping(address account => mapping(address spender => uint256 allowance)) allowance;
  14 |     |         uint8 decimals;
  15 |     |         string symbol;
  16 |     |     }
  17 |     | 
  18 |     |     // keccak256(abi.encode(uint256(keccak256("M0.storage.ERC20Extended")) - 1)) & ~bytes32(uint256(0xff))
  19 |     |     bytes32 private constant _ERC20_EXTENDED_STORAGE_LOCATION =
  20 |     |         0xcbbe23efb65c1eaba394256c463812c20abdb5376e247eba1d0e1e92054da100;
  21 |     | 
  22 | *   |     function _getERC20ExtendedStorageLocation() internal pure returns (ERC20ExtendedStorageStruct storage $) {
  23 |     |         assembly {
  24 | *   |             $.slot := _ERC20_EXTENDED_STORAGE_LOCATION
  25 |     |         }
  26 |     |     }
  27 |     | }
  28 |     | 
  29 |     | /**
  30 |     |  * @title  An upgradeable ERC20 token extended with EIP-2612 permits for signed approvals
  31 |     |  *         (via EIP-712 and with EIP-1271 and EIP-5267 compatibility).
  32 |     |  * @author M0 Labs
  33 |     |  */
  34 |     | abstract contract ERC20ExtendedUpgradeable is
  35 |     |     ERC20ExtendedUpgradeableStorageLayout,
  36 |     |     ERC3009Upgradeable,
  37 |     |     IERC20Extended
  38 |     | {
  39 |     |     /* ============ Variables ============ */
  40 |     | 
  41 |     |     /**
  42 |     |      * @inheritdoc IERC20Extended
  43 |     |      * @dev Keeping this constant, despite `permit` parameter name differences, to ensure max EIP-2612 compatibility.
  44 |     |      *      keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")
  45 |     |      */
  46 |     |     bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
  47 |     | 
  48 |     |     /* ============ Initializer ============ */
  49 |     | 
  50 | *   |     function __ERC20ExtendedUpgradeable_init(
  51 |     |         string memory name_,
  52 |     |         string memory symbol_,
  53 |     |         uint8 decimals_
  54 | *   |     ) internal onlyInitializing {
  55 | *   |         __ERC3009Upgradeable_init(name_);
  56 |     | 
  57 | *   |         ERC20ExtendedStorageStruct storage $ = _getERC20ExtendedStorageLocation();
  58 |     | 
  59 | *   |         $.decimals = decimals_;
  60 | *   |         $.symbol = symbol_;
  61 |     |     }
  62 |     | 
  63 |     |     /* ============ Interactive Functions ============ */
  64 |     | 
  65 |     |     /// @inheritdoc IERC20
  66 | *   |     function approve(address spender_, uint256 amount_) external returns (bool) {
  67 | *   |         _approve(msg.sender, spender_, amount_);
  68 | *   |         return true;
  69 |     |     }
  70 |     | 
  71 |     |     /// @inheritdoc IERC20Extended
  72 |     |     function permit(
  73 |     |         address owner_,
  74 |     |         address spender_,
  75 |     |         uint256 value_,
  76 |     |         uint256 deadline_,
  77 |     |         uint8 v_,
  78 |     |         bytes32 r_,
  79 |     |         bytes32 s_
  80 |     |     ) external {
  81 |     |         _revertIfInvalidSignature(owner_, _permitAndGetDigest(owner_, spender_, value_, deadline_), v_, r_, s_);
  82 |     |     }
  83 |     | 
  84 |     |     /// @inheritdoc IERC20Extended
  85 |     |     function permit(
  86 |     |         address owner_,
  87 |     |         address spender_,
  88 |     |         uint256 value_,
  89 |     |         uint256 deadline_,
  90 |     |         bytes memory signature_
  91 |     |     ) external {
  92 |     |         _revertIfInvalidSignature(owner_, _permitAndGetDigest(owner_, spender_, value_, deadline_), signature_);
  93 |     |     }
  94 |     | 
  95 |     |     /// @inheritdoc IERC20
  96 | *   |     function transfer(address recipient_, uint256 amount_) external returns (bool) {
  97 | *   |         _transfer(msg.sender, recipient_, amount_);
  98 | *   |         return true;
  99 |     |     }
 100 |     | 
 101 |     |     /// @inheritdoc IERC20
 102 | *   |     function transferFrom(address sender_, address recipient_, uint256 amount_) external returns (bool) {
 103 | *   |         ERC20ExtendedStorageStruct storage $ = _getERC20ExtendedStorageLocation();
 104 | *   |         uint256 spenderAllowance_ = $.allowance[sender_][msg.sender]; // Cache `spenderAllowance_` to stack.
 105 |     | 
 106 | *   |         if (spenderAllowance_ != type(uint256).max) {
 107 | *   |             if (spenderAllowance_ < amount_) revert InsufficientAllowance(msg.sender, spenderAllowance_, amount_);
 108 |     | 
 109 |     |             unchecked {
 110 | *   |                 _setAllowance($, sender_, msg.sender, spenderAllowance_ - amount_);
 111 |     |             }
 112 |     |         }
 113 |     | 
 114 | *   |         _transfer(sender_, recipient_, amount_);
 115 |     | 
 116 | *   |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /* ============ View/Pure Functions ============ */
 120 |     | 
 121 |     |     /// @inheritdoc IERC20
 122 |     |     function allowance(address account, address spender) public view returns (uint256) {
 123 |     |         return _getERC20ExtendedStorageLocation().allowance[account][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /// @inheritdoc IERC20
 127 |     |     function decimals() external view virtual returns (uint8) {
 128 |     |         return _getERC20ExtendedStorageLocation().decimals;
 129 |     |     }
 130 |     | 
 131 |     |     /// @inheritdoc IERC20
 132 |     |     function name() external view virtual returns (string memory) {
 133 |     |         return _getERC712ExtendedStorageLocation().name;
 134 |     |     }
 135 |     | 
 136 |     |     /// @inheritdoc IERC20
 137 |     |     function symbol() external view virtual returns (string memory) {
 138 |     |         return _getERC20ExtendedStorageLocation().symbol;
 139 |     |     }
 140 |     | 
 141 |     |     /* ============ Internal Interactive Functions ============ */
 142 |     | 
 143 |     |     /**
 144 |     |      * @dev Approve `spender_` to spend `amount_` of tokens from `account_`.
 145 |     |      * @param  account_ The address approving the allowance.
 146 |     |      * @param  spender_ The address approved to spend the tokens.
 147 |     |      * @param  amount_  The amount of tokens being approved for spending.
 148 |     |      */
 149 | *   |     function _approve(address account_, address spender_, uint256 amount_) internal virtual {
 150 | *   |         _setAllowance(_getERC20ExtendedStorageLocation(), account_, spender_, amount_);
 151 | *   |         emit Approval(account_, spender_, amount_);
 152 |     |     }
 153 |     | 
 154 |     |     /**
 155 |     |      * @dev Set the `amount_` of tokens `spender_` is allowed to spend from `account_`.
 156 |     |      * @param $         ERC20Extended storage location.
 157 |     |      * @param  account_ The address for which the allowance is set.
 158 |     |      * @param  spender_ The address allowed to spend the tokens.
 159 |     |      * @param  amount_  The amount of tokens being allowed for spending.
 160 |     |      */
 161 | *   |     function _setAllowance(
 162 |     |         ERC20ExtendedStorageStruct storage $,
 163 |     |         address account_,
 164 |     |         address spender_,
 165 |     |         uint256 amount_
 166 |     |     ) internal virtual {
 167 | *   |         $.allowance[account_][spender_] = amount_;
 168 |     |     }
 169 |     | 
 170 |     |     /**
 171 |     |      * @dev    Performs the approval based on the permit info, validates the deadline, and returns the digest.
 172 |     |      * @param  owner_    The address of the account approving the allowance.
 173 |     |      * @param  spender_  The address of the account being allowed to spend the tokens.
 174 |     |      * @param  amount_   The amount of tokens being approved for spending.
 175 |     |      * @param  deadline_ The deadline by which the signature must be used.
 176 |     |      * @return digest_   The EIP-712 digest of the permit.
 177 |     |      */
 178 |     |     function _permitAndGetDigest(
 179 |     |         address owner_,
 180 |     |         address spender_,
 181 |     |         uint256 amount_,
 182 |     |         uint256 deadline_
 183 |     |     ) internal virtual returns (bytes32) {
 184 |     |         _revertIfExpired(deadline_);
 185 |     | 
 186 |     |         _approve(owner_, spender_, amount_);
 187 |     | 
 188 |     |         unchecked {
 189 |     |             // Nonce realistically cannot overflow.
 190 |     |             return
 191 |     |                 _getDigest(
 192 |     |                     keccak256(
 193 |     |                         abi.encode(
 194 |     |                             PERMIT_TYPEHASH,
 195 |     |                             owner_,
 196 |     |                             spender_,
 197 |     |                             amount_,
 198 |     |                             _getStatefulERC712ExtendedStorageLocation().nonces[owner_]++,
 199 |     |                             deadline_
 200 |     |                         )
 201 |     |                     )
 202 |     |                 );
 203 |     |         }
 204 |     |     }
 205 |     | }
 206 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/ERC3009.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity >=0.8.20 <0.9.0;
   4 |     | 
   5 |     | import { IERC3009 } from "./interfaces/IERC3009.sol";
   6 |     | 
   7 |     | import { StatefulERC712 } from "./StatefulERC712.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title  ERC3009 implementation allowing the transfer of fungible assets via a signed authorization.
  11 |     |  * @author M^0 Labs
  12 |     |  * @dev    Inherits from ERC712 and StatefulERC712.
  13 |     |  */
  14 |     | abstract contract ERC3009 is IERC3009, StatefulERC712 {
  15 |     |     /* ============ Variables ============ */
  16 |     | 
  17 |     |     // solhint-disable-next-line max-line-length
  18 |     |     /// @dev        keccak256("TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)")
  19 |     |     /// @inheritdoc IERC3009
  20 |     |     bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =
  21 |     |         0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;
  22 |     | 
  23 |     |     // solhint-disable-next-line max-line-length
  24 |     |     /// @dev        keccak256("ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)")
  25 |     |     /// @inheritdoc IERC3009
  26 |     |     bytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH =
  27 |     |         0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;
  28 |     | 
  29 |     |     /**
  30 |     |      * @inheritdoc IERC3009
  31 |     |      * @dev        keccak256("CancelAuthorization(address authorizer,bytes32 nonce)")
  32 |     |      */
  33 |     |     bytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH =
  34 |     |         0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;
  35 |     | 
  36 |     |     /// @inheritdoc IERC3009
  37 |     |     mapping(address authorizer => mapping(bytes32 nonce => bool isNonceUsed)) public authorizationState;
  38 |     | 
  39 |     |     /* ============ Constructor ============ */
  40 |     | 
  41 |     |     /**
  42 |     |      * @notice Construct the ERC3009 contract.
  43 |     |      * @param  name_ The name of the contract.
  44 |     |      */
  45 | *   |     constructor(string memory name_) StatefulERC712(name_) {}
  46 |     | 
  47 |     |     /* ============ Interactive Functions ============ */
  48 |     | 
  49 |     |     /// @inheritdoc IERC3009
  50 |     |     function transferWithAuthorization(
  51 |     |         address from_,
  52 |     |         address to_,
  53 |     |         uint256 value_,
  54 |     |         uint256 validAfter_,
  55 |     |         uint256 validBefore_,
  56 |     |         bytes32 nonce_,
  57 |     |         bytes memory signature_
  58 |     |     ) external {
  59 |     |         _revertIfInvalidSignature(
  60 |     |             from_,
  61 |     |             _getTransferWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
  62 |     |             signature_
  63 |     |         );
  64 |     | 
  65 |     |         _transferWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
  66 |     |     }
  67 |     | 
  68 |     |     /// @inheritdoc IERC3009
  69 |     |     function transferWithAuthorization(
  70 |     |         address from_,
  71 |     |         address to_,
  72 |     |         uint256 value_,
  73 |     |         uint256 validAfter_,
  74 |     |         uint256 validBefore_,
  75 |     |         bytes32 nonce_,
  76 |     |         bytes32 r_,
  77 |     |         bytes32 vs_
  78 |     |     ) external {
  79 |     |         _revertIfInvalidSignature(
  80 |     |             from_,
  81 |     |             _getTransferWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
  82 |     |             r_,
  83 |     |             vs_
  84 |     |         );
  85 |     | 
  86 |     |         _transferWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
  87 |     |     }
  88 |     | 
  89 |     |     /// @inheritdoc IERC3009
  90 |     |     function transferWithAuthorization(
  91 |     |         address from_,
  92 |     |         address to_,
  93 |     |         uint256 value_,
  94 |     |         uint256 validAfter_,
  95 |     |         uint256 validBefore_,
  96 |     |         bytes32 nonce_,
  97 |     |         uint8 v_,
  98 |     |         bytes32 r_,
  99 |     |         bytes32 s_
 100 |     |     ) external {
 101 |     |         _revertIfInvalidSignature(
 102 |     |             from_,
 103 |     |             _getTransferWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 104 |     |             v_,
 105 |     |             r_,
 106 |     |             s_
 107 |     |         );
 108 |     | 
 109 |     |         _transferWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 110 |     |     }
 111 |     | 
 112 |     |     /// @inheritdoc IERC3009
 113 |     |     function receiveWithAuthorization(
 114 |     |         address from_,
 115 |     |         address to_,
 116 |     |         uint256 value_,
 117 |     |         uint256 validAfter_,
 118 |     |         uint256 validBefore_,
 119 |     |         bytes32 nonce_,
 120 |     |         bytes memory signature_
 121 |     |     ) external {
 122 |     |         _revertIfInvalidSignature(
 123 |     |             from_,
 124 |     |             _getReceiveWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 125 |     |             signature_
 126 |     |         );
 127 |     | 
 128 |     |         _receiveWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 129 |     |     }
 130 |     | 
 131 |     |     /// @inheritdoc IERC3009
 132 |     |     function receiveWithAuthorization(
 133 |     |         address from_,
 134 |     |         address to_,
 135 |     |         uint256 value_,
 136 |     |         uint256 validAfter_,
 137 |     |         uint256 validBefore_,
 138 |     |         bytes32 nonce_,
 139 |     |         bytes32 r_,
 140 |     |         bytes32 vs_
 141 |     |     ) external {
 142 |     |         _revertIfInvalidSignature(
 143 |     |             from_,
 144 |     |             _getReceiveWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 145 |     |             r_,
 146 |     |             vs_
 147 |     |         );
 148 |     | 
 149 |     |         _receiveWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 150 |     |     }
 151 |     | 
 152 |     |     /// @inheritdoc IERC3009
 153 |     |     function receiveWithAuthorization(
 154 |     |         address from_,
 155 |     |         address to_,
 156 |     |         uint256 value_,
 157 |     |         uint256 validAfter_,
 158 |     |         uint256 validBefore_,
 159 |     |         bytes32 nonce_,
 160 |     |         uint8 v_,
 161 |     |         bytes32 r_,
 162 |     |         bytes32 s_
 163 |     |     ) external {
 164 |     |         _revertIfInvalidSignature(
 165 |     |             from_,
 166 |     |             _getReceiveWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 167 |     |             v_,
 168 |     |             r_,
 169 |     |             s_
 170 |     |         );
 171 |     | 
 172 |     |         _receiveWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 173 |     |     }
 174 |     | 
 175 |     |     /// @inheritdoc IERC3009
 176 |     |     function cancelAuthorization(address authorizer_, bytes32 nonce_, bytes memory signature_) external {
 177 |     |         _revertIfInvalidSignature(authorizer_, _getCancelAuthorizationDigest(authorizer_, nonce_), signature_);
 178 |     |         _cancelAuthorization(authorizer_, nonce_);
 179 |     |     }
 180 |     | 
 181 |     |     /// @inheritdoc IERC3009
 182 |     |     function cancelAuthorization(address authorizer_, bytes32 nonce_, bytes32 r_, bytes32 vs_) external {
 183 |     |         _revertIfInvalidSignature(authorizer_, _getCancelAuthorizationDigest(authorizer_, nonce_), r_, vs_);
 184 |     |         _cancelAuthorization(authorizer_, nonce_);
 185 |     |     }
 186 |     | 
 187 |     |     /// @inheritdoc IERC3009
 188 |     |     function cancelAuthorization(address authorizer_, bytes32 nonce_, uint8 v_, bytes32 r_, bytes32 s_) external {
 189 |     |         _revertIfInvalidSignature(authorizer_, _getCancelAuthorizationDigest(authorizer_, nonce_), v_, r_, s_);
 190 |     |         _cancelAuthorization(authorizer_, nonce_);
 191 |     |     }
 192 |     | 
 193 |     |     /* ============ Internal Interactive Functions ============ */
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev   Common transfer function used by `transferWithAuthorization` and `_receiveWithAuthorization`.
 197 |     |      * @param from_        Payer's address (Authorizer).
 198 |     |      * @param to_          Payee's address.
 199 |     |      * @param value_       Amount to be transferred.
 200 |     |      * @param validAfter_  The time after which this is valid (unix time).
 201 |     |      * @param validBefore_ The time before which this is valid (unix time).
 202 |     |      * @param nonce_       Unique nonce.
 203 |     |      */
 204 |     |     function _transferWithAuthorization(
 205 |     |         address from_,
 206 |     |         address to_,
 207 |     |         uint256 value_,
 208 |     |         uint256 validAfter_,
 209 |     |         uint256 validBefore_,
 210 |     |         bytes32 nonce_
 211 |     |     ) internal {
 212 |     |         if (block.timestamp <= validAfter_) revert AuthorizationNotYetValid(block.timestamp, validAfter_);
 213 |     |         if (block.timestamp >= validBefore_) revert AuthorizationExpired(block.timestamp, validBefore_);
 214 |     | 
 215 |     |         _revertIfAuthorizationAlreadyUsed(from_, nonce_);
 216 |     | 
 217 |     |         authorizationState[from_][nonce_] = true;
 218 |     | 
 219 |     |         emit AuthorizationUsed(from_, nonce_);
 220 |     | 
 221 |     |         _transfer(from_, to_, value_);
 222 |     |     }
 223 |     | 
 224 |     |     /**
 225 |     |      * @dev   Common receive function used by `receiveWithAuthorization`.
 226 |     |      * @param from_        Payer's address (Authorizer).
 227 |     |      * @param to_          Payee's address.
 228 |     |      * @param value_       Amount to be transferred.
 229 |     |      * @param validAfter_  The time after which this is valid (unix time).
 230 |     |      * @param validBefore_ The time before which this is valid (unix time).
 231 |     |      * @param nonce_       Unique nonce.
 232 |     |      */
 233 |     |     function _receiveWithAuthorization(
 234 |     |         address from_,
 235 |     |         address to_,
 236 |     |         uint256 value_,
 237 |     |         uint256 validAfter_,
 238 |     |         uint256 validBefore_,
 239 |     |         bytes32 nonce_
 240 |     |     ) internal {
 241 |     |         if (msg.sender != to_) revert CallerMustBePayee(msg.sender, to_);
 242 |     | 
 243 |     |         _transferWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 244 |     |     }
 245 |     | 
 246 |     |     /**
 247 |     |      * @dev   Common cancel function used by `cancelAuthorization`.
 248 |     |      * @param authorizer_ Authorizer's address.
 249 |     |      * @param nonce_      Nonce of the authorization.
 250 |     |      */
 251 |     |     function _cancelAuthorization(address authorizer_, bytes32 nonce_) internal {
 252 |     |         _revertIfAuthorizationAlreadyUsed(authorizer_, nonce_);
 253 |     | 
 254 |     |         authorizationState[authorizer_][nonce_] = true;
 255 |     | 
 256 |     |         emit AuthorizationCanceled(authorizer_, nonce_);
 257 |     |     }
 258 |     | 
 259 |     |     /**
 260 |     |      * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.
 261 |     |      * @param sender_    The sender's address.
 262 |     |      * @param recipient_ The recipient's address.
 263 |     |      * @param amount_    The amount to be transferred.
 264 |     |      */
 265 |     |     function _transfer(address sender_, address recipient_, uint256 amount_) internal virtual;
 266 |     | 
 267 |     |     /* ============ Internal View/Pure Functions ============ */
 268 |     | 
 269 |     |     /**
 270 |     |      * @dev    Returns the internal EIP-712 digest of a transferWithAuthorization call.
 271 |     |      * @param  from_        Payer's address (Authorizer).
 272 |     |      * @param  to_          Payee's address.
 273 |     |      * @param  value_       Amount to be transferred.
 274 |     |      * @param  validAfter_  The time after which this is valid (unix time).
 275 |     |      * @param  validBefore_ The time before which this is valid (unix time).
 276 |     |      * @param  nonce_       Unique nonce.
 277 |     |      * @return The internal EIP-712 digest.
 278 |     |      */
 279 |     |     function _getTransferWithAuthorizationDigest(
 280 |     |         address from_,
 281 |     |         address to_,
 282 |     |         uint256 value_,
 283 |     |         uint256 validAfter_,
 284 |     |         uint256 validBefore_,
 285 |     |         bytes32 nonce_
 286 |     |     ) internal view returns (bytes32) {
 287 |     |         return
 288 |     |             _getDigest(
 289 |     |                 keccak256(
 290 |     |                     abi.encode(
 291 |     |                         TRANSFER_WITH_AUTHORIZATION_TYPEHASH,
 292 |     |                         from_,
 293 |     |                         to_,
 294 |     |                         value_,
 295 |     |                         validAfter_,
 296 |     |                         validBefore_,
 297 |     |                         nonce_
 298 |     |                     )
 299 |     |                 )
 300 |     |             );
 301 |     |     }
 302 |     | 
 303 |     |     /**
 304 |     |      * @dev    Returns the internal EIP-712 digest of a receiveWithAuthorization call.
 305 |     |      * @param  from_        Payer's address (Authorizer).
 306 |     |      * @param  to_          Payee's address.
 307 |     |      * @param  value_       Amount to be transferred.
 308 |     |      * @param  validAfter_  The time after which this is valid (unix time).
 309 |     |      * @param  validBefore_ The time before which this is valid (unix time).
 310 |     |      * @param  nonce_       Unique nonce.
 311 |     |      * @return The internal EIP-712 digest.
 312 |     |      */
 313 |     |     function _getReceiveWithAuthorizationDigest(
 314 |     |         address from_,
 315 |     |         address to_,
 316 |     |         uint256 value_,
 317 |     |         uint256 validAfter_,
 318 |     |         uint256 validBefore_,
 319 |     |         bytes32 nonce_
 320 |     |     ) internal view returns (bytes32) {
 321 |     |         return
 322 |     |             _getDigest(
 323 |     |                 keccak256(
 324 |     |                     abi.encode(
 325 |     |                         RECEIVE_WITH_AUTHORIZATION_TYPEHASH,
 326 |     |                         from_,
 327 |     |                         to_,
 328 |     |                         value_,
 329 |     |                         validAfter_,
 330 |     |                         validBefore_,
 331 |     |                         nonce_
 332 |     |                     )
 333 |     |                 )
 334 |     |             );
 335 |     |     }
 336 |     | 
 337 |     |     /**
 338 |     |      * @dev    Returns the internal EIP-712 digest of a cancelAuthorization call.
 339 |     |      * @param  authorizer_ Authorizer's address.
 340 |     |      * @param  nonce_      Nonce of the authorization.
 341 |     |      * @return The internal EIP-712 digest.
 342 |     |      */
 343 |     |     function _getCancelAuthorizationDigest(address authorizer_, bytes32 nonce_) internal view returns (bytes32) {
 344 |     |         return _getDigest(keccak256(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, authorizer_, nonce_)));
 345 |     |     }
 346 |     | 
 347 |     |     /**
 348 |     |      * @dev   Reverts if the authorization is already used.
 349 |     |      * @param authorizer_ The authorizer's address.
 350 |     |      * @param nonce_      The nonce of the authorization.
 351 |     |      */
 352 |     |     function _revertIfAuthorizationAlreadyUsed(address authorizer_, bytes32 nonce_) internal view {
 353 |     |         if (authorizationState[authorizer_][nonce_]) revert AuthorizationAlreadyUsed(authorizer_, nonce_);
 354 |     |     }
 355 |     | }
 356 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/ERC3009Upgradeable.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity >=0.8.20 <0.9.0;
   4 |     | 
   5 |     | import { Initializable } from "../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol";
   6 |     | import { IERC3009 } from "./interfaces/IERC3009.sol";
   7 |     | 
   8 |     | import { StatefulERC712Upgradeable } from "./StatefulERC712Upgradeable.sol";
   9 |     | 
  10 |     | abstract contract ERC3009UpgradeableStorageLayout {
  11 |     |     /// @custom:storage-location erc7201:M0.storage.ERC3009
  12 |     |     struct ERC3009StorageStruct {
  13 |     |         mapping(address authorizer => mapping(bytes32 nonce => bool isNonceUsed)) authorizationState;
  14 |     |     }
  15 |     | 
  16 |     |     // keccak256(abi.encode(uint256(keccak256("M0.storage.ERC3009")) - 1)) & ~bytes32(uint256(0xff))
  17 |     |     bytes32 private constant _ERC3009_STORAGE_LOCATION =
  18 |     |         0x1116a1d33aa5fb91b2652b3b0fdb63704173742d6dbecaf4256ebe33a4888600;
  19 |     | 
  20 |     |     function _getERC3009StorageLocation() internal pure returns (ERC3009StorageStruct storage $) {
  21 |     |         assembly {
  22 |     |             $.slot := _ERC3009_STORAGE_LOCATION
  23 |     |         }
  24 |     |     }
  25 |     | }
  26 |     | 
  27 |     | /**
  28 |     |  * @title  ERC3009 implementation allowing the transfer of fungible assets via a signed authorization.
  29 |     |  * @author M0 Labs
  30 |     |  * @dev    Inherits from ERC712ExtendedUpgradeable and StatefulERC712Upgradeable.
  31 |     |  */
  32 |     | abstract contract ERC3009Upgradeable is IERC3009, ERC3009UpgradeableStorageLayout, StatefulERC712Upgradeable {
  33 |     |     /* ============ Variables ============ */
  34 |     | 
  35 |     |     // solhint-disable-next-line max-line-length
  36 |     |     /// @dev        keccak256("TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)")
  37 |     |     /// @inheritdoc IERC3009
  38 |     |     bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =
  39 |     |         0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;
  40 |     | 
  41 |     |     // solhint-disable-next-line max-line-length
  42 |     |     /// @dev        keccak256("ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)")
  43 |     |     /// @inheritdoc IERC3009
  44 |     |     bytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH =
  45 |     |         0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;
  46 |     | 
  47 |     |     /**
  48 |     |      * @inheritdoc IERC3009
  49 |     |      * @dev        keccak256("CancelAuthorization(address authorizer,bytes32 nonce)")
  50 |     |      */
  51 |     |     bytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH =
  52 |     |         0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;
  53 |     | 
  54 |     |     /* ============ Initializer ============ */
  55 |     | 
  56 |     |     /**
  57 |     |      * @notice Initializes the ERC3009Upgradeable contract.
  58 |     |      * @param  name_ The name of the contract.
  59 |     |      */
  60 | *   |     function __ERC3009Upgradeable_init(string memory name_) internal onlyInitializing {
  61 | *   |         __StatefulERC712ExtendedUpgradeable_init(name_);
  62 |     |     }
  63 |     | 
  64 |     |     /* ============ Interactive Functions ============ */
  65 |     | 
  66 |     |     /// @inheritdoc IERC3009
  67 |     |     function transferWithAuthorization(
  68 |     |         address from_,
  69 |     |         address to_,
  70 |     |         uint256 value_,
  71 |     |         uint256 validAfter_,
  72 |     |         uint256 validBefore_,
  73 |     |         bytes32 nonce_,
  74 |     |         bytes memory signature_
  75 |     |     ) external {
  76 |     |         _revertIfInvalidSignature(
  77 |     |             from_,
  78 |     |             _getTransferWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
  79 |     |             signature_
  80 |     |         );
  81 |     | 
  82 |     |         _transferWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
  83 |     |     }
  84 |     | 
  85 |     |     /// @inheritdoc IERC3009
  86 |     |     function transferWithAuthorization(
  87 |     |         address from_,
  88 |     |         address to_,
  89 |     |         uint256 value_,
  90 |     |         uint256 validAfter_,
  91 |     |         uint256 validBefore_,
  92 |     |         bytes32 nonce_,
  93 |     |         bytes32 r_,
  94 |     |         bytes32 vs_
  95 |     |     ) external {
  96 |     |         _revertIfInvalidSignature(
  97 |     |             from_,
  98 |     |             _getTransferWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
  99 |     |             r_,
 100 |     |             vs_
 101 |     |         );
 102 |     | 
 103 |     |         _transferWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 104 |     |     }
 105 |     | 
 106 |     |     /// @inheritdoc IERC3009
 107 |     |     function transferWithAuthorization(
 108 |     |         address from_,
 109 |     |         address to_,
 110 |     |         uint256 value_,
 111 |     |         uint256 validAfter_,
 112 |     |         uint256 validBefore_,
 113 |     |         bytes32 nonce_,
 114 |     |         uint8 v_,
 115 |     |         bytes32 r_,
 116 |     |         bytes32 s_
 117 |     |     ) external {
 118 |     |         _revertIfInvalidSignature(
 119 |     |             from_,
 120 |     |             _getTransferWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 121 |     |             v_,
 122 |     |             r_,
 123 |     |             s_
 124 |     |         );
 125 |     | 
 126 |     |         _transferWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 127 |     |     }
 128 |     | 
 129 |     |     /// @inheritdoc IERC3009
 130 |     |     function receiveWithAuthorization(
 131 |     |         address from_,
 132 |     |         address to_,
 133 |     |         uint256 value_,
 134 |     |         uint256 validAfter_,
 135 |     |         uint256 validBefore_,
 136 |     |         bytes32 nonce_,
 137 |     |         bytes memory signature_
 138 |     |     ) external {
 139 |     |         _revertIfInvalidSignature(
 140 |     |             from_,
 141 |     |             _getReceiveWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 142 |     |             signature_
 143 |     |         );
 144 |     | 
 145 |     |         _receiveWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 146 |     |     }
 147 |     | 
 148 |     |     /// @inheritdoc IERC3009
 149 |     |     function receiveWithAuthorization(
 150 |     |         address from_,
 151 |     |         address to_,
 152 |     |         uint256 value_,
 153 |     |         uint256 validAfter_,
 154 |     |         uint256 validBefore_,
 155 |     |         bytes32 nonce_,
 156 |     |         bytes32 r_,
 157 |     |         bytes32 vs_
 158 |     |     ) external {
 159 |     |         _revertIfInvalidSignature(
 160 |     |             from_,
 161 |     |             _getReceiveWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 162 |     |             r_,
 163 |     |             vs_
 164 |     |         );
 165 |     | 
 166 |     |         _receiveWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 167 |     |     }
 168 |     | 
 169 |     |     /// @inheritdoc IERC3009
 170 |     |     function receiveWithAuthorization(
 171 |     |         address from_,
 172 |     |         address to_,
 173 |     |         uint256 value_,
 174 |     |         uint256 validAfter_,
 175 |     |         uint256 validBefore_,
 176 |     |         bytes32 nonce_,
 177 |     |         uint8 v_,
 178 |     |         bytes32 r_,
 179 |     |         bytes32 s_
 180 |     |     ) external {
 181 |     |         _revertIfInvalidSignature(
 182 |     |             from_,
 183 |     |             _getReceiveWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 184 |     |             v_,
 185 |     |             r_,
 186 |     |             s_
 187 |     |         );
 188 |     | 
 189 |     |         _receiveWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 190 |     |     }
 191 |     | 
 192 |     |     /// @inheritdoc IERC3009
 193 |     |     function cancelAuthorization(address authorizer_, bytes32 nonce_, bytes memory signature_) external {
 194 |     |         _revertIfInvalidSignature(authorizer_, _getCancelAuthorizationDigest(authorizer_, nonce_), signature_);
 195 |     |         _cancelAuthorization(authorizer_, nonce_);
 196 |     |     }
 197 |     | 
 198 |     |     /// @inheritdoc IERC3009
 199 |     |     function cancelAuthorization(address authorizer_, bytes32 nonce_, bytes32 r_, bytes32 vs_) external {
 200 |     |         _revertIfInvalidSignature(authorizer_, _getCancelAuthorizationDigest(authorizer_, nonce_), r_, vs_);
 201 |     |         _cancelAuthorization(authorizer_, nonce_);
 202 |     |     }
 203 |     | 
 204 |     |     /// @inheritdoc IERC3009
 205 |     |     function cancelAuthorization(address authorizer_, bytes32 nonce_, uint8 v_, bytes32 r_, bytes32 s_) external {
 206 |     |         _revertIfInvalidSignature(authorizer_, _getCancelAuthorizationDigest(authorizer_, nonce_), v_, r_, s_);
 207 |     |         _cancelAuthorization(authorizer_, nonce_);
 208 |     |     }
 209 |     | 
 210 |     |     /* ============ View/Pure Functions ============ */
 211 |     | 
 212 |     |     /// @inheritdoc IERC3009
 213 |     |     function authorizationState(address authorizer, bytes32 nonce) public view returns (bool) {
 214 |     |         return _getERC3009StorageLocation().authorizationState[authorizer][nonce];
 215 |     |     }
 216 |     | 
 217 |     |     /* ============ Internal Interactive Functions ============ */
 218 |     | 
 219 |     |     /**
 220 |     |      * @dev   Common transfer function used by `transferWithAuthorization` and `_receiveWithAuthorization`.
 221 |     |      * @param from_        Payer's address (Authorizer).
 222 |     |      * @param to_          Payee's address.
 223 |     |      * @param value_       Amount to be transferred.
 224 |     |      * @param validAfter_  The time after which this is valid (unix time).
 225 |     |      * @param validBefore_ The time before which this is valid (unix time).
 226 |     |      * @param nonce_       Unique nonce.
 227 |     |      */
 228 |     |     function _transferWithAuthorization(
 229 |     |         address from_,
 230 |     |         address to_,
 231 |     |         uint256 value_,
 232 |     |         uint256 validAfter_,
 233 |     |         uint256 validBefore_,
 234 |     |         bytes32 nonce_
 235 |     |     ) internal {
 236 |     |         if (block.timestamp <= validAfter_) revert AuthorizationNotYetValid(block.timestamp, validAfter_);
 237 |     |         if (block.timestamp >= validBefore_) revert AuthorizationExpired(block.timestamp, validBefore_);
 238 |     | 
 239 |     |         _revertIfAuthorizationAlreadyUsed(from_, nonce_);
 240 |     | 
 241 |     |         _getERC3009StorageLocation().authorizationState[from_][nonce_] = true;
 242 |     | 
 243 |     |         emit AuthorizationUsed(from_, nonce_);
 244 |     | 
 245 |     |         _transfer(from_, to_, value_);
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev   Common receive function used by `receiveWithAuthorization`.
 250 |     |      * @param from_        Payer's address (Authorizer).
 251 |     |      * @param to_          Payee's address.
 252 |     |      * @param value_       Amount to be transferred.
 253 |     |      * @param validAfter_  The time after which this is valid (unix time).
 254 |     |      * @param validBefore_ The time before which this is valid (unix time).
 255 |     |      * @param nonce_       Unique nonce.
 256 |     |      */
 257 |     |     function _receiveWithAuthorization(
 258 |     |         address from_,
 259 |     |         address to_,
 260 |     |         uint256 value_,
 261 |     |         uint256 validAfter_,
 262 |     |         uint256 validBefore_,
 263 |     |         bytes32 nonce_
 264 |     |     ) internal {
 265 |     |         if (msg.sender != to_) revert CallerMustBePayee(msg.sender, to_);
 266 |     | 
 267 |     |         _transferWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 268 |     |     }
 269 |     | 
 270 |     |     /**
 271 |     |      * @dev   Common cancel function used by `cancelAuthorization`.
 272 |     |      * @param authorizer_ Authorizer's address.
 273 |     |      * @param nonce_      Nonce of the authorization.
 274 |     |      */
 275 |     |     function _cancelAuthorization(address authorizer_, bytes32 nonce_) internal {
 276 |     |         _revertIfAuthorizationAlreadyUsed(authorizer_, nonce_);
 277 |     | 
 278 |     |         _getERC3009StorageLocation().authorizationState[authorizer_][nonce_] = true;
 279 |     | 
 280 |     |         emit AuthorizationCanceled(authorizer_, nonce_);
 281 |     |     }
 282 |     | 
 283 |     |     /**
 284 |     |      * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.
 285 |     |      * @param sender_    The sender's address.
 286 |     |      * @param recipient_ The recipient's address.
 287 |     |      * @param amount_    The amount to be transferred.
 288 |     |      */
 289 |     |     function _transfer(address sender_, address recipient_, uint256 amount_) internal virtual;
 290 |     | 
 291 |     |     /* ============ Internal View/Pure Functions ============ */
 292 |     | 
 293 |     |     /**
 294 |     |      * @dev    Returns the internal EIP-712 digest of a transferWithAuthorization call.
 295 |     |      * @param  from_        Payer's address (Authorizer).
 296 |     |      * @param  to_          Payee's address.
 297 |     |      * @param  value_       Amount to be transferred.
 298 |     |      * @param  validAfter_  The time after which this is valid (unix time).
 299 |     |      * @param  validBefore_ The time before which this is valid (unix time).
 300 |     |      * @param  nonce_       Unique nonce.
 301 |     |      * @return The internal EIP-712 digest.
 302 |     |      */
 303 |     |     function _getTransferWithAuthorizationDigest(
 304 |     |         address from_,
 305 |     |         address to_,
 306 |     |         uint256 value_,
 307 |     |         uint256 validAfter_,
 308 |     |         uint256 validBefore_,
 309 |     |         bytes32 nonce_
 310 |     |     ) internal view returns (bytes32) {
 311 |     |         return
 312 |     |             _getDigest(
 313 |     |                 keccak256(
 314 |     |                     abi.encode(
 315 |     |                         TRANSFER_WITH_AUTHORIZATION_TYPEHASH,
 316 |     |                         from_,
 317 |     |                         to_,
 318 |     |                         value_,
 319 |     |                         validAfter_,
 320 |     |                         validBefore_,
 321 |     |                         nonce_
 322 |     |                     )
 323 |     |                 )
 324 |     |             );
 325 |     |     }
 326 |     | 
 327 |     |     /**
 328 |     |      * @dev    Returns the internal EIP-712 digest of a receiveWithAuthorization call.
 329 |     |      * @param  from_        Payer's address (Authorizer).
 330 |     |      * @param  to_          Payee's address.
 331 |     |      * @param  value_       Amount to be transferred.
 332 |     |      * @param  validAfter_  The time after which this is valid (unix time).
 333 |     |      * @param  validBefore_ The time before which this is valid (unix time).
 334 |     |      * @param  nonce_       Unique nonce.
 335 |     |      * @return The internal EIP-712 digest.
 336 |     |      */
 337 |     |     function _getReceiveWithAuthorizationDigest(
 338 |     |         address from_,
 339 |     |         address to_,
 340 |     |         uint256 value_,
 341 |     |         uint256 validAfter_,
 342 |     |         uint256 validBefore_,
 343 |     |         bytes32 nonce_
 344 |     |     ) internal view returns (bytes32) {
 345 |     |         return
 346 |     |             _getDigest(
 347 |     |                 keccak256(
 348 |     |                     abi.encode(
 349 |     |                         RECEIVE_WITH_AUTHORIZATION_TYPEHASH,
 350 |     |                         from_,
 351 |     |                         to_,
 352 |     |                         value_,
 353 |     |                         validAfter_,
 354 |     |                         validBefore_,
 355 |     |                         nonce_
 356 |     |                     )
 357 |     |                 )
 358 |     |             );
 359 |     |     }
 360 |     | 
 361 |     |     /**
 362 |     |      * @dev    Returns the internal EIP-712 digest of a cancelAuthorization call.
 363 |     |      * @param  authorizer_ Authorizer's address.
 364 |     |      * @param  nonce_      Nonce of the authorization.
 365 |     |      * @return The internal EIP-712 digest.
 366 |     |      */
 367 |     |     function _getCancelAuthorizationDigest(address authorizer_, bytes32 nonce_) internal view returns (bytes32) {
 368 |     |         return _getDigest(keccak256(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, authorizer_, nonce_)));
 369 |     |     }
 370 |     | 
 371 |     |     /**
 372 |     |      * @dev   Reverts if the authorization is already used.
 373 |     |      * @param authorizer_ The authorizer's address.
 374 |     |      * @param nonce_      The nonce of the authorization.
 375 |     |      */
 376 |     |     function _revertIfAuthorizationAlreadyUsed(address authorizer_, bytes32 nonce_) internal view {
 377 |     |         if (authorizationState(authorizer_, nonce_)) revert AuthorizationAlreadyUsed(authorizer_, nonce_);
 378 |     |     }
 379 |     | }
 380 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/ERC712Extended.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity >=0.8.20 <0.9.0;
   4 |     | 
   5 |     | import { IERC712 } from "./interfaces/IERC712.sol";
   6 |     | import { IERC712Extended } from "./interfaces/IERC712Extended.sol";
   7 |     | 
   8 |     | import { Bytes32String } from "./libs/Bytes32String.sol";
   9 |     | import { SignatureChecker } from "./libs/SignatureChecker.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @title  Typed structured data hashing and signing via EIP-712, extended by EIP-5267.
  13 |     |  * @author M^0 Labs
  14 |     |  * @dev    An abstract implementation to satisfy EIP-712: https://eips.ethereum.org/EIPS/eip-712
  15 |     |  */
  16 |     | abstract contract ERC712Extended is IERC712Extended {
  17 |     |     /* ============ Variables ============ */
  18 |     | 
  19 |     |     /// @dev keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")
  20 | *   |     bytes32 internal constant _EIP712_DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;
  21 |     | 
  22 |     |     /// @dev keccak256("1")
  23 | *   |     bytes32 internal constant _EIP712_VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;
  24 |     | 
  25 |     |     /// @dev Initial Chain ID set at deployment.
  26 |     |     uint256 internal immutable _INITIAL_CHAIN_ID;
  27 |     | 
  28 |     |     /// @dev Initial EIP-712 domain separator set at deployment.
  29 |     |     bytes32 internal immutable _INITIAL_DOMAIN_SEPARATOR;
  30 |     | 
  31 |     |     /// @dev The name of the contract (stored as a bytes32 instead of a string in order to be immutable).
  32 |     |     bytes32 internal immutable _name;
  33 |     | 
  34 |     |     /* ============ Constructor ============ */
  35 |     | 
  36 |     |     /**
  37 |     |      * @notice Constructs the EIP-712 domain separator.
  38 |     |      * @param  name_ The name of the contract.
  39 |     |      */
  40 | *   |     constructor(string memory name_) {
  41 | *   |         _name = Bytes32String.toBytes32(name_);
  42 |     | 
  43 | *   |         _INITIAL_CHAIN_ID = block.chainid;
  44 | *   |         _INITIAL_DOMAIN_SEPARATOR = _getDomainSeparator();
  45 |     |     }
  46 |     | 
  47 |     |     /* ============ View/Pure Functions ============ */
  48 |     | 
  49 |     |     /// @inheritdoc IERC712Extended
  50 |     |     function eip712Domain()
  51 |     |         external
  52 |     |         view
  53 |     |         virtual
  54 |     |         returns (
  55 |     |             bytes1 fields_,
  56 |     |             string memory name_,
  57 |     |             string memory version_,
  58 |     |             uint256 chainId_,
  59 |     |             address verifyingContract_,
  60 |     |             bytes32 salt_,
  61 |     |             uint256[] memory extensions_
  62 |     |         )
  63 |     |     {
  64 |     |         return (
  65 |     |             hex"0f", // 01111
  66 |     |             Bytes32String.toString(_name),
  67 |     |             "1",
  68 |     |             block.chainid,
  69 |     |             address(this),
  70 |     |             bytes32(0),
  71 |     |             new uint256[](0)
  72 |     |         );
  73 |     |     }
  74 |     | 
  75 |     |     /// @inheritdoc IERC712
  76 |     |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
  77 |     |         return block.chainid == _INITIAL_CHAIN_ID ? _INITIAL_DOMAIN_SEPARATOR : _getDomainSeparator();
  78 |     |     }
  79 |     | 
  80 |     |     /* ============ Internal View/Pure Functions ============ */
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev    Computes the EIP-712 domain separator.
  84 |     |      * @return The EIP-712 domain separator.
  85 |     |      */
  86 | *   |     function _getDomainSeparator() internal view returns (bytes32) {
  87 | *   |         return
  88 | *   |             keccak256(
  89 | *   |                 abi.encode(
  90 | *   |                     _EIP712_DOMAIN_HASH,
  91 | *   |                     keccak256(bytes(Bytes32String.toString(_name))),
  92 | *   |                     _EIP712_VERSION_HASH,
  93 | *   |                     block.chainid,
  94 | *   |                     address(this)
  95 |     |                 )
  96 |     |             );
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev    Returns the digest to be signed, via EIP-712, given an internal digest (i.e. hash struct).
 101 |     |      * @param  internalDigest_ The internal digest.
 102 |     |      * @return The digest to be signed.
 103 |     |      */
 104 |     |     function _getDigest(bytes32 internalDigest_) internal view returns (bytes32) {
 105 |     |         return keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR(), internalDigest_));
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev   Revert if the signature is expired.
 110 |     |      * @param expiry_ Timestamp at which the signature expires or max uint256 for no expiry.
 111 |     |      */
 112 |     |     function _revertIfExpired(uint256 expiry_) internal view {
 113 |     |         if (block.timestamp > expiry_) revert SignatureExpired(expiry_, block.timestamp);
 114 |     |     }
 115 |     | 
 116 |     |     /**
 117 |     |      * @dev   Revert if the signature is invalid.
 118 |     |      * @dev   We first validate if the signature is a valid ECDSA signature and return early if it is the case.
 119 |     |      *        Then, we validate if it is a valid ERC-1271 signature, and return early if it is the case.
 120 |     |      *        If not, we revert with the error from the ECDSA signature validation.
 121 |     |      * @param signer_    The signer of the signature.
 122 |     |      * @param digest_    The digest that was signed.
 123 |     |      * @param signature_ The signature.
 124 |     |      */
 125 |     |     function _revertIfInvalidSignature(address signer_, bytes32 digest_, bytes memory signature_) internal view {
 126 |     |         SignatureChecker.Error error_ = SignatureChecker.validateECDSASignature(signer_, digest_, signature_);
 127 |     | 
 128 |     |         if (error_ == SignatureChecker.Error.NoError) return;
 129 |     | 
 130 |     |         if (SignatureChecker.isValidERC1271Signature(signer_, digest_, signature_)) return;
 131 |     | 
 132 |     |         _revertIfError(error_);
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev    Returns the signer of a signed digest, via EIP-712, and reverts if the signature is invalid.
 137 |     |      * @param  digest_ The digest that was signed.
 138 |     |      * @param  v_      v of the signature.
 139 |     |      * @param  r_      r of the signature.
 140 |     |      * @param  s_      s of the signature.
 141 |     |      * @return signer_ The signer of the digest.
 142 |     |      */
 143 |     |     function _getSignerAndRevertIfInvalidSignature(
 144 |     |         bytes32 digest_,
 145 |     |         uint8 v_,
 146 |     |         bytes32 r_,
 147 |     |         bytes32 s_
 148 |     |     ) internal pure returns (address signer_) {
 149 |     |         SignatureChecker.Error error_;
 150 |     | 
 151 |     |         (error_, signer_) = SignatureChecker.recoverECDSASigner(digest_, v_, r_, s_);
 152 |     | 
 153 |     |         _revertIfError(error_);
 154 |     |     }
 155 |     | 
 156 |     |     /**
 157 |     |      * @dev   Revert if the signature is invalid.
 158 |     |      * @param signer_ The signer of the signature.
 159 |     |      * @param digest_ The digest that was signed.
 160 |     |      * @param r_      An ECDSA/secp256k1 signature parameter.
 161 |     |      * @param vs_     An ECDSA/secp256k1 short signature parameter.
 162 |     |      */
 163 |     |     function _revertIfInvalidSignature(address signer_, bytes32 digest_, bytes32 r_, bytes32 vs_) internal pure {
 164 |     |         _revertIfError(SignatureChecker.validateECDSASignature(signer_, digest_, r_, vs_));
 165 |     |     }
 166 |     | 
 167 |     |     /**
 168 |     |      * @dev   Revert if the signature is invalid.
 169 |     |      * @param signer_ The signer of the signature.
 170 |     |      * @param digest_ The digest that was signed.
 171 |     |      * @param v_      v of the signature.
 172 |     |      * @param r_      r of the signature.
 173 |     |      * @param s_      s of the signature.
 174 |     |      */
 175 |     |     function _revertIfInvalidSignature(
 176 |     |         address signer_,
 177 |     |         bytes32 digest_,
 178 |     |         uint8 v_,
 179 |     |         bytes32 r_,
 180 |     |         bytes32 s_
 181 |     |     ) internal pure {
 182 |     |         _revertIfError(SignatureChecker.validateECDSASignature(signer_, digest_, v_, r_, s_));
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @dev   Revert if error.
 187 |     |      * @param error_ The SignatureChecker Error enum.
 188 |     |      */
 189 |     |     function _revertIfError(SignatureChecker.Error error_) private pure {
 190 |     |         if (error_ == SignatureChecker.Error.NoError) return;
 191 |     |         if (error_ == SignatureChecker.Error.InvalidSignature) revert InvalidSignature();
 192 |     |         if (error_ == SignatureChecker.Error.InvalidSignatureLength) revert InvalidSignatureLength();
 193 |     |         if (error_ == SignatureChecker.Error.InvalidSignatureS) revert InvalidSignatureS();
 194 |     |         if (error_ == SignatureChecker.Error.InvalidSignatureV) revert InvalidSignatureV();
 195 |     |         if (error_ == SignatureChecker.Error.SignerMismatch) revert SignerMismatch();
 196 |     | 
 197 |     |         revert InvalidSignature();
 198 |     |     }
 199 |     | }
 200 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/ERC712ExtendedUpgradeable.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity >=0.8.20 <0.9.0;
   4 |     | 
   5 |     | import { Initializable } from "../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol";
   6 |     | 
   7 |     | import { IERC712 } from "./interfaces/IERC712.sol";
   8 |     | import { IERC712Extended } from "./interfaces/IERC712Extended.sol";
   9 |     | 
  10 |     | import { SignatureChecker } from "./libs/SignatureChecker.sol";
  11 |     | 
  12 |     | abstract contract ERC712ExtendedUpgradeableStorageLayout {
  13 |     |     /// @custom:storage-location erc7201:M0.storage.ERC712Extended
  14 |     |     struct ERC712ExtendedStorageStruct {
  15 |     |         uint256 initialChainId;
  16 |     |         bytes32 initialDomainSeparator;
  17 |     |         string name;
  18 |     |     }
  19 |     | 
  20 |     |     // keccak256(abi.encode(uint256(keccak256("M0.storage.ERC712Extended")) - 1)) & ~bytes32(uint256(0xff))
  21 |     |     bytes32 private constant _ERC712_EXTENDED_STORAGE_LOCATION =
  22 |     |         0x103ce0bed7138196cdb0d79ef04042681b16e7a2c58d74b78443c813042ea100;
  23 |     | 
  24 | *   |     function _getERC712ExtendedStorageLocation() internal pure returns (ERC712ExtendedStorageStruct storage $) {
  25 |     |         assembly {
  26 | *   |             $.slot := _ERC712_EXTENDED_STORAGE_LOCATION
  27 |     |         }
  28 |     |     }
  29 |     | }
  30 |     | 
  31 |     | /**
  32 |     |  * @title  Typed structured data hashing and signing via EIP-712, extended by EIP-5267.
  33 |     |  * @author M0 Labs
  34 |     |  * @dev    An abstract implementation to satisfy EIP-712: https://eips.ethereum.org/EIPS/eip-712
  35 |     |  */
  36 |     | abstract contract ERC712ExtendedUpgradeable is ERC712ExtendedUpgradeableStorageLayout, IERC712Extended, Initializable {
  37 |     |     /* ============ Variables ============ */
  38 |     | 
  39 |     |     /// @dev keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")
  40 | *   |     bytes32 internal constant _EIP712_DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;
  41 |     | 
  42 |     |     /// @dev keccak256("1")
  43 | *   |     bytes32 internal constant _EIP712_VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;
  44 |     | 
  45 |     |     /* ============ Initializer ============ */
  46 |     | 
  47 |     |     /**
  48 |     |      * @notice Initializes the ERC712ExtendedUpgradeable contract.
  49 |     |      * @param  name_ The name of the contract.
  50 |     |      */
  51 | *   |     function __ERC712ExtendedUpgradeable_init(string memory name_) internal onlyInitializing {
  52 | *   |         ERC712ExtendedStorageStruct storage $ = _getERC712ExtendedStorageLocation();
  53 |     | 
  54 | *   |         $.name = name_;
  55 | *   |         $.initialChainId = block.chainid;
  56 | *   |         $.initialDomainSeparator = _getDomainSeparator();
  57 |     |     }
  58 |     | 
  59 |     |     /* ============ View/Pure Functions ============ */
  60 |     | 
  61 |     |     /// @inheritdoc IERC712Extended
  62 |     |     function eip712Domain()
  63 |     |         external
  64 |     |         view
  65 |     |         virtual
  66 |     |         returns (
  67 |     |             bytes1 fields_,
  68 |     |             string memory name_,
  69 |     |             string memory version_,
  70 |     |             uint256 chainId_,
  71 |     |             address verifyingContract_,
  72 |     |             bytes32 salt_,
  73 |     |             uint256[] memory extensions_
  74 |     |         )
  75 |     |     {
  76 |     |         return (
  77 |     |             hex"0f", // 01111
  78 |     |             _getERC712ExtendedStorageLocation().name,
  79 |     |             "1",
  80 |     |             block.chainid,
  81 |     |             address(this),
  82 |     |             bytes32(0),
  83 |     |             new uint256[](0)
  84 |     |         );
  85 |     |     }
  86 |     | 
  87 |     |     /// @inheritdoc IERC712
  88 |     |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
  89 |     |         ERC712ExtendedStorageStruct storage $ = _getERC712ExtendedStorageLocation();
  90 |     |         return block.chainid == $.initialChainId ? $.initialDomainSeparator : _getDomainSeparator();
  91 |     |     }
  92 |     | 
  93 |     |     /* ============ Internal View/Pure Functions ============ */
  94 |     | 
  95 |     |     /**
  96 |     |      * @dev    Computes the EIP-712 domain separator.
  97 |     |      * @return The EIP-712 domain separator.
  98 |     |      */
  99 | *   |     function _getDomainSeparator() internal view returns (bytes32) {
 100 | *   |         return
 101 | *   |             keccak256(
 102 | *   |                 abi.encode(
 103 | *   |                     _EIP712_DOMAIN_HASH,
 104 | *   |                     keccak256(bytes(_getERC712ExtendedStorageLocation().name)),
 105 | *   |                     _EIP712_VERSION_HASH,
 106 | *   |                     block.chainid,
 107 | *   |                     address(this)
 108 |     |                 )
 109 |     |             );
 110 |     |     }
 111 |     | 
 112 |     |     /**
 113 |     |      * @dev    Returns the digest to be signed, via EIP-712, given an internal digest (i.e. hash struct).
 114 |     |      * @param  internalDigest_ The internal digest.
 115 |     |      * @return The digest to be signed.
 116 |     |      */
 117 |     |     function _getDigest(bytes32 internalDigest_) internal view returns (bytes32) {
 118 |     |         return keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR(), internalDigest_));
 119 |     |     }
 120 |     | 
 121 |     |     /**
 122 |     |      * @dev   Revert if the signature is expired.
 123 |     |      * @param expiry_ Timestamp at which the signature expires or max uint256 for no expiry.
 124 |     |      */
 125 |     |     function _revertIfExpired(uint256 expiry_) internal view {
 126 |     |         if (block.timestamp > expiry_) revert SignatureExpired(expiry_, block.timestamp);
 127 |     |     }
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev   Revert if the signature is invalid.
 131 |     |      * @dev   We first validate if the signature is a valid ECDSA signature and return early if it is the case.
 132 |     |      *        Then, we validate if it is a valid ERC-1271 signature, and return early if it is the case.
 133 |     |      *        If not, we revert with the error from the ECDSA signature validation.
 134 |     |      * @param signer_    The signer of the signature.
 135 |     |      * @param digest_    The digest that was signed.
 136 |     |      * @param signature_ The signature.
 137 |     |      */
 138 |     |     function _revertIfInvalidSignature(address signer_, bytes32 digest_, bytes memory signature_) internal view {
 139 |     |         SignatureChecker.Error error_ = SignatureChecker.validateECDSASignature(signer_, digest_, signature_);
 140 |     | 
 141 |     |         if (error_ == SignatureChecker.Error.NoError) return;
 142 |     | 
 143 |     |         if (SignatureChecker.isValidERC1271Signature(signer_, digest_, signature_)) return;
 144 |     | 
 145 |     |         _revertIfError(error_);
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev    Returns the signer of a signed digest, via EIP-712, and reverts if the signature is invalid.
 150 |     |      * @param  digest_ The digest that was signed.
 151 |     |      * @param  v_      v of the signature.
 152 |     |      * @param  r_      r of the signature.
 153 |     |      * @param  s_      s of the signature.
 154 |     |      * @return signer_ The signer of the digest.
 155 |     |      */
 156 |     |     function _getSignerAndRevertIfInvalidSignature(
 157 |     |         bytes32 digest_,
 158 |     |         uint8 v_,
 159 |     |         bytes32 r_,
 160 |     |         bytes32 s_
 161 |     |     ) internal pure returns (address signer_) {
 162 |     |         SignatureChecker.Error error_;
 163 |     | 
 164 |     |         (error_, signer_) = SignatureChecker.recoverECDSASigner(digest_, v_, r_, s_);
 165 |     | 
 166 |     |         _revertIfError(error_);
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev   Revert if the signature is invalid.
 171 |     |      * @param signer_ The signer of the signature.
 172 |     |      * @param digest_ The digest that was signed.
 173 |     |      * @param r_      An ECDSA/secp256k1 signature parameter.
 174 |     |      * @param vs_     An ECDSA/secp256k1 short signature parameter.
 175 |     |      */
 176 |     |     function _revertIfInvalidSignature(address signer_, bytes32 digest_, bytes32 r_, bytes32 vs_) internal pure {
 177 |     |         _revertIfError(SignatureChecker.validateECDSASignature(signer_, digest_, r_, vs_));
 178 |     |     }
 179 |     | 
 180 |     |     /**
 181 |     |      * @dev   Revert if the signature is invalid.
 182 |     |      * @param signer_ The signer of the signature.
 183 |     |      * @param digest_ The digest that was signed.
 184 |     |      * @param v_      v of the signature.
 185 |     |      * @param r_      r of the signature.
 186 |     |      * @param s_      s of the signature.
 187 |     |      */
 188 |     |     function _revertIfInvalidSignature(
 189 |     |         address signer_,
 190 |     |         bytes32 digest_,
 191 |     |         uint8 v_,
 192 |     |         bytes32 r_,
 193 |     |         bytes32 s_
 194 |     |     ) internal pure {
 195 |     |         _revertIfError(SignatureChecker.validateECDSASignature(signer_, digest_, v_, r_, s_));
 196 |     |     }
 197 |     | 
 198 |     |     /**
 199 |     |      * @dev   Revert if error.
 200 |     |      * @param error_ The SignatureChecker Error enum.
 201 |     |      */
 202 |     |     function _revertIfError(SignatureChecker.Error error_) private pure {
 203 |     |         if (error_ == SignatureChecker.Error.NoError) return;
 204 |     |         if (error_ == SignatureChecker.Error.InvalidSignature) revert InvalidSignature();
 205 |     |         if (error_ == SignatureChecker.Error.InvalidSignatureLength) revert InvalidSignatureLength();
 206 |     |         if (error_ == SignatureChecker.Error.InvalidSignatureS) revert InvalidSignatureS();
 207 |     |         if (error_ == SignatureChecker.Error.InvalidSignatureV) revert InvalidSignatureV();
 208 |     |         if (error_ == SignatureChecker.Error.SignerMismatch) revert SignerMismatch();
 209 |     | 
 210 |     |         revert InvalidSignature();
 211 |     |     }
 212 |     | }
 213 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/StatefulERC712.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity >=0.8.20 <0.9.0;
  4 |     | 
  5 |     | import { IStatefulERC712 } from "./interfaces/IStatefulERC712.sol";
  6 |     | 
  7 |     | import { ERC712Extended } from "./ERC712Extended.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title  Stateful Extension for EIP-712 typed structured data hashing and signing with nonces.
 11 |     |  * @author M^0 Labs
 12 |     |  * @dev    An abstract implementation to satisfy stateful EIP-712 with nonces.
 13 |     |  */
 14 |     | abstract contract StatefulERC712 is IStatefulERC712, ERC712Extended {
 15 |     |     /// @inheritdoc IStatefulERC712
 16 |     |     mapping(address account => uint256 nonce) public nonces; // Nonces for all signatures.
 17 |     | 
 18 |     |     /**
 19 |     |      * @notice Construct the StatefulERC712 contract.
 20 |     |      * @param  name_ The name of the contract.
 21 |     |      */
 22 | *   |     constructor(string memory name_) ERC712Extended(name_) {}
 23 |     | }
 24 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/StatefulERC712Upgradeable.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity >=0.8.20 <0.9.0;
  4 |     | 
  5 |     | import { IStatefulERC712 } from "./interfaces/IStatefulERC712.sol";
  6 |     | 
  7 |     | import { ERC712ExtendedUpgradeable } from "./ERC712ExtendedUpgradeable.sol";
  8 |     | 
  9 |     | abstract contract StatefulERC712ExtendedUpgradeableStorageLayout {
 10 |     |     /// @custom:storage-location erc7201:M0.storage.StatefulERC712Extended
 11 |     |     struct StatefulERC712ExtendedStorageStruct {
 12 |     |         mapping(address account => uint256 nonce) nonces; // Nonces for all signatures.
 13 |     |     }
 14 |     | 
 15 |     |     // keccak256(abi.encode(uint256(keccak256("M0.storage.StatefulERC712Extended")) - 1)) & ~bytes32(uint256(0xff))
 16 |     |     bytes32 private constant _STATEFUL_ERC712_EXTENDED_STORAGE_LOCATION =
 17 |     |         0x1b21ba3f0a2135d61c468900b54084f04af8111bce0f8bbb6ab8c46d11afbd00;
 18 |     | 
 19 |     |     function _getStatefulERC712ExtendedStorageLocation()
 20 |     |         internal
 21 |     |         pure
 22 |     |         returns (StatefulERC712ExtendedStorageStruct storage $)
 23 |     |     {
 24 |     |         assembly {
 25 |     |             $.slot := _STATEFUL_ERC712_EXTENDED_STORAGE_LOCATION
 26 |     |         }
 27 |     |     }
 28 |     | }
 29 |     | 
 30 |     | /**
 31 |     |  * @title  Stateful and upgradeable extension for EIP-712 typed structured data hashing and signing with nonces.
 32 |     |  * @author M0 Labs
 33 |     |  * @dev    An abstract implementation to satisfy stateful EIP-712 with nonces.
 34 |     |  */
 35 |     | abstract contract StatefulERC712Upgradeable is
 36 |     |     StatefulERC712ExtendedUpgradeableStorageLayout,
 37 |     |     IStatefulERC712,
 38 |     |     ERC712ExtendedUpgradeable
 39 |     | {
 40 |     |     /* ============ Initializer ============ */
 41 |     | 
 42 |     |     /**
 43 |     |      * @notice Initializes the StatefulERC712Upgradeable contract.
 44 |     |      * @param  name The name of the contract.
 45 |     |      */
 46 | *   |     function __StatefulERC712ExtendedUpgradeable_init(string memory name) internal onlyInitializing {
 47 | *   |         __ERC712ExtendedUpgradeable_init(name);
 48 |     |     }
 49 |     | 
 50 |     |     /* ============ View/Pure Functions ============ */
 51 |     | 
 52 |     |     /// @inheritdoc IStatefulERC712
 53 |     |     function nonces(address account) external view returns (uint256) {
 54 |     |         return _getStatefulERC712ExtendedStorageLocation().nonces[account];
 55 |     |     }
 56 |     | }
 57 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/interfaces/IERC1271.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity >=0.8.20 <0.9.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  Standard Signature Validation Method for Contracts via EIP-1271.
  7 |     |  * @author M^0 Labs
  8 |     |  * @dev    The interface as defined by EIP-1271: https://eips.ethereum.org/EIPS/eip-1271
  9 |     |  */
 10 |     | interface IERC1271 {
 11 |     |     /**
 12 |     |      * @dev    Returns a specific magic value if the provided signature is valid for the provided digest.
 13 |     |      * @param  digest     Hash of the data purported to have been signed.
 14 |     |      * @param  signature  Signature byte array associated with the digest.
 15 |     |      * @return magicValue Magic value 0x1626ba7e if the signature is valid.
 16 |     |      */
 17 |     |     function isValidSignature(bytes32 digest, bytes memory signature) external view returns (bytes4 magicValue);
 18 |     | }
 19 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/interfaces/IERC20.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity >=0.8.20 <0.9.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  ERC20 Token Standard.
  7 |     |  * @author M^0 Labs
  8 |     |  * @dev    The interface as defined by EIP-20: https://eips.ethereum.org/EIPS/eip-20
  9 |     |  */
 10 |     | interface IERC20 {
 11 |     |     /* ============ Events ============ */
 12 |     | 
 13 |     |     /**
 14 |     |      * @notice Emitted when `spender` has been approved for `amount` of the token balance of `account`.
 15 |     |      * @param  account The address of the account.
 16 |     |      * @param  spender The address of the spender being approved for the allowance.
 17 |     |      * @param  amount  The amount of the allowance being approved.
 18 |     |      */
 19 |     |     event Approval(address indexed account, address indexed spender, uint256 amount);
 20 |     | 
 21 |     |     /**
 22 |     |      * @notice Emitted when `amount` tokens is transferred from `sender` to `recipient`.
 23 |     |      * @param  sender    The address of the sender who's token balance is decremented.
 24 |     |      * @param  recipient The address of the recipient who's token balance is incremented.
 25 |     |      * @param  amount    The amount of tokens being transferred.
 26 |     |      */
 27 |     |     event Transfer(address indexed sender, address indexed recipient, uint256 amount);
 28 |     | 
 29 |     |     /* ============ Interactive Functions ============ */
 30 |     | 
 31 |     |     /**
 32 |     |      * @notice Allows a calling account to approve `spender` to spend up to `amount` of its token balance.
 33 |     |      * @dev    MUST emit an `Approval` event.
 34 |     |      * @param  spender The address of the account being allowed to spend up to the allowed amount.
 35 |     |      * @param  amount  The amount of the allowance being approved.
 36 |     |      * @return Whether or not the approval was successful.
 37 |     |      */
 38 |     |     function approve(address spender, uint256 amount) external returns (bool);
 39 |     | 
 40 |     |     /**
 41 |     |      * @notice Allows a calling account to transfer `amount` tokens to `recipient`.
 42 |     |      * @param  recipient The address of the recipient who's token balance will be incremented.
 43 |     |      * @param  amount    The amount of tokens being transferred.
 44 |     |      * @return Whether or not the transfer was successful.
 45 |     |      */
 46 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 47 |     | 
 48 |     |     /**
 49 |     |      * @notice Allows a calling account to transfer `amount` tokens from `sender`, with allowance, to a `recipient`.
 50 |     |      * @param  sender    The address of the sender who's token balance will be decremented.
 51 |     |      * @param  recipient The address of the recipient who's token balance will be incremented.
 52 |     |      * @param  amount    The amount of tokens being transferred.
 53 |     |      * @return Whether or not the transfer was successful.
 54 |     |      */
 55 |     |     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
 56 |     | 
 57 |     |     /* ============ View/Pure Functions ============ */
 58 |     | 
 59 |     |     /**
 60 |     |      * @notice Returns the allowance `spender` is allowed to spend on behalf of `account`.
 61 |     |      * @param  account The address of the account who's token balance `spender` is allowed to spend.
 62 |     |      * @param  spender The address of an account allowed to spend on behalf of `account`.
 63 |     |      * @return The amount `spender` can spend on behalf of `account`.
 64 |     |      */
 65 |     |     function allowance(address account, address spender) external view returns (uint256);
 66 |     | 
 67 |     |     /**
 68 |     |      * @notice Returns the token balance of `account`.
 69 |     |      * @param  account The address of some account.
 70 |     |      * @return The token balance of `account`.
 71 |     |      */
 72 |     |     function balanceOf(address account) external view returns (uint256);
 73 |     | 
 74 |     |     /// @notice Returns the number of decimals UIs should assume all amounts have.
 75 |     |     function decimals() external view returns (uint8);
 76 |     | 
 77 |     |     /// @notice Returns the name of the contract/token.
 78 |     |     function name() external view returns (string memory);
 79 |     | 
 80 |     |     /// @notice Returns the symbol of the token.
 81 |     |     function symbol() external view returns (string memory);
 82 |     | 
 83 |     |     /// @notice Returns the current total supply of the token.
 84 |     |     function totalSupply() external view returns (uint256);
 85 |     | }
 86 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/interfaces/IERC20Extended.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity >=0.8.20 <0.9.0;
  4 |     | 
  5 |     | import { IERC20 } from "./IERC20.sol";
  6 |     | import { IERC3009 } from "./IERC3009.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title  An ERC20 token extended with EIP-2612 permits for signed approvals (via EIP-712
 10 |     |  *         and with EIP-1271 compatibility), and extended with EIP-3009 transfer with authorization (via EIP-712).
 11 |     |  * @author M^0 Labs
 12 |     |  * @dev    The additional interface as defined by EIP-2612: https://eips.ethereum.org/EIPS/eip-2612
 13 |     |  */
 14 |     | interface IERC20Extended is IERC20, IERC3009 {
 15 |     |     /* ============ Custom Errors ============ */
 16 |     | 
 17 |     |     /**
 18 |     |      * @notice Revert message when spender's allowance is not sufficient.
 19 |     |      * @param  spender    Address that may be allowed to operate on tokens without being their owner.
 20 |     |      * @param  allowance  Amount of tokens a `spender` is allowed to operate with.
 21 |     |      * @param  needed     Minimum amount required to perform a transfer.
 22 |     |      */
 23 |     |     error InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
 24 |     | 
 25 |     |     /**
 26 |     |      * @notice Revert message emitted when the transferred amount is insufficient.
 27 |     |      * @param  amount Amount transferred.
 28 |     |      */
 29 |     |     error InsufficientAmount(uint256 amount);
 30 |     | 
 31 |     |     /**
 32 |     |      * @notice Revert message emitted when the recipient of a token is invalid.
 33 |     |      * @param  recipient Address of the invalid recipient.
 34 |     |      */
 35 |     |     error InvalidRecipient(address recipient);
 36 |     | 
 37 |     |     /* ============ Interactive Functions ============ */
 38 |     | 
 39 |     |     /**
 40 |     |      * @notice Approves `spender` to spend up to `amount` of the token balance of `owner`, via a signature.
 41 |     |      * @param  owner    The address of the account who's token balance is being approved to be spent by `spender`.
 42 |     |      * @param  spender  The address of an account allowed to spend on behalf of `owner`.
 43 |     |      * @param  value    The amount of the allowance being approved.
 44 |     |      * @param  deadline The last timestamp where the signature is still valid.
 45 |     |      * @param  v        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 46 |     |      * @param  r        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 47 |     |      * @param  s        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 48 |     |      */
 49 |     |     function permit(
 50 |     |         address owner,
 51 |     |         address spender,
 52 |     |         uint256 value,
 53 |     |         uint256 deadline,
 54 |     |         uint8 v,
 55 |     |         bytes32 r,
 56 |     |         bytes32 s
 57 |     |     ) external;
 58 |     | 
 59 |     |     /**
 60 |     |      * @notice Approves `spender` to spend up to `amount` of the token balance of `owner`, via a signature.
 61 |     |      * @param  owner     The address of the account who's token balance is being approved to be spent by `spender`.
 62 |     |      * @param  spender   The address of an account allowed to spend on behalf of `owner`.
 63 |     |      * @param  value     The amount of the allowance being approved.
 64 |     |      * @param  deadline  The last timestamp where the signature is still valid.
 65 |     |      * @param  signature An arbitrary signature (EIP-712).
 66 |     |      */
 67 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) external;
 68 |     | 
 69 |     |     /* ============ View/Pure Functions ============ */
 70 |     | 
 71 |     |     /// @notice Returns the EIP712 typehash used in the encoding of the digest for the permit function.
 72 |     |     function PERMIT_TYPEHASH() external view returns (bytes32);
 73 |     | }
 74 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/interfaces/IERC3009.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity >=0.8.20 <0.9.0;
   4 |     | 
   5 |     | import { IStatefulERC712 } from "./IStatefulERC712.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title  Transfer via signed authorization following EIP-3009 standard.
   9 |     |  * @author M^0 Labs
  10 |     |  * @dev    The interface as defined by EIP-3009: https://eips.ethereum.org/EIPS/eip-3009
  11 |     |  */
  12 |     | interface IERC3009 is IStatefulERC712 {
  13 |     |     /* ============ Events ============ */
  14 |     | 
  15 |     |     /**
  16 |     |      * @notice Emitted when an authorization has been canceled.
  17 |     |      * @param  authorizer Authorizer's address.
  18 |     |      * @param  nonce      Nonce of the canceled authorization.
  19 |     |      */
  20 |     |     event AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);
  21 |     | 
  22 |     |     /**
  23 |     |      * @notice Emitted when an authorization has been used.
  24 |     |      * @param  authorizer Authorizer's address.
  25 |     |      * @param  nonce      Nonce of the used authorization.
  26 |     |      */
  27 |     |     event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);
  28 |     | 
  29 |     |     /* ============ Custom Errors ============ */
  30 |     | 
  31 |     |     /**
  32 |     |      * @notice Emitted when an authorization has already been used.
  33 |     |      * @param  authorizer Authorizer's address.
  34 |     |      * @param  nonce      Nonce of the used authorization.
  35 |     |      */
  36 |     |     error AuthorizationAlreadyUsed(address authorizer, bytes32 nonce);
  37 |     | 
  38 |     |     /**
  39 |     |      * @notice Emitted when an authorization is expired.
  40 |     |      * @param  timestamp   Timestamp at which the transaction was submitted.
  41 |     |      * @param  validBefore Timestamp before which the authorization would have been valid.
  42 |     |      */
  43 |     |     error AuthorizationExpired(uint256 timestamp, uint256 validBefore);
  44 |     | 
  45 |     |     /**
  46 |     |      * @notice Emitted when an authorization is not yet valid.
  47 |     |      * @param  timestamp  Timestamp at which the transaction was submitted.
  48 |     |      * @param  validAfter Timestamp after which the authorization will be valid.
  49 |     |      */
  50 |     |     error AuthorizationNotYetValid(uint256 timestamp, uint256 validAfter);
  51 |     | 
  52 |     |     /**
  53 |     |      * @notice Emitted when the caller of `receiveWithAuthorization` is not the payee.
  54 |     |      * @param  caller Caller's address.
  55 |     |      * @param  payee  Payee's address.
  56 |     |      */
  57 |     |     error CallerMustBePayee(address caller, address payee);
  58 |     | 
  59 |     |     /* ============ Interactive Functions ============ */
  60 |     | 
  61 |     |     /**
  62 |     |      * @notice Execute a transfer with a signed authorization.
  63 |     |      * @param  from        Payer's address (Authorizer).
  64 |     |      * @param  to          Payee's address.
  65 |     |      * @param  value       Amount to be transferred.
  66 |     |      * @param  validAfter  The time after which this is valid (unix time).
  67 |     |      * @param  validBefore The time before which this is valid (unix time).
  68 |     |      * @param  nonce       Unique nonce.
  69 |     |      * @param  signature   A byte array ECDSA/secp256k1 signature (encoded r, s, v).
  70 |     |      */
  71 |     |     function transferWithAuthorization(
  72 |     |         address from,
  73 |     |         address to,
  74 |     |         uint256 value,
  75 |     |         uint256 validAfter,
  76 |     |         uint256 validBefore,
  77 |     |         bytes32 nonce,
  78 |     |         bytes memory signature
  79 |     |     ) external;
  80 |     | 
  81 |     |     /**
  82 |     |      * @notice Execute a transfer with a signed authorization.
  83 |     |      * @param  from        Payer's address (Authorizer).
  84 |     |      * @param  to          Payee's address.
  85 |     |      * @param  value       Amount to be transferred.
  86 |     |      * @param  validAfter  The time after which this is valid (unix time).
  87 |     |      * @param  validBefore The time before which this is valid (unix time).
  88 |     |      * @param  nonce       Unique nonce.
  89 |     |      * @param  r           An ECDSA/secp256k1 signature parameter.
  90 |     |      * @param  vs          An ECDSA/secp256k1 short signature parameter.
  91 |     |      */
  92 |     |     function transferWithAuthorization(
  93 |     |         address from,
  94 |     |         address to,
  95 |     |         uint256 value,
  96 |     |         uint256 validAfter,
  97 |     |         uint256 validBefore,
  98 |     |         bytes32 nonce,
  99 |     |         bytes32 r,
 100 |     |         bytes32 vs
 101 |     |     ) external;
 102 |     | 
 103 |     |     /**
 104 |     |      * @notice Execute a transfer with a signed authorization.
 105 |     |      * @param  from        Payer's address (Authorizer).
 106 |     |      * @param  to          Payee's address.
 107 |     |      * @param  value       Amount to be transferred.
 108 |     |      * @param  validAfter  The time after which this is valid (unix time).
 109 |     |      * @param  validBefore The time before which this is valid (unix time).
 110 |     |      * @param  nonce       Unique nonce.
 111 |     |      * @param  v           v of the signature.
 112 |     |      * @param  r           r of the signature.
 113 |     |      * @param  s           s of the signature.
 114 |     |      */
 115 |     |     function transferWithAuthorization(
 116 |     |         address from,
 117 |     |         address to,
 118 |     |         uint256 value,
 119 |     |         uint256 validAfter,
 120 |     |         uint256 validBefore,
 121 |     |         bytes32 nonce,
 122 |     |         uint8 v,
 123 |     |         bytes32 r,
 124 |     |         bytes32 s
 125 |     |     ) external;
 126 |     | 
 127 |     |     /**
 128 |     |      * @notice Receive a transfer with a signed authorization from the payer.
 129 |     |      * @dev    This has an additional check to ensure that the payee's address matches
 130 |     |      *         the caller of this function to prevent front-running attacks.
 131 |     |      *         (See security considerations)
 132 |     |      * @param  from        Payer's address (Authorizer).
 133 |     |      * @param  to          Payee's address.
 134 |     |      * @param  value       Amount to be transferred.
 135 |     |      * @param  validAfter  The time after which this is valid (unix time).
 136 |     |      * @param  validBefore The time before which this is valid (unix time).
 137 |     |      * @param  nonce       Unique nonce.
 138 |     |      * @param  signature   A byte array ECDSA/secp256k1 signature (encoded r, s, v).
 139 |     |      */
 140 |     |     function receiveWithAuthorization(
 141 |     |         address from,
 142 |     |         address to,
 143 |     |         uint256 value,
 144 |     |         uint256 validAfter,
 145 |     |         uint256 validBefore,
 146 |     |         bytes32 nonce,
 147 |     |         bytes memory signature
 148 |     |     ) external;
 149 |     | 
 150 |     |     /**
 151 |     |      * @notice Receive a transfer with a signed authorization from the payer.
 152 |     |      * @dev    This has an additional check to ensure that the payee's address matches
 153 |     |      *         the caller of this function to prevent front-running attacks.
 154 |     |      *         (See security considerations)
 155 |     |      * @param  from        Payer's address (Authorizer).
 156 |     |      * @param  to          Payee's address.
 157 |     |      * @param  value       Amount to be transferred.
 158 |     |      * @param  validAfter  The time after which this is valid (unix time).
 159 |     |      * @param  validBefore The time before which this is valid (unix time).
 160 |     |      * @param  nonce       Unique nonce.
 161 |     |      * @param  r           An ECDSA/secp256k1 signature parameter.
 162 |     |      * @param  vs          An ECDSA/secp256k1 short signature parameter.
 163 |     |      */
 164 |     |     function receiveWithAuthorization(
 165 |     |         address from,
 166 |     |         address to,
 167 |     |         uint256 value,
 168 |     |         uint256 validAfter,
 169 |     |         uint256 validBefore,
 170 |     |         bytes32 nonce,
 171 |     |         bytes32 r,
 172 |     |         bytes32 vs
 173 |     |     ) external;
 174 |     | 
 175 |     |     /**
 176 |     |      * @notice Receive a transfer with a signed authorization from the payer.
 177 |     |      * @dev    This has an additional check to ensure that the payee's address matches
 178 |     |      *         the caller of this function to prevent front-running attacks.
 179 |     |      *         (See security considerations)
 180 |     |      * @param  from        Payer's address (Authorizer).
 181 |     |      * @param  to          Payee's address.
 182 |     |      * @param  value       Amount to be transferred.
 183 |     |      * @param  validAfter  The time after which this is valid (unix time).
 184 |     |      * @param  validBefore The time before which this is valid (unix time).
 185 |     |      * @param  nonce       Unique nonce.
 186 |     |      * @param  v           v of the signature.
 187 |     |      * @param  r           r of the signature.
 188 |     |      * @param  s           s of the signature.
 189 |     |      */
 190 |     |     function receiveWithAuthorization(
 191 |     |         address from,
 192 |     |         address to,
 193 |     |         uint256 value,
 194 |     |         uint256 validAfter,
 195 |     |         uint256 validBefore,
 196 |     |         bytes32 nonce,
 197 |     |         uint8 v,
 198 |     |         bytes32 r,
 199 |     |         bytes32 s
 200 |     |     ) external;
 201 |     | 
 202 |     |     /**
 203 |     |      * @notice Attempt to cancel an authorization.
 204 |     |      * @param  authorizer Authorizer's address.
 205 |     |      * @param  nonce      Nonce of the authorization.
 206 |     |      * @param  signature  A byte array ECDSA/secp256k1 signature (encoded r, s, v).
 207 |     |      */
 208 |     |     function cancelAuthorization(address authorizer, bytes32 nonce, bytes memory signature) external;
 209 |     | 
 210 |     |     /**
 211 |     |      * @notice Attempt to cancel an authorization.
 212 |     |      * @param  authorizer Authorizer's address.
 213 |     |      * @param  nonce      Nonce of the authorization.
 214 |     |      * @param  r          An ECDSA/secp256k1 signature parameter.
 215 |     |      * @param  vs         An ECDSA/secp256k1 short signature parameter.
 216 |     |      */
 217 |     |     function cancelAuthorization(address authorizer, bytes32 nonce, bytes32 r, bytes32 vs) external;
 218 |     | 
 219 |     |     /**
 220 |     |      * @notice Attempt to cancel an authorization.
 221 |     |      * @param  authorizer Authorizer's address.
 222 |     |      * @param  nonce      Nonce of the authorization.
 223 |     |      * @param  v          v of the signature.
 224 |     |      * @param  r          r of the signature.
 225 |     |      * @param  s          s of the signature.
 226 |     |      */
 227 |     |     function cancelAuthorization(address authorizer, bytes32 nonce, uint8 v, bytes32 r, bytes32 s) external;
 228 |     | 
 229 |     |     /* ============ View/Pure Functions ============ */
 230 |     | 
 231 |     |     /**
 232 |     |      * @notice Returns the state of an authorization.
 233 |     |      * @dev    Nonces are randomly generated 32-byte data unique to the authorizer's address
 234 |     |      * @param  authorizer Authorizer's address.
 235 |     |      * @param  nonce      Nonce of the authorization.
 236 |     |      * @return True if the nonce is used.
 237 |     |      */
 238 |     |     function authorizationState(address authorizer, bytes32 nonce) external view returns (bool);
 239 |     | 
 240 |     |     /// @notice Returns `transferWithAuthorization` typehash.
 241 |     |     function TRANSFER_WITH_AUTHORIZATION_TYPEHASH() external view returns (bytes32);
 242 |     | 
 243 |     |     /// @notice Returns `receiveWithAuthorization` typehash.
 244 |     |     function RECEIVE_WITH_AUTHORIZATION_TYPEHASH() external view returns (bytes32);
 245 |     | 
 246 |     |     /// @notice Returns `cancelAuthorization` typehash.
 247 |     |     function CANCEL_AUTHORIZATION_TYPEHASH() external view returns (bytes32);
 248 |     | }
 249 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/interfaces/IERC712.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity >=0.8.20 <0.9.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  Typed structured data hashing and signing via EIP-712.
  7 |     |  * @author M^0 Labs
  8 |     |  * @dev    The interface as defined by EIP-712: https://eips.ethereum.org/EIPS/eip-712
  9 |     |  */
 10 |     | interface IERC712 {
 11 |     |     /* ============ Custom Errors ============ */
 12 |     | 
 13 |     |     /// @notice Revert message when an invalid signature is detected.
 14 |     |     error InvalidSignature();
 15 |     | 
 16 |     |     /// @notice Revert message when a signature with invalid length is detected.
 17 |     |     error InvalidSignatureLength();
 18 |     | 
 19 |     |     /// @notice Revert message when the S portion of a signature is invalid.
 20 |     |     error InvalidSignatureS();
 21 |     | 
 22 |     |     /// @notice Revert message when the V portion of a signature is invalid.
 23 |     |     error InvalidSignatureV();
 24 |     | 
 25 |     |     /**
 26 |     |      * @notice Revert message when a signature is being used beyond its deadline (i.e. expiry).
 27 |     |      * @param  deadline  The last timestamp where the signature is still valid.
 28 |     |      * @param  timestamp The current timestamp.
 29 |     |      */
 30 |     |     error SignatureExpired(uint256 deadline, uint256 timestamp);
 31 |     | 
 32 |     |     /// @notice Revert message when a recovered signer does not match the account being purported to have signed.
 33 |     |     error SignerMismatch();
 34 |     | 
 35 |     |     /* ============ View/Pure Functions ============ */
 36 |     | 
 37 |     |     /// @notice Returns the EIP712 domain separator used in the encoding of a signed digest.
 38 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 39 |     | }
 40 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/interfaces/IERC712Extended.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity >=0.8.20 <0.9.0;
  4 |     | 
  5 |     | import { IERC712 } from "./IERC712.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title  EIP-712 extended by EIP-5267.
  9 |     |  * @author M^0 Labs
 10 |     |  * @dev    The additional interface as defined by EIP-5267: https://eips.ethereum.org/EIPS/eip-5267
 11 |     |  */
 12 |     | interface IERC712Extended is IERC712 {
 13 |     |     /* ============ Events ============ */
 14 |     | 
 15 |     |     /// @notice MAY be emitted to signal that the domain could have changed.
 16 |     |     event EIP712DomainChanged();
 17 |     | 
 18 |     |     /* ============ View/Pure Functions ============ */
 19 |     | 
 20 |     |     /// @notice Returns the fields and values that describe the domain separator used by this contract for EIP-712.
 21 |     |     function eip712Domain()
 22 |     |         external
 23 |     |         view
 24 |     |         returns (
 25 |     |             bytes1 fields,
 26 |     |             string memory name,
 27 |     |             string memory version,
 28 |     |             uint256 chainId,
 29 |     |             address verifyingContract,
 30 |     |             bytes32 salt,
 31 |     |             uint256[] memory extensions
 32 |     |         );
 33 |     | }
 34 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/interfaces/IStatefulERC712.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity >=0.8.20 <0.9.0;
  4 |     | 
  5 |     | import { IERC712Extended } from "./IERC712Extended.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title  Stateful Extension for EIP-712 typed structured data hashing and signing with nonces.
  9 |     |  * @author M^0 Labs
 10 |     |  */
 11 |     | interface IStatefulERC712 is IERC712Extended {
 12 |     |     /* ============ Custom Errors ============ */
 13 |     | 
 14 |     |     /**
 15 |     |      * @notice Revert message when a signing account's nonce is not the expected current nonce.
 16 |     |      * @param  nonce         The nonce used in the signature.
 17 |     |      * @param  expectedNonce The expected nonce to be used in a signature by the signing account.
 18 |     |      */
 19 |     |     error InvalidAccountNonce(uint256 nonce, uint256 expectedNonce);
 20 |     | 
 21 |     |     /* ============ View/Pure Functions ============ */
 22 |     | 
 23 |     |     /**
 24 |     |      * @notice Returns the next nonce to be used in a signature by `account`.
 25 |     |      * @param  account The address of some account.
 26 |     |      * @return nonce   The next nonce to be used in a signature by `account`.
 27 |     |      */
 28 |     |     function nonces(address account) external view returns (uint256 nonce);
 29 |     | }
 30 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/libs/Bytes32String.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity >=0.8.20 <0.9.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  A library to convert between string and bytes32 (assuming 32 characters or less).
  7 |     |  * @author M^0 Labs
  8 |     |  */
  9 |     | library Bytes32String {
 10 | *   |     function toBytes32(string memory input) internal pure returns (bytes32) {
 11 | *   |         return bytes32(abi.encodePacked(input));
 12 |     |     }
 13 |     | 
 14 | *   |     function toString(bytes32 input) internal pure returns (string memory) {
 15 | *   |         uint256 length;
 16 |     | 
 17 | *   |         while (length < 32 && uint8(input[length]) != 0) {
 18 | *   |             ++length;
 19 |     |         }
 20 |     | 
 21 | *   |         bytes memory name = new bytes(length);
 22 |     | 
 23 | *   |         for (uint256 index; index < length; ++index) {
 24 | *   |             name[index] = input[index];
 25 |     |         }
 26 |     | 
 27 | *   |         return string(name);
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/libs/ContinuousIndexingMath.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity >=0.8.20 <0.9.0;
   4 |     | 
   5 |     | import { IndexingMath } from "./IndexingMath.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title  Arithmetic library with operations for calculating continuous indexing.
   9 |     |  * @author M^0 Labs
  10 |     |  */
  11 |     | library ContinuousIndexingMath {
  12 |     |     /* ============ Variables ============ */
  13 |     | 
  14 |     |     /// @notice The scaling of indexes for exponent math.
  15 |     |     uint56 internal constant EXP_SCALED_ONE = IndexingMath.EXP_SCALED_ONE;
  16 |     | 
  17 |     |     /// @notice The number of seconds in a year.
  18 | *   |     uint32 internal constant SECONDS_PER_YEAR = 31_536_000;
  19 |     | 
  20 |     |     /// @notice 100% in basis points.
  21 | *   |     uint16 internal constant BPS_SCALED_ONE = 1e4;
  22 |     | 
  23 |     |     /* ============ Internal View/Pure Functions ============ */
  24 |     | 
  25 |     |     /**
  26 |     |      * @notice Helper function to calculate `(index * deltaIndex) / EXP_SCALED_ONE`, rounded down.
  27 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  28 |     |      */
  29 | *   |     function multiplyIndicesDown(uint128 index, uint48 deltaIndex) internal pure returns (uint144) {
  30 |     |         unchecked {
  31 | *   |             return uint144((uint256(index) * deltaIndex) / EXP_SCALED_ONE);
  32 |     |         }
  33 |     |     }
  34 |     | 
  35 |     |     /**
  36 |     |      * @notice Helper function to calculate `(index * deltaIndex) / EXP_SCALED_ONE`, rounded up.
  37 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  38 |     |      */
  39 |     |     function multiplyIndicesUp(uint128 index, uint48 deltaIndex) internal pure returns (uint144) {
  40 |     |         unchecked {
  41 |     |             return uint144((uint256(index) * deltaIndex + (EXP_SCALED_ONE - 1)) / EXP_SCALED_ONE);
  42 |     |         }
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @notice Helper function to calculate e^rt (continuous compounding formula).
  47 |     |      * @dev    `uint64 yearlyRate` can accommodate 1000% interest per year.
  48 |     |      * @dev    `uint32 time` can accommodate 100 years.
  49 |     |      * @dev    `type(uint64).max * type(uint32).max / SECONDS_PER_YEAR` fits in a `uint72`.
  50 |     |      */
  51 | *   |     function getContinuousIndex(uint64 yearlyRate, uint32 time) internal pure returns (uint48) {
  52 |     |         unchecked {
  53 |     |             // NOTE: Casting `uint256(yearlyRate) * time` to a `uint72` is safe because the largest value is
  54 |     |             //      `type(uint64).max * type(uint32).max / SECONDS_PER_YEAR`, which is less than `type(uint72).max`.
  55 | *   |             return exponent(uint72((uint256(yearlyRate) * time) / SECONDS_PER_YEAR));
  56 |     |         }
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @notice Helper function to calculate y = e^x using R(4,4) Pad approximation:
  61 |     |      *           e(x) = (1 + x/2 + 3(x^2)/28 + x^3/84 + x^4/1680) / (1 - x/2 + 3(x^2)/28 - x^3/84 + x^4/1680)
  62 |     |      *           See: https://en.wikipedia.org/wiki/Pad%C3%A9_table
  63 |     |      *           See: https://www.wolframalpha.com/input?i=PadeApproximant%5Bexp%5Bx%5D%2C%7Bx%2C0%2C%7B4%2C+4%7D%7D%5D
  64 |     |      *         Despite itself being a whole number, `x` represents a real number scaled by `EXP_SCALED_ONE`, thus
  65 |     |      *         allowing for y = e^x where x is a real number.
  66 |     |      * @dev    Output for a `uint72` input `x` will fit in `uint48`
  67 |     |      */
  68 | *   |     function exponent(uint72 x) internal pure returns (uint48) {
  69 |     |         // NOTE: This can be done unchecked even for `x = type(uint72).max`.
  70 |     |         //       Verify by removing `unchecked` and running `test_exponent()`.
  71 |     |         unchecked {
  72 | *   |             uint256 x2 = uint256(x) * x;
  73 |     | 
  74 |     |             // `additiveTerms` is `(1 + 3(x^2)/28 + x^4/1680)`, and scaled by `84e27`.
  75 |     |             // NOTE: `84e27` the cleanest and largest scalar, given the various intermediate overflow possibilities.
  76 |     |             // NOTE: The resulting `(x2 * x2) / 20e21` term has been split to avoid overflow of `x2 * x2`.
  77 | *   |             uint256 additiveTerms = 84e27 + (9e3 * x2) + ((x2 / 2e11) * (x2 / 1e11));
  78 |     | 
  79 |     |             // `differentTerms` is `(- x/2 - x^3/84)`, but positive (will be subtracted later), and scaled by `84e27`.
  80 | *   |             uint256 differentTerms = uint256(x) * (42e15 + (x2 / 1e9));
  81 |     | 
  82 |     |             // Result needs to be scaled by `1e12`.
  83 |     |             // NOTE: Can cast to `uint48` because contents can never be larger than `type(uint48).max` for any `x`.
  84 |     |             //       Max `y` is ~200e12, before falling off. See links above for reference.
  85 | *   |             return uint48(((additiveTerms + differentTerms) * 1e12) / (additiveTerms - differentTerms));
  86 |     |         }
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @notice Helper function to convert a scaled 12-decimal percentage to basis points.
  91 |     |      * @param  input A percentage represented as a scaled 12-decimal number.
  92 |     |      * @return The percentage represented as basis points.
  93 |     |      */
  94 |     |     function convertToBasisPoints(uint64 input) internal pure returns (uint40) {
  95 |     |         unchecked {
  96 |     |             return uint40((uint256(input) * BPS_SCALED_ONE) / EXP_SCALED_ONE);
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @notice Helper function to convert basis points to a scaled 12-decimal percentage.
 102 |     |      * @param  input A percentage represented as basis points.
 103 |     |      * @return The percentage represented as a scaled 12-decimal number.
 104 |     |      */
 105 | *   |     function convertFromBasisPoints(uint32 input) internal pure returns (uint64) {
 106 |     |         unchecked {
 107 | *   |             return uint64((uint256(input) * EXP_SCALED_ONE) / BPS_SCALED_ONE);
 108 |     |         }
 109 |     |     }
 110 |     | }
 111 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/libs/IndexingMath.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity >=0.8.20 <0.9.0;
   4 |     | 
   5 |     | import { UIntMath } from "./UIntMath.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title  Helper library for indexing math functions.
   9 |     |  * @author M^0 Labs
  10 |     |  */
  11 |     | library IndexingMath {
  12 |     |     /* ============ Variables ============ */
  13 |     | 
  14 |     |     /// @notice The scaling of indexes for exponent math.
  15 | *   |     uint56 internal constant EXP_SCALED_ONE = 1e12;
  16 |     | 
  17 |     |     /* ============ Custom Errors ============ */
  18 |     | 
  19 |     |     /// @notice Emitted when a division by zero occurs.
  20 |     |     error DivisionByZero();
  21 |     | 
  22 |     |     /* ============ Exposed Functions ============ */
  23 |     | 
  24 |     |     /**
  25 |     |      * @notice Helper function to calculate `(x * EXP_SCALED_ONE) / y`, rounded down.
  26 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  27 |     |      */
  28 |     |     function divide240By128Down(uint240 x, uint128 y) internal pure returns (uint112) {
  29 |     |         if (y == 0) revert DivisionByZero();
  30 |     | 
  31 |     |         unchecked {
  32 |     |             // NOTE: While `uint256(x) * EXP_SCALED_ONE` can technically overflow, these divide/multiply functions are
  33 |     |             //       only used for the purpose of principal/present amount calculations for continuous indexing, and
  34 |     |             //       so for an `x` to be large enough to overflow this, it would have to be a possible result of
  35 |     |             //       `multiply112By128Down` or `multiply112By128Up`, which would already satisfy
  36 |     |             //       `uint256(x) * EXP_SCALED_ONE < type(uint240).max`.
  37 |     |             return UIntMath.safe112((uint256(x) * EXP_SCALED_ONE) / y);
  38 |     |         }
  39 |     |     }
  40 |     | 
  41 |     |     /**
  42 |     |      * @notice Helper function to calculate `(x * EXP_SCALED_ONE) / y`, rounded up.
  43 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  44 |     |      */
  45 |     |     function divide240By128Up(uint240 x, uint128 y) internal pure returns (uint112) {
  46 |     |         if (y == 0) revert DivisionByZero();
  47 |     | 
  48 |     |         unchecked {
  49 |     |             // NOTE: While `uint256(x) * EXP_SCALED_ONE` can technically overflow, these divide/multiply functions are
  50 |     |             //       only used for the purpose of principal/present amount calculations for continuous indexing, and
  51 |     |             //       so for an `x` to be large enough to overflow this, it would have to be a possible result of
  52 |     |             //       `multiply112By128Down` or `multiply112By128Up`, which would already satisfy
  53 |     |             //       `uint256(x) * EXP_SCALED_ONE < type(uint240).max`.
  54 |     |             return UIntMath.safe112(((uint256(x) * EXP_SCALED_ONE) + y - 1) / y);
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     /**
  59 |     |      * @notice Helper function to calculate `(x * y) / EXP_SCALED_ONE`, rounded down.
  60 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  61 |     |      */
  62 |     |     function multiply112By128Down(uint112 x, uint128 y) internal pure returns (uint240) {
  63 |     |         unchecked {
  64 |     |             return uint240((uint256(x) * y) / EXP_SCALED_ONE);
  65 |     |         }
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @notice Helper function to calculate `(x * index) / EXP_SCALED_ONE`, rounded up.
  70 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  71 |     |      */
  72 |     |     function multiply112By128Up(uint112 x, uint128 index) internal pure returns (uint240 z) {
  73 |     |         unchecked {
  74 |     |             return uint240(((uint256(x) * index) + (EXP_SCALED_ONE - 1)) / EXP_SCALED_ONE);
  75 |     |         }
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev    Returns the present amount (rounded down) given the principal amount and an index.
  80 |     |      * @param  principalAmount The principal amount.
  81 |     |      * @param  index           An index.
  82 |     |      * @return The present amount rounded down.
  83 |     |      */
  84 |     |     function getPresentAmountRoundedDown(uint112 principalAmount, uint128 index) internal pure returns (uint240) {
  85 |     |         return multiply112By128Down(principalAmount, index);
  86 |     |     }
  87 |     | 
  88 |     |     /**
  89 |     |      * @dev    Returns the present amount (rounded up) given the principal amount and an index.
  90 |     |      * @param  principalAmount The principal amount.
  91 |     |      * @param  index           An index.
  92 |     |      * @return The present amount rounded up.
  93 |     |      */
  94 |     |     function getPresentAmountRoundedUp(uint112 principalAmount, uint128 index) internal pure returns (uint240) {
  95 |     |         return multiply112By128Up(principalAmount, index);
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev    Returns the principal amount given the present amount, using the current index.
 100 |     |      * @param  presentAmount The present amount.
 101 |     |      * @param  index         An index.
 102 |     |      * @return The principal amount rounded down.
 103 |     |      */
 104 |     |     function getPrincipalAmountRoundedDown(uint240 presentAmount, uint128 index) internal pure returns (uint112) {
 105 |     |         return divide240By128Down(presentAmount, index);
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev    Returns the principal amount given the present amount, using the current index.
 110 |     |      * @param  presentAmount The present amount.
 111 |     |      * @param  index         An index.
 112 |     |      * @return The principal amount rounded up.
 113 |     |      */
 114 |     |     function getPrincipalAmountRoundedUp(uint240 presentAmount, uint128 index) internal pure returns (uint112) {
 115 |     |         return divide240By128Up(presentAmount, index);
 116 |     |     }
 117 |     | }
 118 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/libs/SignatureChecker.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity >=0.8.20 <0.9.0;
   4 |     | 
   5 |     | import { IERC1271 } from "../interfaces/IERC1271.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title  A library to handle ECDSA/secp256k1 and ERC1271 signatures, individually or in arbitrarily in combination.
   9 |     |  * @author M^0 Labs
  10 |     |  */
  11 |     | library SignatureChecker {
  12 |     |     /* ============ Enums ============ */
  13 |     | 
  14 |     |     /**
  15 |     |      * @notice An enum representing the possible errors that can be emitted during signature validation.
  16 |     |      * @param  NoError                No error occurred during signature validation.
  17 |     |      * @param  InvalidSignature       The signature is invalid.
  18 |     |      * @param  InvalidSignatureLength The signature length is invalid.
  19 |     |      * @param  InvalidSignatureS      The signature parameter S is invalid.
  20 |     |      * @param  InvalidSignatureV      The signature parameter V is invalid.
  21 |     |      * @param  SignerMismatch         The signer does not match the recovered signer.
  22 |     |      */
  23 |     |     enum Error {
  24 |     |         NoError,
  25 |     |         InvalidSignature,
  26 |     |         InvalidSignatureLength,
  27 |     |         InvalidSignatureS,
  28 |     |         InvalidSignatureV,
  29 |     |         SignerMismatch
  30 |     |     }
  31 |     | 
  32 |     |     /* ============ Internal View/Pure Functions ============ */
  33 |     | 
  34 |     |     /**
  35 |     |      * @dev    Returns whether a signature is valid (ECDSA/secp256k1 or ERC1271) for a signer and digest.
  36 |     |      * @dev    Signatures must not be used as unique identifiers since the `ecrecover` EVM opcode
  37 |     |      *         allows for malleable (non-unique) signatures.
  38 |     |      *         See https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h
  39 |     |      * @param  signer    The address of the account purported to have signed.
  40 |     |      * @param  digest    The hash of the data that was signed.
  41 |     |      * @param  signature A byte array signature.
  42 |     |      * @return           Whether the signature is valid or not.
  43 |     |      */
  44 |     |     function isValidSignature(address signer, bytes32 digest, bytes memory signature) internal view returns (bool) {
  45 |     |         return isValidECDSASignature(signer, digest, signature) || isValidERC1271Signature(signer, digest, signature);
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev    Returns whether an ERC1271 signature is valid for a signer and digest.
  50 |     |      * @param  signer    The address of the account purported to have signed.
  51 |     |      * @param  digest    The hash of the data that was signed.
  52 |     |      * @param  signature A byte array ERC1271 signature.
  53 |     |      * @return           Whether the signature is valid or not.
  54 |     |      */
  55 |     |     function isValidERC1271Signature(
  56 |     |         address signer,
  57 |     |         bytes32 digest,
  58 |     |         bytes memory signature
  59 |     |     ) internal view returns (bool) {
  60 |     |         (bool success_, bytes memory result_) = signer.staticcall(
  61 |     |             abi.encodeCall(IERC1271.isValidSignature, (digest, signature))
  62 |     |         );
  63 |     | 
  64 |     |         return
  65 |     |             success_ &&
  66 |     |             result_.length >= 32 &&
  67 |     |             abi.decode(result_, (bytes32)) == bytes32(IERC1271.isValidSignature.selector);
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev    Decodes an ECDSA/secp256k1 signature from a byte array to standard v, r, and s parameters.
  72 |     |      * @param  signature A byte array ECDSA/secp256k1 signature.
  73 |     |      * @return v         An ECDSA/secp256k1 signature parameter.
  74 |     |      * @return r         An ECDSA/secp256k1 signature parameter.
  75 |     |      * @return s         An ECDSA/secp256k1 signature parameter.
  76 |     |      */
  77 |     |     function decodeECDSASignature(bytes memory signature) internal pure returns (uint8 v, bytes32 r, bytes32 s) {
  78 |     |         // ecrecover takes the signature parameters, and they can be decoded using assembly.
  79 |     |         /// @solidity memory-safe-assembly
  80 |     |         assembly {
  81 |     |             r := mload(add(signature, 0x20))
  82 |     |             s := mload(add(signature, 0x40))
  83 |     |             v := byte(0, mload(add(signature, 0x60)))
  84 |     |         }
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev    Decodes an ECDSA/secp256k1 short signature as defined by EIP2098
  89 |     |      *         from a byte array to standard v, r, and s parameters.
  90 |     |      * @param  signature A byte array ECDSA/secp256k1 short signature.
  91 |     |      * @return r         An ECDSA/secp256k1 signature parameter.
  92 |     |      * @return vs        An ECDSA/secp256k1 short signature parameter.
  93 |     |      */
  94 |     |     function decodeShortECDSASignature(bytes memory signature) internal pure returns (bytes32 r, bytes32 vs) {
  95 |     |         // ecrecover takes the signature parameters, and they can be decoded using assembly.
  96 |     |         /// @solidity memory-safe-assembly
  97 |     |         assembly {
  98 |     |             r := mload(add(signature, 0x20))
  99 |     |             vs := mload(add(signature, 0x40))
 100 |     |         }
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @dev    Returns whether an ECDSA/secp256k1 signature is valid for a signer and digest.
 105 |     |      * @param  signer    The address of the account purported to have signed.
 106 |     |      * @param  digest    The hash of the data that was signed.
 107 |     |      * @param  signature A byte array ECDSA/secp256k1 signature (encoded r, s, v).
 108 |     |      * @return           Whether the signature is valid or not.
 109 |     |      */
 110 |     |     function isValidECDSASignature(
 111 |     |         address signer,
 112 |     |         bytes32 digest,
 113 |     |         bytes memory signature
 114 |     |     ) internal pure returns (bool) {
 115 |     |         if (signature.length == 64) {
 116 |     |             (bytes32 r, bytes32 vs) = decodeShortECDSASignature(signature);
 117 |     |             return isValidECDSASignature(signer, digest, r, vs);
 118 |     |         }
 119 |     | 
 120 |     |         return validateECDSASignature(signer, digest, signature) == Error.NoError;
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev    Returns whether an ECDSA/secp256k1 short signature is valid for a signer and digest.
 125 |     |      * @param  signer The address of the account purported to have signed.
 126 |     |      * @param  digest The hash of the data that was signed.
 127 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
 128 |     |      * @param  vs     An ECDSA/secp256k1 short signature parameter.
 129 |     |      * @return        Whether the signature is valid or not.
 130 |     |      */
 131 |     |     function isValidECDSASignature(address signer, bytes32 digest, bytes32 r, bytes32 vs) internal pure returns (bool) {
 132 |     |         return validateECDSASignature(signer, digest, r, vs) == Error.NoError;
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev    Returns the signer of an ECDSA/secp256k1 signature for some digest.
 137 |     |      * @param  digest    The hash of the data that was signed.
 138 |     |      * @param  signature A byte array ECDSA/secp256k1 signature.
 139 |     |      * @return           An error, if any, that occurred during the signer recovery.
 140 |     |      * @return           The address of the account recovered form the signature (0 if error).
 141 |     |      */
 142 |     |     function recoverECDSASigner(bytes32 digest, bytes memory signature) internal pure returns (Error, address) {
 143 |     |         if (signature.length != 65) return (Error.InvalidSignatureLength, address(0));
 144 |     | 
 145 |     |         (uint8 v, bytes32 r, bytes32 s) = decodeECDSASignature(signature);
 146 |     | 
 147 |     |         return recoverECDSASigner(digest, v, r, s);
 148 |     |     }
 149 |     | 
 150 |     |     /**
 151 |     |      * @dev    Returns the signer of an ECDSA/secp256k1 short signature for some digest.
 152 |     |      * @dev    See https://eips.ethereum.org/EIPS/eip-2098
 153 |     |      * @param  digest The hash of the data that was signed.
 154 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
 155 |     |      * @param  vs     An ECDSA/secp256k1 short signature parameter.
 156 |     |      * @return        An error, if any, that occurred during the signer recovery.
 157 |     |      * @return        The address of the account recovered form the signature (0 if error).
 158 |     |      */
 159 |     |     function recoverECDSASigner(bytes32 digest, bytes32 r, bytes32 vs) internal pure returns (Error, address) {
 160 |     |         unchecked {
 161 |     |             // We do not check for an overflow here since the shift operation results in 0 or 1.
 162 |     |             uint8 v = uint8((uint256(vs) >> 255) + 27);
 163 |     |             bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
 164 |     |             return recoverECDSASigner(digest, v, r, s);
 165 |     |         }
 166 |     |     }
 167 |     | 
 168 |     |     /**
 169 |     |      * @dev    Returns the signer of an ECDSA/secp256k1 signature for some digest.
 170 |     |      * @param  digest The hash of the data that was signed.
 171 |     |      * @param  v      An ECDSA/secp256k1 signature parameter.
 172 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
 173 |     |      * @param  s      An ECDSA/secp256k1 signature parameter.
 174 |     |      * @return        An error, if any, that occurred during the signer recovery.
 175 |     |      * @return signer The address of the account recovered form the signature (0 if error).
 176 |     |      */
 177 |     |     function recoverECDSASigner(
 178 |     |         bytes32 digest,
 179 |     |         uint8 v,
 180 |     |         bytes32 r,
 181 |     |         bytes32 s
 182 |     |     ) internal pure returns (Error, address signer) {
 183 |     |         // Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
 184 |     |         // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}.
 185 |     |         if (uint256(s) > uint256(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0))
 186 |     |             return (Error.InvalidSignatureS, address(0));
 187 |     | 
 188 |     |         if (v != 27 && v != 28) return (Error.InvalidSignatureV, address(0));
 189 |     | 
 190 |     |         signer = ecrecover(digest, v, r, s);
 191 |     | 
 192 |     |         return (signer == address(0)) ? (Error.InvalidSignature, address(0)) : (Error.NoError, signer);
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev    Returns an error, if any, in validating an ECDSA/secp256k1 signature for a signer and digest.
 197 |     |      * @param  signer    The address of the account purported to have signed.
 198 |     |      * @param  digest    The hash of the data that was signed.
 199 |     |      * @param  signature A byte array ERC1271 signature.
 200 |     |      * @return           An error, if any, that occurred during the signer recovery.
 201 |     |      */
 202 |     |     function validateECDSASignature(
 203 |     |         address signer,
 204 |     |         bytes32 digest,
 205 |     |         bytes memory signature
 206 |     |     ) internal pure returns (Error) {
 207 |     |         (Error recoverError, address recoveredSigner) = recoverECDSASigner(digest, signature);
 208 |     | 
 209 |     |         return (recoverError == Error.NoError) ? validateRecoveredSigner(signer, recoveredSigner) : recoverError;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev    Returns an error, if any, in validating an ECDSA/secp256k1 short signature for a signer and digest.
 214 |     |      * @param  signer The address of the account purported to have signed.
 215 |     |      * @param  digest The hash of the data that was signed.
 216 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
 217 |     |      * @param  vs     An ECDSA/secp256k1 short signature parameter.
 218 |     |      * @return        An error, if any, that occurred during the signer recovery.
 219 |     |      */
 220 |     |     function validateECDSASignature(
 221 |     |         address signer,
 222 |     |         bytes32 digest,
 223 |     |         bytes32 r,
 224 |     |         bytes32 vs
 225 |     |     ) internal pure returns (Error) {
 226 |     |         (Error recoverError, address recoveredSigner) = recoverECDSASigner(digest, r, vs);
 227 |     | 
 228 |     |         return (recoverError == Error.NoError) ? validateRecoveredSigner(signer, recoveredSigner) : recoverError;
 229 |     |     }
 230 |     | 
 231 |     |     /**
 232 |     |      * @dev    Returns an error, if any, in validating an ECDSA/secp256k1 signature for a signer and digest.
 233 |     |      * @param  signer The address of the account purported to have signed.
 234 |     |      * @param  digest The hash of the data that was signed.
 235 |     |      * @param  v      An ECDSA/secp256k1 signature parameter.
 236 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
 237 |     |      * @param  s      An ECDSA/secp256k1 signature parameter.
 238 |     |      * @return        An error, if any, that occurred during the signer recovery.
 239 |     |      */
 240 |     |     function validateECDSASignature(
 241 |     |         address signer,
 242 |     |         bytes32 digest,
 243 |     |         uint8 v,
 244 |     |         bytes32 r,
 245 |     |         bytes32 s
 246 |     |     ) internal pure returns (Error) {
 247 |     |         (Error recoverError, address recoveredSigner) = recoverECDSASigner(digest, v, r, s);
 248 |     | 
 249 |     |         return (recoverError == Error.NoError) ? validateRecoveredSigner(signer, recoveredSigner) : recoverError;
 250 |     |     }
 251 |     | 
 252 |     |     /**
 253 |     |      * @dev    Returns an error if `signer` is not `recoveredSigner`.
 254 |     |      * @param  signer          The address of the some signer.
 255 |     |      * @param  recoveredSigner The address of the some recoveredSigner.
 256 |     |      * @return                 An error if `signer` is not `recoveredSigner`.
 257 |     |      */
 258 |     |     function validateRecoveredSigner(address signer, address recoveredSigner) internal pure returns (Error) {
 259 |     |         return (signer == recoveredSigner) ? Error.NoError : Error.SignerMismatch;
 260 |     |     }
 261 |     | }
 262 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/common/src/libs/UIntMath.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity >=0.8.20 <0.9.0;
   4 |     | 
   5 |     | /**
   6 |     |  * @title  Library to perform safe math operations on uint types
   7 |     |  * @author M^0 Labs
   8 |     |  */
   9 |     | library UIntMath {
  10 |     |     /* ============ Custom Errors ============ */
  11 |     | 
  12 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint16.
  13 |     |     error InvalidUInt16();
  14 |     | 
  15 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint32.
  16 |     |     error InvalidUInt32();
  17 |     | 
  18 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint40.
  19 |     |     error InvalidUInt40();
  20 |     | 
  21 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint48.
  22 |     |     error InvalidUInt48();
  23 |     | 
  24 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint112.
  25 |     |     error InvalidUInt112();
  26 |     | 
  27 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint128.
  28 |     |     error InvalidUInt128();
  29 |     | 
  30 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint240.
  31 |     |     error InvalidUInt240();
  32 |     | 
  33 |     |     /* ============ Internal View/Pure Functions ============ */
  34 |     | 
  35 |     |     /**
  36 |     |      * @notice Casts a uint256 value to a uint16, ensuring that it is less than or equal to the maximum uint16 value.
  37 |     |      * @param  n The value to cast.
  38 |     |      * @return The value casted to uint16.
  39 |     |      */
  40 |     |     function safe16(uint256 n) internal pure returns (uint16) {
  41 |     |         if (n > type(uint16).max) revert InvalidUInt16();
  42 |     |         return uint16(n);
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @notice Casts a uint256 value to a uint32, ensuring that it is less than or equal to the maximum uint32 value.
  47 |     |      * @param  n The value to cast.
  48 |     |      * @return The value casted to uint32.
  49 |     |      */
  50 | *   |     function safe32(uint256 n) internal pure returns (uint32) {
  51 | *   |         if (n > type(uint32).max) revert InvalidUInt32();
  52 | *   |         return uint32(n);
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @notice Casts a uint256 value to a uint40, ensuring that it is less than or equal to the maximum uint40 value.
  57 |     |      * @param  n The value to cast.
  58 |     |      * @return The value casted to uint40.
  59 |     |      */
  60 |     |     function safe40(uint256 n) internal pure returns (uint40) {
  61 |     |         if (n > type(uint40).max) revert InvalidUInt40();
  62 |     |         return uint40(n);
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @notice Casts a uint256 value to a uint48, ensuring that it is less than or equal to the maximum uint48 value.
  67 |     |      * @param  n The value to cast.
  68 |     |      * @return The value casted to uint48.
  69 |     |      */
  70 |     |     function safe48(uint256 n) internal pure returns (uint48) {
  71 |     |         if (n > type(uint48).max) revert InvalidUInt48();
  72 |     |         return uint48(n);
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @notice Casts a uint256 value to a uint112, ensuring that it is less than or equal to the maximum uint112 value.
  77 |     |      * @param  n The value to cast.
  78 |     |      * @return The value casted to uint112.
  79 |     |      */
  80 | *   |     function safe112(uint256 n) internal pure returns (uint112) {
  81 | *   |         if (n > type(uint112).max) revert InvalidUInt112();
  82 | *   |         return uint112(n);
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @notice Casts a uint256 value to a uint128, ensuring that it is less than or equal to the maximum uint128 value.
  87 |     |      * @param  n The value to cast.
  88 |     |      * @return The value casted to uint128.
  89 |     |      */
  90 |     |     function safe128(uint256 n) internal pure returns (uint128) {
  91 |     |         if (n > type(uint128).max) revert InvalidUInt128();
  92 |     |         return uint128(n);
  93 |     |     }
  94 |     | 
  95 |     |     /**
  96 |     |      * @notice Casts a uint256 value to a uint240, ensuring that it is less than or equal to the maximum uint240 value.
  97 |     |      * @param  n The value to cast.
  98 |     |      * @return The value casted to uint240.
  99 |     |      */
 100 | *   |     function safe240(uint256 n) internal pure returns (uint240) {
 101 | *   |         if (n > type(uint240).max) revert InvalidUInt240();
 102 | *   |         return uint240(n);
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @notice Limits a uint256 value to the maximum uint32 value.
 107 |     |      * @param  n The value to bound.
 108 |     |      * @return The value limited to within uint32 bounds.
 109 |     |      */
 110 | *   |     function bound32(uint256 n) internal pure returns (uint32) {
 111 | *   |         return uint32(min256(n, uint256(type(uint32).max)));
 112 |     |     }
 113 |     | 
 114 |     |     /**
 115 |     |      * @notice Limits a uint256 value to the maximum uint112 value.
 116 |     |      * @param  n The value to bound.
 117 |     |      * @return The value limited to within uint112 bounds.
 118 |     |      */
 119 |     |     function bound112(uint256 n) internal pure returns (uint112) {
 120 |     |         return uint112(min256(n, uint256(type(uint112).max)));
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @notice Limits a uint256 value to the maximum uint128 value.
 125 |     |      * @param  n The value to bound.
 126 |     |      * @return The value limited to within uint128 bounds.
 127 |     |      */
 128 | *   |     function bound128(uint256 n) internal pure returns (uint128) {
 129 | *   |         return uint128(min256(n, uint256(type(uint128).max)));
 130 |     |     }
 131 |     | 
 132 |     |     /**
 133 |     |      * @notice Limits a uint256 value to the maximum uint240 value.
 134 |     |      * @param  n The value to bound.
 135 |     |      * @return The value limited to within uint240 bounds.
 136 |     |      */
 137 |     |     function bound240(uint256 n) internal pure returns (uint240) {
 138 |     |         return uint240(min256(n, uint256(type(uint240).max)));
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @notice Compares two uint32 values and returns the larger one.
 143 |     |      * @param  a Value to compare.
 144 |     |      * @param  b Value to compare.
 145 |     |      * @return The larger value.
 146 |     |      */
 147 |     |     function max32(uint32 a, uint32 b) internal pure returns (uint32) {
 148 |     |         return a > b ? a : b;
 149 |     |     }
 150 |     | 
 151 |     |     /**
 152 |     |      * @notice Compares two uint40 values and returns the larger one.
 153 |     |      * @param  a Value to compare.
 154 |     |      * @param  b Value to compare.
 155 |     |      * @return The larger value.
 156 |     |      */
 157 |     |     function max40(uint40 a, uint40 b) internal pure returns (uint40) {
 158 |     |         return a > b ? a : b;
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @notice Compares two uint128 values and returns the larger one.
 163 |     |      * @param  a Value to compare.
 164 |     |      * @param  b Value to compare.
 165 |     |      * @return The larger value.
 166 |     |      */
 167 |     |     function max128(uint128 a, uint128 b) internal pure returns (uint128) {
 168 |     |         return a > b ? a : b;
 169 |     |     }
 170 |     | 
 171 |     |     /**
 172 |     |      * @notice Compares two uint240 values and returns the larger one.
 173 |     |      * @param  a Value to compare.
 174 |     |      * @param  b Value to compare.
 175 |     |      * @return The larger value.
 176 |     |      */
 177 |     |     function max240(uint240 a, uint240 b) internal pure returns (uint240) {
 178 |     |         return a > b ? a : b;
 179 |     |     }
 180 |     | 
 181 |     |     /**
 182 |     |      * @notice Compares two uint32 values and returns the lesser one.
 183 |     |      * @param  a Value to compare.
 184 |     |      * @param  b Value to compare.
 185 |     |      * @return The lesser value.
 186 |     |      */
 187 |     |     function min32(uint32 a, uint32 b) internal pure returns (uint32) {
 188 |     |         return a < b ? a : b;
 189 |     |     }
 190 |     | 
 191 |     |     /**
 192 |     |      * @notice Compares two uint40 values and returns the lesser one.
 193 |     |      * @param  a Value to compare.
 194 |     |      * @param  b Value to compare.
 195 |     |      * @return The lesser value.
 196 |     |      */
 197 |     |     function min40(uint40 a, uint40 b) internal pure returns (uint40) {
 198 |     |         return a < b ? a : b;
 199 |     |     }
 200 |     | 
 201 |     |     /**
 202 |     |      * @notice Compares two uint240 values and returns the lesser one.
 203 |     |      * @param  a Value to compare.
 204 |     |      * @param  b Value to compare.
 205 |     |      * @return The lesser value.
 206 |     |      */
 207 |     |     function min240(uint240 a, uint240 b) internal pure returns (uint240) {
 208 |     |         return a < b ? a : b;
 209 |     |     }
 210 |     | 
 211 |     |     /**
 212 |     |      * @notice Compares two uint112 values and returns the lesser one.
 213 |     |      * @param  a Value to compare.
 214 |     |      * @param  b Value to compare.
 215 |     |      * @return The lesser value.
 216 |     |      */
 217 |     |     function min112(uint112 a, uint112 b) internal pure returns (uint112) {
 218 |     |         return a < b ? a : b;
 219 |     |     }
 220 |     | 
 221 |     |     /**
 222 |     |      * @notice Compares two uint256 values and returns the lesser one.
 223 |     |      * @param  a Value to compare.
 224 |     |      * @param  b Value to compare.
 225 |     |      * @return The lesser value.
 226 |     |      */
 227 | *   |     function min256(uint256 a, uint256 b) internal pure returns (uint256) {
 228 | *   |         return a < b ? a : b;
 229 |     |     }
 230 |     | }
 231 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/Base.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | import {StdStorage} from "./StdStorage.sol";
  5 |     | import {Vm, VmSafe} from "./Vm.sol";
  6 |     | 
  7 |     | abstract contract CommonBase {
  8 |     |     /// @dev Cheat code address.
  9 |     |     /// Calculated as `address(uint160(uint256(keccak256("hevm cheat code"))))`.
 10 | *   |     address internal constant VM_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;
 11 |     |     /// @dev console.sol and console2.sol work by executing a staticcall to this address.
 12 |     |     /// Calculated as `address(uint160(uint88(bytes11("console.log"))))`.
 13 |     |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
 14 |     |     /// @dev Used when deploying with create2.
 15 |     |     /// Taken from https://github.com/Arachnid/deterministic-deployment-proxy.
 16 |     |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
 17 |     |     /// @dev The default address for tx.origin and msg.sender.
 18 |     |     /// Calculated as `address(uint160(uint256(keccak256("foundry default caller"))))`.
 19 |     |     address internal constant DEFAULT_SENDER = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;
 20 |     |     /// @dev The address of the first contract `CREATE`d by a running test contract.
 21 |     |     /// When running tests, each test contract is `CREATE`d by `DEFAULT_SENDER` with nonce 1.
 22 |     |     /// Calculated as `VM.computeCreateAddress(VM.computeCreateAddress(DEFAULT_SENDER, 1), 1)`.
 23 |     |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
 24 |     |     /// @dev Deterministic deployment address of the Multicall3 contract.
 25 |     |     /// Taken from https://www.multicall3.com.
 26 |     |     address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;
 27 |     |     /// @dev The order of the secp256k1 curve.
 28 |     |     uint256 internal constant SECP256K1_ORDER =
 29 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
 30 |     | 
 31 |     |     uint256 internal constant UINT256_MAX =
 32 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
 33 |     | 
 34 |     |     Vm internal constant vm = Vm(VM_ADDRESS);
 35 |     |     StdStorage internal stdstore;
 36 |     | }
 37 |     | 
 38 |     | abstract contract TestBase is CommonBase {}
 39 |     | 
 40 |     | abstract contract ScriptBase is CommonBase {
 41 |     |     VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);
 42 |     | }
 43 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/StdAssertions.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | pragma experimental ABIEncoderV2;
   4 |     | 
   5 |     | import {Vm} from "./Vm.sol";
   6 |     | 
   7 |     | abstract contract StdAssertions {
   8 | *   |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
   9 |     | 
  10 |     |     event log(string);
  11 |     |     event logs(bytes);
  12 |     | 
  13 |     |     event log_address(address);
  14 |     |     event log_bytes32(bytes32);
  15 |     |     event log_int(int256);
  16 |     |     event log_uint(uint256);
  17 |     |     event log_bytes(bytes);
  18 |     |     event log_string(string);
  19 |     | 
  20 |     |     event log_named_address(string key, address val);
  21 |     |     event log_named_bytes32(string key, bytes32 val);
  22 |     |     event log_named_decimal_int(string key, int256 val, uint256 decimals);
  23 |     |     event log_named_decimal_uint(string key, uint256 val, uint256 decimals);
  24 |     |     event log_named_int(string key, int256 val);
  25 |     |     event log_named_uint(string key, uint256 val);
  26 |     |     event log_named_bytes(string key, bytes val);
  27 |     |     event log_named_string(string key, string val);
  28 |     | 
  29 |     |     event log_array(uint256[] val);
  30 |     |     event log_array(int256[] val);
  31 |     |     event log_array(address[] val);
  32 |     |     event log_named_array(string key, uint256[] val);
  33 |     |     event log_named_array(string key, int256[] val);
  34 |     |     event log_named_array(string key, address[] val);
  35 |     | 
  36 |     |     bool private _failed;
  37 |     | 
  38 |     |     function failed() public view returns (bool) {
  39 |     |         if (_failed) {
  40 |     |             return _failed;
  41 |     |         } else {
  42 |     |             return vm.load(address(vm), bytes32("failed")) != bytes32(0);
  43 |     |         }
  44 |     |     }
  45 |     | 
  46 |     |     function fail() internal virtual {
  47 |     |         vm.store(address(vm), bytes32("failed"), bytes32(uint256(1)));
  48 |     |         _failed = true;
  49 |     |     }
  50 |     | 
  51 |     |     function assertTrue(bool data) internal pure virtual {
  52 |     |         vm.assertTrue(data);
  53 |     |     }
  54 |     | 
  55 | *   |     function assertTrue(bool data, string memory err) internal pure virtual {
  56 | *   |         vm.assertTrue(data, err);
  57 |     |     }
  58 |     | 
  59 |     |     function assertFalse(bool data) internal pure virtual {
  60 |     |         vm.assertFalse(data);
  61 |     |     }
  62 |     | 
  63 |     |     function assertFalse(bool data, string memory err) internal pure virtual {
  64 |     |         vm.assertFalse(data, err);
  65 |     |     }
  66 |     | 
  67 |     |     function assertEq(bool left, bool right) internal pure virtual {
  68 |     |         vm.assertEq(left, right);
  69 |     |     }
  70 |     | 
  71 |     |     function assertEq(bool left, bool right, string memory err) internal pure virtual {
  72 |     |         vm.assertEq(left, right, err);
  73 |     |     }
  74 |     | 
  75 |     |     function assertEq(uint256 left, uint256 right) internal pure virtual {
  76 |     |         vm.assertEq(left, right);
  77 |     |     }
  78 |     | 
  79 |     |     function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {
  80 |     |         vm.assertEq(left, right, err);
  81 |     |     }
  82 |     | 
  83 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
  84 |     |         vm.assertEqDecimal(left, right, decimals);
  85 |     |     }
  86 |     | 
  87 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
  88 |     |         vm.assertEqDecimal(left, right, decimals, err);
  89 |     |     }
  90 |     | 
  91 |     |     function assertEq(int256 left, int256 right) internal pure virtual {
  92 |     |         vm.assertEq(left, right);
  93 |     |     }
  94 |     | 
  95 |     |     function assertEq(int256 left, int256 right, string memory err) internal pure virtual {
  96 |     |         vm.assertEq(left, right, err);
  97 |     |     }
  98 |     | 
  99 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 100 |     |         vm.assertEqDecimal(left, right, decimals);
 101 |     |     }
 102 |     | 
 103 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 104 |     |         vm.assertEqDecimal(left, right, decimals, err);
 105 |     |     }
 106 |     | 
 107 |     |     function assertEq(address left, address right) internal pure virtual {
 108 |     |         vm.assertEq(left, right);
 109 |     |     }
 110 |     | 
 111 |     |     function assertEq(address left, address right, string memory err) internal pure virtual {
 112 |     |         vm.assertEq(left, right, err);
 113 |     |     }
 114 |     | 
 115 |     |     function assertEq(bytes32 left, bytes32 right) internal pure virtual {
 116 |     |         vm.assertEq(left, right);
 117 |     |     }
 118 |     | 
 119 |     |     function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 120 |     |         vm.assertEq(left, right, err);
 121 |     |     }
 122 |     | 
 123 |     |     function assertEq32(bytes32 left, bytes32 right) internal pure virtual {
 124 |     |         assertEq(left, right);
 125 |     |     }
 126 |     | 
 127 |     |     function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 128 |     |         assertEq(left, right, err);
 129 |     |     }
 130 |     | 
 131 |     |     function assertEq(string memory left, string memory right) internal pure virtual {
 132 |     |         vm.assertEq(left, right);
 133 |     |     }
 134 |     | 
 135 |     |     function assertEq(string memory left, string memory right, string memory err) internal pure virtual {
 136 |     |         vm.assertEq(left, right, err);
 137 |     |     }
 138 |     | 
 139 |     |     function assertEq(bytes memory left, bytes memory right) internal pure virtual {
 140 |     |         vm.assertEq(left, right);
 141 |     |     }
 142 |     | 
 143 |     |     function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 144 |     |         vm.assertEq(left, right, err);
 145 |     |     }
 146 |     | 
 147 |     |     function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {
 148 |     |         vm.assertEq(left, right);
 149 |     |     }
 150 |     | 
 151 |     |     function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {
 152 |     |         vm.assertEq(left, right, err);
 153 |     |     }
 154 |     | 
 155 |     |     function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {
 156 |     |         vm.assertEq(left, right);
 157 |     |     }
 158 |     | 
 159 |     |     function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {
 160 |     |         vm.assertEq(left, right, err);
 161 |     |     }
 162 |     | 
 163 |     |     function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {
 164 |     |         vm.assertEq(left, right);
 165 |     |     }
 166 |     | 
 167 |     |     function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {
 168 |     |         vm.assertEq(left, right, err);
 169 |     |     }
 170 |     | 
 171 |     |     function assertEq(address[] memory left, address[] memory right) internal pure virtual {
 172 |     |         vm.assertEq(left, right);
 173 |     |     }
 174 |     | 
 175 |     |     function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {
 176 |     |         vm.assertEq(left, right, err);
 177 |     |     }
 178 |     | 
 179 |     |     function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {
 180 |     |         vm.assertEq(left, right);
 181 |     |     }
 182 |     | 
 183 |     |     function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {
 184 |     |         vm.assertEq(left, right, err);
 185 |     |     }
 186 |     | 
 187 |     |     function assertEq(string[] memory left, string[] memory right) internal pure virtual {
 188 |     |         vm.assertEq(left, right);
 189 |     |     }
 190 |     | 
 191 |     |     function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {
 192 |     |         vm.assertEq(left, right, err);
 193 |     |     }
 194 |     | 
 195 |     |     function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {
 196 |     |         vm.assertEq(left, right);
 197 |     |     }
 198 |     | 
 199 |     |     function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {
 200 |     |         vm.assertEq(left, right, err);
 201 |     |     }
 202 |     | 
 203 |     |     // Legacy helper
 204 |     |     function assertEqUint(uint256 left, uint256 right) internal pure virtual {
 205 |     |         assertEq(left, right);
 206 |     |     }
 207 |     | 
 208 |     |     function assertNotEq(bool left, bool right) internal pure virtual {
 209 |     |         vm.assertNotEq(left, right);
 210 |     |     }
 211 |     | 
 212 |     |     function assertNotEq(bool left, bool right, string memory err) internal pure virtual {
 213 |     |         vm.assertNotEq(left, right, err);
 214 |     |     }
 215 |     | 
 216 |     |     function assertNotEq(uint256 left, uint256 right) internal pure virtual {
 217 |     |         vm.assertNotEq(left, right);
 218 |     |     }
 219 |     | 
 220 |     |     function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {
 221 |     |         vm.assertNotEq(left, right, err);
 222 |     |     }
 223 |     | 
 224 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 225 |     |         vm.assertNotEqDecimal(left, right, decimals);
 226 |     |     }
 227 |     | 
 228 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)
 229 |     |         internal
 230 |     |         pure
 231 |     |         virtual
 232 |     |     {
 233 |     |         vm.assertNotEqDecimal(left, right, decimals, err);
 234 |     |     }
 235 |     | 
 236 |     |     function assertNotEq(int256 left, int256 right) internal pure virtual {
 237 |     |         vm.assertNotEq(left, right);
 238 |     |     }
 239 |     | 
 240 |     |     function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {
 241 |     |         vm.assertNotEq(left, right, err);
 242 |     |     }
 243 |     | 
 244 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 245 |     |         vm.assertNotEqDecimal(left, right, decimals);
 246 |     |     }
 247 |     | 
 248 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 249 |     |         vm.assertNotEqDecimal(left, right, decimals, err);
 250 |     |     }
 251 |     | 
 252 |     |     function assertNotEq(address left, address right) internal pure virtual {
 253 |     |         vm.assertNotEq(left, right);
 254 |     |     }
 255 |     | 
 256 |     |     function assertNotEq(address left, address right, string memory err) internal pure virtual {
 257 |     |         vm.assertNotEq(left, right, err);
 258 |     |     }
 259 |     | 
 260 |     |     function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {
 261 |     |         vm.assertNotEq(left, right);
 262 |     |     }
 263 |     | 
 264 |     |     function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 265 |     |         vm.assertNotEq(left, right, err);
 266 |     |     }
 267 |     | 
 268 |     |     function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {
 269 |     |         assertNotEq(left, right);
 270 |     |     }
 271 |     | 
 272 |     |     function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 273 |     |         assertNotEq(left, right, err);
 274 |     |     }
 275 |     | 
 276 |     |     function assertNotEq(string memory left, string memory right) internal pure virtual {
 277 |     |         vm.assertNotEq(left, right);
 278 |     |     }
 279 |     | 
 280 |     |     function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {
 281 |     |         vm.assertNotEq(left, right, err);
 282 |     |     }
 283 |     | 
 284 |     |     function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {
 285 |     |         vm.assertNotEq(left, right);
 286 |     |     }
 287 |     | 
 288 |     |     function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 289 |     |         vm.assertNotEq(left, right, err);
 290 |     |     }
 291 |     | 
 292 |     |     function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {
 293 |     |         vm.assertNotEq(left, right);
 294 |     |     }
 295 |     | 
 296 |     |     function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {
 297 |     |         vm.assertNotEq(left, right, err);
 298 |     |     }
 299 |     | 
 300 |     |     function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {
 301 |     |         vm.assertNotEq(left, right);
 302 |     |     }
 303 |     | 
 304 |     |     function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {
 305 |     |         vm.assertNotEq(left, right, err);
 306 |     |     }
 307 |     | 
 308 |     |     function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {
 309 |     |         vm.assertNotEq(left, right);
 310 |     |     }
 311 |     | 
 312 |     |     function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {
 313 |     |         vm.assertNotEq(left, right, err);
 314 |     |     }
 315 |     | 
 316 |     |     function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {
 317 |     |         vm.assertNotEq(left, right);
 318 |     |     }
 319 |     | 
 320 |     |     function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {
 321 |     |         vm.assertNotEq(left, right, err);
 322 |     |     }
 323 |     | 
 324 |     |     function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {
 325 |     |         vm.assertNotEq(left, right);
 326 |     |     }
 327 |     | 
 328 |     |     function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {
 329 |     |         vm.assertNotEq(left, right, err);
 330 |     |     }
 331 |     | 
 332 |     |     function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {
 333 |     |         vm.assertNotEq(left, right);
 334 |     |     }
 335 |     | 
 336 |     |     function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {
 337 |     |         vm.assertNotEq(left, right, err);
 338 |     |     }
 339 |     | 
 340 |     |     function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {
 341 |     |         vm.assertNotEq(left, right);
 342 |     |     }
 343 |     | 
 344 |     |     function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {
 345 |     |         vm.assertNotEq(left, right, err);
 346 |     |     }
 347 |     | 
 348 |     |     function assertLt(uint256 left, uint256 right) internal pure virtual {
 349 |     |         vm.assertLt(left, right);
 350 |     |     }
 351 |     | 
 352 |     |     function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {
 353 |     |         vm.assertLt(left, right, err);
 354 |     |     }
 355 |     | 
 356 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 357 |     |         vm.assertLtDecimal(left, right, decimals);
 358 |     |     }
 359 |     | 
 360 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 361 |     |         vm.assertLtDecimal(left, right, decimals, err);
 362 |     |     }
 363 |     | 
 364 |     |     function assertLt(int256 left, int256 right) internal pure virtual {
 365 |     |         vm.assertLt(left, right);
 366 |     |     }
 367 |     | 
 368 |     |     function assertLt(int256 left, int256 right, string memory err) internal pure virtual {
 369 |     |         vm.assertLt(left, right, err);
 370 |     |     }
 371 |     | 
 372 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 373 |     |         vm.assertLtDecimal(left, right, decimals);
 374 |     |     }
 375 |     | 
 376 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 377 |     |         vm.assertLtDecimal(left, right, decimals, err);
 378 |     |     }
 379 |     | 
 380 |     |     function assertGt(uint256 left, uint256 right) internal pure virtual {
 381 |     |         vm.assertGt(left, right);
 382 |     |     }
 383 |     | 
 384 |     |     function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {
 385 |     |         vm.assertGt(left, right, err);
 386 |     |     }
 387 |     | 
 388 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 389 |     |         vm.assertGtDecimal(left, right, decimals);
 390 |     |     }
 391 |     | 
 392 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 393 |     |         vm.assertGtDecimal(left, right, decimals, err);
 394 |     |     }
 395 |     | 
 396 |     |     function assertGt(int256 left, int256 right) internal pure virtual {
 397 |     |         vm.assertGt(left, right);
 398 |     |     }
 399 |     | 
 400 |     |     function assertGt(int256 left, int256 right, string memory err) internal pure virtual {
 401 |     |         vm.assertGt(left, right, err);
 402 |     |     }
 403 |     | 
 404 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 405 |     |         vm.assertGtDecimal(left, right, decimals);
 406 |     |     }
 407 |     | 
 408 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 409 |     |         vm.assertGtDecimal(left, right, decimals, err);
 410 |     |     }
 411 |     | 
 412 |     |     function assertLe(uint256 left, uint256 right) internal pure virtual {
 413 |     |         vm.assertLe(left, right);
 414 |     |     }
 415 |     | 
 416 |     |     function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {
 417 |     |         vm.assertLe(left, right, err);
 418 |     |     }
 419 |     | 
 420 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 421 |     |         vm.assertLeDecimal(left, right, decimals);
 422 |     |     }
 423 |     | 
 424 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 425 |     |         vm.assertLeDecimal(left, right, decimals, err);
 426 |     |     }
 427 |     | 
 428 |     |     function assertLe(int256 left, int256 right) internal pure virtual {
 429 |     |         vm.assertLe(left, right);
 430 |     |     }
 431 |     | 
 432 |     |     function assertLe(int256 left, int256 right, string memory err) internal pure virtual {
 433 |     |         vm.assertLe(left, right, err);
 434 |     |     }
 435 |     | 
 436 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 437 |     |         vm.assertLeDecimal(left, right, decimals);
 438 |     |     }
 439 |     | 
 440 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 441 |     |         vm.assertLeDecimal(left, right, decimals, err);
 442 |     |     }
 443 |     | 
 444 |     |     function assertGe(uint256 left, uint256 right) internal pure virtual {
 445 |     |         vm.assertGe(left, right);
 446 |     |     }
 447 |     | 
 448 |     |     function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {
 449 |     |         vm.assertGe(left, right, err);
 450 |     |     }
 451 |     | 
 452 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 453 |     |         vm.assertGeDecimal(left, right, decimals);
 454 |     |     }
 455 |     | 
 456 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 457 |     |         vm.assertGeDecimal(left, right, decimals, err);
 458 |     |     }
 459 |     | 
 460 |     |     function assertGe(int256 left, int256 right) internal pure virtual {
 461 |     |         vm.assertGe(left, right);
 462 |     |     }
 463 |     | 
 464 |     |     function assertGe(int256 left, int256 right, string memory err) internal pure virtual {
 465 |     |         vm.assertGe(left, right, err);
 466 |     |     }
 467 |     | 
 468 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 469 |     |         vm.assertGeDecimal(left, right, decimals);
 470 |     |     }
 471 |     | 
 472 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 473 |     |         vm.assertGeDecimal(left, right, decimals, err);
 474 |     |     }
 475 |     | 
 476 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {
 477 |     |         vm.assertApproxEqAbs(left, right, maxDelta);
 478 |     |     }
 479 |     | 
 480 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err)
 481 |     |         internal
 482 |     |         pure
 483 |     |         virtual
 484 |     |     {
 485 |     |         vm.assertApproxEqAbs(left, right, maxDelta, err);
 486 |     |     }
 487 |     | 
 488 |     |     function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)
 489 |     |         internal
 490 |     |         pure
 491 |     |         virtual
 492 |     |     {
 493 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);
 494 |     |     }
 495 |     | 
 496 |     |     function assertApproxEqAbsDecimal(
 497 |     |         uint256 left,
 498 |     |         uint256 right,
 499 |     |         uint256 maxDelta,
 500 |     |         uint256 decimals,
 501 |     |         string memory err
 502 |     |     ) internal pure virtual {
 503 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);
 504 |     |     }
 505 |     | 
 506 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {
 507 |     |         vm.assertApproxEqAbs(left, right, maxDelta);
 508 |     |     }
 509 |     | 
 510 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {
 511 |     |         vm.assertApproxEqAbs(left, right, maxDelta, err);
 512 |     |     }
 513 |     | 
 514 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)
 515 |     |         internal
 516 |     |         pure
 517 |     |         virtual
 518 |     |     {
 519 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);
 520 |     |     }
 521 |     | 
 522 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)
 523 |     |         internal
 524 |     |         pure
 525 |     |         virtual
 526 |     |     {
 527 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);
 528 |     |     }
 529 |     | 
 530 |     |     function assertApproxEqRel(
 531 |     |         uint256 left,
 532 |     |         uint256 right,
 533 |     |         uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%
 534 |     |     ) internal pure virtual {
 535 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta);
 536 |     |     }
 537 |     | 
 538 |     |     function assertApproxEqRel(
 539 |     |         uint256 left,
 540 |     |         uint256 right,
 541 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 542 |     |         string memory err
 543 |     |     ) internal pure virtual {
 544 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta, err);
 545 |     |     }
 546 |     | 
 547 |     |     function assertApproxEqRelDecimal(
 548 |     |         uint256 left,
 549 |     |         uint256 right,
 550 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 551 |     |         uint256 decimals
 552 |     |     ) internal pure virtual {
 553 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);
 554 |     |     }
 555 |     | 
 556 |     |     function assertApproxEqRelDecimal(
 557 |     |         uint256 left,
 558 |     |         uint256 right,
 559 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 560 |     |         uint256 decimals,
 561 |     |         string memory err
 562 |     |     ) internal pure virtual {
 563 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);
 564 |     |     }
 565 |     | 
 566 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {
 567 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta);
 568 |     |     }
 569 |     | 
 570 |     |     function assertApproxEqRel(
 571 |     |         int256 left,
 572 |     |         int256 right,
 573 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 574 |     |         string memory err
 575 |     |     ) internal pure virtual {
 576 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta, err);
 577 |     |     }
 578 |     | 
 579 |     |     function assertApproxEqRelDecimal(
 580 |     |         int256 left,
 581 |     |         int256 right,
 582 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 583 |     |         uint256 decimals
 584 |     |     ) internal pure virtual {
 585 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);
 586 |     |     }
 587 |     | 
 588 |     |     function assertApproxEqRelDecimal(
 589 |     |         int256 left,
 590 |     |         int256 right,
 591 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 592 |     |         uint256 decimals,
 593 |     |         string memory err
 594 |     |     ) internal pure virtual {
 595 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);
 596 |     |     }
 597 |     | 
 598 |     |     // Inherited from DSTest, not used but kept for backwards-compatibility
 599 |     |     function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {
 600 |     |         return keccak256(left) == keccak256(right);
 601 |     |     }
 602 |     | 
 603 |     |     function assertEq0(bytes memory left, bytes memory right) internal pure virtual {
 604 |     |         assertEq(left, right);
 605 |     |     }
 606 |     | 
 607 |     |     function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 608 |     |         assertEq(left, right, err);
 609 |     |     }
 610 |     | 
 611 |     |     function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {
 612 |     |         assertNotEq(left, right);
 613 |     |     }
 614 |     | 
 615 |     |     function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 616 |     |         assertNotEq(left, right, err);
 617 |     |     }
 618 |     | 
 619 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {
 620 |     |         assertEqCall(target, callDataA, target, callDataB, true);
 621 |     |     }
 622 |     | 
 623 |     |     function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)
 624 |     |         internal
 625 |     |         virtual
 626 |     |     {
 627 |     |         assertEqCall(targetA, callDataA, targetB, callDataB, true);
 628 |     |     }
 629 |     | 
 630 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)
 631 |     |         internal
 632 |     |         virtual
 633 |     |     {
 634 |     |         assertEqCall(target, callDataA, target, callDataB, strictRevertData);
 635 |     |     }
 636 |     | 
 637 |     |     function assertEqCall(
 638 |     |         address targetA,
 639 |     |         bytes memory callDataA,
 640 |     |         address targetB,
 641 |     |         bytes memory callDataB,
 642 |     |         bool strictRevertData
 643 |     |     ) internal virtual {
 644 |     |         (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);
 645 |     |         (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);
 646 |     | 
 647 |     |         if (successA && successB) {
 648 |     |             assertEq(returnDataA, returnDataB, "Call return data does not match");
 649 |     |         }
 650 |     | 
 651 |     |         if (!successA && !successB && strictRevertData) {
 652 |     |             assertEq(returnDataA, returnDataB, "Call revert data does not match");
 653 |     |         }
 654 |     | 
 655 |     |         if (!successA && successB) {
 656 |     |             emit log("Error: Calls were not equal");
 657 |     |             emit log_named_bytes("  Left call revert data", returnDataA);
 658 |     |             emit log_named_bytes(" Right call return data", returnDataB);
 659 |     |             revert("assertion failed");
 660 |     |         }
 661 |     | 
 662 |     |         if (successA && !successB) {
 663 |     |             emit log("Error: Calls were not equal");
 664 |     |             emit log_named_bytes("  Left call return data", returnDataA);
 665 |     |             emit log_named_bytes(" Right call revert data", returnDataB);
 666 |     |             revert("assertion failed");
 667 |     |         }
 668 |     |     }
 669 |     | }
 670 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/StdChains.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {VmSafe} from "./Vm.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * StdChains provides information about EVM compatible chains that can be used in scripts/tests.
   8 |     |  * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are
   9 |     |  * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of
  10 |     |  * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the
  11 |     |  * alias used in this contract, which can be found as the first argument to the
  12 |     |  * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.
  13 |     |  *
  14 |     |  * There are two main ways to use this contract:
  15 |     |  *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or
  16 |     |  *      `setChain(string memory chainAlias, Chain memory chain)`
  17 |     |  *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.
  18 |     |  *
  19 |     |  * The first time either of those are used, chains are initialized with the default set of RPC URLs.
  20 |     |  * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in
  21 |     |  * `defaultRpcUrls`.
  22 |     |  *
  23 |     |  * The `setChain` function is straightforward, and it simply saves off the given chain data.
  24 |     |  *
  25 |     |  * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say
  26 |     |  * we want to retrieve the RPC URL for `mainnet`:
  27 |     |  *   - If you have specified data with `setChain`, it will return that.
  28 |     |  *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it
  29 |     |  *     is valid (e.g. a URL is specified, or an environment variable is given and exists).
  30 |     |  *   - If neither of the above conditions is met, the default data is returned.
  31 |     |  *
  32 |     |  * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.
  33 |     |  */
  34 |     | abstract contract StdChains {
  35 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  36 |     | 
  37 |     |     bool private stdChainsInitialized;
  38 |     | 
  39 |     |     struct ChainData {
  40 |     |         string name;
  41 |     |         uint256 chainId;
  42 |     |         string rpcUrl;
  43 |     |     }
  44 |     | 
  45 |     |     struct Chain {
  46 |     |         // The chain name.
  47 |     |         string name;
  48 |     |         // The chain's Chain ID.
  49 |     |         uint256 chainId;
  50 |     |         // The chain's alias. (i.e. what gets specified in `foundry.toml`).
  51 |     |         string chainAlias;
  52 |     |         // A default RPC endpoint for this chain.
  53 |     |         // NOTE: This default RPC URL is included for convenience to facilitate quick tests and
  54 |     |         // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy
  55 |     |         // usage as you will be throttled and this is a disservice to others who need this endpoint.
  56 |     |         string rpcUrl;
  57 |     |     }
  58 |     | 
  59 |     |     // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.
  60 |     |     mapping(string => Chain) private chains;
  61 |     |     // Maps from the chain's alias to it's default RPC URL.
  62 |     |     mapping(string => string) private defaultRpcUrls;
  63 |     |     // Maps from a chain ID to it's alias.
  64 |     |     mapping(uint256 => string) private idToAlias;
  65 |     | 
  66 | *   |     bool private fallbackToDefaultRpcUrls = true;
  67 |     | 
  68 |     |     // The RPC URL will be fetched from config or defaultRpcUrls if possible.
  69 |     |     function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {
  70 |     |         require(bytes(chainAlias).length != 0, "StdChains getChain(string): Chain alias cannot be the empty string.");
  71 |     | 
  72 |     |         initializeStdChains();
  73 |     |         chain = chains[chainAlias];
  74 |     |         require(
  75 |     |             chain.chainId != 0,
  76 |     |             string(abi.encodePacked("StdChains getChain(string): Chain with alias \"", chainAlias, "\" not found."))
  77 |     |         );
  78 |     | 
  79 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  80 |     |     }
  81 |     | 
  82 |     |     function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {
  83 |     |         require(chainId != 0, "StdChains getChain(uint256): Chain ID cannot be 0.");
  84 |     |         initializeStdChains();
  85 |     |         string memory chainAlias = idToAlias[chainId];
  86 |     | 
  87 |     |         chain = chains[chainAlias];
  88 |     | 
  89 |     |         require(
  90 |     |             chain.chainId != 0,
  91 |     |             string(abi.encodePacked("StdChains getChain(uint256): Chain with ID ", vm.toString(chainId), " not found."))
  92 |     |         );
  93 |     | 
  94 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  95 |     |     }
  96 |     | 
  97 |     |     // set chain info, with priority to argument's rpcUrl field.
  98 |     |     function setChain(string memory chainAlias, ChainData memory chain) internal virtual {
  99 |     |         require(
 100 |     |             bytes(chainAlias).length != 0,
 101 |     |             "StdChains setChain(string,ChainData): Chain alias cannot be the empty string."
 102 |     |         );
 103 |     | 
 104 |     |         require(chain.chainId != 0, "StdChains setChain(string,ChainData): Chain ID cannot be 0.");
 105 |     | 
 106 |     |         initializeStdChains();
 107 |     |         string memory foundAlias = idToAlias[chain.chainId];
 108 |     | 
 109 |     |         require(
 110 |     |             bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),
 111 |     |             string(
 112 |     |                 abi.encodePacked(
 113 |     |                     "StdChains setChain(string,ChainData): Chain ID ",
 114 |     |                     vm.toString(chain.chainId),
 115 |     |                     " already used by \"",
 116 |     |                     foundAlias,
 117 |     |                     "\"."
 118 |     |                 )
 119 |     |             )
 120 |     |         );
 121 |     | 
 122 |     |         uint256 oldChainId = chains[chainAlias].chainId;
 123 |     |         delete idToAlias[oldChainId];
 124 |     | 
 125 |     |         chains[chainAlias] =
 126 |     |             Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});
 127 |     |         idToAlias[chain.chainId] = chainAlias;
 128 |     |     }
 129 |     | 
 130 |     |     // set chain info, with priority to argument's rpcUrl field.
 131 |     |     function setChain(string memory chainAlias, Chain memory chain) internal virtual {
 132 |     |         setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));
 133 |     |     }
 134 |     | 
 135 |     |     function _toUpper(string memory str) private pure returns (string memory) {
 136 |     |         bytes memory strb = bytes(str);
 137 |     |         bytes memory copy = new bytes(strb.length);
 138 |     |         for (uint256 i = 0; i < strb.length; i++) {
 139 |     |             bytes1 b = strb[i];
 140 |     |             if (b >= 0x61 && b <= 0x7A) {
 141 |     |                 copy[i] = bytes1(uint8(b) - 32);
 142 |     |             } else {
 143 |     |                 copy[i] = b;
 144 |     |             }
 145 |     |         }
 146 |     |         return string(copy);
 147 |     |     }
 148 |     | 
 149 |     |     // lookup rpcUrl, in descending order of priority:
 150 |     |     // current -> config (foundry.toml) -> environment variable -> default
 151 |     |     function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)
 152 |     |         private
 153 |     |         view
 154 |     |         returns (Chain memory)
 155 |     |     {
 156 |     |         if (bytes(chain.rpcUrl).length == 0) {
 157 |     |             try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {
 158 |     |                 chain.rpcUrl = configRpcUrl;
 159 |     |             } catch (bytes memory err) {
 160 |     |                 string memory envName = string(abi.encodePacked(_toUpper(chainAlias), "_RPC_URL"));
 161 |     |                 if (fallbackToDefaultRpcUrls) {
 162 |     |                     chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);
 163 |     |                 } else {
 164 |     |                     chain.rpcUrl = vm.envString(envName);
 165 |     |                 }
 166 |     |                 // Distinguish 'not found' from 'cannot read'
 167 |     |                 // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions
 168 |     |                 bytes memory oldNotFoundError =
 169 |     |                     abi.encodeWithSignature("CheatCodeError", string(abi.encodePacked("invalid rpc url ", chainAlias)));
 170 |     |                 bytes memory newNotFoundError = abi.encodeWithSignature(
 171 |     |                     "CheatcodeError(string)", string(abi.encodePacked("invalid rpc url: ", chainAlias))
 172 |     |                 );
 173 |     |                 bytes32 errHash = keccak256(err);
 174 |     |                 if (
 175 |     |                     (errHash != keccak256(oldNotFoundError) && errHash != keccak256(newNotFoundError))
 176 |     |                         || bytes(chain.rpcUrl).length == 0
 177 |     |                 ) {
 178 |     |                     /// @solidity memory-safe-assembly
 179 |     |                     assembly {
 180 |     |                         revert(add(32, err), mload(err))
 181 |     |                     }
 182 |     |                 }
 183 |     |             }
 184 |     |         }
 185 |     |         return chain;
 186 |     |     }
 187 |     | 
 188 |     |     function setFallbackToDefaultRpcUrls(bool useDefault) internal {
 189 |     |         fallbackToDefaultRpcUrls = useDefault;
 190 |     |     }
 191 |     | 
 192 |     |     function initializeStdChains() private {
 193 |     |         if (stdChainsInitialized) return;
 194 |     | 
 195 |     |         stdChainsInitialized = true;
 196 |     | 
 197 |     |         // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`
 198 |     |         setChainWithDefaultRpcUrl("anvil", ChainData("Anvil", 31337, "http://127.0.0.1:8545"));
 199 |     |         setChainWithDefaultRpcUrl("mainnet", ChainData("Mainnet", 1, "https://eth.llamarpc.com"));
 200 |     |         setChainWithDefaultRpcUrl(
 201 |     |             "sepolia", ChainData("Sepolia", 11155111, "https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001")
 202 |     |         );
 203 |     |         setChainWithDefaultRpcUrl("holesky", ChainData("Holesky", 17000, "https://rpc.holesky.ethpandaops.io"));
 204 |     |         setChainWithDefaultRpcUrl("hoodi", ChainData("Hoodi", 560048, "https://rpc.hoodi.ethpandaops.io"));
 205 |     |         setChainWithDefaultRpcUrl("optimism", ChainData("Optimism", 10, "https://mainnet.optimism.io"));
 206 |     |         setChainWithDefaultRpcUrl(
 207 |     |             "optimism_sepolia", ChainData("Optimism Sepolia", 11155420, "https://sepolia.optimism.io")
 208 |     |         );
 209 |     |         setChainWithDefaultRpcUrl("arbitrum_one", ChainData("Arbitrum One", 42161, "https://arb1.arbitrum.io/rpc"));
 210 |     |         setChainWithDefaultRpcUrl(
 211 |     |             "arbitrum_one_sepolia", ChainData("Arbitrum One Sepolia", 421614, "https://sepolia-rollup.arbitrum.io/rpc")
 212 |     |         );
 213 |     |         setChainWithDefaultRpcUrl("arbitrum_nova", ChainData("Arbitrum Nova", 42170, "https://nova.arbitrum.io/rpc"));
 214 |     |         setChainWithDefaultRpcUrl("polygon", ChainData("Polygon", 137, "https://polygon-rpc.com"));
 215 |     |         setChainWithDefaultRpcUrl(
 216 |     |             "polygon_amoy", ChainData("Polygon Amoy", 80002, "https://rpc-amoy.polygon.technology")
 217 |     |         );
 218 |     |         setChainWithDefaultRpcUrl("avalanche", ChainData("Avalanche", 43114, "https://api.avax.network/ext/bc/C/rpc"));
 219 |     |         setChainWithDefaultRpcUrl(
 220 |     |             "avalanche_fuji", ChainData("Avalanche Fuji", 43113, "https://api.avax-test.network/ext/bc/C/rpc")
 221 |     |         );
 222 |     |         setChainWithDefaultRpcUrl(
 223 |     |             "bnb_smart_chain", ChainData("BNB Smart Chain", 56, "https://bsc-dataseed1.binance.org")
 224 |     |         );
 225 |     |         setChainWithDefaultRpcUrl(
 226 |     |             "bnb_smart_chain_testnet",
 227 |     |             ChainData("BNB Smart Chain Testnet", 97, "https://rpc.ankr.com/bsc_testnet_chapel")
 228 |     |         );
 229 |     |         setChainWithDefaultRpcUrl("gnosis_chain", ChainData("Gnosis Chain", 100, "https://rpc.gnosischain.com"));
 230 |     |         setChainWithDefaultRpcUrl("moonbeam", ChainData("Moonbeam", 1284, "https://rpc.api.moonbeam.network"));
 231 |     |         setChainWithDefaultRpcUrl(
 232 |     |             "moonriver", ChainData("Moonriver", 1285, "https://rpc.api.moonriver.moonbeam.network")
 233 |     |         );
 234 |     |         setChainWithDefaultRpcUrl("moonbase", ChainData("Moonbase", 1287, "https://rpc.testnet.moonbeam.network"));
 235 |     |         setChainWithDefaultRpcUrl("base_sepolia", ChainData("Base Sepolia", 84532, "https://sepolia.base.org"));
 236 |     |         setChainWithDefaultRpcUrl("base", ChainData("Base", 8453, "https://mainnet.base.org"));
 237 |     |         setChainWithDefaultRpcUrl("blast_sepolia", ChainData("Blast Sepolia", 168587773, "https://sepolia.blast.io"));
 238 |     |         setChainWithDefaultRpcUrl("blast", ChainData("Blast", 81457, "https://rpc.blast.io"));
 239 |     |         setChainWithDefaultRpcUrl("fantom_opera", ChainData("Fantom Opera", 250, "https://rpc.ankr.com/fantom/"));
 240 |     |         setChainWithDefaultRpcUrl(
 241 |     |             "fantom_opera_testnet", ChainData("Fantom Opera Testnet", 4002, "https://rpc.ankr.com/fantom_testnet/")
 242 |     |         );
 243 |     |         setChainWithDefaultRpcUrl("fraxtal", ChainData("Fraxtal", 252, "https://rpc.frax.com"));
 244 |     |         setChainWithDefaultRpcUrl("fraxtal_testnet", ChainData("Fraxtal Testnet", 2522, "https://rpc.testnet.frax.com"));
 245 |     |         setChainWithDefaultRpcUrl(
 246 |     |             "berachain_bartio_testnet", ChainData("Berachain bArtio Testnet", 80084, "https://bartio.rpc.berachain.com")
 247 |     |         );
 248 |     |         setChainWithDefaultRpcUrl("flare", ChainData("Flare", 14, "https://flare-api.flare.network/ext/C/rpc"));
 249 |     |         setChainWithDefaultRpcUrl(
 250 |     |             "flare_coston2", ChainData("Flare Coston2", 114, "https://coston2-api.flare.network/ext/C/rpc")
 251 |     |         );
 252 |     | 
 253 |     |         setChainWithDefaultRpcUrl("mode", ChainData("Mode", 34443, "https://mode.drpc.org"));
 254 |     |         setChainWithDefaultRpcUrl("mode_sepolia", ChainData("Mode Sepolia", 919, "https://sepolia.mode.network"));
 255 |     | 
 256 |     |         setChainWithDefaultRpcUrl("zora", ChainData("Zora", 7777777, "https://zora.drpc.org"));
 257 |     |         setChainWithDefaultRpcUrl(
 258 |     |             "zora_sepolia", ChainData("Zora Sepolia", 999999999, "https://sepolia.rpc.zora.energy")
 259 |     |         );
 260 |     | 
 261 |     |         setChainWithDefaultRpcUrl("race", ChainData("Race", 6805, "https://racemainnet.io"));
 262 |     |         setChainWithDefaultRpcUrl("race_sepolia", ChainData("Race Sepolia", 6806, "https://racemainnet.io"));
 263 |     | 
 264 |     |         setChainWithDefaultRpcUrl("metal", ChainData("Metal", 1750, "https://metall2.drpc.org"));
 265 |     |         setChainWithDefaultRpcUrl("metal_sepolia", ChainData("Metal Sepolia", 1740, "https://testnet.rpc.metall2.com"));
 266 |     | 
 267 |     |         setChainWithDefaultRpcUrl("binary", ChainData("Binary", 624, "https://rpc.zero.thebinaryholdings.com"));
 268 |     |         setChainWithDefaultRpcUrl(
 269 |     |             "binary_sepolia", ChainData("Binary Sepolia", 625, "https://rpc.zero.thebinaryholdings.com")
 270 |     |         );
 271 |     | 
 272 |     |         setChainWithDefaultRpcUrl("orderly", ChainData("Orderly", 291, "https://rpc.orderly.network"));
 273 |     |         setChainWithDefaultRpcUrl(
 274 |     |             "orderly_sepolia", ChainData("Orderly Sepolia", 4460, "https://testnet-rpc.orderly.org")
 275 |     |         );
 276 |     |     }
 277 |     | 
 278 |     |     // set chain info, with priority to chainAlias' rpc url in foundry.toml
 279 |     |     function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {
 280 |     |         string memory rpcUrl = chain.rpcUrl;
 281 |     |         defaultRpcUrls[chainAlias] = rpcUrl;
 282 |     |         chain.rpcUrl = "";
 283 |     |         setChain(chainAlias, chain);
 284 |     |         chain.rpcUrl = rpcUrl; // restore argument
 285 |     |     }
 286 |     | }
 287 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/StdCheats.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
   7 |     | import {console2} from "./console2.sol";
   8 |     | import {Vm} from "./Vm.sol";
   9 |     | 
  10 |     | abstract contract StdCheatsSafe {
  11 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  12 |     | 
  13 |     |     uint256 private constant UINT256_MAX =
  14 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  15 |     | 
  16 |     |     bool private gasMeteringOff;
  17 |     | 
  18 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  19 |     |     // that conform to EIP1559. The Raw structs is what is parsed from the JSON
  20 |     |     // and then converted to the one that is used by the user for better UX.
  21 |     | 
  22 |     |     struct RawTx1559 {
  23 |     |         string[] arguments;
  24 |     |         address contractAddress;
  25 |     |         string contractName;
  26 |     |         // json value name = function
  27 |     |         string functionSig;
  28 |     |         bytes32 hash;
  29 |     |         // json value name = tx
  30 |     |         RawTx1559Detail txDetail;
  31 |     |         // json value name = type
  32 |     |         string opcode;
  33 |     |     }
  34 |     | 
  35 |     |     struct RawTx1559Detail {
  36 |     |         AccessList[] accessList;
  37 |     |         bytes data;
  38 |     |         address from;
  39 |     |         bytes gas;
  40 |     |         bytes nonce;
  41 |     |         address to;
  42 |     |         bytes txType;
  43 |     |         bytes value;
  44 |     |     }
  45 |     | 
  46 |     |     struct Tx1559 {
  47 |     |         string[] arguments;
  48 |     |         address contractAddress;
  49 |     |         string contractName;
  50 |     |         string functionSig;
  51 |     |         bytes32 hash;
  52 |     |         Tx1559Detail txDetail;
  53 |     |         string opcode;
  54 |     |     }
  55 |     | 
  56 |     |     struct Tx1559Detail {
  57 |     |         AccessList[] accessList;
  58 |     |         bytes data;
  59 |     |         address from;
  60 |     |         uint256 gas;
  61 |     |         uint256 nonce;
  62 |     |         address to;
  63 |     |         uint256 txType;
  64 |     |         uint256 value;
  65 |     |     }
  66 |     | 
  67 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  68 |     |     // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON
  69 |     |     // and then converted to the one that is used by the user for better UX.
  70 |     | 
  71 |     |     struct TxLegacy {
  72 |     |         string[] arguments;
  73 |     |         address contractAddress;
  74 |     |         string contractName;
  75 |     |         string functionSig;
  76 |     |         string hash;
  77 |     |         string opcode;
  78 |     |         TxDetailLegacy transaction;
  79 |     |     }
  80 |     | 
  81 |     |     struct TxDetailLegacy {
  82 |     |         AccessList[] accessList;
  83 |     |         uint256 chainId;
  84 |     |         bytes data;
  85 |     |         address from;
  86 |     |         uint256 gas;
  87 |     |         uint256 gasPrice;
  88 |     |         bytes32 hash;
  89 |     |         uint256 nonce;
  90 |     |         bytes1 opcode;
  91 |     |         bytes32 r;
  92 |     |         bytes32 s;
  93 |     |         uint256 txType;
  94 |     |         address to;
  95 |     |         uint8 v;
  96 |     |         uint256 value;
  97 |     |     }
  98 |     | 
  99 |     |     struct AccessList {
 100 |     |         address accessAddress;
 101 |     |         bytes32[] storageKeys;
 102 |     |     }
 103 |     | 
 104 |     |     // Data structures to parse Receipt objects from the broadcast artifact.
 105 |     |     // The Raw structs is what is parsed from the JSON
 106 |     |     // and then converted to the one that is used by the user for better UX.
 107 |     | 
 108 |     |     struct RawReceipt {
 109 |     |         bytes32 blockHash;
 110 |     |         bytes blockNumber;
 111 |     |         address contractAddress;
 112 |     |         bytes cumulativeGasUsed;
 113 |     |         bytes effectiveGasPrice;
 114 |     |         address from;
 115 |     |         bytes gasUsed;
 116 |     |         RawReceiptLog[] logs;
 117 |     |         bytes logsBloom;
 118 |     |         bytes status;
 119 |     |         address to;
 120 |     |         bytes32 transactionHash;
 121 |     |         bytes transactionIndex;
 122 |     |     }
 123 |     | 
 124 |     |     struct Receipt {
 125 |     |         bytes32 blockHash;
 126 |     |         uint256 blockNumber;
 127 |     |         address contractAddress;
 128 |     |         uint256 cumulativeGasUsed;
 129 |     |         uint256 effectiveGasPrice;
 130 |     |         address from;
 131 |     |         uint256 gasUsed;
 132 |     |         ReceiptLog[] logs;
 133 |     |         bytes logsBloom;
 134 |     |         uint256 status;
 135 |     |         address to;
 136 |     |         bytes32 transactionHash;
 137 |     |         uint256 transactionIndex;
 138 |     |     }
 139 |     | 
 140 |     |     // Data structures to parse the entire broadcast artifact, assuming the
 141 |     |     // transactions conform to EIP1559.
 142 |     | 
 143 |     |     struct EIP1559ScriptArtifact {
 144 |     |         string[] libraries;
 145 |     |         string path;
 146 |     |         string[] pending;
 147 |     |         Receipt[] receipts;
 148 |     |         uint256 timestamp;
 149 |     |         Tx1559[] transactions;
 150 |     |         TxReturn[] txReturns;
 151 |     |     }
 152 |     | 
 153 |     |     struct RawEIP1559ScriptArtifact {
 154 |     |         string[] libraries;
 155 |     |         string path;
 156 |     |         string[] pending;
 157 |     |         RawReceipt[] receipts;
 158 |     |         TxReturn[] txReturns;
 159 |     |         uint256 timestamp;
 160 |     |         RawTx1559[] transactions;
 161 |     |     }
 162 |     | 
 163 |     |     struct RawReceiptLog {
 164 |     |         // json value = address
 165 |     |         address logAddress;
 166 |     |         bytes32 blockHash;
 167 |     |         bytes blockNumber;
 168 |     |         bytes data;
 169 |     |         bytes logIndex;
 170 |     |         bool removed;
 171 |     |         bytes32[] topics;
 172 |     |         bytes32 transactionHash;
 173 |     |         bytes transactionIndex;
 174 |     |         bytes transactionLogIndex;
 175 |     |     }
 176 |     | 
 177 |     |     struct ReceiptLog {
 178 |     |         // json value = address
 179 |     |         address logAddress;
 180 |     |         bytes32 blockHash;
 181 |     |         uint256 blockNumber;
 182 |     |         bytes data;
 183 |     |         uint256 logIndex;
 184 |     |         bytes32[] topics;
 185 |     |         uint256 transactionIndex;
 186 |     |         uint256 transactionLogIndex;
 187 |     |         bool removed;
 188 |     |     }
 189 |     | 
 190 |     |     struct TxReturn {
 191 |     |         string internalType;
 192 |     |         string value;
 193 |     |     }
 194 |     | 
 195 |     |     struct Account {
 196 |     |         address addr;
 197 |     |         uint256 key;
 198 |     |     }
 199 |     | 
 200 |     |     enum AddressType {
 201 |     |         Payable,
 202 |     |         NonPayable,
 203 |     |         ZeroAddress,
 204 |     |         Precompile,
 205 |     |         ForgeAddress
 206 |     |     }
 207 |     | 
 208 |     |     // Checks that `addr` is not blacklisted by token contracts that have a blacklist.
 209 |     |     function assumeNotBlacklisted(address token, address addr) internal view virtual {
 210 |     |         // Nothing to check if `token` is not a contract.
 211 |     |         uint256 tokenCodeSize;
 212 |     |         assembly {
 213 |     |             tokenCodeSize := extcodesize(token)
 214 |     |         }
 215 |     |         require(tokenCodeSize > 0, "StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.");
 216 |     | 
 217 |     |         bool success;
 218 |     |         bytes memory returnData;
 219 |     | 
 220 |     |         // 4-byte selector for `isBlacklisted(address)`, used by USDC.
 221 |     |         (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));
 222 |     |         vm.assume(!success || abi.decode(returnData, (bool)) == false);
 223 |     | 
 224 |     |         // 4-byte selector for `isBlackListed(address)`, used by USDT.
 225 |     |         (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));
 226 |     |         vm.assume(!success || abi.decode(returnData, (bool)) == false);
 227 |     |     }
 228 |     | 
 229 |     |     // Checks that `addr` is not blacklisted by token contracts that have a blacklist.
 230 |     |     // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for
 231 |     |     // backwards compatibility, since this name was used in the original PR which already has
 232 |     |     // a release. This function can be removed in a future release once we want a breaking change.
 233 |     |     function assumeNoBlacklisted(address token, address addr) internal view virtual {
 234 |     |         assumeNotBlacklisted(token, addr);
 235 |     |     }
 236 |     | 
 237 |     |     function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {
 238 |     |         if (addressType == AddressType.Payable) {
 239 |     |             assumeNotPayable(addr);
 240 |     |         } else if (addressType == AddressType.NonPayable) {
 241 |     |             assumePayable(addr);
 242 |     |         } else if (addressType == AddressType.ZeroAddress) {
 243 |     |             assumeNotZeroAddress(addr);
 244 |     |         } else if (addressType == AddressType.Precompile) {
 245 |     |             assumeNotPrecompile(addr);
 246 |     |         } else if (addressType == AddressType.ForgeAddress) {
 247 |     |             assumeNotForgeAddress(addr);
 248 |     |         }
 249 |     |     }
 250 |     | 
 251 |     |     function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {
 252 |     |         assumeAddressIsNot(addr, addressType1);
 253 |     |         assumeAddressIsNot(addr, addressType2);
 254 |     |     }
 255 |     | 
 256 |     |     function assumeAddressIsNot(
 257 |     |         address addr,
 258 |     |         AddressType addressType1,
 259 |     |         AddressType addressType2,
 260 |     |         AddressType addressType3
 261 |     |     ) internal virtual {
 262 |     |         assumeAddressIsNot(addr, addressType1);
 263 |     |         assumeAddressIsNot(addr, addressType2);
 264 |     |         assumeAddressIsNot(addr, addressType3);
 265 |     |     }
 266 |     | 
 267 |     |     function assumeAddressIsNot(
 268 |     |         address addr,
 269 |     |         AddressType addressType1,
 270 |     |         AddressType addressType2,
 271 |     |         AddressType addressType3,
 272 |     |         AddressType addressType4
 273 |     |     ) internal virtual {
 274 |     |         assumeAddressIsNot(addr, addressType1);
 275 |     |         assumeAddressIsNot(addr, addressType2);
 276 |     |         assumeAddressIsNot(addr, addressType3);
 277 |     |         assumeAddressIsNot(addr, addressType4);
 278 |     |     }
 279 |     | 
 280 |     |     // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to
 281 |     |     // `addr` and checking the `success` return value.
 282 |     |     // NOTE: This function may result in state changes depending on the fallback/receive logic
 283 |     |     // implemented by `addr`, which should be taken into account when this function is used.
 284 |     |     function _isPayable(address addr) private returns (bool) {
 285 |     |         require(
 286 |     |             addr.balance < UINT256_MAX,
 287 |     |             "StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds"
 288 |     |         );
 289 |     |         uint256 origBalanceTest = address(this).balance;
 290 |     |         uint256 origBalanceAddr = address(addr).balance;
 291 |     | 
 292 |     |         vm.deal(address(this), 1);
 293 |     |         (bool success,) = payable(addr).call{value: 1}("");
 294 |     | 
 295 |     |         // reset balances
 296 |     |         vm.deal(address(this), origBalanceTest);
 297 |     |         vm.deal(addr, origBalanceAddr);
 298 |     | 
 299 |     |         return success;
 300 |     |     }
 301 |     | 
 302 |     |     // NOTE: This function may result in state changes depending on the fallback/receive logic
 303 |     |     // implemented by `addr`, which should be taken into account when this function is used. See the
 304 |     |     // `_isPayable` method for more information.
 305 |     |     function assumePayable(address addr) internal virtual {
 306 |     |         vm.assume(_isPayable(addr));
 307 |     |     }
 308 |     | 
 309 |     |     function assumeNotPayable(address addr) internal virtual {
 310 |     |         vm.assume(!_isPayable(addr));
 311 |     |     }
 312 |     | 
 313 |     |     function assumeNotZeroAddress(address addr) internal pure virtual {
 314 |     |         vm.assume(addr != address(0));
 315 |     |     }
 316 |     | 
 317 |     |     function assumeNotPrecompile(address addr) internal pure virtual {
 318 |     |         assumeNotPrecompile(addr, _pureChainId());
 319 |     |     }
 320 |     | 
 321 |     |     function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {
 322 |     |         // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific
 323 |     |         // address), but the same rationale for excluding them applies so we include those too.
 324 |     | 
 325 |     |         // These are reserved by Ethereum and may be on all EVM-compatible chains.
 326 |     |         vm.assume(addr < address(0x1) || addr > address(0xff));
 327 |     | 
 328 |     |         // forgefmt: disable-start
 329 |     |         if (chainId == 10 || chainId == 420) {
 330 |     |             // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21
 331 |     |             vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));
 332 |     |         } else if (chainId == 42161 || chainId == 421613) {
 333 |     |             // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains
 334 |     |             vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));
 335 |     |         } else if (chainId == 43114 || chainId == 43113) {
 336 |     |             // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59
 337 |     |             vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));
 338 |     |             vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));
 339 |     |             vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));
 340 |     |         }
 341 |     |         // forgefmt: disable-end
 342 |     |     }
 343 |     | 
 344 |     |     function assumeNotForgeAddress(address addr) internal pure virtual {
 345 |     |         // vm, console, and Create2Deployer addresses
 346 |     |         vm.assume(
 347 |     |             addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67
 348 |     |                 && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C
 349 |     |         );
 350 |     |     }
 351 |     | 
 352 |     |     function assumeUnusedAddress(address addr) internal view virtual {
 353 |     |         uint256 size;
 354 |     |         assembly {
 355 |     |             size := extcodesize(addr)
 356 |     |         }
 357 |     |         vm.assume(size == 0);
 358 |     | 
 359 |     |         assumeNotPrecompile(addr);
 360 |     |         assumeNotZeroAddress(addr);
 361 |     |         assumeNotForgeAddress(addr);
 362 |     |     }
 363 |     | 
 364 |     |     function readEIP1559ScriptArtifact(string memory path)
 365 |     |         internal
 366 |     |         view
 367 |     |         virtual
 368 |     |         returns (EIP1559ScriptArtifact memory)
 369 |     |     {
 370 |     |         string memory data = vm.readFile(path);
 371 |     |         bytes memory parsedData = vm.parseJson(data);
 372 |     |         RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));
 373 |     |         EIP1559ScriptArtifact memory artifact;
 374 |     |         artifact.libraries = rawArtifact.libraries;
 375 |     |         artifact.path = rawArtifact.path;
 376 |     |         artifact.timestamp = rawArtifact.timestamp;
 377 |     |         artifact.pending = rawArtifact.pending;
 378 |     |         artifact.txReturns = rawArtifact.txReturns;
 379 |     |         artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);
 380 |     |         artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);
 381 |     |         return artifact;
 382 |     |     }
 383 |     | 
 384 |     |     function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {
 385 |     |         Tx1559[] memory txs = new Tx1559[](rawTxs.length);
 386 |     |         for (uint256 i; i < rawTxs.length; i++) {
 387 |     |             txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);
 388 |     |         }
 389 |     |         return txs;
 390 |     |     }
 391 |     | 
 392 |     |     function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {
 393 |     |         Tx1559 memory transaction;
 394 |     |         transaction.arguments = rawTx.arguments;
 395 |     |         transaction.contractName = rawTx.contractName;
 396 |     |         transaction.functionSig = rawTx.functionSig;
 397 |     |         transaction.hash = rawTx.hash;
 398 |     |         transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);
 399 |     |         transaction.opcode = rawTx.opcode;
 400 |     |         return transaction;
 401 |     |     }
 402 |     | 
 403 |     |     function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)
 404 |     |         internal
 405 |     |         pure
 406 |     |         virtual
 407 |     |         returns (Tx1559Detail memory)
 408 |     |     {
 409 |     |         Tx1559Detail memory txDetail;
 410 |     |         txDetail.data = rawDetail.data;
 411 |     |         txDetail.from = rawDetail.from;
 412 |     |         txDetail.to = rawDetail.to;
 413 |     |         txDetail.nonce = _bytesToUint(rawDetail.nonce);
 414 |     |         txDetail.txType = _bytesToUint(rawDetail.txType);
 415 |     |         txDetail.value = _bytesToUint(rawDetail.value);
 416 |     |         txDetail.gas = _bytesToUint(rawDetail.gas);
 417 |     |         txDetail.accessList = rawDetail.accessList;
 418 |     |         return txDetail;
 419 |     |     }
 420 |     | 
 421 |     |     function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {
 422 |     |         string memory deployData = vm.readFile(path);
 423 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".transactions");
 424 |     |         RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));
 425 |     |         return rawToConvertedEIPTx1559s(rawTxs);
 426 |     |     }
 427 |     | 
 428 |     |     function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {
 429 |     |         string memory deployData = vm.readFile(path);
 430 |     |         string memory key = string(abi.encodePacked(".transactions[", vm.toString(index), "]"));
 431 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 432 |     |         RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));
 433 |     |         return rawToConvertedEIPTx1559(rawTx);
 434 |     |     }
 435 |     | 
 436 |     |     // Analogous to readTransactions, but for receipts.
 437 |     |     function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {
 438 |     |         string memory deployData = vm.readFile(path);
 439 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".receipts");
 440 |     |         RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));
 441 |     |         return rawToConvertedReceipts(rawReceipts);
 442 |     |     }
 443 |     | 
 444 |     |     function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {
 445 |     |         string memory deployData = vm.readFile(path);
 446 |     |         string memory key = string(abi.encodePacked(".receipts[", vm.toString(index), "]"));
 447 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 448 |     |         RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));
 449 |     |         return rawToConvertedReceipt(rawReceipt);
 450 |     |     }
 451 |     | 
 452 |     |     function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {
 453 |     |         Receipt[] memory receipts = new Receipt[](rawReceipts.length);
 454 |     |         for (uint256 i; i < rawReceipts.length; i++) {
 455 |     |             receipts[i] = rawToConvertedReceipt(rawReceipts[i]);
 456 |     |         }
 457 |     |         return receipts;
 458 |     |     }
 459 |     | 
 460 |     |     function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {
 461 |     |         Receipt memory receipt;
 462 |     |         receipt.blockHash = rawReceipt.blockHash;
 463 |     |         receipt.to = rawReceipt.to;
 464 |     |         receipt.from = rawReceipt.from;
 465 |     |         receipt.contractAddress = rawReceipt.contractAddress;
 466 |     |         receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);
 467 |     |         receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);
 468 |     |         receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);
 469 |     |         receipt.status = _bytesToUint(rawReceipt.status);
 470 |     |         receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);
 471 |     |         receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);
 472 |     |         receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);
 473 |     |         receipt.logsBloom = rawReceipt.logsBloom;
 474 |     |         receipt.transactionHash = rawReceipt.transactionHash;
 475 |     |         return receipt;
 476 |     |     }
 477 |     | 
 478 |     |     function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)
 479 |     |         internal
 480 |     |         pure
 481 |     |         virtual
 482 |     |         returns (ReceiptLog[] memory)
 483 |     |     {
 484 |     |         ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);
 485 |     |         for (uint256 i; i < rawLogs.length; i++) {
 486 |     |             logs[i].logAddress = rawLogs[i].logAddress;
 487 |     |             logs[i].blockHash = rawLogs[i].blockHash;
 488 |     |             logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);
 489 |     |             logs[i].data = rawLogs[i].data;
 490 |     |             logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);
 491 |     |             logs[i].topics = rawLogs[i].topics;
 492 |     |             logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);
 493 |     |             logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);
 494 |     |             logs[i].removed = rawLogs[i].removed;
 495 |     |         }
 496 |     |         return logs;
 497 |     |     }
 498 |     | 
 499 |     |     // Deploy a contract by fetching the contract bytecode from
 500 |     |     // the artifacts directory
 501 |     |     // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`
 502 |     |     function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {
 503 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 504 |     |         /// @solidity memory-safe-assembly
 505 |     |         assembly {
 506 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 507 |     |         }
 508 |     | 
 509 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes): Deployment failed.");
 510 |     |     }
 511 |     | 
 512 |     |     function deployCode(string memory what) internal virtual returns (address addr) {
 513 |     |         bytes memory bytecode = vm.getCode(what);
 514 |     |         /// @solidity memory-safe-assembly
 515 |     |         assembly {
 516 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 517 |     |         }
 518 |     | 
 519 |     |         require(addr != address(0), "StdCheats deployCode(string): Deployment failed.");
 520 |     |     }
 521 |     | 
 522 |     |     /// @dev deploy contract with value on construction
 523 |     |     function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {
 524 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 525 |     |         /// @solidity memory-safe-assembly
 526 |     |         assembly {
 527 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 528 |     |         }
 529 |     | 
 530 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes,uint256): Deployment failed.");
 531 |     |     }
 532 |     | 
 533 |     |     function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {
 534 |     |         bytes memory bytecode = vm.getCode(what);
 535 |     |         /// @solidity memory-safe-assembly
 536 |     |         assembly {
 537 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 538 |     |         }
 539 |     | 
 540 |     |         require(addr != address(0), "StdCheats deployCode(string,uint256): Deployment failed.");
 541 |     |     }
 542 |     | 
 543 |     |     // creates a labeled address and the corresponding private key
 544 |     |     function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {
 545 |     |         privateKey = uint256(keccak256(abi.encodePacked(name)));
 546 |     |         addr = vm.addr(privateKey);
 547 |     |         vm.label(addr, name);
 548 |     |     }
 549 |     | 
 550 |     |     // creates a labeled address
 551 |     |     function makeAddr(string memory name) internal virtual returns (address addr) {
 552 |     |         (addr,) = makeAddrAndKey(name);
 553 |     |     }
 554 |     | 
 555 |     |     // Destroys an account immediately, sending the balance to beneficiary.
 556 |     |     // Destroying means: balance will be zero, code will be empty, and nonce will be 0
 557 |     |     // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce
 558 |     |     // only after tx ends, this will run immediately.
 559 |     |     function destroyAccount(address who, address beneficiary) internal virtual {
 560 |     |         uint256 currBalance = who.balance;
 561 |     |         vm.etch(who, abi.encode());
 562 |     |         vm.deal(who, 0);
 563 |     |         vm.resetNonce(who);
 564 |     | 
 565 |     |         uint256 beneficiaryBalance = beneficiary.balance;
 566 |     |         vm.deal(beneficiary, currBalance + beneficiaryBalance);
 567 |     |     }
 568 |     | 
 569 |     |     // creates a struct containing both a labeled address and the corresponding private key
 570 |     |     function makeAccount(string memory name) internal virtual returns (Account memory account) {
 571 |     |         (account.addr, account.key) = makeAddrAndKey(name);
 572 |     |     }
 573 |     | 
 574 |     |     function deriveRememberKey(string memory mnemonic, uint32 index)
 575 |     |         internal
 576 |     |         virtual
 577 |     |         returns (address who, uint256 privateKey)
 578 |     |     {
 579 |     |         privateKey = vm.deriveKey(mnemonic, index);
 580 |     |         who = vm.rememberKey(privateKey);
 581 |     |     }
 582 |     | 
 583 |     |     function _bytesToUint(bytes memory b) private pure returns (uint256) {
 584 |     |         require(b.length <= 32, "StdCheats _bytesToUint(bytes): Bytes length exceeds 32.");
 585 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
 586 |     |     }
 587 |     | 
 588 |     |     function isFork() internal view virtual returns (bool status) {
 589 |     |         try vm.activeFork() {
 590 |     |             status = true;
 591 |     |         } catch (bytes memory) {}
 592 |     |     }
 593 |     | 
 594 |     |     modifier skipWhenForking() {
 595 |     |         if (!isFork()) {
 596 |     |             _;
 597 |     |         }
 598 |     |     }
 599 |     | 
 600 |     |     modifier skipWhenNotForking() {
 601 |     |         if (isFork()) {
 602 |     |             _;
 603 |     |         }
 604 |     |     }
 605 |     | 
 606 |     |     modifier noGasMetering() {
 607 |     |         vm.pauseGasMetering();
 608 |     |         // To prevent turning gas monitoring back on with nested functions that use this modifier,
 609 |     |         // we check if gasMetering started in the off position. If it did, we don't want to turn
 610 |     |         // it back on until we exit the top level function that used the modifier
 611 |     |         //
 612 |     |         // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.
 613 |     |         // funcA will have `gasStartedOff` as false, funcB will have it as true,
 614 |     |         // so we only turn metering back on at the end of the funcA
 615 |     |         bool gasStartedOff = gasMeteringOff;
 616 |     |         gasMeteringOff = true;
 617 |     | 
 618 |     |         _;
 619 |     | 
 620 |     |         // if gas metering was on when this modifier was called, turn it back on at the end
 621 |     |         if (!gasStartedOff) {
 622 |     |             gasMeteringOff = false;
 623 |     |             vm.resumeGasMetering();
 624 |     |         }
 625 |     |     }
 626 |     | 
 627 |     |     // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no
 628 |     |     // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We
 629 |     |     // can't simply access the chain ID in a normal view or pure function because the solc View Pure
 630 |     |     // Checker changed `chainid` from pure to view in 0.8.0.
 631 |     |     function _viewChainId() private view returns (uint256 chainId) {
 632 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 633 |     |         assembly {
 634 |     |             chainId := chainid()
 635 |     |         }
 636 |     | 
 637 |     |         address(this); // Silence warnings in older Solc versions.
 638 |     |     }
 639 |     | 
 640 |     |     function _pureChainId() private pure returns (uint256 chainId) {
 641 |     |         function() internal view returns (uint256) fnIn = _viewChainId;
 642 |     |         function() internal pure returns (uint256) pureChainId;
 643 |     |         assembly {
 644 |     |             pureChainId := fnIn
 645 |     |         }
 646 |     |         chainId = pureChainId();
 647 |     |     }
 648 |     | }
 649 |     | 
 650 |     | // Wrappers around cheatcodes to avoid footguns
 651 |     | abstract contract StdCheats is StdCheatsSafe {
 652 |     |     using stdStorage for StdStorage;
 653 |     | 
 654 |     |     StdStorage private stdstore;
 655 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 656 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
 657 |     | 
 658 |     |     // Skip forward or rewind time by the specified number of seconds
 659 |     |     function skip(uint256 time) internal virtual {
 660 |     |         vm.warp(vm.getBlockTimestamp() + time);
 661 |     |     }
 662 |     | 
 663 |     |     function rewind(uint256 time) internal virtual {
 664 |     |         vm.warp(vm.getBlockTimestamp() - time);
 665 |     |     }
 666 |     | 
 667 |     |     // Setup a prank from an address that has some ether
 668 |     |     function hoax(address msgSender) internal virtual {
 669 |     |         vm.deal(msgSender, 1 << 128);
 670 |     |         vm.prank(msgSender);
 671 |     |     }
 672 |     | 
 673 |     |     function hoax(address msgSender, uint256 give) internal virtual {
 674 |     |         vm.deal(msgSender, give);
 675 |     |         vm.prank(msgSender);
 676 |     |     }
 677 |     | 
 678 |     |     function hoax(address msgSender, address origin) internal virtual {
 679 |     |         vm.deal(msgSender, 1 << 128);
 680 |     |         vm.prank(msgSender, origin);
 681 |     |     }
 682 |     | 
 683 |     |     function hoax(address msgSender, address origin, uint256 give) internal virtual {
 684 |     |         vm.deal(msgSender, give);
 685 |     |         vm.prank(msgSender, origin);
 686 |     |     }
 687 |     | 
 688 |     |     // Start perpetual prank from an address that has some ether
 689 |     |     function startHoax(address msgSender) internal virtual {
 690 |     |         vm.deal(msgSender, 1 << 128);
 691 |     |         vm.startPrank(msgSender);
 692 |     |     }
 693 |     | 
 694 |     |     function startHoax(address msgSender, uint256 give) internal virtual {
 695 |     |         vm.deal(msgSender, give);
 696 |     |         vm.startPrank(msgSender);
 697 |     |     }
 698 |     | 
 699 |     |     // Start perpetual prank from an address that has some ether
 700 |     |     // tx.origin is set to the origin parameter
 701 |     |     function startHoax(address msgSender, address origin) internal virtual {
 702 |     |         vm.deal(msgSender, 1 << 128);
 703 |     |         vm.startPrank(msgSender, origin);
 704 |     |     }
 705 |     | 
 706 |     |     function startHoax(address msgSender, address origin, uint256 give) internal virtual {
 707 |     |         vm.deal(msgSender, give);
 708 |     |         vm.startPrank(msgSender, origin);
 709 |     |     }
 710 |     | 
 711 |     |     function changePrank(address msgSender) internal virtual {
 712 |     |         console2_log_StdCheats("changePrank is deprecated. Please use vm.startPrank instead.");
 713 |     |         vm.stopPrank();
 714 |     |         vm.startPrank(msgSender);
 715 |     |     }
 716 |     | 
 717 |     |     function changePrank(address msgSender, address txOrigin) internal virtual {
 718 |     |         vm.stopPrank();
 719 |     |         vm.startPrank(msgSender, txOrigin);
 720 |     |     }
 721 |     | 
 722 |     |     // The same as Vm's `deal`
 723 |     |     // Use the alternative signature for ERC20 tokens
 724 |     |     function deal(address to, uint256 give) internal virtual {
 725 |     |         vm.deal(to, give);
 726 |     |     }
 727 |     | 
 728 |     |     // Set the balance of an account for any ERC20 token
 729 |     |     // Use the alternative signature to update `totalSupply`
 730 |     |     function deal(address token, address to, uint256 give) internal virtual {
 731 |     |         deal(token, to, give, false);
 732 |     |     }
 733 |     | 
 734 |     |     // Set the balance of an account for any ERC1155 token
 735 |     |     // Use the alternative signature to update `totalSupply`
 736 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {
 737 |     |         dealERC1155(token, to, id, give, false);
 738 |     |     }
 739 |     | 
 740 |     |     function deal(address token, address to, uint256 give, bool adjust) internal virtual {
 741 |     |         // get current balance
 742 |     |         (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));
 743 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 744 |     | 
 745 |     |         // update balance
 746 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);
 747 |     | 
 748 |     |         // update total supply
 749 |     |         if (adjust) {
 750 |     |             (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));
 751 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 752 |     |             if (give < prevBal) {
 753 |     |                 totSup -= (prevBal - give);
 754 |     |             } else {
 755 |     |                 totSup += (give - prevBal);
 756 |     |             }
 757 |     |             stdstore.target(token).sig(0x18160ddd).checked_write(totSup);
 758 |     |         }
 759 |     |     }
 760 |     | 
 761 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {
 762 |     |         // get current balance
 763 |     |         (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));
 764 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 765 |     | 
 766 |     |         // update balance
 767 |     |         stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);
 768 |     | 
 769 |     |         // update total supply
 770 |     |         if (adjust) {
 771 |     |             (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));
 772 |     |             require(
 773 |     |                 totSupData.length != 0,
 774 |     |                 "StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply."
 775 |     |             );
 776 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 777 |     |             if (give < prevBal) {
 778 |     |                 totSup -= (prevBal - give);
 779 |     |             } else {
 780 |     |                 totSup += (give - prevBal);
 781 |     |             }
 782 |     |             stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);
 783 |     |         }
 784 |     |     }
 785 |     | 
 786 |     |     function dealERC721(address token, address to, uint256 id) internal virtual {
 787 |     |         // check if token id is already minted and the actual owner.
 788 |     |         (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));
 789 |     |         require(successMinted, "StdCheats deal(address,address,uint,bool): id not minted.");
 790 |     | 
 791 |     |         // get owner current balance
 792 |     |         (, bytes memory fromBalData) =
 793 |     |             token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));
 794 |     |         uint256 fromPrevBal = abi.decode(fromBalData, (uint256));
 795 |     | 
 796 |     |         // get new user current balance
 797 |     |         (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));
 798 |     |         uint256 toPrevBal = abi.decode(toBalData, (uint256));
 799 |     | 
 800 |     |         // update balances
 801 |     |         stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);
 802 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);
 803 |     | 
 804 |     |         // update owner
 805 |     |         stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);
 806 |     |     }
 807 |     | 
 808 |     |     function deployCodeTo(string memory what, address where) internal virtual {
 809 |     |         deployCodeTo(what, "", 0, where);
 810 |     |     }
 811 |     | 
 812 |     |     function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {
 813 |     |         deployCodeTo(what, args, 0, where);
 814 |     |     }
 815 |     | 
 816 |     |     function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {
 817 |     |         bytes memory creationCode = vm.getCode(what);
 818 |     |         vm.etch(where, abi.encodePacked(creationCode, args));
 819 |     |         (bool success, bytes memory runtimeBytecode) = where.call{value: value}("");
 820 |     |         require(success, "StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.");
 821 |     |         vm.etch(where, runtimeBytecode);
 822 |     |     }
 823 |     | 
 824 |     |     // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.
 825 |     |     function console2_log_StdCheats(string memory p0) private view {
 826 |     |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string)", p0));
 827 |     |         status;
 828 |     |     }
 829 |     | }
 830 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/StdConstants.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | import {IMulticall3} from "./interfaces/IMulticall3.sol";
  5 |     | import {Vm} from "./Vm.sol";
  6 |     | 
  7 |     | library StdConstants {
  8 |     |     /// @dev Cheat code address.
  9 |     |     /// Calculated as `address(uint160(uint256(keccak256("hevm cheat code"))))`.
 10 |     |     Vm internal constant VM = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 11 |     |     /// @dev console.sol and console2.sol work by executing a staticcall to this address.
 12 |     |     /// Calculated as `address(uint160(uint88(bytes11("console.log"))))`.
 13 |     |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
 14 |     |     /// @dev Used when deploying with create2.
 15 |     |     /// Taken from https://github.com/Arachnid/deterministic-deployment-proxy.
 16 |     |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
 17 |     |     /// @dev The default address for tx.origin and msg.sender.
 18 |     |     /// Calculated as `address(uint160(uint256(keccak256("foundry default caller"))))`.
 19 |     |     address internal constant DEFAULT_SENDER = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;
 20 |     |     /// @dev The address of the first contract `CREATE`d by a running test contract.
 21 |     |     /// When running tests, each test contract is `CREATE`d by `DEFAULT_SENDER` with nonce 1.
 22 |     |     /// Calculated as `VM.computeCreateAddress(VM.computeCreateAddress(DEFAULT_SENDER, 1), 1)`.
 23 |     |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
 24 |     |     /// @dev Deterministic deployment address of the Multicall3 contract.
 25 |     |     /// Taken from https://www.multicall3.com.
 26 |     |     IMulticall3 internal constant MULTICALL3_ADDRESS = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);
 27 |     |     /// @dev The order of the secp256k1 curve.
 28 |     |     uint256 internal constant SECP256K1_ORDER =
 29 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
 30 |     | }
 31 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/StdError.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test
  3 |     | pragma solidity >=0.6.2 <0.9.0;
  4 |     | 
  5 |     | library stdError {
  6 |     |     bytes public constant assertionError = abi.encodeWithSignature("Panic(uint256)", 0x01);
  7 |     |     bytes public constant arithmeticError = abi.encodeWithSignature("Panic(uint256)", 0x11);
  8 |     |     bytes public constant divisionError = abi.encodeWithSignature("Panic(uint256)", 0x12);
  9 |     |     bytes public constant enumConversionError = abi.encodeWithSignature("Panic(uint256)", 0x21);
 10 |     |     bytes public constant encodeStorageError = abi.encodeWithSignature("Panic(uint256)", 0x22);
 11 |     |     bytes public constant popError = abi.encodeWithSignature("Panic(uint256)", 0x31);
 12 |     |     bytes public constant indexOOBError = abi.encodeWithSignature("Panic(uint256)", 0x32);
 13 |     |     bytes public constant memOverflowError = abi.encodeWithSignature("Panic(uint256)", 0x41);
 14 |     |     bytes public constant zeroVarError = abi.encodeWithSignature("Panic(uint256)", 0x51);
 15 |     | }
 16 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/StdInvariant.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | abstract contract StdInvariant {
   7 |     |     struct FuzzSelector {
   8 |     |         address addr;
   9 |     |         bytes4[] selectors;
  10 |     |     }
  11 |     | 
  12 |     |     struct FuzzArtifactSelector {
  13 |     |         string artifact;
  14 |     |         bytes4[] selectors;
  15 |     |     }
  16 |     | 
  17 |     |     struct FuzzInterface {
  18 |     |         address addr;
  19 |     |         string[] artifacts;
  20 |     |     }
  21 |     | 
  22 |     |     address[] private _excludedContracts;
  23 |     |     address[] private _excludedSenders;
  24 |     |     address[] private _targetedContracts;
  25 |     |     address[] private _targetedSenders;
  26 |     | 
  27 |     |     string[] private _excludedArtifacts;
  28 |     |     string[] private _targetedArtifacts;
  29 |     | 
  30 |     |     FuzzArtifactSelector[] private _targetedArtifactSelectors;
  31 |     | 
  32 |     |     FuzzSelector[] private _excludedSelectors;
  33 |     |     FuzzSelector[] private _targetedSelectors;
  34 |     | 
  35 |     |     FuzzInterface[] private _targetedInterfaces;
  36 |     | 
  37 |     |     // Functions for users:
  38 |     |     // These are intended to be called in tests.
  39 |     | 
  40 |     |     function excludeContract(address newExcludedContract_) internal {
  41 |     |         _excludedContracts.push(newExcludedContract_);
  42 |     |     }
  43 |     | 
  44 |     |     function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {
  45 |     |         _excludedSelectors.push(newExcludedSelector_);
  46 |     |     }
  47 |     | 
  48 |     |     function excludeSender(address newExcludedSender_) internal {
  49 |     |         _excludedSenders.push(newExcludedSender_);
  50 |     |     }
  51 |     | 
  52 |     |     function excludeArtifact(string memory newExcludedArtifact_) internal {
  53 |     |         _excludedArtifacts.push(newExcludedArtifact_);
  54 |     |     }
  55 |     | 
  56 |     |     function targetArtifact(string memory newTargetedArtifact_) internal {
  57 |     |         _targetedArtifacts.push(newTargetedArtifact_);
  58 |     |     }
  59 |     | 
  60 |     |     function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {
  61 |     |         _targetedArtifactSelectors.push(newTargetedArtifactSelector_);
  62 |     |     }
  63 |     | 
  64 |     |     function targetContract(address newTargetedContract_) internal {
  65 |     |         _targetedContracts.push(newTargetedContract_);
  66 |     |     }
  67 |     | 
  68 |     |     function targetSelector(FuzzSelector memory newTargetedSelector_) internal {
  69 |     |         _targetedSelectors.push(newTargetedSelector_);
  70 |     |     }
  71 |     | 
  72 |     |     function targetSender(address newTargetedSender_) internal {
  73 |     |         _targetedSenders.push(newTargetedSender_);
  74 |     |     }
  75 |     | 
  76 |     |     function targetInterface(FuzzInterface memory newTargetedInterface_) internal {
  77 |     |         _targetedInterfaces.push(newTargetedInterface_);
  78 |     |     }
  79 |     | 
  80 |     |     // Functions for forge:
  81 |     |     // These are called by forge to run invariant tests and don't need to be called in tests.
  82 |     | 
  83 |     |     function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {
  84 |     |         excludedArtifacts_ = _excludedArtifacts;
  85 |     |     }
  86 |     | 
  87 |     |     function excludeContracts() public view returns (address[] memory excludedContracts_) {
  88 |     |         excludedContracts_ = _excludedContracts;
  89 |     |     }
  90 |     | 
  91 |     |     function excludeSelectors() public view returns (FuzzSelector[] memory excludedSelectors_) {
  92 |     |         excludedSelectors_ = _excludedSelectors;
  93 |     |     }
  94 |     | 
  95 |     |     function excludeSenders() public view returns (address[] memory excludedSenders_) {
  96 |     |         excludedSenders_ = _excludedSenders;
  97 |     |     }
  98 |     | 
  99 |     |     function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {
 100 |     |         targetedArtifacts_ = _targetedArtifacts;
 101 |     |     }
 102 |     | 
 103 |     |     function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {
 104 |     |         targetedArtifactSelectors_ = _targetedArtifactSelectors;
 105 |     |     }
 106 |     | 
 107 |     |     function targetContracts() public view returns (address[] memory targetedContracts_) {
 108 |     |         targetedContracts_ = _targetedContracts;
 109 |     |     }
 110 |     | 
 111 |     |     function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {
 112 |     |         targetedSelectors_ = _targetedSelectors;
 113 |     |     }
 114 |     | 
 115 |     |     function targetSenders() public view returns (address[] memory targetedSenders_) {
 116 |     |         targetedSenders_ = _targetedSenders;
 117 |     |     }
 118 |     | 
 119 |     |     function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {
 120 |     |         targetedInterfaces_ = _targetedInterfaces;
 121 |     |     }
 122 |     | }
 123 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/StdJson.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing JSON files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdJson for string;
  12 |     | // string memory json = vm.readFile("<some_path>");
  13 |     | // json.readUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdJson for string;
  18 |     | // string memory json = "json";
  19 |     | // json.serialize("a", uint256(123));
  20 |     | // string memory semiFinal = json.serialize("b", string("test"));
  21 |     | // string memory finalJson = json.serialize("c", semiFinal);
  22 |     | // finalJson.write("<some_path>");
  23 |     | // ```
  24 |     | 
  25 |     | library stdJson {
  26 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  27 |     | 
  28 |     |     function keyExists(string memory json, string memory key) internal view returns (bool) {
  29 |     |         return vm.keyExistsJson(json, key);
  30 |     |     }
  31 |     | 
  32 |     |     function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {
  33 |     |         return vm.parseJson(json, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUint(string memory json, string memory key) internal pure returns (uint256) {
  37 |     |         return vm.parseJsonUint(json, key);
  38 |     |     }
  39 |     | 
  40 |     |     function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {
  41 |     |         return vm.parseJsonUintArray(json, key);
  42 |     |     }
  43 |     | 
  44 |     |     function readInt(string memory json, string memory key) internal pure returns (int256) {
  45 |     |         return vm.parseJsonInt(json, key);
  46 |     |     }
  47 |     | 
  48 |     |     function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {
  49 |     |         return vm.parseJsonIntArray(json, key);
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {
  53 |     |         return vm.parseJsonBytes32(json, key);
  54 |     |     }
  55 |     | 
  56 |     |     function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {
  57 |     |         return vm.parseJsonBytes32Array(json, key);
  58 |     |     }
  59 |     | 
  60 |     |     function readString(string memory json, string memory key) internal pure returns (string memory) {
  61 |     |         return vm.parseJsonString(json, key);
  62 |     |     }
  63 |     | 
  64 |     |     function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {
  65 |     |         return vm.parseJsonStringArray(json, key);
  66 |     |     }
  67 |     | 
  68 |     |     function readAddress(string memory json, string memory key) internal pure returns (address) {
  69 |     |         return vm.parseJsonAddress(json, key);
  70 |     |     }
  71 |     | 
  72 |     |     function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {
  73 |     |         return vm.parseJsonAddressArray(json, key);
  74 |     |     }
  75 |     | 
  76 |     |     function readBool(string memory json, string memory key) internal pure returns (bool) {
  77 |     |         return vm.parseJsonBool(json, key);
  78 |     |     }
  79 |     | 
  80 |     |     function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {
  81 |     |         return vm.parseJsonBoolArray(json, key);
  82 |     |     }
  83 |     | 
  84 |     |     function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {
  85 |     |         return vm.parseJsonBytes(json, key);
  86 |     |     }
  87 |     | 
  88 |     |     function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {
  89 |     |         return vm.parseJsonBytesArray(json, key);
  90 |     |     }
  91 |     | 
  92 |     |     function readUintOr(string memory json, string memory key, uint256 defaultValue) internal view returns (uint256) {
  93 |     |         return keyExists(json, key) ? readUint(json, key) : defaultValue;
  94 |     |     }
  95 |     | 
  96 |     |     function readUintArrayOr(string memory json, string memory key, uint256[] memory defaultValue)
  97 |     |         internal
  98 |     |         view
  99 |     |         returns (uint256[] memory)
 100 |     |     {
 101 |     |         return keyExists(json, key) ? readUintArray(json, key) : defaultValue;
 102 |     |     }
 103 |     | 
 104 |     |     function readIntOr(string memory json, string memory key, int256 defaultValue) internal view returns (int256) {
 105 |     |         return keyExists(json, key) ? readInt(json, key) : defaultValue;
 106 |     |     }
 107 |     | 
 108 |     |     function readIntArrayOr(string memory json, string memory key, int256[] memory defaultValue)
 109 |     |         internal
 110 |     |         view
 111 |     |         returns (int256[] memory)
 112 |     |     {
 113 |     |         return keyExists(json, key) ? readIntArray(json, key) : defaultValue;
 114 |     |     }
 115 |     | 
 116 |     |     function readBytes32Or(string memory json, string memory key, bytes32 defaultValue)
 117 |     |         internal
 118 |     |         view
 119 |     |         returns (bytes32)
 120 |     |     {
 121 |     |         return keyExists(json, key) ? readBytes32(json, key) : defaultValue;
 122 |     |     }
 123 |     | 
 124 |     |     function readBytes32ArrayOr(string memory json, string memory key, bytes32[] memory defaultValue)
 125 |     |         internal
 126 |     |         view
 127 |     |         returns (bytes32[] memory)
 128 |     |     {
 129 |     |         return keyExists(json, key) ? readBytes32Array(json, key) : defaultValue;
 130 |     |     }
 131 |     | 
 132 |     |     function readStringOr(string memory json, string memory key, string memory defaultValue)
 133 |     |         internal
 134 |     |         view
 135 |     |         returns (string memory)
 136 |     |     {
 137 |     |         return keyExists(json, key) ? readString(json, key) : defaultValue;
 138 |     |     }
 139 |     | 
 140 |     |     function readStringArrayOr(string memory json, string memory key, string[] memory defaultValue)
 141 |     |         internal
 142 |     |         view
 143 |     |         returns (string[] memory)
 144 |     |     {
 145 |     |         return keyExists(json, key) ? readStringArray(json, key) : defaultValue;
 146 |     |     }
 147 |     | 
 148 |     |     function readAddressOr(string memory json, string memory key, address defaultValue)
 149 |     |         internal
 150 |     |         view
 151 |     |         returns (address)
 152 |     |     {
 153 |     |         return keyExists(json, key) ? readAddress(json, key) : defaultValue;
 154 |     |     }
 155 |     | 
 156 |     |     function readAddressArrayOr(string memory json, string memory key, address[] memory defaultValue)
 157 |     |         internal
 158 |     |         view
 159 |     |         returns (address[] memory)
 160 |     |     {
 161 |     |         return keyExists(json, key) ? readAddressArray(json, key) : defaultValue;
 162 |     |     }
 163 |     | 
 164 |     |     function readBoolOr(string memory json, string memory key, bool defaultValue) internal view returns (bool) {
 165 |     |         return keyExists(json, key) ? readBool(json, key) : defaultValue;
 166 |     |     }
 167 |     | 
 168 |     |     function readBoolArrayOr(string memory json, string memory key, bool[] memory defaultValue)
 169 |     |         internal
 170 |     |         view
 171 |     |         returns (bool[] memory)
 172 |     |     {
 173 |     |         return keyExists(json, key) ? readBoolArray(json, key) : defaultValue;
 174 |     |     }
 175 |     | 
 176 |     |     function readBytesOr(string memory json, string memory key, bytes memory defaultValue)
 177 |     |         internal
 178 |     |         view
 179 |     |         returns (bytes memory)
 180 |     |     {
 181 |     |         return keyExists(json, key) ? readBytes(json, key) : defaultValue;
 182 |     |     }
 183 |     | 
 184 |     |     function readBytesArrayOr(string memory json, string memory key, bytes[] memory defaultValue)
 185 |     |         internal
 186 |     |         view
 187 |     |         returns (bytes[] memory)
 188 |     |     {
 189 |     |         return keyExists(json, key) ? readBytesArray(json, key) : defaultValue;
 190 |     |     }
 191 |     | 
 192 |     |     function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {
 193 |     |         return vm.serializeJson(jsonKey, rootObject);
 194 |     |     }
 195 |     | 
 196 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
 197 |     |         return vm.serializeBool(jsonKey, key, value);
 198 |     |     }
 199 |     | 
 200 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
 201 |     |         internal
 202 |     |         returns (string memory)
 203 |     |     {
 204 |     |         return vm.serializeBool(jsonKey, key, value);
 205 |     |     }
 206 |     | 
 207 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 208 |     |         return vm.serializeUint(jsonKey, key, value);
 209 |     |     }
 210 |     | 
 211 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 212 |     |         internal
 213 |     |         returns (string memory)
 214 |     |     {
 215 |     |         return vm.serializeUint(jsonKey, key, value);
 216 |     |     }
 217 |     | 
 218 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 219 |     |         return vm.serializeInt(jsonKey, key, value);
 220 |     |     }
 221 |     | 
 222 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 223 |     |         internal
 224 |     |         returns (string memory)
 225 |     |     {
 226 |     |         return vm.serializeInt(jsonKey, key, value);
 227 |     |     }
 228 |     | 
 229 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 230 |     |         return vm.serializeAddress(jsonKey, key, value);
 231 |     |     }
 232 |     | 
 233 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 234 |     |         internal
 235 |     |         returns (string memory)
 236 |     |     {
 237 |     |         return vm.serializeAddress(jsonKey, key, value);
 238 |     |     }
 239 |     | 
 240 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 241 |     |         return vm.serializeBytes32(jsonKey, key, value);
 242 |     |     }
 243 |     | 
 244 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 245 |     |         internal
 246 |     |         returns (string memory)
 247 |     |     {
 248 |     |         return vm.serializeBytes32(jsonKey, key, value);
 249 |     |     }
 250 |     | 
 251 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 252 |     |         return vm.serializeBytes(jsonKey, key, value);
 253 |     |     }
 254 |     | 
 255 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 256 |     |         internal
 257 |     |         returns (string memory)
 258 |     |     {
 259 |     |         return vm.serializeBytes(jsonKey, key, value);
 260 |     |     }
 261 |     | 
 262 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 263 |     |         internal
 264 |     |         returns (string memory)
 265 |     |     {
 266 |     |         return vm.serializeString(jsonKey, key, value);
 267 |     |     }
 268 |     | 
 269 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 270 |     |         internal
 271 |     |         returns (string memory)
 272 |     |     {
 273 |     |         return vm.serializeString(jsonKey, key, value);
 274 |     |     }
 275 |     | 
 276 |     |     function write(string memory jsonKey, string memory path) internal {
 277 |     |         vm.writeJson(jsonKey, path);
 278 |     |     }
 279 |     | 
 280 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 281 |     |         vm.writeJson(jsonKey, path, valueKey);
 282 |     |     }
 283 |     | }
 284 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/StdMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | library stdMath {
  5 |     |     int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;
  6 |     | 
  7 |     |     function abs(int256 a) internal pure returns (uint256) {
  8 |     |         // Required or it will fail when `a = type(int256).min`
  9 |     |         if (a == INT256_MIN) {
 10 |     |             return 57896044618658097711785492504343953926634992332820282019728792003956564819968;
 11 |     |         }
 12 |     | 
 13 |     |         return uint256(a > 0 ? a : -a);
 14 |     |     }
 15 |     | 
 16 |     |     function delta(uint256 a, uint256 b) internal pure returns (uint256) {
 17 |     |         return a > b ? a - b : b - a;
 18 |     |     }
 19 |     | 
 20 |     |     function delta(int256 a, int256 b) internal pure returns (uint256) {
 21 |     |         // a and b are of the same sign
 22 |     |         // this works thanks to two's complement, the left-most bit is the sign bit
 23 |     |         if ((a ^ b) > -1) {
 24 |     |             return delta(abs(a), abs(b));
 25 |     |         }
 26 |     | 
 27 |     |         // a and b are of opposite signs
 28 |     |         return abs(a) + abs(b);
 29 |     |     }
 30 |     | 
 31 |     |     function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {
 32 |     |         uint256 absDelta = delta(a, b);
 33 |     | 
 34 |     |         return absDelta * 1e18 / b;
 35 |     |     }
 36 |     | 
 37 |     |     function percentDelta(int256 a, int256 b) internal pure returns (uint256) {
 38 |     |         uint256 absDelta = delta(a, b);
 39 |     |         uint256 absB = abs(b);
 40 |     | 
 41 |     |         return absDelta * 1e18 / absB;
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/StdStorage.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {Vm} from "./Vm.sol";
   5 |     | 
   6 |     | struct FindData {
   7 |     |     uint256 slot;
   8 |     |     uint256 offsetLeft;
   9 |     |     uint256 offsetRight;
  10 |     |     bool found;
  11 |     | }
  12 |     | 
  13 |     | struct StdStorage {
  14 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => FindData))) finds;
  15 |     |     bytes32[] _keys;
  16 |     |     bytes4 _sig;
  17 |     |     uint256 _depth;
  18 |     |     address _target;
  19 |     |     bytes32 _set;
  20 |     |     bool _enable_packed_slots;
  21 |     |     bytes _calldata;
  22 |     | }
  23 |     | 
  24 |     | library stdStorageSafe {
  25 |     |     event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);
  26 |     |     event WARNING_UninitedSlot(address who, uint256 slot);
  27 |     | 
  28 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  29 |     |     uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
  30 |     | 
  31 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
  32 |     |         return bytes4(keccak256(bytes(sigStr)));
  33 |     |     }
  34 |     | 
  35 |     |     function getCallParams(StdStorage storage self) internal view returns (bytes memory) {
  36 |     |         if (self._calldata.length == 0) {
  37 |     |             return flatten(self._keys);
  38 |     |         } else {
  39 |     |             return self._calldata;
  40 |     |         }
  41 |     |     }
  42 |     | 
  43 |     |     // Calls target contract with configured parameters
  44 |     |     function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {
  45 |     |         bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));
  46 |     |         (bool success, bytes memory rdat) = self._target.staticcall(cald);
  47 |     |         bytes32 result = bytesToBytes32(rdat, 32 * self._depth);
  48 |     | 
  49 |     |         return (success, result);
  50 |     |     }
  51 |     | 
  52 |     |     // Tries mutating slot value to determine if the targeted value is stored in it.
  53 |     |     // If current value is 0, then we are setting slot value to type(uint256).max
  54 |     |     // Otherwise, we set it to 0. That way, return value should always be affected.
  55 |     |     function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {
  56 |     |         bytes32 prevSlotValue = vm.load(self._target, slot);
  57 |     |         (bool success, bytes32 prevReturnValue) = callTarget(self);
  58 |     | 
  59 |     |         bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);
  60 |     |         vm.store(self._target, slot, testVal);
  61 |     | 
  62 |     |         (, bytes32 newReturnValue) = callTarget(self);
  63 |     | 
  64 |     |         vm.store(self._target, slot, prevSlotValue);
  65 |     | 
  66 |     |         return (success && (prevReturnValue != newReturnValue));
  67 |     |     }
  68 |     | 
  69 |     |     // Tries setting one of the bits in slot to 1 until return value changes.
  70 |     |     // Index of resulted bit is an offset packed slot has from left/right side
  71 |     |     function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {
  72 |     |         for (uint256 offset = 0; offset < 256; offset++) {
  73 |     |             uint256 valueToPut = left ? (1 << (255 - offset)) : (1 << offset);
  74 |     |             vm.store(self._target, slot, bytes32(valueToPut));
  75 |     | 
  76 |     |             (bool success, bytes32 data) = callTarget(self);
  77 |     | 
  78 |     |             if (success && (uint256(data) > 0)) {
  79 |     |                 return (true, offset);
  80 |     |             }
  81 |     |         }
  82 |     |         return (false, 0);
  83 |     |     }
  84 |     | 
  85 |     |     function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {
  86 |     |         bytes32 prevSlotValue = vm.load(self._target, slot);
  87 |     | 
  88 |     |         (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);
  89 |     |         (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);
  90 |     | 
  91 |     |         // `findOffset` may mutate slot value, so we are setting it to initial value
  92 |     |         vm.store(self._target, slot, prevSlotValue);
  93 |     |         return (foundLeft && foundRight, offsetLeft, offsetRight);
  94 |     |     }
  95 |     | 
  96 |     |     function find(StdStorage storage self) internal returns (FindData storage) {
  97 |     |         return find(self, true);
  98 |     |     }
  99 |     | 
 100 |     |     /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
 101 |     |     // slot complexity:
 102 |     |     //  if flat, will be bytes32(uint256(uint));
 103 |     |     //  if map, will be keccak256(abi.encode(key, uint(slot)));
 104 |     |     //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
 105 |     |     //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
 106 |     |     function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {
 107 |     |         address who = self._target;
 108 |     |         bytes4 fsig = self._sig;
 109 |     |         uint256 field_depth = self._depth;
 110 |     |         bytes memory params = getCallParams(self);
 111 |     | 
 112 |     |         // calldata to test against
 113 |     |         if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {
 114 |     |             if (_clear) {
 115 |     |                 clear(self);
 116 |     |             }
 117 |     |             return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 118 |     |         }
 119 |     |         vm.record();
 120 |     |         (, bytes32 callResult) = callTarget(self);
 121 |     |         (bytes32[] memory reads,) = vm.accesses(address(who));
 122 |     | 
 123 |     |         if (reads.length == 0) {
 124 |     |             revert("stdStorage find(StdStorage): No storage use detected for target.");
 125 |     |         } else {
 126 |     |             for (uint256 i = reads.length; --i >= 0;) {
 127 |     |                 bytes32 prev = vm.load(who, reads[i]);
 128 |     |                 if (prev == bytes32(0)) {
 129 |     |                     emit WARNING_UninitedSlot(who, uint256(reads[i]));
 130 |     |                 }
 131 |     | 
 132 |     |                 if (!checkSlotMutatesCall(self, reads[i])) {
 133 |     |                     continue;
 134 |     |                 }
 135 |     | 
 136 |     |                 (uint256 offsetLeft, uint256 offsetRight) = (0, 0);
 137 |     | 
 138 |     |                 if (self._enable_packed_slots) {
 139 |     |                     bool found;
 140 |     |                     (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);
 141 |     |                     if (!found) {
 142 |     |                         continue;
 143 |     |                     }
 144 |     |                 }
 145 |     | 
 146 |     |                 // Check that value between found offsets is equal to the current call result
 147 |     |                 uint256 curVal = (uint256(prev) & getMaskByOffsets(offsetLeft, offsetRight)) >> offsetRight;
 148 |     | 
 149 |     |                 if (uint256(callResult) != curVal) {
 150 |     |                     continue;
 151 |     |                 }
 152 |     | 
 153 |     |                 emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));
 154 |     |                 self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =
 155 |     |                     FindData(uint256(reads[i]), offsetLeft, offsetRight, true);
 156 |     |                 break;
 157 |     |             }
 158 |     |         }
 159 |     | 
 160 |     |         require(
 161 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,
 162 |     |             "stdStorage find(StdStorage): Slot(s) not found."
 163 |     |         );
 164 |     | 
 165 |     |         if (_clear) {
 166 |     |             clear(self);
 167 |     |         }
 168 |     |         return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 169 |     |     }
 170 |     | 
 171 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 172 |     |         self._target = _target;
 173 |     |         return self;
 174 |     |     }
 175 |     | 
 176 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 177 |     |         self._sig = _sig;
 178 |     |         return self;
 179 |     |     }
 180 |     | 
 181 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 182 |     |         self._sig = sigs(_sig);
 183 |     |         return self;
 184 |     |     }
 185 |     | 
 186 |     |     function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {
 187 |     |         self._calldata = _calldata;
 188 |     |         return self;
 189 |     |     }
 190 |     | 
 191 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 192 |     |         self._keys.push(bytes32(uint256(uint160(who))));
 193 |     |         return self;
 194 |     |     }
 195 |     | 
 196 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 197 |     |         self._keys.push(bytes32(amt));
 198 |     |         return self;
 199 |     |     }
 200 |     | 
 201 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 202 |     |         self._keys.push(key);
 203 |     |         return self;
 204 |     |     }
 205 |     | 
 206 |     |     function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {
 207 |     |         self._enable_packed_slots = true;
 208 |     |         return self;
 209 |     |     }
 210 |     | 
 211 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 212 |     |         self._depth = _depth;
 213 |     |         return self;
 214 |     |     }
 215 |     | 
 216 |     |     function read(StdStorage storage self) private returns (bytes memory) {
 217 |     |         FindData storage data = find(self, false);
 218 |     |         uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);
 219 |     |         uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) & mask) >> data.offsetRight;
 220 |     |         clear(self);
 221 |     |         return abi.encode(value);
 222 |     |     }
 223 |     | 
 224 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 225 |     |         return abi.decode(read(self), (bytes32));
 226 |     |     }
 227 |     | 
 228 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 229 |     |         int256 v = read_int(self);
 230 |     |         if (v == 0) return false;
 231 |     |         if (v == 1) return true;
 232 |     |         revert("stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.");
 233 |     |     }
 234 |     | 
 235 |     |     function read_address(StdStorage storage self) internal returns (address) {
 236 |     |         return abi.decode(read(self), (address));
 237 |     |     }
 238 |     | 
 239 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 240 |     |         return abi.decode(read(self), (uint256));
 241 |     |     }
 242 |     | 
 243 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 244 |     |         return abi.decode(read(self), (int256));
 245 |     |     }
 246 |     | 
 247 |     |     function parent(StdStorage storage self) internal returns (uint256, bytes32) {
 248 |     |         address who = self._target;
 249 |     |         uint256 field_depth = self._depth;
 250 |     |         vm.startMappingRecording();
 251 |     |         uint256 child = find(self, true).slot - field_depth;
 252 |     |         (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));
 253 |     |         if (!found) {
 254 |     |             revert(
 255 |     |                 "stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called."
 256 |     |             );
 257 |     |         }
 258 |     |         return (uint256(parent_slot), key);
 259 |     |     }
 260 |     | 
 261 |     |     function root(StdStorage storage self) internal returns (uint256) {
 262 |     |         address who = self._target;
 263 |     |         uint256 field_depth = self._depth;
 264 |     |         vm.startMappingRecording();
 265 |     |         uint256 child = find(self, true).slot - field_depth;
 266 |     |         bool found;
 267 |     |         bytes32 root_slot;
 268 |     |         bytes32 parent_slot;
 269 |     |         (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));
 270 |     |         if (!found) {
 271 |     |             revert(
 272 |     |                 "stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called."
 273 |     |             );
 274 |     |         }
 275 |     |         while (found) {
 276 |     |             root_slot = parent_slot;
 277 |     |             (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));
 278 |     |         }
 279 |     |         return uint256(root_slot);
 280 |     |     }
 281 |     | 
 282 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 283 |     |         bytes32 out;
 284 |     | 
 285 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 286 |     |         for (uint256 i = 0; i < max; i++) {
 287 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 288 |     |         }
 289 |     |         return out;
 290 |     |     }
 291 |     | 
 292 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 293 |     |         bytes memory result = new bytes(b.length * 32);
 294 |     |         for (uint256 i = 0; i < b.length; i++) {
 295 |     |             bytes32 k = b[i];
 296 |     |             /// @solidity memory-safe-assembly
 297 |     |             assembly {
 298 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 299 |     |             }
 300 |     |         }
 301 |     | 
 302 |     |         return result;
 303 |     |     }
 304 |     | 
 305 |     |     function clear(StdStorage storage self) internal {
 306 |     |         delete self._target;
 307 |     |         delete self._sig;
 308 |     |         delete self._keys;
 309 |     |         delete self._depth;
 310 |     |         delete self._enable_packed_slots;
 311 |     |         delete self._calldata;
 312 |     |     }
 313 |     | 
 314 |     |     // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`
 315 |     |     // (slotValue & mask) >> offsetRight will be the value of the given packed variable
 316 |     |     function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {
 317 |     |         // mask = ((1 << (256 - (offsetRight + offsetLeft))) - 1) << offsetRight;
 318 |     |         // using assembly because (1 << 256) causes overflow
 319 |     |         assembly {
 320 |     |             mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))
 321 |     |         }
 322 |     |     }
 323 |     | 
 324 |     |     // Returns slot value with updated packed variable.
 325 |     |     function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)
 326 |     |         internal
 327 |     |         pure
 328 |     |         returns (bytes32 newValue)
 329 |     |     {
 330 |     |         return bytes32((uint256(curValue) & ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue << offsetRight));
 331 |     |     }
 332 |     | }
 333 |     | 
 334 |     | library stdStorage {
 335 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 336 |     | 
 337 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
 338 |     |         return stdStorageSafe.sigs(sigStr);
 339 |     |     }
 340 |     | 
 341 |     |     function find(StdStorage storage self) internal returns (uint256) {
 342 |     |         return find(self, true);
 343 |     |     }
 344 |     | 
 345 |     |     function find(StdStorage storage self, bool _clear) internal returns (uint256) {
 346 |     |         return stdStorageSafe.find(self, _clear).slot;
 347 |     |     }
 348 |     | 
 349 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 350 |     |         return stdStorageSafe.target(self, _target);
 351 |     |     }
 352 |     | 
 353 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 354 |     |         return stdStorageSafe.sig(self, _sig);
 355 |     |     }
 356 |     | 
 357 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 358 |     |         return stdStorageSafe.sig(self, _sig);
 359 |     |     }
 360 |     | 
 361 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 362 |     |         return stdStorageSafe.with_key(self, who);
 363 |     |     }
 364 |     | 
 365 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 366 |     |         return stdStorageSafe.with_key(self, amt);
 367 |     |     }
 368 |     | 
 369 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 370 |     |         return stdStorageSafe.with_key(self, key);
 371 |     |     }
 372 |     | 
 373 |     |     function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {
 374 |     |         return stdStorageSafe.with_calldata(self, _calldata);
 375 |     |     }
 376 |     | 
 377 |     |     function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {
 378 |     |         return stdStorageSafe.enable_packed_slots(self);
 379 |     |     }
 380 |     | 
 381 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 382 |     |         return stdStorageSafe.depth(self, _depth);
 383 |     |     }
 384 |     | 
 385 |     |     function clear(StdStorage storage self) internal {
 386 |     |         stdStorageSafe.clear(self);
 387 |     |     }
 388 |     | 
 389 |     |     function checked_write(StdStorage storage self, address who) internal {
 390 |     |         checked_write(self, bytes32(uint256(uint160(who))));
 391 |     |     }
 392 |     | 
 393 |     |     function checked_write(StdStorage storage self, uint256 amt) internal {
 394 |     |         checked_write(self, bytes32(amt));
 395 |     |     }
 396 |     | 
 397 |     |     function checked_write_int(StdStorage storage self, int256 val) internal {
 398 |     |         checked_write(self, bytes32(uint256(val)));
 399 |     |     }
 400 |     | 
 401 |     |     function checked_write(StdStorage storage self, bool write) internal {
 402 |     |         bytes32 t;
 403 |     |         /// @solidity memory-safe-assembly
 404 |     |         assembly {
 405 |     |             t := write
 406 |     |         }
 407 |     |         checked_write(self, t);
 408 |     |     }
 409 |     | 
 410 |     |     function checked_write(StdStorage storage self, bytes32 set) internal {
 411 |     |         address who = self._target;
 412 |     |         bytes4 fsig = self._sig;
 413 |     |         uint256 field_depth = self._depth;
 414 |     |         bytes memory params = stdStorageSafe.getCallParams(self);
 415 |     | 
 416 |     |         if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {
 417 |     |             find(self, false);
 418 |     |         }
 419 |     |         FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 420 |     |         if ((data.offsetLeft + data.offsetRight) > 0) {
 421 |     |             uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));
 422 |     |             require(
 423 |     |                 uint256(set) < maxVal,
 424 |     |                 string(
 425 |     |                     abi.encodePacked(
 426 |     |                         "stdStorage find(StdStorage): Packed slot. We can't fit value greater than ",
 427 |     |                         vm.toString(maxVal)
 428 |     |                     )
 429 |     |                 )
 430 |     |             );
 431 |     |         }
 432 |     |         bytes32 curVal = vm.load(who, bytes32(data.slot));
 433 |     |         bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);
 434 |     | 
 435 |     |         vm.store(who, bytes32(data.slot), valToSet);
 436 |     | 
 437 |     |         (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);
 438 |     | 
 439 |     |         if (!success || callResult != set) {
 440 |     |             vm.store(who, bytes32(data.slot), curVal);
 441 |     |             revert("stdStorage find(StdStorage): Failed to write value.");
 442 |     |         }
 443 |     |         clear(self);
 444 |     |     }
 445 |     | 
 446 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 447 |     |         return stdStorageSafe.read_bytes32(self);
 448 |     |     }
 449 |     | 
 450 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 451 |     |         return stdStorageSafe.read_bool(self);
 452 |     |     }
 453 |     | 
 454 |     |     function read_address(StdStorage storage self) internal returns (address) {
 455 |     |         return stdStorageSafe.read_address(self);
 456 |     |     }
 457 |     | 
 458 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 459 |     |         return stdStorageSafe.read_uint(self);
 460 |     |     }
 461 |     | 
 462 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 463 |     |         return stdStorageSafe.read_int(self);
 464 |     |     }
 465 |     | 
 466 |     |     function parent(StdStorage storage self) internal returns (uint256, bytes32) {
 467 |     |         return stdStorageSafe.parent(self);
 468 |     |     }
 469 |     | 
 470 |     |     function root(StdStorage storage self) internal returns (uint256) {
 471 |     |         return stdStorageSafe.root(self);
 472 |     |     }
 473 |     | }
 474 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/StdStyle.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.4.22 <0.9.0;
   3 |     | 
   4 |     | import {VmSafe} from "./Vm.sol";
   5 |     | 
   6 |     | library StdStyle {
   7 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
   8 |     | 
   9 |     |     string constant RED = "\u001b[91m";
  10 |     |     string constant GREEN = "\u001b[92m";
  11 |     |     string constant YELLOW = "\u001b[93m";
  12 |     |     string constant BLUE = "\u001b[94m";
  13 |     |     string constant MAGENTA = "\u001b[95m";
  14 |     |     string constant CYAN = "\u001b[96m";
  15 |     |     string constant BOLD = "\u001b[1m";
  16 |     |     string constant DIM = "\u001b[2m";
  17 |     |     string constant ITALIC = "\u001b[3m";
  18 |     |     string constant UNDERLINE = "\u001b[4m";
  19 |     |     string constant INVERSE = "\u001b[7m";
  20 |     |     string constant RESET = "\u001b[0m";
  21 |     | 
  22 |     |     function styleConcat(string memory style, string memory self) private pure returns (string memory) {
  23 |     |         return string(abi.encodePacked(style, self, RESET));
  24 |     |     }
  25 |     | 
  26 |     |     function red(string memory self) internal pure returns (string memory) {
  27 |     |         return styleConcat(RED, self);
  28 |     |     }
  29 |     | 
  30 |     |     function red(uint256 self) internal pure returns (string memory) {
  31 |     |         return red(vm.toString(self));
  32 |     |     }
  33 |     | 
  34 |     |     function red(int256 self) internal pure returns (string memory) {
  35 |     |         return red(vm.toString(self));
  36 |     |     }
  37 |     | 
  38 |     |     function red(address self) internal pure returns (string memory) {
  39 |     |         return red(vm.toString(self));
  40 |     |     }
  41 |     | 
  42 |     |     function red(bool self) internal pure returns (string memory) {
  43 |     |         return red(vm.toString(self));
  44 |     |     }
  45 |     | 
  46 |     |     function redBytes(bytes memory self) internal pure returns (string memory) {
  47 |     |         return red(vm.toString(self));
  48 |     |     }
  49 |     | 
  50 |     |     function redBytes32(bytes32 self) internal pure returns (string memory) {
  51 |     |         return red(vm.toString(self));
  52 |     |     }
  53 |     | 
  54 |     |     function green(string memory self) internal pure returns (string memory) {
  55 |     |         return styleConcat(GREEN, self);
  56 |     |     }
  57 |     | 
  58 |     |     function green(uint256 self) internal pure returns (string memory) {
  59 |     |         return green(vm.toString(self));
  60 |     |     }
  61 |     | 
  62 |     |     function green(int256 self) internal pure returns (string memory) {
  63 |     |         return green(vm.toString(self));
  64 |     |     }
  65 |     | 
  66 |     |     function green(address self) internal pure returns (string memory) {
  67 |     |         return green(vm.toString(self));
  68 |     |     }
  69 |     | 
  70 |     |     function green(bool self) internal pure returns (string memory) {
  71 |     |         return green(vm.toString(self));
  72 |     |     }
  73 |     | 
  74 |     |     function greenBytes(bytes memory self) internal pure returns (string memory) {
  75 |     |         return green(vm.toString(self));
  76 |     |     }
  77 |     | 
  78 |     |     function greenBytes32(bytes32 self) internal pure returns (string memory) {
  79 |     |         return green(vm.toString(self));
  80 |     |     }
  81 |     | 
  82 |     |     function yellow(string memory self) internal pure returns (string memory) {
  83 |     |         return styleConcat(YELLOW, self);
  84 |     |     }
  85 |     | 
  86 |     |     function yellow(uint256 self) internal pure returns (string memory) {
  87 |     |         return yellow(vm.toString(self));
  88 |     |     }
  89 |     | 
  90 |     |     function yellow(int256 self) internal pure returns (string memory) {
  91 |     |         return yellow(vm.toString(self));
  92 |     |     }
  93 |     | 
  94 |     |     function yellow(address self) internal pure returns (string memory) {
  95 |     |         return yellow(vm.toString(self));
  96 |     |     }
  97 |     | 
  98 |     |     function yellow(bool self) internal pure returns (string memory) {
  99 |     |         return yellow(vm.toString(self));
 100 |     |     }
 101 |     | 
 102 |     |     function yellowBytes(bytes memory self) internal pure returns (string memory) {
 103 |     |         return yellow(vm.toString(self));
 104 |     |     }
 105 |     | 
 106 |     |     function yellowBytes32(bytes32 self) internal pure returns (string memory) {
 107 |     |         return yellow(vm.toString(self));
 108 |     |     }
 109 |     | 
 110 |     |     function blue(string memory self) internal pure returns (string memory) {
 111 |     |         return styleConcat(BLUE, self);
 112 |     |     }
 113 |     | 
 114 |     |     function blue(uint256 self) internal pure returns (string memory) {
 115 |     |         return blue(vm.toString(self));
 116 |     |     }
 117 |     | 
 118 |     |     function blue(int256 self) internal pure returns (string memory) {
 119 |     |         return blue(vm.toString(self));
 120 |     |     }
 121 |     | 
 122 |     |     function blue(address self) internal pure returns (string memory) {
 123 |     |         return blue(vm.toString(self));
 124 |     |     }
 125 |     | 
 126 |     |     function blue(bool self) internal pure returns (string memory) {
 127 |     |         return blue(vm.toString(self));
 128 |     |     }
 129 |     | 
 130 |     |     function blueBytes(bytes memory self) internal pure returns (string memory) {
 131 |     |         return blue(vm.toString(self));
 132 |     |     }
 133 |     | 
 134 |     |     function blueBytes32(bytes32 self) internal pure returns (string memory) {
 135 |     |         return blue(vm.toString(self));
 136 |     |     }
 137 |     | 
 138 |     |     function magenta(string memory self) internal pure returns (string memory) {
 139 |     |         return styleConcat(MAGENTA, self);
 140 |     |     }
 141 |     | 
 142 |     |     function magenta(uint256 self) internal pure returns (string memory) {
 143 |     |         return magenta(vm.toString(self));
 144 |     |     }
 145 |     | 
 146 |     |     function magenta(int256 self) internal pure returns (string memory) {
 147 |     |         return magenta(vm.toString(self));
 148 |     |     }
 149 |     | 
 150 |     |     function magenta(address self) internal pure returns (string memory) {
 151 |     |         return magenta(vm.toString(self));
 152 |     |     }
 153 |     | 
 154 |     |     function magenta(bool self) internal pure returns (string memory) {
 155 |     |         return magenta(vm.toString(self));
 156 |     |     }
 157 |     | 
 158 |     |     function magentaBytes(bytes memory self) internal pure returns (string memory) {
 159 |     |         return magenta(vm.toString(self));
 160 |     |     }
 161 |     | 
 162 |     |     function magentaBytes32(bytes32 self) internal pure returns (string memory) {
 163 |     |         return magenta(vm.toString(self));
 164 |     |     }
 165 |     | 
 166 |     |     function cyan(string memory self) internal pure returns (string memory) {
 167 |     |         return styleConcat(CYAN, self);
 168 |     |     }
 169 |     | 
 170 |     |     function cyan(uint256 self) internal pure returns (string memory) {
 171 |     |         return cyan(vm.toString(self));
 172 |     |     }
 173 |     | 
 174 |     |     function cyan(int256 self) internal pure returns (string memory) {
 175 |     |         return cyan(vm.toString(self));
 176 |     |     }
 177 |     | 
 178 |     |     function cyan(address self) internal pure returns (string memory) {
 179 |     |         return cyan(vm.toString(self));
 180 |     |     }
 181 |     | 
 182 |     |     function cyan(bool self) internal pure returns (string memory) {
 183 |     |         return cyan(vm.toString(self));
 184 |     |     }
 185 |     | 
 186 |     |     function cyanBytes(bytes memory self) internal pure returns (string memory) {
 187 |     |         return cyan(vm.toString(self));
 188 |     |     }
 189 |     | 
 190 |     |     function cyanBytes32(bytes32 self) internal pure returns (string memory) {
 191 |     |         return cyan(vm.toString(self));
 192 |     |     }
 193 |     | 
 194 |     |     function bold(string memory self) internal pure returns (string memory) {
 195 |     |         return styleConcat(BOLD, self);
 196 |     |     }
 197 |     | 
 198 |     |     function bold(uint256 self) internal pure returns (string memory) {
 199 |     |         return bold(vm.toString(self));
 200 |     |     }
 201 |     | 
 202 |     |     function bold(int256 self) internal pure returns (string memory) {
 203 |     |         return bold(vm.toString(self));
 204 |     |     }
 205 |     | 
 206 |     |     function bold(address self) internal pure returns (string memory) {
 207 |     |         return bold(vm.toString(self));
 208 |     |     }
 209 |     | 
 210 |     |     function bold(bool self) internal pure returns (string memory) {
 211 |     |         return bold(vm.toString(self));
 212 |     |     }
 213 |     | 
 214 |     |     function boldBytes(bytes memory self) internal pure returns (string memory) {
 215 |     |         return bold(vm.toString(self));
 216 |     |     }
 217 |     | 
 218 |     |     function boldBytes32(bytes32 self) internal pure returns (string memory) {
 219 |     |         return bold(vm.toString(self));
 220 |     |     }
 221 |     | 
 222 |     |     function dim(string memory self) internal pure returns (string memory) {
 223 |     |         return styleConcat(DIM, self);
 224 |     |     }
 225 |     | 
 226 |     |     function dim(uint256 self) internal pure returns (string memory) {
 227 |     |         return dim(vm.toString(self));
 228 |     |     }
 229 |     | 
 230 |     |     function dim(int256 self) internal pure returns (string memory) {
 231 |     |         return dim(vm.toString(self));
 232 |     |     }
 233 |     | 
 234 |     |     function dim(address self) internal pure returns (string memory) {
 235 |     |         return dim(vm.toString(self));
 236 |     |     }
 237 |     | 
 238 |     |     function dim(bool self) internal pure returns (string memory) {
 239 |     |         return dim(vm.toString(self));
 240 |     |     }
 241 |     | 
 242 |     |     function dimBytes(bytes memory self) internal pure returns (string memory) {
 243 |     |         return dim(vm.toString(self));
 244 |     |     }
 245 |     | 
 246 |     |     function dimBytes32(bytes32 self) internal pure returns (string memory) {
 247 |     |         return dim(vm.toString(self));
 248 |     |     }
 249 |     | 
 250 |     |     function italic(string memory self) internal pure returns (string memory) {
 251 |     |         return styleConcat(ITALIC, self);
 252 |     |     }
 253 |     | 
 254 |     |     function italic(uint256 self) internal pure returns (string memory) {
 255 |     |         return italic(vm.toString(self));
 256 |     |     }
 257 |     | 
 258 |     |     function italic(int256 self) internal pure returns (string memory) {
 259 |     |         return italic(vm.toString(self));
 260 |     |     }
 261 |     | 
 262 |     |     function italic(address self) internal pure returns (string memory) {
 263 |     |         return italic(vm.toString(self));
 264 |     |     }
 265 |     | 
 266 |     |     function italic(bool self) internal pure returns (string memory) {
 267 |     |         return italic(vm.toString(self));
 268 |     |     }
 269 |     | 
 270 |     |     function italicBytes(bytes memory self) internal pure returns (string memory) {
 271 |     |         return italic(vm.toString(self));
 272 |     |     }
 273 |     | 
 274 |     |     function italicBytes32(bytes32 self) internal pure returns (string memory) {
 275 |     |         return italic(vm.toString(self));
 276 |     |     }
 277 |     | 
 278 |     |     function underline(string memory self) internal pure returns (string memory) {
 279 |     |         return styleConcat(UNDERLINE, self);
 280 |     |     }
 281 |     | 
 282 |     |     function underline(uint256 self) internal pure returns (string memory) {
 283 |     |         return underline(vm.toString(self));
 284 |     |     }
 285 |     | 
 286 |     |     function underline(int256 self) internal pure returns (string memory) {
 287 |     |         return underline(vm.toString(self));
 288 |     |     }
 289 |     | 
 290 |     |     function underline(address self) internal pure returns (string memory) {
 291 |     |         return underline(vm.toString(self));
 292 |     |     }
 293 |     | 
 294 |     |     function underline(bool self) internal pure returns (string memory) {
 295 |     |         return underline(vm.toString(self));
 296 |     |     }
 297 |     | 
 298 |     |     function underlineBytes(bytes memory self) internal pure returns (string memory) {
 299 |     |         return underline(vm.toString(self));
 300 |     |     }
 301 |     | 
 302 |     |     function underlineBytes32(bytes32 self) internal pure returns (string memory) {
 303 |     |         return underline(vm.toString(self));
 304 |     |     }
 305 |     | 
 306 |     |     function inverse(string memory self) internal pure returns (string memory) {
 307 |     |         return styleConcat(INVERSE, self);
 308 |     |     }
 309 |     | 
 310 |     |     function inverse(uint256 self) internal pure returns (string memory) {
 311 |     |         return inverse(vm.toString(self));
 312 |     |     }
 313 |     | 
 314 |     |     function inverse(int256 self) internal pure returns (string memory) {
 315 |     |         return inverse(vm.toString(self));
 316 |     |     }
 317 |     | 
 318 |     |     function inverse(address self) internal pure returns (string memory) {
 319 |     |         return inverse(vm.toString(self));
 320 |     |     }
 321 |     | 
 322 |     |     function inverse(bool self) internal pure returns (string memory) {
 323 |     |         return inverse(vm.toString(self));
 324 |     |     }
 325 |     | 
 326 |     |     function inverseBytes(bytes memory self) internal pure returns (string memory) {
 327 |     |         return inverse(vm.toString(self));
 328 |     |     }
 329 |     | 
 330 |     |     function inverseBytes32(bytes32 self) internal pure returns (string memory) {
 331 |     |         return inverse(vm.toString(self));
 332 |     |     }
 333 |     | }
 334 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/StdToml.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing TOML files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdToml for string;
  12 |     | // string memory toml = vm.readFile("<some_path>");
  13 |     | // toml.readUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdToml for string;
  18 |     | // string memory json = "json";
  19 |     | // json.serialize("a", uint256(123));
  20 |     | // string memory semiFinal = json.serialize("b", string("test"));
  21 |     | // string memory finalJson = json.serialize("c", semiFinal);
  22 |     | // finalJson.write("<some_path>");
  23 |     | // ```
  24 |     | 
  25 |     | library stdToml {
  26 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  27 |     | 
  28 |     |     function keyExists(string memory toml, string memory key) internal view returns (bool) {
  29 |     |         return vm.keyExistsToml(toml, key);
  30 |     |     }
  31 |     | 
  32 |     |     function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {
  33 |     |         return vm.parseToml(toml, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUint(string memory toml, string memory key) internal pure returns (uint256) {
  37 |     |         return vm.parseTomlUint(toml, key);
  38 |     |     }
  39 |     | 
  40 |     |     function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {
  41 |     |         return vm.parseTomlUintArray(toml, key);
  42 |     |     }
  43 |     | 
  44 |     |     function readInt(string memory toml, string memory key) internal pure returns (int256) {
  45 |     |         return vm.parseTomlInt(toml, key);
  46 |     |     }
  47 |     | 
  48 |     |     function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {
  49 |     |         return vm.parseTomlIntArray(toml, key);
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {
  53 |     |         return vm.parseTomlBytes32(toml, key);
  54 |     |     }
  55 |     | 
  56 |     |     function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {
  57 |     |         return vm.parseTomlBytes32Array(toml, key);
  58 |     |     }
  59 |     | 
  60 |     |     function readString(string memory toml, string memory key) internal pure returns (string memory) {
  61 |     |         return vm.parseTomlString(toml, key);
  62 |     |     }
  63 |     | 
  64 |     |     function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {
  65 |     |         return vm.parseTomlStringArray(toml, key);
  66 |     |     }
  67 |     | 
  68 |     |     function readAddress(string memory toml, string memory key) internal pure returns (address) {
  69 |     |         return vm.parseTomlAddress(toml, key);
  70 |     |     }
  71 |     | 
  72 |     |     function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {
  73 |     |         return vm.parseTomlAddressArray(toml, key);
  74 |     |     }
  75 |     | 
  76 |     |     function readBool(string memory toml, string memory key) internal pure returns (bool) {
  77 |     |         return vm.parseTomlBool(toml, key);
  78 |     |     }
  79 |     | 
  80 |     |     function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {
  81 |     |         return vm.parseTomlBoolArray(toml, key);
  82 |     |     }
  83 |     | 
  84 |     |     function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {
  85 |     |         return vm.parseTomlBytes(toml, key);
  86 |     |     }
  87 |     | 
  88 |     |     function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {
  89 |     |         return vm.parseTomlBytesArray(toml, key);
  90 |     |     }
  91 |     | 
  92 |     |     function readUintOr(string memory toml, string memory key, uint256 defaultValue) internal view returns (uint256) {
  93 |     |         return keyExists(toml, key) ? readUint(toml, key) : defaultValue;
  94 |     |     }
  95 |     | 
  96 |     |     function readUintArrayOr(string memory toml, string memory key, uint256[] memory defaultValue)
  97 |     |         internal
  98 |     |         view
  99 |     |         returns (uint256[] memory)
 100 |     |     {
 101 |     |         return keyExists(toml, key) ? readUintArray(toml, key) : defaultValue;
 102 |     |     }
 103 |     | 
 104 |     |     function readIntOr(string memory toml, string memory key, int256 defaultValue) internal view returns (int256) {
 105 |     |         return keyExists(toml, key) ? readInt(toml, key) : defaultValue;
 106 |     |     }
 107 |     | 
 108 |     |     function readIntArrayOr(string memory toml, string memory key, int256[] memory defaultValue)
 109 |     |         internal
 110 |     |         view
 111 |     |         returns (int256[] memory)
 112 |     |     {
 113 |     |         return keyExists(toml, key) ? readIntArray(toml, key) : defaultValue;
 114 |     |     }
 115 |     | 
 116 |     |     function readBytes32Or(string memory toml, string memory key, bytes32 defaultValue)
 117 |     |         internal
 118 |     |         view
 119 |     |         returns (bytes32)
 120 |     |     {
 121 |     |         return keyExists(toml, key) ? readBytes32(toml, key) : defaultValue;
 122 |     |     }
 123 |     | 
 124 |     |     function readBytes32ArrayOr(string memory toml, string memory key, bytes32[] memory defaultValue)
 125 |     |         internal
 126 |     |         view
 127 |     |         returns (bytes32[] memory)
 128 |     |     {
 129 |     |         return keyExists(toml, key) ? readBytes32Array(toml, key) : defaultValue;
 130 |     |     }
 131 |     | 
 132 |     |     function readStringOr(string memory toml, string memory key, string memory defaultValue)
 133 |     |         internal
 134 |     |         view
 135 |     |         returns (string memory)
 136 |     |     {
 137 |     |         return keyExists(toml, key) ? readString(toml, key) : defaultValue;
 138 |     |     }
 139 |     | 
 140 |     |     function readStringArrayOr(string memory toml, string memory key, string[] memory defaultValue)
 141 |     |         internal
 142 |     |         view
 143 |     |         returns (string[] memory)
 144 |     |     {
 145 |     |         return keyExists(toml, key) ? readStringArray(toml, key) : defaultValue;
 146 |     |     }
 147 |     | 
 148 |     |     function readAddressOr(string memory toml, string memory key, address defaultValue)
 149 |     |         internal
 150 |     |         view
 151 |     |         returns (address)
 152 |     |     {
 153 |     |         return keyExists(toml, key) ? readAddress(toml, key) : defaultValue;
 154 |     |     }
 155 |     | 
 156 |     |     function readAddressArrayOr(string memory toml, string memory key, address[] memory defaultValue)
 157 |     |         internal
 158 |     |         view
 159 |     |         returns (address[] memory)
 160 |     |     {
 161 |     |         return keyExists(toml, key) ? readAddressArray(toml, key) : defaultValue;
 162 |     |     }
 163 |     | 
 164 |     |     function readBoolOr(string memory toml, string memory key, bool defaultValue) internal view returns (bool) {
 165 |     |         return keyExists(toml, key) ? readBool(toml, key) : defaultValue;
 166 |     |     }
 167 |     | 
 168 |     |     function readBoolArrayOr(string memory toml, string memory key, bool[] memory defaultValue)
 169 |     |         internal
 170 |     |         view
 171 |     |         returns (bool[] memory)
 172 |     |     {
 173 |     |         return keyExists(toml, key) ? readBoolArray(toml, key) : defaultValue;
 174 |     |     }
 175 |     | 
 176 |     |     function readBytesOr(string memory toml, string memory key, bytes memory defaultValue)
 177 |     |         internal
 178 |     |         view
 179 |     |         returns (bytes memory)
 180 |     |     {
 181 |     |         return keyExists(toml, key) ? readBytes(toml, key) : defaultValue;
 182 |     |     }
 183 |     | 
 184 |     |     function readBytesArrayOr(string memory toml, string memory key, bytes[] memory defaultValue)
 185 |     |         internal
 186 |     |         view
 187 |     |         returns (bytes[] memory)
 188 |     |     {
 189 |     |         return keyExists(toml, key) ? readBytesArray(toml, key) : defaultValue;
 190 |     |     }
 191 |     | 
 192 |     |     function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {
 193 |     |         return vm.serializeJson(jsonKey, rootObject);
 194 |     |     }
 195 |     | 
 196 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
 197 |     |         return vm.serializeBool(jsonKey, key, value);
 198 |     |     }
 199 |     | 
 200 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
 201 |     |         internal
 202 |     |         returns (string memory)
 203 |     |     {
 204 |     |         return vm.serializeBool(jsonKey, key, value);
 205 |     |     }
 206 |     | 
 207 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 208 |     |         return vm.serializeUint(jsonKey, key, value);
 209 |     |     }
 210 |     | 
 211 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 212 |     |         internal
 213 |     |         returns (string memory)
 214 |     |     {
 215 |     |         return vm.serializeUint(jsonKey, key, value);
 216 |     |     }
 217 |     | 
 218 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 219 |     |         return vm.serializeInt(jsonKey, key, value);
 220 |     |     }
 221 |     | 
 222 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 223 |     |         internal
 224 |     |         returns (string memory)
 225 |     |     {
 226 |     |         return vm.serializeInt(jsonKey, key, value);
 227 |     |     }
 228 |     | 
 229 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 230 |     |         return vm.serializeAddress(jsonKey, key, value);
 231 |     |     }
 232 |     | 
 233 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 234 |     |         internal
 235 |     |         returns (string memory)
 236 |     |     {
 237 |     |         return vm.serializeAddress(jsonKey, key, value);
 238 |     |     }
 239 |     | 
 240 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 241 |     |         return vm.serializeBytes32(jsonKey, key, value);
 242 |     |     }
 243 |     | 
 244 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 245 |     |         internal
 246 |     |         returns (string memory)
 247 |     |     {
 248 |     |         return vm.serializeBytes32(jsonKey, key, value);
 249 |     |     }
 250 |     | 
 251 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 252 |     |         return vm.serializeBytes(jsonKey, key, value);
 253 |     |     }
 254 |     | 
 255 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 256 |     |         internal
 257 |     |         returns (string memory)
 258 |     |     {
 259 |     |         return vm.serializeBytes(jsonKey, key, value);
 260 |     |     }
 261 |     | 
 262 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 263 |     |         internal
 264 |     |         returns (string memory)
 265 |     |     {
 266 |     |         return vm.serializeString(jsonKey, key, value);
 267 |     |     }
 268 |     | 
 269 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 270 |     |         internal
 271 |     |         returns (string memory)
 272 |     |     {
 273 |     |         return vm.serializeString(jsonKey, key, value);
 274 |     |     }
 275 |     | 
 276 |     |     function write(string memory jsonKey, string memory path) internal {
 277 |     |         vm.writeToml(jsonKey, path);
 278 |     |     }
 279 |     | 
 280 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 281 |     |         vm.writeToml(jsonKey, path, valueKey);
 282 |     |     }
 283 |     | }
 284 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/StdUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {IMulticall3} from "./interfaces/IMulticall3.sol";
   7 |     | import {VmSafe} from "./Vm.sol";
   8 |     | 
   9 |     | abstract contract StdUtils {
  10 |     |     /*//////////////////////////////////////////////////////////////////////////
  11 |     |                                      CONSTANTS
  12 |     |     //////////////////////////////////////////////////////////////////////////*/
  13 |     | 
  14 |     |     IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);
  15 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  16 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
  17 |     |     uint256 private constant INT256_MIN_ABS =
  18 |     |         57896044618658097711785492504343953926634992332820282019728792003956564819968;
  19 |     |     uint256 private constant SECP256K1_ORDER =
  20 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
  21 |     |     uint256 private constant UINT256_MAX =
  22 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  23 |     | 
  24 |     |     // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
  25 |     |     address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
  26 |     | 
  27 |     |     /*//////////////////////////////////////////////////////////////////////////
  28 |     |                                  INTERNAL FUNCTIONS
  29 |     |     //////////////////////////////////////////////////////////////////////////*/
  30 |     | 
  31 |     |     function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  32 |     |         require(min <= max, "StdUtils bound(uint256,uint256,uint256): Max is less than min.");
  33 |     |         // If x is between min and max, return x directly. This is to ensure that dictionary values
  34 |     |         // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188
  35 |     |         if (x >= min && x <= max) return x;
  36 |     | 
  37 |     |         uint256 size = max - min + 1;
  38 |     | 
  39 |     |         // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.
  40 |     |         // This helps ensure coverage of the min/max values.
  41 |     |         if (x <= 3 && size > x) return min + x;
  42 |     |         if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);
  43 |     | 
  44 |     |         // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.
  45 |     |         if (x > max) {
  46 |     |             uint256 diff = x - max;
  47 |     |             uint256 rem = diff % size;
  48 |     |             if (rem == 0) return max;
  49 |     |             result = min + rem - 1;
  50 |     |         } else if (x < min) {
  51 |     |             uint256 diff = min - x;
  52 |     |             uint256 rem = diff % size;
  53 |     |             if (rem == 0) return min;
  54 |     |             result = max - rem + 1;
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  59 |     |         result = _bound(x, min, max);
  60 |     |         console2_log_StdUtils("Bound result", result);
  61 |     |     }
  62 |     | 
  63 |     |     function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
  64 |     |         require(min <= max, "StdUtils bound(int256,int256,int256): Max is less than min.");
  65 |     | 
  66 |     |         // Shifting all int256 values to uint256 to use _bound function. The range of two types are:
  67 |     |         // int256 : -(2**255) ~ (2**255 - 1)
  68 |     |         // uint256:     0     ~ (2**256 - 1)
  69 |     |         // So, add 2**255, INT256_MIN_ABS to the integer values.
  70 |     |         //
  71 |     |         // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.
  72 |     |         // So, use `~uint256(x) + 1` instead.
  73 |     |         uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);
  74 |     |         uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);
  75 |     |         uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);
  76 |     | 
  77 |     |         uint256 y = _bound(_x, _min, _max);
  78 |     | 
  79 |     |         // To move it back to int256 value, subtract INT256_MIN_ABS at here.
  80 |     |         result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);
  81 |     |     }
  82 |     | 
  83 |     |     function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
  84 |     |         result = _bound(x, min, max);
  85 |     |         console2_log_StdUtils("Bound result", vm.toString(result));
  86 |     |     }
  87 |     | 
  88 |     |     function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {
  89 |     |         result = _bound(privateKey, 1, SECP256K1_ORDER - 1);
  90 |     |     }
  91 |     | 
  92 |     |     function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {
  93 |     |         require(b.length <= 32, "StdUtils bytesToUint(bytes): Bytes length exceeds 32.");
  94 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
  95 |     |     }
  96 |     | 
  97 |     |     /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce
  98 |     |     /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)
  99 |     |     function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {
 100 |     |         console2_log_StdUtils("computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.");
 101 |     |         return vm.computeCreateAddress(deployer, nonce);
 102 |     |     }
 103 |     | 
 104 |     |     function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)
 105 |     |         internal
 106 |     |         pure
 107 |     |         virtual
 108 |     |         returns (address)
 109 |     |     {
 110 |     |         console2_log_StdUtils("computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.");
 111 |     |         return vm.computeCreate2Address(salt, initcodeHash, deployer);
 112 |     |     }
 113 |     | 
 114 |     |     /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer
 115 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {
 116 |     |         console2_log_StdUtils("computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.");
 117 |     |         return vm.computeCreate2Address(salt, initCodeHash);
 118 |     |     }
 119 |     | 
 120 |     |     /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments
 121 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 122 |     |     function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {
 123 |     |         return hashInitCode(creationCode, "");
 124 |     |     }
 125 |     | 
 126 |     |     /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2
 127 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 128 |     |     /// @param args the ABI-encoded arguments to the constructor of C
 129 |     |     function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {
 130 |     |         return keccak256(abi.encodePacked(creationCode, args));
 131 |     |     }
 132 |     | 
 133 |     |     // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.
 134 |     |     function getTokenBalances(address token, address[] memory addresses)
 135 |     |         internal
 136 |     |         virtual
 137 |     |         returns (uint256[] memory balances)
 138 |     |     {
 139 |     |         uint256 tokenCodeSize;
 140 |     |         assembly {
 141 |     |             tokenCodeSize := extcodesize(token)
 142 |     |         }
 143 |     |         require(tokenCodeSize > 0, "StdUtils getTokenBalances(address,address[]): Token address is not a contract.");
 144 |     | 
 145 |     |         // ABI encode the aggregate call to Multicall3.
 146 |     |         uint256 length = addresses.length;
 147 |     |         IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);
 148 |     |         for (uint256 i = 0; i < length; ++i) {
 149 |     |             // 0x70a08231 = bytes4("balanceOf(address)"))
 150 |     |             calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});
 151 |     |         }
 152 |     | 
 153 |     |         // Make the aggregate call.
 154 |     |         (, bytes[] memory returnData) = multicall.aggregate(calls);
 155 |     | 
 156 |     |         // ABI decode the return data and return the balances.
 157 |     |         balances = new uint256[](length);
 158 |     |         for (uint256 i = 0; i < length; ++i) {
 159 |     |             balances[i] = abi.decode(returnData[i], (uint256));
 160 |     |         }
 161 |     |     }
 162 |     | 
 163 |     |     /*//////////////////////////////////////////////////////////////////////////
 164 |     |                                  PRIVATE FUNCTIONS
 165 |     |     //////////////////////////////////////////////////////////////////////////*/
 166 |     | 
 167 |     |     function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {
 168 |     |         return address(uint160(uint256(bytesValue)));
 169 |     |     }
 170 |     | 
 171 |     |     // This section is used to prevent the compilation of console, which shortens the compilation time when console is
 172 |     |     // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid
 173 |     |     // any breaking changes to function signatures.
 174 |     |     function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)
 175 |     |         internal
 176 |     |         pure
 177 |     |         returns (function(bytes memory) internal pure fnOut)
 178 |     |     {
 179 |     |         assembly {
 180 |     |             fnOut := fnIn
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     function _sendLogPayload(bytes memory payload) internal pure {
 185 |     |         _castLogPayloadViewToPure(_sendLogPayloadView)(payload);
 186 |     |     }
 187 |     | 
 188 |     |     function _sendLogPayloadView(bytes memory payload) private view {
 189 |     |         uint256 payloadLength = payload.length;
 190 |     |         address consoleAddress = CONSOLE2_ADDRESS;
 191 |     |         /// @solidity memory-safe-assembly
 192 |     |         assembly {
 193 |     |             let payloadStart := add(payload, 32)
 194 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
 195 |     |         }
 196 |     |     }
 197 |     | 
 198 |     |     function console2_log_StdUtils(string memory p0) private pure {
 199 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
 200 |     |     }
 201 |     | 
 202 |     |     function console2_log_StdUtils(string memory p0, uint256 p1) private pure {
 203 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
 204 |     |     }
 205 |     | 
 206 |     |     function console2_log_StdUtils(string memory p0, string memory p1) private pure {
 207 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
 208 |     |     }
 209 |     | }
 210 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/Test.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | //  ABOUT
  7 |     | // Forge Std's default Test.
  8 |     | 
  9 |     | //  MODULES
 10 |     | import {console} from "./console.sol";
 11 |     | import {console2} from "./console2.sol";
 12 |     | import {safeconsole} from "./safeconsole.sol";
 13 |     | import {StdAssertions} from "./StdAssertions.sol";
 14 |     | import {StdChains} from "./StdChains.sol";
 15 |     | import {StdCheats} from "./StdCheats.sol";
 16 |     | import {StdConstants} from "./StdConstants.sol";
 17 |     | import {stdError} from "./StdError.sol";
 18 |     | import {StdInvariant} from "./StdInvariant.sol";
 19 |     | import {stdJson} from "./StdJson.sol";
 20 |     | import {stdMath} from "./StdMath.sol";
 21 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
 22 |     | import {StdStyle} from "./StdStyle.sol";
 23 |     | import {stdToml} from "./StdToml.sol";
 24 |     | import {StdUtils} from "./StdUtils.sol";
 25 |     | import {Vm} from "./Vm.sol";
 26 |     | 
 27 |     | //  BOILERPLATE
 28 |     | import {TestBase} from "./Base.sol";
 29 |     | 
 30 |     | //  TEST
 31 |     | abstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {
 32 |     |     // Note: IS_TEST() must return true.
 33 | *   |     bool public IS_TEST = true;
 34 |     | }
 35 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/Vm.sol
    1 |     | // Automatically @generated by scripts/vm.py. Do not modify manually.
    2 |     | 
    3 |     | // SPDX-License-Identifier: MIT OR Apache-2.0
    4 |     | pragma solidity >=0.6.2 <0.9.0;
    5 |     | pragma experimental ABIEncoderV2;
    6 |     | 
    7 |     | /// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may
    8 |     | /// result in Script simulations differing from on-chain execution. It is recommended to only use
    9 |     | /// these cheats in scripts.
   10 |     | interface VmSafe {
   11 |     |     /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.
   12 |     |     enum CallerMode {
   13 |     |         // No caller modification is currently active.
   14 |     |         None,
   15 |     |         // A one time broadcast triggered by a `vm.broadcast()` call is currently active.
   16 |     |         Broadcast,
   17 |     |         // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.
   18 |     |         RecurrentBroadcast,
   19 |     |         // A one time prank triggered by a `vm.prank()` call is currently active.
   20 |     |         Prank,
   21 |     |         // A recurrent prank triggered by a `vm.startPrank()` call is currently active.
   22 |     |         RecurrentPrank
   23 |     |     }
   24 |     | 
   25 |     |     /// The kind of account access that occurred.
   26 |     |     enum AccountAccessKind {
   27 |     |         // The account was called.
   28 |     |         Call,
   29 |     |         // The account was called via delegatecall.
   30 |     |         DelegateCall,
   31 |     |         // The account was called via callcode.
   32 |     |         CallCode,
   33 |     |         // The account was called via staticcall.
   34 |     |         StaticCall,
   35 |     |         // The account was created.
   36 |     |         Create,
   37 |     |         // The account was selfdestructed.
   38 |     |         SelfDestruct,
   39 |     |         // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).
   40 |     |         Resume,
   41 |     |         // The account's balance was read.
   42 |     |         Balance,
   43 |     |         // The account's codesize was read.
   44 |     |         Extcodesize,
   45 |     |         // The account's codehash was read.
   46 |     |         Extcodehash,
   47 |     |         // The account's code was copied.
   48 |     |         Extcodecopy
   49 |     |     }
   50 |     | 
   51 |     |     /// Forge execution contexts.
   52 |     |     enum ForgeContext {
   53 |     |         // Test group execution context (test, coverage or snapshot).
   54 |     |         TestGroup,
   55 |     |         // `forge test` execution context.
   56 |     |         Test,
   57 |     |         // `forge coverage` execution context.
   58 |     |         Coverage,
   59 |     |         // `forge snapshot` execution context.
   60 |     |         Snapshot,
   61 |     |         // Script group execution context (dry run, broadcast or resume).
   62 |     |         ScriptGroup,
   63 |     |         // `forge script` execution context.
   64 |     |         ScriptDryRun,
   65 |     |         // `forge script --broadcast` execution context.
   66 |     |         ScriptBroadcast,
   67 |     |         // `forge script --resume` execution context.
   68 |     |         ScriptResume,
   69 |     |         // Unknown `forge` execution context.
   70 |     |         Unknown
   71 |     |     }
   72 |     | 
   73 |     |     /// The transaction type (`txType`) of the broadcast.
   74 |     |     enum BroadcastTxType {
   75 |     |         // Represents a CALL broadcast tx.
   76 |     |         Call,
   77 |     |         // Represents a CREATE broadcast tx.
   78 |     |         Create,
   79 |     |         // Represents a CREATE2 broadcast tx.
   80 |     |         Create2
   81 |     |     }
   82 |     | 
   83 |     |     /// An Ethereum log. Returned by `getRecordedLogs`.
   84 |     |     struct Log {
   85 |     |         // The topics of the log, including the signature, if any.
   86 |     |         bytes32[] topics;
   87 |     |         // The raw data of the log.
   88 |     |         bytes data;
   89 |     |         // The address of the log's emitter.
   90 |     |         address emitter;
   91 |     |     }
   92 |     | 
   93 |     |     /// An RPC URL and its alias. Returned by `rpcUrlStructs`.
   94 |     |     struct Rpc {
   95 |     |         // The alias of the RPC URL.
   96 |     |         string key;
   97 |     |         // The RPC URL.
   98 |     |         string url;
   99 |     |     }
  100 |     | 
  101 |     |     /// An RPC log object. Returned by `eth_getLogs`.
  102 |     |     struct EthGetLogs {
  103 |     |         // The address of the log's emitter.
  104 |     |         address emitter;
  105 |     |         // The topics of the log, including the signature, if any.
  106 |     |         bytes32[] topics;
  107 |     |         // The raw data of the log.
  108 |     |         bytes data;
  109 |     |         // The block hash.
  110 |     |         bytes32 blockHash;
  111 |     |         // The block number.
  112 |     |         uint64 blockNumber;
  113 |     |         // The transaction hash.
  114 |     |         bytes32 transactionHash;
  115 |     |         // The transaction index in the block.
  116 |     |         uint64 transactionIndex;
  117 |     |         // The log index.
  118 |     |         uint256 logIndex;
  119 |     |         // Whether the log was removed.
  120 |     |         bool removed;
  121 |     |     }
  122 |     | 
  123 |     |     /// A single entry in a directory listing. Returned by `readDir`.
  124 |     |     struct DirEntry {
  125 |     |         // The error message, if any.
  126 |     |         string errorMessage;
  127 |     |         // The path of the entry.
  128 |     |         string path;
  129 |     |         // The depth of the entry.
  130 |     |         uint64 depth;
  131 |     |         // Whether the entry is a directory.
  132 |     |         bool isDir;
  133 |     |         // Whether the entry is a symlink.
  134 |     |         bool isSymlink;
  135 |     |     }
  136 |     | 
  137 |     |     /// Metadata information about a file.
  138 |     |     /// This structure is returned from the `fsMetadata` function and represents known
  139 |     |     /// metadata about a file such as its permissions, size, modification
  140 |     |     /// times, etc.
  141 |     |     struct FsMetadata {
  142 |     |         // True if this metadata is for a directory.
  143 |     |         bool isDir;
  144 |     |         // True if this metadata is for a symlink.
  145 |     |         bool isSymlink;
  146 |     |         // The size of the file, in bytes, this metadata is for.
  147 |     |         uint256 length;
  148 |     |         // True if this metadata is for a readonly (unwritable) file.
  149 |     |         bool readOnly;
  150 |     |         // The last modification time listed in this metadata.
  151 |     |         uint256 modified;
  152 |     |         // The last access time of this metadata.
  153 |     |         uint256 accessed;
  154 |     |         // The creation time listed in this metadata.
  155 |     |         uint256 created;
  156 |     |     }
  157 |     | 
  158 |     |     /// A wallet with a public and private key.
  159 |     |     struct Wallet {
  160 |     |         // The wallet's address.
  161 |     |         address addr;
  162 |     |         // The wallet's public key `X`.
  163 |     |         uint256 publicKeyX;
  164 |     |         // The wallet's public key `Y`.
  165 |     |         uint256 publicKeyY;
  166 |     |         // The wallet's private key.
  167 |     |         uint256 privateKey;
  168 |     |     }
  169 |     | 
  170 |     |     /// The result of a `tryFfi` call.
  171 |     |     struct FfiResult {
  172 |     |         // The exit code of the call.
  173 |     |         int32 exitCode;
  174 |     |         // The optionally hex-decoded `stdout` data.
  175 |     |         bytes stdout;
  176 |     |         // The `stderr` data.
  177 |     |         bytes stderr;
  178 |     |     }
  179 |     | 
  180 |     |     /// Information on the chain and fork.
  181 |     |     struct ChainInfo {
  182 |     |         // The fork identifier. Set to zero if no fork is active.
  183 |     |         uint256 forkId;
  184 |     |         // The chain ID of the current fork.
  185 |     |         uint256 chainId;
  186 |     |     }
  187 |     | 
  188 |     |     /// Information about a blockchain.
  189 |     |     struct Chain {
  190 |     |         // The chain name.
  191 |     |         string name;
  192 |     |         // The chain's Chain ID.
  193 |     |         uint256 chainId;
  194 |     |         // The chain's alias. (i.e. what gets specified in `foundry.toml`).
  195 |     |         string chainAlias;
  196 |     |         // A default RPC endpoint for this chain.
  197 |     |         string rpcUrl;
  198 |     |     }
  199 |     | 
  200 |     |     /// The result of a `stopAndReturnStateDiff` call.
  201 |     |     struct AccountAccess {
  202 |     |         // The chain and fork the access occurred.
  203 |     |         ChainInfo chainInfo;
  204 |     |         // The kind of account access that determines what the account is.
  205 |     |         // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.
  206 |     |         // If kind is Create, then the account is the newly created account.
  207 |     |         // If kind is SelfDestruct, then the account is the selfdestruct recipient.
  208 |     |         // If kind is a Resume, then account represents a account context that has resumed.
  209 |     |         AccountAccessKind kind;
  210 |     |         // The account that was accessed.
  211 |     |         // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.
  212 |     |         address account;
  213 |     |         // What accessed the account.
  214 |     |         address accessor;
  215 |     |         // If the account was initialized or empty prior to the access.
  216 |     |         // An account is considered initialized if it has code, a
  217 |     |         // non-zero nonce, or a non-zero balance.
  218 |     |         bool initialized;
  219 |     |         // The previous balance of the accessed account.
  220 |     |         uint256 oldBalance;
  221 |     |         // The potential new balance of the accessed account.
  222 |     |         // That is, all balance changes are recorded here, even if reverts occurred.
  223 |     |         uint256 newBalance;
  224 |     |         // Code of the account deployed by CREATE.
  225 |     |         bytes deployedCode;
  226 |     |         // Value passed along with the account access
  227 |     |         uint256 value;
  228 |     |         // Input data provided to the CREATE or CALL
  229 |     |         bytes data;
  230 |     |         // If this access reverted in either the current or parent context.
  231 |     |         bool reverted;
  232 |     |         // An ordered list of storage accesses made during an account access operation.
  233 |     |         StorageAccess[] storageAccesses;
  234 |     |         // Call depth traversed during the recording of state differences
  235 |     |         uint64 depth;
  236 |     |     }
  237 |     | 
  238 |     |     /// The storage accessed during an `AccountAccess`.
  239 |     |     struct StorageAccess {
  240 |     |         // The account whose storage was accessed.
  241 |     |         address account;
  242 |     |         // The slot that was accessed.
  243 |     |         bytes32 slot;
  244 |     |         // If the access was a write.
  245 |     |         bool isWrite;
  246 |     |         // The previous value of the slot.
  247 |     |         bytes32 previousValue;
  248 |     |         // The new value of the slot.
  249 |     |         bytes32 newValue;
  250 |     |         // If the access was reverted.
  251 |     |         bool reverted;
  252 |     |     }
  253 |     | 
  254 |     |     /// Gas used. Returned by `lastCallGas`.
  255 |     |     struct Gas {
  256 |     |         // The gas limit of the call.
  257 |     |         uint64 gasLimit;
  258 |     |         // The total gas used.
  259 |     |         uint64 gasTotalUsed;
  260 |     |         // DEPRECATED: The amount of gas used for memory expansion. Ref: <https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939>
  261 |     |         uint64 gasMemoryUsed;
  262 |     |         // The amount of gas refunded.
  263 |     |         int64 gasRefunded;
  264 |     |         // The amount of gas remaining.
  265 |     |         uint64 gasRemaining;
  266 |     |     }
  267 |     | 
  268 |     |     /// The result of the `stopDebugTraceRecording` call
  269 |     |     struct DebugStep {
  270 |     |         // The stack before executing the step of the run.
  271 |     |         // stack\[0\] represents the top of the stack.
  272 |     |         // and only stack data relevant to the opcode execution is contained.
  273 |     |         uint256[] stack;
  274 |     |         // The memory input data before executing the step of the run.
  275 |     |         // only input data relevant to the opcode execution is contained.
  276 |     |         // e.g. for MLOAD, it will have memory\[offset:offset+32\] copied here.
  277 |     |         // the offset value can be get by the stack data.
  278 |     |         bytes memoryInput;
  279 |     |         // The opcode that was accessed.
  280 |     |         uint8 opcode;
  281 |     |         // The call depth of the step.
  282 |     |         uint64 depth;
  283 |     |         // Whether the call end up with out of gas error.
  284 |     |         bool isOutOfGas;
  285 |     |         // The contract address where the opcode is running
  286 |     |         address contractAddr;
  287 |     |     }
  288 |     | 
  289 |     |     /// Represents a transaction's broadcast details.
  290 |     |     struct BroadcastTxSummary {
  291 |     |         // The hash of the transaction that was broadcasted
  292 |     |         bytes32 txHash;
  293 |     |         // Represent the type of transaction among CALL, CREATE, CREATE2
  294 |     |         BroadcastTxType txType;
  295 |     |         // The address of the contract that was called or created.
  296 |     |         // This is address of the contract that is created if the txType is CREATE or CREATE2.
  297 |     |         address contractAddress;
  298 |     |         // The block number the transaction landed in.
  299 |     |         uint64 blockNumber;
  300 |     |         // Status of the transaction, retrieved from the transaction receipt.
  301 |     |         bool success;
  302 |     |     }
  303 |     | 
  304 |     |     /// Holds a signed EIP-7702 authorization for an authority account to delegate to an implementation.
  305 |     |     struct SignedDelegation {
  306 |     |         // The y-parity of the recovered secp256k1 signature (0 or 1).
  307 |     |         uint8 v;
  308 |     |         // First 32 bytes of the signature.
  309 |     |         bytes32 r;
  310 |     |         // Second 32 bytes of the signature.
  311 |     |         bytes32 s;
  312 |     |         // The current nonce of the authority account at signing time.
  313 |     |         // Used to ensure signature can't be replayed after account nonce changes.
  314 |     |         uint64 nonce;
  315 |     |         // Address of the contract implementation that will be delegated to.
  316 |     |         // Gets encoded into delegation code: 0xef0100 || implementation.
  317 |     |         address implementation;
  318 |     |     }
  319 |     | 
  320 |     |     /// Represents a "potential" revert reason from a single subsequent call when using `vm.assumeNoReverts`.
  321 |     |     /// Reverts that match will result in a FOUNDRY::ASSUME rejection, whereas unmatched reverts will be surfaced
  322 |     |     /// as normal.
  323 |     |     struct PotentialRevert {
  324 |     |         // The allowed origin of the revert opcode; address(0) allows reverts from any address
  325 |     |         address reverter;
  326 |     |         // When true, only matches on the beginning of the revert data, otherwise, matches on entire revert data
  327 |     |         bool partialMatch;
  328 |     |         // The data to use to match encountered reverts
  329 |     |         bytes revertData;
  330 |     |     }
  331 |     | 
  332 |     |     /// An EIP-2930 access list item.
  333 |     |     struct AccessListItem {
  334 |     |         // The address to be added in access list.
  335 |     |         address target;
  336 |     |         // The storage keys to be added in access list.
  337 |     |         bytes32[] storageKeys;
  338 |     |     }
  339 |     | 
  340 |     |     // ======== Crypto ========
  341 |     | 
  342 |     |     /// Derives a private key from the name, labels the account with that name, and returns the wallet.
  343 |     |     function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);
  344 |     | 
  345 |     |     /// Generates a wallet from the private key and returns the wallet.
  346 |     |     function createWallet(uint256 privateKey) external returns (Wallet memory wallet);
  347 |     | 
  348 |     |     /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.
  349 |     |     function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);
  350 |     | 
  351 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path)
  352 |     |     /// at the derivation path `m/44'/60'/0'/0/{index}`.
  353 |     |     function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);
  354 |     | 
  355 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path)
  356 |     |     /// at `{derivationPath}{index}`.
  357 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)
  358 |     |         external
  359 |     |         pure
  360 |     |         returns (uint256 privateKey);
  361 |     | 
  362 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language
  363 |     |     /// at the derivation path `m/44'/60'/0'/0/{index}`.
  364 |     |     function deriveKey(string calldata mnemonic, uint32 index, string calldata language)
  365 |     |         external
  366 |     |         pure
  367 |     |         returns (uint256 privateKey);
  368 |     | 
  369 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language
  370 |     |     /// at `{derivationPath}{index}`.
  371 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)
  372 |     |         external
  373 |     |         pure
  374 |     |         returns (uint256 privateKey);
  375 |     | 
  376 |     |     /// Derives secp256r1 public key from the provided `privateKey`.
  377 |     |     function publicKeyP256(uint256 privateKey) external pure returns (uint256 publicKeyX, uint256 publicKeyY);
  378 |     | 
  379 |     |     /// Adds a private key to the local forge wallet and returns the address.
  380 |     |     function rememberKey(uint256 privateKey) external returns (address keyAddr);
  381 |     | 
  382 |     |     /// Derive a set number of wallets from a mnemonic at the derivation path `m/44'/60'/0'/0/{0..count}`.
  383 |     |     /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.
  384 |     |     function rememberKeys(string calldata mnemonic, string calldata derivationPath, uint32 count)
  385 |     |         external
  386 |     |         returns (address[] memory keyAddrs);
  387 |     | 
  388 |     |     /// Derive a set number of wallets from a mnemonic in the specified language at the derivation path `m/44'/60'/0'/0/{0..count}`.
  389 |     |     /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.
  390 |     |     function rememberKeys(
  391 |     |         string calldata mnemonic,
  392 |     |         string calldata derivationPath,
  393 |     |         string calldata language,
  394 |     |         uint32 count
  395 |     |     ) external returns (address[] memory keyAddrs);
  396 |     | 
  397 |     |     /// Signs data with a `Wallet`.
  398 |     |     /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the
  399 |     |     /// signature's `s` value, and the recovery id `v` in a single bytes32.
  400 |     |     /// This format reduces the signature size from 65 to 64 bytes.
  401 |     |     function signCompact(Wallet calldata wallet, bytes32 digest) external returns (bytes32 r, bytes32 vs);
  402 |     | 
  403 |     |     /// Signs `digest` with `privateKey` using the secp256k1 curve.
  404 |     |     /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the
  405 |     |     /// signature's `s` value, and the recovery id `v` in a single bytes32.
  406 |     |     /// This format reduces the signature size from 65 to 64 bytes.
  407 |     |     function signCompact(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
  408 |     | 
  409 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  410 |     |     /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the
  411 |     |     /// signature's `s` value, and the recovery id `v` in a single bytes32.
  412 |     |     /// This format reduces the signature size from 65 to 64 bytes.
  413 |     |     /// If `--sender` is provided, the signer with provided address is used, otherwise,
  414 |     |     /// if exactly one signer is provided to the script, that signer is used.
  415 |     |     /// Raises error if signer passed through `--sender` does not match any unlocked signers or
  416 |     |     /// if `--sender` is not provided and not exactly one signer is passed to the script.
  417 |     |     function signCompact(bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
  418 |     | 
  419 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  420 |     |     /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the
  421 |     |     /// signature's `s` value, and the recovery id `v` in a single bytes32.
  422 |     |     /// This format reduces the signature size from 65 to 64 bytes.
  423 |     |     /// Raises error if none of the signers passed into the script have provided address.
  424 |     |     function signCompact(address signer, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
  425 |     | 
  426 |     |     /// Signs `digest` with `privateKey` using the secp256r1 curve.
  427 |     |     function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);
  428 |     | 
  429 |     |     /// Signs data with a `Wallet`.
  430 |     |     function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);
  431 |     | 
  432 |     |     /// Signs `digest` with `privateKey` using the secp256k1 curve.
  433 |     |     function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  434 |     | 
  435 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  436 |     |     /// If `--sender` is provided, the signer with provided address is used, otherwise,
  437 |     |     /// if exactly one signer is provided to the script, that signer is used.
  438 |     |     /// Raises error if signer passed through `--sender` does not match any unlocked signers or
  439 |     |     /// if `--sender` is not provided and not exactly one signer is passed to the script.
  440 |     |     function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  441 |     | 
  442 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  443 |     |     /// Raises error if none of the signers passed into the script have provided address.
  444 |     |     function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  445 |     | 
  446 |     |     // ======== Environment ========
  447 |     | 
  448 |     |     /// Gets the environment variable `name` and parses it as `address`.
  449 |     |     /// Reverts if the variable was not found or could not be parsed.
  450 |     |     function envAddress(string calldata name) external view returns (address value);
  451 |     | 
  452 |     |     /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.
  453 |     |     /// Reverts if the variable was not found or could not be parsed.
  454 |     |     function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);
  455 |     | 
  456 |     |     /// Gets the environment variable `name` and parses it as `bool`.
  457 |     |     /// Reverts if the variable was not found or could not be parsed.
  458 |     |     function envBool(string calldata name) external view returns (bool value);
  459 |     | 
  460 |     |     /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.
  461 |     |     /// Reverts if the variable was not found or could not be parsed.
  462 |     |     function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);
  463 |     | 
  464 |     |     /// Gets the environment variable `name` and parses it as `bytes32`.
  465 |     |     /// Reverts if the variable was not found or could not be parsed.
  466 |     |     function envBytes32(string calldata name) external view returns (bytes32 value);
  467 |     | 
  468 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.
  469 |     |     /// Reverts if the variable was not found or could not be parsed.
  470 |     |     function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);
  471 |     | 
  472 |     |     /// Gets the environment variable `name` and parses it as `bytes`.
  473 |     |     /// Reverts if the variable was not found or could not be parsed.
  474 |     |     function envBytes(string calldata name) external view returns (bytes memory value);
  475 |     | 
  476 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.
  477 |     |     /// Reverts if the variable was not found or could not be parsed.
  478 |     |     function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);
  479 |     | 
  480 |     |     /// Gets the environment variable `name` and returns true if it exists, else returns false.
  481 |     |     function envExists(string calldata name) external view returns (bool result);
  482 |     | 
  483 |     |     /// Gets the environment variable `name` and parses it as `int256`.
  484 |     |     /// Reverts if the variable was not found or could not be parsed.
  485 |     |     function envInt(string calldata name) external view returns (int256 value);
  486 |     | 
  487 |     |     /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.
  488 |     |     /// Reverts if the variable was not found or could not be parsed.
  489 |     |     function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);
  490 |     | 
  491 |     |     /// Gets the environment variable `name` and parses it as `bool`.
  492 |     |     /// Reverts if the variable could not be parsed.
  493 |     |     /// Returns `defaultValue` if the variable was not found.
  494 |     |     function envOr(string calldata name, bool defaultValue) external view returns (bool value);
  495 |     | 
  496 |     |     /// Gets the environment variable `name` and parses it as `uint256`.
  497 |     |     /// Reverts if the variable could not be parsed.
  498 |     |     /// Returns `defaultValue` if the variable was not found.
  499 |     |     function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);
  500 |     | 
  501 |     |     /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.
  502 |     |     /// Reverts if the variable could not be parsed.
  503 |     |     /// Returns `defaultValue` if the variable was not found.
  504 |     |     function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)
  505 |     |         external
  506 |     |         view
  507 |     |         returns (address[] memory value);
  508 |     | 
  509 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.
  510 |     |     /// Reverts if the variable could not be parsed.
  511 |     |     /// Returns `defaultValue` if the variable was not found.
  512 |     |     function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)
  513 |     |         external
  514 |     |         view
  515 |     |         returns (bytes32[] memory value);
  516 |     | 
  517 |     |     /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.
  518 |     |     /// Reverts if the variable could not be parsed.
  519 |     |     /// Returns `defaultValue` if the variable was not found.
  520 |     |     function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)
  521 |     |         external
  522 |     |         view
  523 |     |         returns (string[] memory value);
  524 |     | 
  525 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.
  526 |     |     /// Reverts if the variable could not be parsed.
  527 |     |     /// Returns `defaultValue` if the variable was not found.
  528 |     |     function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)
  529 |     |         external
  530 |     |         view
  531 |     |         returns (bytes[] memory value);
  532 |     | 
  533 |     |     /// Gets the environment variable `name` and parses it as `int256`.
  534 |     |     /// Reverts if the variable could not be parsed.
  535 |     |     /// Returns `defaultValue` if the variable was not found.
  536 |     |     function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);
  537 |     | 
  538 |     |     /// Gets the environment variable `name` and parses it as `address`.
  539 |     |     /// Reverts if the variable could not be parsed.
  540 |     |     /// Returns `defaultValue` if the variable was not found.
  541 |     |     function envOr(string calldata name, address defaultValue) external view returns (address value);
  542 |     | 
  543 |     |     /// Gets the environment variable `name` and parses it as `bytes32`.
  544 |     |     /// Reverts if the variable could not be parsed.
  545 |     |     /// Returns `defaultValue` if the variable was not found.
  546 |     |     function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);
  547 |     | 
  548 |     |     /// Gets the environment variable `name` and parses it as `string`.
  549 |     |     /// Reverts if the variable could not be parsed.
  550 |     |     /// Returns `defaultValue` if the variable was not found.
  551 |     |     function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);
  552 |     | 
  553 |     |     /// Gets the environment variable `name` and parses it as `bytes`.
  554 |     |     /// Reverts if the variable could not be parsed.
  555 |     |     /// Returns `defaultValue` if the variable was not found.
  556 |     |     function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);
  557 |     | 
  558 |     |     /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.
  559 |     |     /// Reverts if the variable could not be parsed.
  560 |     |     /// Returns `defaultValue` if the variable was not found.
  561 |     |     function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)
  562 |     |         external
  563 |     |         view
  564 |     |         returns (bool[] memory value);
  565 |     | 
  566 |     |     /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.
  567 |     |     /// Reverts if the variable could not be parsed.
  568 |     |     /// Returns `defaultValue` if the variable was not found.
  569 |     |     function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)
  570 |     |         external
  571 |     |         view
  572 |     |         returns (uint256[] memory value);
  573 |     | 
  574 |     |     /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.
  575 |     |     /// Reverts if the variable could not be parsed.
  576 |     |     /// Returns `defaultValue` if the variable was not found.
  577 |     |     function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)
  578 |     |         external
  579 |     |         view
  580 |     |         returns (int256[] memory value);
  581 |     | 
  582 |     |     /// Gets the environment variable `name` and parses it as `string`.
  583 |     |     /// Reverts if the variable was not found or could not be parsed.
  584 |     |     function envString(string calldata name) external view returns (string memory value);
  585 |     | 
  586 |     |     /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.
  587 |     |     /// Reverts if the variable was not found or could not be parsed.
  588 |     |     function envString(string calldata name, string calldata delim) external view returns (string[] memory value);
  589 |     | 
  590 |     |     /// Gets the environment variable `name` and parses it as `uint256`.
  591 |     |     /// Reverts if the variable was not found or could not be parsed.
  592 |     |     function envUint(string calldata name) external view returns (uint256 value);
  593 |     | 
  594 |     |     /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.
  595 |     |     /// Reverts if the variable was not found or could not be parsed.
  596 |     |     function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);
  597 |     | 
  598 |     |     /// Returns true if `forge` command was executed in given context.
  599 |     |     function isContext(ForgeContext context) external view returns (bool result);
  600 |     | 
  601 |     |     /// Sets environment variables.
  602 |     |     function setEnv(string calldata name, string calldata value) external;
  603 |     | 
  604 |     |     // ======== EVM ========
  605 |     | 
  606 |     |     /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.
  607 |     |     function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);
  608 |     | 
  609 |     |     /// Gets the address for a given private key.
  610 |     |     function addr(uint256 privateKey) external pure returns (address keyAddr);
  611 |     | 
  612 |     |     /// Gets all the logs according to specified filter.
  613 |     |     function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)
  614 |     |         external
  615 |     |         returns (EthGetLogs[] memory logs);
  616 |     | 
  617 |     |     /// Gets the current `block.blobbasefee`.
  618 |     |     /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,
  619 |     |     /// and as a result will get optimized out by the compiler.
  620 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  621 |     |     function getBlobBaseFee() external view returns (uint256 blobBaseFee);
  622 |     | 
  623 |     |     /// Gets the current `block.number`.
  624 |     |     /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,
  625 |     |     /// and as a result will get optimized out by the compiler.
  626 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  627 |     |     function getBlockNumber() external view returns (uint256 height);
  628 |     | 
  629 |     |     /// Gets the current `block.timestamp`.
  630 |     |     /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,
  631 |     |     /// and as a result will get optimized out by the compiler.
  632 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  633 |     |     function getBlockTimestamp() external view returns (uint256 timestamp);
  634 |     | 
  635 |     |     /// Gets the map key and parent of a mapping at a given slot, for a given address.
  636 |     |     function getMappingKeyAndParentOf(address target, bytes32 elementSlot)
  637 |     |         external
  638 |     |         returns (bool found, bytes32 key, bytes32 parent);
  639 |     | 
  640 |     |     /// Gets the number of elements in the mapping at the given slot, for a given address.
  641 |     |     function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);
  642 |     | 
  643 |     |     /// Gets the elements at index idx of the mapping at the given slot, for a given address. The
  644 |     |     /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).
  645 |     |     function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);
  646 |     | 
  647 |     |     /// Gets the nonce of an account.
  648 |     |     function getNonce(address account) external view returns (uint64 nonce);
  649 |     | 
  650 |     |     /// Get the nonce of a `Wallet`.
  651 |     |     function getNonce(Wallet calldata wallet) external returns (uint64 nonce);
  652 |     | 
  653 |     |     /// Gets all the recorded logs.
  654 |     |     function getRecordedLogs() external returns (Log[] memory logs);
  655 |     | 
  656 |     |     /// Returns state diffs from current `vm.startStateDiffRecording` session.
  657 |     |     function getStateDiff() external view returns (string memory diff);
  658 |     | 
  659 |     |     /// Returns state diffs from current `vm.startStateDiffRecording` session, in json format.
  660 |     |     function getStateDiffJson() external view returns (string memory diff);
  661 |     | 
  662 |     |     /// Gets the gas used in the last call from the callee perspective.
  663 |     |     function lastCallGas() external view returns (Gas memory gas);
  664 |     | 
  665 |     |     /// Loads a storage slot from an address.
  666 |     |     function load(address target, bytes32 slot) external view returns (bytes32 data);
  667 |     | 
  668 |     |     /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
  669 |     |     function pauseGasMetering() external;
  670 |     | 
  671 |     |     /// Records all storage reads and writes.
  672 |     |     function record() external;
  673 |     | 
  674 |     |     /// Record all the transaction logs.
  675 |     |     function recordLogs() external;
  676 |     | 
  677 |     |     /// Reset gas metering (i.e. gas usage is set to gas limit).
  678 |     |     function resetGasMetering() external;
  679 |     | 
  680 |     |     /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
  681 |     |     function resumeGasMetering() external;
  682 |     | 
  683 |     |     /// Performs an Ethereum JSON-RPC request to the current fork URL.
  684 |     |     function rpc(string calldata method, string calldata params) external returns (bytes memory data);
  685 |     | 
  686 |     |     /// Performs an Ethereum JSON-RPC request to the given endpoint.
  687 |     |     function rpc(string calldata urlOrAlias, string calldata method, string calldata params)
  688 |     |         external
  689 |     |         returns (bytes memory data);
  690 |     | 
  691 |     |     /// Records the debug trace during the run.
  692 |     |     function startDebugTraceRecording() external;
  693 |     | 
  694 |     |     /// Starts recording all map SSTOREs for later retrieval.
  695 |     |     function startMappingRecording() external;
  696 |     | 
  697 |     |     /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,
  698 |     |     /// along with the context of the calls
  699 |     |     function startStateDiffRecording() external;
  700 |     | 
  701 |     |     /// Stop debug trace recording and returns the recorded debug trace.
  702 |     |     function stopAndReturnDebugTraceRecording() external returns (DebugStep[] memory step);
  703 |     | 
  704 |     |     /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
  705 |     |     function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);
  706 |     | 
  707 |     |     /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.
  708 |     |     function stopMappingRecording() external;
  709 |     | 
  710 |     |     // ======== Filesystem ========
  711 |     | 
  712 |     |     /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.
  713 |     |     /// `path` is relative to the project root.
  714 |     |     function closeFile(string calldata path) external;
  715 |     | 
  716 |     |     /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.
  717 |     |     /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.
  718 |     |     /// Both `from` and `to` are relative to the project root.
  719 |     |     function copyFile(string calldata from, string calldata to) external returns (uint64 copied);
  720 |     | 
  721 |     |     /// Creates a new, empty directory at the provided path.
  722 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  723 |     |     /// - User lacks permissions to modify `path`.
  724 |     |     /// - A parent of the given path doesn't exist and `recursive` is false.
  725 |     |     /// - `path` already exists and `recursive` is false.
  726 |     |     /// `path` is relative to the project root.
  727 |     |     function createDir(string calldata path, bool recursive) external;
  728 |     | 
  729 |     |     /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the
  730 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  731 |     |     function deployCode(string calldata artifactPath) external returns (address deployedAddress);
  732 |     | 
  733 |     |     /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the
  734 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  735 |     |     /// Additionally accepts abi-encoded constructor arguments.
  736 |     |     function deployCode(string calldata artifactPath, bytes calldata constructorArgs)
  737 |     |         external
  738 |     |         returns (address deployedAddress);
  739 |     | 
  740 |     |     /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the
  741 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  742 |     |     /// Additionally accepts `msg.value`.
  743 |     |     function deployCode(string calldata artifactPath, uint256 value) external returns (address deployedAddress);
  744 |     | 
  745 |     |     /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the
  746 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  747 |     |     /// Additionally accepts abi-encoded constructor arguments and `msg.value`.
  748 |     |     function deployCode(string calldata artifactPath, bytes calldata constructorArgs, uint256 value)
  749 |     |         external
  750 |     |         returns (address deployedAddress);
  751 |     | 
  752 |     |     /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the
  753 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  754 |     |     function deployCode(string calldata artifactPath, bytes32 salt) external returns (address deployedAddress);
  755 |     | 
  756 |     |     /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the
  757 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  758 |     |     /// Additionally accepts abi-encoded constructor arguments.
  759 |     |     function deployCode(string calldata artifactPath, bytes calldata constructorArgs, bytes32 salt)
  760 |     |         external
  761 |     |         returns (address deployedAddress);
  762 |     | 
  763 |     |     /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the
  764 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  765 |     |     /// Additionally accepts `msg.value`.
  766 |     |     function deployCode(string calldata artifactPath, uint256 value, bytes32 salt)
  767 |     |         external
  768 |     |         returns (address deployedAddress);
  769 |     | 
  770 |     |     /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the
  771 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  772 |     |     /// Additionally accepts abi-encoded constructor arguments and `msg.value`.
  773 |     |     function deployCode(string calldata artifactPath, bytes calldata constructorArgs, uint256 value, bytes32 salt)
  774 |     |         external
  775 |     |         returns (address deployedAddress);
  776 |     | 
  777 |     |     /// Returns true if the given path points to an existing entity, else returns false.
  778 |     |     function exists(string calldata path) external view returns (bool result);
  779 |     | 
  780 |     |     /// Performs a foreign function call via the terminal.
  781 |     |     function ffi(string[] calldata commandInput) external returns (bytes memory result);
  782 |     | 
  783 |     |     /// Given a path, query the file system to get information about a file, directory, etc.
  784 |     |     function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);
  785 |     | 
  786 |     |     /// Gets the artifact path from code (aka. creation code).
  787 |     |     function getArtifactPathByCode(bytes calldata code) external view returns (string memory path);
  788 |     | 
  789 |     |     /// Gets the artifact path from deployed code (aka. runtime code).
  790 |     |     function getArtifactPathByDeployedCode(bytes calldata deployedCode) external view returns (string memory path);
  791 |     | 
  792 |     |     /// Returns the most recent broadcast for the given contract on `chainId` matching `txType`.
  793 |     |     /// For example:
  794 |     |     /// The most recent deployment can be fetched by passing `txType` as `CREATE` or `CREATE2`.
  795 |     |     /// The most recent call can be fetched by passing `txType` as `CALL`.
  796 |     |     function getBroadcast(string calldata contractName, uint64 chainId, BroadcastTxType txType)
  797 |     |         external
  798 |     |         view
  799 |     |         returns (BroadcastTxSummary memory);
  800 |     | 
  801 |     |     /// Returns all broadcasts for the given contract on `chainId` with the specified `txType`.
  802 |     |     /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.
  803 |     |     function getBroadcasts(string calldata contractName, uint64 chainId, BroadcastTxType txType)
  804 |     |         external
  805 |     |         view
  806 |     |         returns (BroadcastTxSummary[] memory);
  807 |     | 
  808 |     |     /// Returns all broadcasts for the given contract on `chainId`.
  809 |     |     /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.
  810 |     |     function getBroadcasts(string calldata contractName, uint64 chainId)
  811 |     |         external
  812 |     |         view
  813 |     |         returns (BroadcastTxSummary[] memory);
  814 |     | 
  815 |     |     /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the
  816 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  817 |     |     function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);
  818 |     | 
  819 |     |     /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the
  820 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  821 |     |     function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);
  822 |     | 
  823 |     |     /// Returns the most recent deployment for the current `chainId`.
  824 |     |     function getDeployment(string calldata contractName) external view returns (address deployedAddress);
  825 |     | 
  826 |     |     /// Returns the most recent deployment for the given contract on `chainId`
  827 |     |     function getDeployment(string calldata contractName, uint64 chainId)
  828 |     |         external
  829 |     |         view
  830 |     |         returns (address deployedAddress);
  831 |     | 
  832 |     |     /// Returns all deployments for the given contract on `chainId`
  833 |     |     /// Sorted in descending order of deployment time i.e descending order of BroadcastTxSummary.blockNumber.
  834 |     |     /// The most recent deployment is the first element, and the oldest is the last.
  835 |     |     function getDeployments(string calldata contractName, uint64 chainId)
  836 |     |         external
  837 |     |         view
  838 |     |         returns (address[] memory deployedAddresses);
  839 |     | 
  840 |     |     /// Returns true if the path exists on disk and is pointing at a directory, else returns false.
  841 |     |     function isDir(string calldata path) external view returns (bool result);
  842 |     | 
  843 |     |     /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.
  844 |     |     function isFile(string calldata path) external view returns (bool result);
  845 |     | 
  846 |     |     /// Get the path of the current project root.
  847 |     |     function projectRoot() external view returns (string memory path);
  848 |     | 
  849 |     |     /// Prompts the user for a string value in the terminal.
  850 |     |     function prompt(string calldata promptText) external returns (string memory input);
  851 |     | 
  852 |     |     /// Prompts the user for an address in the terminal.
  853 |     |     function promptAddress(string calldata promptText) external returns (address);
  854 |     | 
  855 |     |     /// Prompts the user for a hidden string value in the terminal.
  856 |     |     function promptSecret(string calldata promptText) external returns (string memory input);
  857 |     | 
  858 |     |     /// Prompts the user for hidden uint256 in the terminal (usually pk).
  859 |     |     function promptSecretUint(string calldata promptText) external returns (uint256);
  860 |     | 
  861 |     |     /// Prompts the user for uint256 in the terminal.
  862 |     |     function promptUint(string calldata promptText) external returns (uint256);
  863 |     | 
  864 |     |     /// Reads the directory at the given path recursively, up to `maxDepth`.
  865 |     |     /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.
  866 |     |     /// Follows symbolic links if `followLinks` is true.
  867 |     |     function readDir(string calldata path) external view returns (DirEntry[] memory entries);
  868 |     | 
  869 |     |     /// See `readDir(string)`.
  870 |     |     function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);
  871 |     | 
  872 |     |     /// See `readDir(string)`.
  873 |     |     function readDir(string calldata path, uint64 maxDepth, bool followLinks)
  874 |     |         external
  875 |     |         view
  876 |     |         returns (DirEntry[] memory entries);
  877 |     | 
  878 |     |     /// Reads the entire content of file to string. `path` is relative to the project root.
  879 |     |     function readFile(string calldata path) external view returns (string memory data);
  880 |     | 
  881 |     |     /// Reads the entire content of file as binary. `path` is relative to the project root.
  882 |     |     function readFileBinary(string calldata path) external view returns (bytes memory data);
  883 |     | 
  884 |     |     /// Reads next line of file to string.
  885 |     |     function readLine(string calldata path) external view returns (string memory line);
  886 |     | 
  887 |     |     /// Reads a symbolic link, returning the path that the link points to.
  888 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  889 |     |     /// - `path` is not a symbolic link.
  890 |     |     /// - `path` does not exist.
  891 |     |     function readLink(string calldata linkPath) external view returns (string memory targetPath);
  892 |     | 
  893 |     |     /// Removes a directory at the provided path.
  894 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  895 |     |     /// - `path` doesn't exist.
  896 |     |     /// - `path` isn't a directory.
  897 |     |     /// - User lacks permissions to modify `path`.
  898 |     |     /// - The directory is not empty and `recursive` is false.
  899 |     |     /// `path` is relative to the project root.
  900 |     |     function removeDir(string calldata path, bool recursive) external;
  901 |     | 
  902 |     |     /// Removes a file from the filesystem.
  903 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  904 |     |     /// - `path` points to a directory.
  905 |     |     /// - The file doesn't exist.
  906 |     |     /// - The user lacks permissions to remove the file.
  907 |     |     /// `path` is relative to the project root.
  908 |     |     function removeFile(string calldata path) external;
  909 |     | 
  910 |     |     /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
  911 |     |     function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);
  912 |     | 
  913 |     |     /// Returns the time since unix epoch in milliseconds.
  914 |     |     function unixTime() external view returns (uint256 milliseconds);
  915 |     | 
  916 |     |     /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.
  917 |     |     /// `path` is relative to the project root.
  918 |     |     function writeFile(string calldata path, string calldata data) external;
  919 |     | 
  920 |     |     /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.
  921 |     |     /// `path` is relative to the project root.
  922 |     |     function writeFileBinary(string calldata path, bytes calldata data) external;
  923 |     | 
  924 |     |     /// Writes line to file, creating a file if it does not exist.
  925 |     |     /// `path` is relative to the project root.
  926 |     |     function writeLine(string calldata path, string calldata data) external;
  927 |     | 
  928 |     |     // ======== JSON ========
  929 |     | 
  930 |     |     /// Checks if `key` exists in a JSON object.
  931 |     |     function keyExistsJson(string calldata json, string calldata key) external view returns (bool);
  932 |     | 
  933 |     |     /// Parses a string of JSON data at `key` and coerces it to `address`.
  934 |     |     function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);
  935 |     | 
  936 |     |     /// Parses a string of JSON data at `key` and coerces it to `address[]`.
  937 |     |     function parseJsonAddressArray(string calldata json, string calldata key)
  938 |     |         external
  939 |     |         pure
  940 |     |         returns (address[] memory);
  941 |     | 
  942 |     |     /// Parses a string of JSON data at `key` and coerces it to `bool`.
  943 |     |     function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);
  944 |     | 
  945 |     |     /// Parses a string of JSON data at `key` and coerces it to `bool[]`.
  946 |     |     function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);
  947 |     | 
  948 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes`.
  949 |     |     function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);
  950 |     | 
  951 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes32`.
  952 |     |     function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);
  953 |     | 
  954 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
  955 |     |     function parseJsonBytes32Array(string calldata json, string calldata key)
  956 |     |         external
  957 |     |         pure
  958 |     |         returns (bytes32[] memory);
  959 |     | 
  960 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.
  961 |     |     function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);
  962 |     | 
  963 |     |     /// Parses a string of JSON data at `key` and coerces it to `int256`.
  964 |     |     function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);
  965 |     | 
  966 |     |     /// Parses a string of JSON data at `key` and coerces it to `int256[]`.
  967 |     |     function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);
  968 |     | 
  969 |     |     /// Returns an array of all the keys in a JSON object.
  970 |     |     function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);
  971 |     | 
  972 |     |     /// Parses a string of JSON data at `key` and coerces it to `string`.
  973 |     |     function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);
  974 |     | 
  975 |     |     /// Parses a string of JSON data at `key` and coerces it to `string[]`.
  976 |     |     function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);
  977 |     | 
  978 |     |     /// Parses a string of JSON data at `key` and coerces it to type array corresponding to `typeDescription`.
  979 |     |     function parseJsonTypeArray(string calldata json, string calldata key, string calldata typeDescription)
  980 |     |         external
  981 |     |         pure
  982 |     |         returns (bytes memory);
  983 |     | 
  984 |     |     /// Parses a string of JSON data and coerces it to type corresponding to `typeDescription`.
  985 |     |     function parseJsonType(string calldata json, string calldata typeDescription)
  986 |     |         external
  987 |     |         pure
  988 |     |         returns (bytes memory);
  989 |     | 
  990 |     |     /// Parses a string of JSON data at `key` and coerces it to type corresponding to `typeDescription`.
  991 |     |     function parseJsonType(string calldata json, string calldata key, string calldata typeDescription)
  992 |     |         external
  993 |     |         pure
  994 |     |         returns (bytes memory);
  995 |     | 
  996 |     |     /// Parses a string of JSON data at `key` and coerces it to `uint256`.
  997 |     |     function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);
  998 |     | 
  999 |     |     /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.
 1000 |     |     function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);
 1001 |     | 
 1002 |     |     /// ABI-encodes a JSON object.
 1003 |     |     function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);
 1004 |     | 
 1005 |     |     /// ABI-encodes a JSON object at `key`.
 1006 |     |     function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);
 1007 |     | 
 1008 |     |     /// See `serializeJson`.
 1009 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address value)
 1010 |     |         external
 1011 |     |         returns (string memory json);
 1012 |     | 
 1013 |     |     /// See `serializeJson`.
 1014 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)
 1015 |     |         external
 1016 |     |         returns (string memory json);
 1017 |     | 
 1018 |     |     /// See `serializeJson`.
 1019 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool value)
 1020 |     |         external
 1021 |     |         returns (string memory json);
 1022 |     | 
 1023 |     |     /// See `serializeJson`.
 1024 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)
 1025 |     |         external
 1026 |     |         returns (string memory json);
 1027 |     | 
 1028 |     |     /// See `serializeJson`.
 1029 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)
 1030 |     |         external
 1031 |     |         returns (string memory json);
 1032 |     | 
 1033 |     |     /// See `serializeJson`.
 1034 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)
 1035 |     |         external
 1036 |     |         returns (string memory json);
 1037 |     | 
 1038 |     |     /// See `serializeJson`.
 1039 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)
 1040 |     |         external
 1041 |     |         returns (string memory json);
 1042 |     | 
 1043 |     |     /// See `serializeJson`.
 1044 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)
 1045 |     |         external
 1046 |     |         returns (string memory json);
 1047 |     | 
 1048 |     |     /// See `serializeJson`.
 1049 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)
 1050 |     |         external
 1051 |     |         returns (string memory json);
 1052 |     | 
 1053 |     |     /// See `serializeJson`.
 1054 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)
 1055 |     |         external
 1056 |     |         returns (string memory json);
 1057 |     | 
 1058 |     |     /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.
 1059 |     |     /// Returns the stringified version of the specific JSON file up to that moment.
 1060 |     |     function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);
 1061 |     | 
 1062 |     |     /// See `serializeJson`.
 1063 |     |     function serializeJsonType(string calldata typeDescription, bytes calldata value)
 1064 |     |         external
 1065 |     |         pure
 1066 |     |         returns (string memory json);
 1067 |     | 
 1068 |     |     /// See `serializeJson`.
 1069 |     |     function serializeJsonType(
 1070 |     |         string calldata objectKey,
 1071 |     |         string calldata valueKey,
 1072 |     |         string calldata typeDescription,
 1073 |     |         bytes calldata value
 1074 |     |     ) external returns (string memory json);
 1075 |     | 
 1076 |     |     /// See `serializeJson`.
 1077 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)
 1078 |     |         external
 1079 |     |         returns (string memory json);
 1080 |     | 
 1081 |     |     /// See `serializeJson`.
 1082 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)
 1083 |     |         external
 1084 |     |         returns (string memory json);
 1085 |     | 
 1086 |     |     /// See `serializeJson`.
 1087 |     |     function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)
 1088 |     |         external
 1089 |     |         returns (string memory json);
 1090 |     | 
 1091 |     |     /// See `serializeJson`.
 1092 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)
 1093 |     |         external
 1094 |     |         returns (string memory json);
 1095 |     | 
 1096 |     |     /// See `serializeJson`.
 1097 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)
 1098 |     |         external
 1099 |     |         returns (string memory json);
 1100 |     | 
 1101 |     |     /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.
 1102 |     |     function writeJson(string calldata json, string calldata path) external;
 1103 |     | 
 1104 |     |     /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>
 1105 |     |     /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
 1106 |     |     function writeJson(string calldata json, string calldata path, string calldata valueKey) external;
 1107 |     | 
 1108 |     |     /// Checks if `key` exists in a JSON object
 1109 |     |     /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
 1110 |     |     function keyExists(string calldata json, string calldata key) external view returns (bool);
 1111 |     | 
 1112 |     |     // ======== Scripting ========
 1113 |     | 
 1114 |     |     /// Attach an EIP-4844 blob to the next call
 1115 |     |     function attachBlob(bytes calldata blob) external;
 1116 |     | 
 1117 |     |     /// Designate the next call as an EIP-7702 transaction
 1118 |     |     function attachDelegation(SignedDelegation calldata signedDelegation) external;
 1119 |     | 
 1120 |     |     /// Takes a signed transaction and broadcasts it to the network.
 1121 |     |     function broadcastRawTransaction(bytes calldata data) external;
 1122 |     | 
 1123 |     |     /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.
 1124 |     |     /// Broadcasting address is determined by checking the following in order:
 1125 |     |     /// 1. If `--sender` argument was provided, that address is used.
 1126 |     |     /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.
 1127 |     |     /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
 1128 |     |     function broadcast() external;
 1129 |     | 
 1130 |     |     /// Has the next call (at this call depth only) create a transaction with the address provided
 1131 |     |     /// as the sender that can later be signed and sent onchain.
 1132 |     |     function broadcast(address signer) external;
 1133 |     | 
 1134 |     |     /// Has the next call (at this call depth only) create a transaction with the private key
 1135 |     |     /// provided as the sender that can later be signed and sent onchain.
 1136 |     |     function broadcast(uint256 privateKey) external;
 1137 |     | 
 1138 |     |     /// Returns addresses of available unlocked wallets in the script environment.
 1139 |     |     function getWallets() external returns (address[] memory wallets);
 1140 |     | 
 1141 |     |     /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction
 1142 |     |     function signAndAttachDelegation(address implementation, uint256 privateKey)
 1143 |     |         external
 1144 |     |         returns (SignedDelegation memory signedDelegation);
 1145 |     | 
 1146 |     |     /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction for specific nonce
 1147 |     |     function signAndAttachDelegation(address implementation, uint256 privateKey, uint64 nonce)
 1148 |     |         external
 1149 |     |         returns (SignedDelegation memory signedDelegation);
 1150 |     | 
 1151 |     |     /// Sign an EIP-7702 authorization for delegation
 1152 |     |     function signDelegation(address implementation, uint256 privateKey)
 1153 |     |         external
 1154 |     |         returns (SignedDelegation memory signedDelegation);
 1155 |     | 
 1156 |     |     /// Sign an EIP-7702 authorization for delegation for specific nonce
 1157 |     |     function signDelegation(address implementation, uint256 privateKey, uint64 nonce)
 1158 |     |         external
 1159 |     |         returns (SignedDelegation memory signedDelegation);
 1160 |     | 
 1161 |     |     /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.
 1162 |     |     /// Broadcasting address is determined by checking the following in order:
 1163 |     |     /// 1. If `--sender` argument was provided, that address is used.
 1164 |     |     /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.
 1165 |     |     /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
 1166 |     |     function startBroadcast() external;
 1167 |     | 
 1168 |     |     /// Has all subsequent calls (at this call depth only) create transactions with the address
 1169 |     |     /// provided that can later be signed and sent onchain.
 1170 |     |     function startBroadcast(address signer) external;
 1171 |     | 
 1172 |     |     /// Has all subsequent calls (at this call depth only) create transactions with the private key
 1173 |     |     /// provided that can later be signed and sent onchain.
 1174 |     |     function startBroadcast(uint256 privateKey) external;
 1175 |     | 
 1176 |     |     /// Stops collecting onchain transactions.
 1177 |     |     function stopBroadcast() external;
 1178 |     | 
 1179 |     |     // ======== String ========
 1180 |     | 
 1181 |     |     /// Returns true if `search` is found in `subject`, false otherwise.
 1182 |     |     function contains(string calldata subject, string calldata search) external returns (bool result);
 1183 |     | 
 1184 |     |     /// Returns the index of the first occurrence of a `key` in an `input` string.
 1185 |     |     /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.
 1186 |     |     /// Returns 0 in case of an empty `key`.
 1187 |     |     function indexOf(string calldata input, string calldata key) external pure returns (uint256);
 1188 |     | 
 1189 |     |     /// Parses the given `string` into an `address`.
 1190 |     |     function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);
 1191 |     | 
 1192 |     |     /// Parses the given `string` into a `bool`.
 1193 |     |     function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);
 1194 |     | 
 1195 |     |     /// Parses the given `string` into `bytes`.
 1196 |     |     function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);
 1197 |     | 
 1198 |     |     /// Parses the given `string` into a `bytes32`.
 1199 |     |     function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);
 1200 |     | 
 1201 |     |     /// Parses the given `string` into a `int256`.
 1202 |     |     function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);
 1203 |     | 
 1204 |     |     /// Parses the given `string` into a `uint256`.
 1205 |     |     function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);
 1206 |     | 
 1207 |     |     /// Replaces occurrences of `from` in the given `string` with `to`.
 1208 |     |     function replace(string calldata input, string calldata from, string calldata to)
 1209 |     |         external
 1210 |     |         pure
 1211 |     |         returns (string memory output);
 1212 |     | 
 1213 |     |     /// Splits the given `string` into an array of strings divided by the `delimiter`.
 1214 |     |     function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);
 1215 |     | 
 1216 |     |     /// Converts the given `string` value to Lowercase.
 1217 |     |     function toLowercase(string calldata input) external pure returns (string memory output);
 1218 |     | 
 1219 |     |     /// Converts the given value to a `string`.
 1220 |     |     function toString(address value) external pure returns (string memory stringifiedValue);
 1221 |     | 
 1222 |     |     /// Converts the given value to a `string`.
 1223 |     |     function toString(bytes calldata value) external pure returns (string memory stringifiedValue);
 1224 |     | 
 1225 |     |     /// Converts the given value to a `string`.
 1226 |     |     function toString(bytes32 value) external pure returns (string memory stringifiedValue);
 1227 |     | 
 1228 |     |     /// Converts the given value to a `string`.
 1229 |     |     function toString(bool value) external pure returns (string memory stringifiedValue);
 1230 |     | 
 1231 |     |     /// Converts the given value to a `string`.
 1232 |     |     function toString(uint256 value) external pure returns (string memory stringifiedValue);
 1233 |     | 
 1234 |     |     /// Converts the given value to a `string`.
 1235 |     |     function toString(int256 value) external pure returns (string memory stringifiedValue);
 1236 |     | 
 1237 |     |     /// Converts the given `string` value to Uppercase.
 1238 |     |     function toUppercase(string calldata input) external pure returns (string memory output);
 1239 |     | 
 1240 |     |     /// Trims leading and trailing whitespace from the given `string` value.
 1241 |     |     function trim(string calldata input) external pure returns (string memory output);
 1242 |     | 
 1243 |     |     // ======== Testing ========
 1244 |     | 
 1245 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
 1246 |     |     /// Formats values with decimals in failure message.
 1247 |     |     function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;
 1248 |     | 
 1249 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
 1250 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1251 |     |     function assertApproxEqAbsDecimal(
 1252 |     |         uint256 left,
 1253 |     |         uint256 right,
 1254 |     |         uint256 maxDelta,
 1255 |     |         uint256 decimals,
 1256 |     |         string calldata error
 1257 |     |     ) external pure;
 1258 |     | 
 1259 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
 1260 |     |     /// Formats values with decimals in failure message.
 1261 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;
 1262 |     | 
 1263 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
 1264 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1265 |     |     function assertApproxEqAbsDecimal(
 1266 |     |         int256 left,
 1267 |     |         int256 right,
 1268 |     |         uint256 maxDelta,
 1269 |     |         uint256 decimals,
 1270 |     |         string calldata error
 1271 |     |     ) external pure;
 1272 |     | 
 1273 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
 1274 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;
 1275 |     | 
 1276 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
 1277 |     |     /// Includes error message into revert string on failure.
 1278 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;
 1279 |     | 
 1280 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
 1281 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;
 1282 |     | 
 1283 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
 1284 |     |     /// Includes error message into revert string on failure.
 1285 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;
 1286 |     | 
 1287 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1288 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1289 |     |     /// Formats values with decimals in failure message.
 1290 |     |     function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)
 1291 |     |         external
 1292 |     |         pure;
 1293 |     | 
 1294 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1295 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1296 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1297 |     |     function assertApproxEqRelDecimal(
 1298 |     |         uint256 left,
 1299 |     |         uint256 right,
 1300 |     |         uint256 maxPercentDelta,
 1301 |     |         uint256 decimals,
 1302 |     |         string calldata error
 1303 |     |     ) external pure;
 1304 |     | 
 1305 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1306 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1307 |     |     /// Formats values with decimals in failure message.
 1308 |     |     function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)
 1309 |     |         external
 1310 |     |         pure;
 1311 |     | 
 1312 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1313 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1314 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1315 |     |     function assertApproxEqRelDecimal(
 1316 |     |         int256 left,
 1317 |     |         int256 right,
 1318 |     |         uint256 maxPercentDelta,
 1319 |     |         uint256 decimals,
 1320 |     |         string calldata error
 1321 |     |     ) external pure;
 1322 |     | 
 1323 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1324 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1325 |     |     function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;
 1326 |     | 
 1327 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1328 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1329 |     |     /// Includes error message into revert string on failure.
 1330 |     |     function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)
 1331 |     |         external
 1332 |     |         pure;
 1333 |     | 
 1334 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1335 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1336 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;
 1337 |     | 
 1338 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1339 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1340 |     |     /// Includes error message into revert string on failure.
 1341 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)
 1342 |     |         external
 1343 |     |         pure;
 1344 |     | 
 1345 |     |     /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
 1346 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1347 |     | 
 1348 |     |     /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
 1349 |     |     /// Includes error message into revert string on failure.
 1350 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1351 |     | 
 1352 |     |     /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.
 1353 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1354 |     | 
 1355 |     |     /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.
 1356 |     |     /// Includes error message into revert string on failure.
 1357 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1358 |     | 
 1359 |     |     /// Asserts that two `bool` values are equal.
 1360 |     |     function assertEq(bool left, bool right) external pure;
 1361 |     | 
 1362 |     |     /// Asserts that two `bool` values are equal and includes error message into revert string on failure.
 1363 |     |     function assertEq(bool left, bool right, string calldata error) external pure;
 1364 |     | 
 1365 |     |     /// Asserts that two `string` values are equal.
 1366 |     |     function assertEq(string calldata left, string calldata right) external pure;
 1367 |     | 
 1368 |     |     /// Asserts that two `string` values are equal and includes error message into revert string on failure.
 1369 |     |     function assertEq(string calldata left, string calldata right, string calldata error) external pure;
 1370 |     | 
 1371 |     |     /// Asserts that two `bytes` values are equal.
 1372 |     |     function assertEq(bytes calldata left, bytes calldata right) external pure;
 1373 |     | 
 1374 |     |     /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.
 1375 |     |     function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;
 1376 |     | 
 1377 |     |     /// Asserts that two arrays of `bool` values are equal.
 1378 |     |     function assertEq(bool[] calldata left, bool[] calldata right) external pure;
 1379 |     | 
 1380 |     |     /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
 1381 |     |     function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;
 1382 |     | 
 1383 |     |     /// Asserts that two arrays of `uint256 values are equal.
 1384 |     |     function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;
 1385 |     | 
 1386 |     |     /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
 1387 |     |     function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;
 1388 |     | 
 1389 |     |     /// Asserts that two arrays of `int256` values are equal.
 1390 |     |     function assertEq(int256[] calldata left, int256[] calldata right) external pure;
 1391 |     | 
 1392 |     |     /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
 1393 |     |     function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;
 1394 |     | 
 1395 |     |     /// Asserts that two `uint256` values are equal.
 1396 |     |     function assertEq(uint256 left, uint256 right) external pure;
 1397 |     | 
 1398 |     |     /// Asserts that two arrays of `address` values are equal.
 1399 |     |     function assertEq(address[] calldata left, address[] calldata right) external pure;
 1400 |     | 
 1401 |     |     /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
 1402 |     |     function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;
 1403 |     | 
 1404 |     |     /// Asserts that two arrays of `bytes32` values are equal.
 1405 |     |     function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;
 1406 |     | 
 1407 |     |     /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
 1408 |     |     function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;
 1409 |     | 
 1410 |     |     /// Asserts that two arrays of `string` values are equal.
 1411 |     |     function assertEq(string[] calldata left, string[] calldata right) external pure;
 1412 |     | 
 1413 |     |     /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
 1414 |     |     function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;
 1415 |     | 
 1416 |     |     /// Asserts that two arrays of `bytes` values are equal.
 1417 |     |     function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;
 1418 |     | 
 1419 |     |     /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
 1420 |     |     function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;
 1421 |     | 
 1422 |     |     /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.
 1423 |     |     function assertEq(uint256 left, uint256 right, string calldata error) external pure;
 1424 |     | 
 1425 |     |     /// Asserts that two `int256` values are equal.
 1426 |     |     function assertEq(int256 left, int256 right) external pure;
 1427 |     | 
 1428 |     |     /// Asserts that two `int256` values are equal and includes error message into revert string on failure.
 1429 |     |     function assertEq(int256 left, int256 right, string calldata error) external pure;
 1430 |     | 
 1431 |     |     /// Asserts that two `address` values are equal.
 1432 |     |     function assertEq(address left, address right) external pure;
 1433 |     | 
 1434 |     |     /// Asserts that two `address` values are equal and includes error message into revert string on failure.
 1435 |     |     function assertEq(address left, address right, string calldata error) external pure;
 1436 |     | 
 1437 |     |     /// Asserts that two `bytes32` values are equal.
 1438 |     |     function assertEq(bytes32 left, bytes32 right) external pure;
 1439 |     | 
 1440 |     |     /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
 1441 |     |     function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;
 1442 |     | 
 1443 |     |     /// Asserts that the given condition is false.
 1444 |     |     function assertFalse(bool condition) external pure;
 1445 |     | 
 1446 |     |     /// Asserts that the given condition is false and includes error message into revert string on failure.
 1447 |     |     function assertFalse(bool condition, string calldata error) external pure;
 1448 |     | 
 1449 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1450 |     |     /// Formats values with decimals in failure message.
 1451 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1452 |     | 
 1453 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1454 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1455 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1456 |     | 
 1457 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1458 |     |     /// Formats values with decimals in failure message.
 1459 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1460 |     | 
 1461 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1462 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1463 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1464 |     | 
 1465 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1466 |     |     function assertGe(uint256 left, uint256 right) external pure;
 1467 |     | 
 1468 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1469 |     |     /// Includes error message into revert string on failure.
 1470 |     |     function assertGe(uint256 left, uint256 right, string calldata error) external pure;
 1471 |     | 
 1472 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1473 |     |     function assertGe(int256 left, int256 right) external pure;
 1474 |     | 
 1475 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1476 |     |     /// Includes error message into revert string on failure.
 1477 |     |     function assertGe(int256 left, int256 right, string calldata error) external pure;
 1478 |     | 
 1479 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1480 |     |     /// Formats values with decimals in failure message.
 1481 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1482 |     | 
 1483 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1484 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1485 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1486 |     | 
 1487 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1488 |     |     /// Formats values with decimals in failure message.
 1489 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1490 |     | 
 1491 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1492 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1493 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1494 |     | 
 1495 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1496 |     |     function assertGt(uint256 left, uint256 right) external pure;
 1497 |     | 
 1498 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1499 |     |     /// Includes error message into revert string on failure.
 1500 |     |     function assertGt(uint256 left, uint256 right, string calldata error) external pure;
 1501 |     | 
 1502 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1503 |     |     function assertGt(int256 left, int256 right) external pure;
 1504 |     | 
 1505 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1506 |     |     /// Includes error message into revert string on failure.
 1507 |     |     function assertGt(int256 left, int256 right, string calldata error) external pure;
 1508 |     | 
 1509 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1510 |     |     /// Formats values with decimals in failure message.
 1511 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1512 |     | 
 1513 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1514 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1515 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1516 |     | 
 1517 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1518 |     |     /// Formats values with decimals in failure message.
 1519 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1520 |     | 
 1521 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1522 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1523 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1524 |     | 
 1525 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1526 |     |     function assertLe(uint256 left, uint256 right) external pure;
 1527 |     | 
 1528 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1529 |     |     /// Includes error message into revert string on failure.
 1530 |     |     function assertLe(uint256 left, uint256 right, string calldata error) external pure;
 1531 |     | 
 1532 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1533 |     |     function assertLe(int256 left, int256 right) external pure;
 1534 |     | 
 1535 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1536 |     |     /// Includes error message into revert string on failure.
 1537 |     |     function assertLe(int256 left, int256 right, string calldata error) external pure;
 1538 |     | 
 1539 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1540 |     |     /// Formats values with decimals in failure message.
 1541 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1542 |     | 
 1543 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1544 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1545 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1546 |     | 
 1547 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1548 |     |     /// Formats values with decimals in failure message.
 1549 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1550 |     | 
 1551 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1552 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1553 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1554 |     | 
 1555 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1556 |     |     function assertLt(uint256 left, uint256 right) external pure;
 1557 |     | 
 1558 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1559 |     |     /// Includes error message into revert string on failure.
 1560 |     |     function assertLt(uint256 left, uint256 right, string calldata error) external pure;
 1561 |     | 
 1562 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1563 |     |     function assertLt(int256 left, int256 right) external pure;
 1564 |     | 
 1565 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1566 |     |     /// Includes error message into revert string on failure.
 1567 |     |     function assertLt(int256 left, int256 right, string calldata error) external pure;
 1568 |     | 
 1569 |     |     /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
 1570 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1571 |     | 
 1572 |     |     /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
 1573 |     |     /// Includes error message into revert string on failure.
 1574 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1575 |     | 
 1576 |     |     /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
 1577 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1578 |     | 
 1579 |     |     /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
 1580 |     |     /// Includes error message into revert string on failure.
 1581 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1582 |     | 
 1583 |     |     /// Asserts that two `bool` values are not equal.
 1584 |     |     function assertNotEq(bool left, bool right) external pure;
 1585 |     | 
 1586 |     |     /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.
 1587 |     |     function assertNotEq(bool left, bool right, string calldata error) external pure;
 1588 |     | 
 1589 |     |     /// Asserts that two `string` values are not equal.
 1590 |     |     function assertNotEq(string calldata left, string calldata right) external pure;
 1591 |     | 
 1592 |     |     /// Asserts that two `string` values are not equal and includes error message into revert string on failure.
 1593 |     |     function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;
 1594 |     | 
 1595 |     |     /// Asserts that two `bytes` values are not equal.
 1596 |     |     function assertNotEq(bytes calldata left, bytes calldata right) external pure;
 1597 |     | 
 1598 |     |     /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
 1599 |     |     function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;
 1600 |     | 
 1601 |     |     /// Asserts that two arrays of `bool` values are not equal.
 1602 |     |     function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;
 1603 |     | 
 1604 |     |     /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
 1605 |     |     function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;
 1606 |     | 
 1607 |     |     /// Asserts that two arrays of `uint256` values are not equal.
 1608 |     |     function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;
 1609 |     | 
 1610 |     |     /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
 1611 |     |     function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;
 1612 |     | 
 1613 |     |     /// Asserts that two arrays of `int256` values are not equal.
 1614 |     |     function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;
 1615 |     | 
 1616 |     |     /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
 1617 |     |     function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;
 1618 |     | 
 1619 |     |     /// Asserts that two `uint256` values are not equal.
 1620 |     |     function assertNotEq(uint256 left, uint256 right) external pure;
 1621 |     | 
 1622 |     |     /// Asserts that two arrays of `address` values are not equal.
 1623 |     |     function assertNotEq(address[] calldata left, address[] calldata right) external pure;
 1624 |     | 
 1625 |     |     /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
 1626 |     |     function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;
 1627 |     | 
 1628 |     |     /// Asserts that two arrays of `bytes32` values are not equal.
 1629 |     |     function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;
 1630 |     | 
 1631 |     |     /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
 1632 |     |     function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;
 1633 |     | 
 1634 |     |     /// Asserts that two arrays of `string` values are not equal.
 1635 |     |     function assertNotEq(string[] calldata left, string[] calldata right) external pure;
 1636 |     | 
 1637 |     |     /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
 1638 |     |     function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;
 1639 |     | 
 1640 |     |     /// Asserts that two arrays of `bytes` values are not equal.
 1641 |     |     function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;
 1642 |     | 
 1643 |     |     /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
 1644 |     |     function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;
 1645 |     | 
 1646 |     |     /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
 1647 |     |     function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;
 1648 |     | 
 1649 |     |     /// Asserts that two `int256` values are not equal.
 1650 |     |     function assertNotEq(int256 left, int256 right) external pure;
 1651 |     | 
 1652 |     |     /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.
 1653 |     |     function assertNotEq(int256 left, int256 right, string calldata error) external pure;
 1654 |     | 
 1655 |     |     /// Asserts that two `address` values are not equal.
 1656 |     |     function assertNotEq(address left, address right) external pure;
 1657 |     | 
 1658 |     |     /// Asserts that two `address` values are not equal and includes error message into revert string on failure.
 1659 |     |     function assertNotEq(address left, address right, string calldata error) external pure;
 1660 |     | 
 1661 |     |     /// Asserts that two `bytes32` values are not equal.
 1662 |     |     function assertNotEq(bytes32 left, bytes32 right) external pure;
 1663 |     | 
 1664 |     |     /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
 1665 |     |     function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;
 1666 |     | 
 1667 |     |     /// Asserts that the given condition is true.
 1668 |     |     function assertTrue(bool condition) external pure;
 1669 |     | 
 1670 |     |     /// Asserts that the given condition is true and includes error message into revert string on failure.
 1671 |     |     function assertTrue(bool condition, string calldata error) external pure;
 1672 |     | 
 1673 |     |     /// If the condition is false, discard this run's fuzz inputs and generate new ones.
 1674 |     |     function assume(bool condition) external pure;
 1675 |     | 
 1676 |     |     /// Discard this run's fuzz inputs and generate new ones if next call reverted.
 1677 |     |     function assumeNoRevert() external pure;
 1678 |     | 
 1679 |     |     /// Discard this run's fuzz inputs and generate new ones if next call reverts with the potential revert parameters.
 1680 |     |     function assumeNoRevert(PotentialRevert calldata potentialRevert) external pure;
 1681 |     | 
 1682 |     |     /// Discard this run's fuzz inputs and generate new ones if next call reverts with the any of the potential revert parameters.
 1683 |     |     function assumeNoRevert(PotentialRevert[] calldata potentialReverts) external pure;
 1684 |     | 
 1685 |     |     /// Writes a breakpoint to jump to in the debugger.
 1686 |     |     function breakpoint(string calldata char) external pure;
 1687 |     | 
 1688 |     |     /// Writes a conditional breakpoint to jump to in the debugger.
 1689 |     |     function breakpoint(string calldata char, bool value) external pure;
 1690 |     | 
 1691 |     |     /// Returns true if the current Foundry version is greater than or equal to the given version.
 1692 |     |     /// The given version string must be in the format `major.minor.patch`.
 1693 |     |     /// This is equivalent to `foundryVersionCmp(version) >= 0`.
 1694 |     |     function foundryVersionAtLeast(string calldata version) external view returns (bool);
 1695 |     | 
 1696 |     |     /// Compares the current Foundry version with the given version string.
 1697 |     |     /// The given version string must be in the format `major.minor.patch`.
 1698 |     |     /// Returns:
 1699 |     |     /// -1 if current Foundry version is less than the given version
 1700 |     |     /// 0 if current Foundry version equals the given version
 1701 |     |     /// 1 if current Foundry version is greater than the given version
 1702 |     |     /// This result can then be used with a comparison operator against `0`.
 1703 |     |     /// For example, to check if the current Foundry version is greater than or equal to `1.0.0`:
 1704 |     |     /// `if (foundryVersionCmp("1.0.0") >= 0) { ... }`
 1705 |     |     function foundryVersionCmp(string calldata version) external view returns (int256);
 1706 |     | 
 1707 |     |     /// Returns a Chain struct for specific alias
 1708 |     |     function getChain(string calldata chainAlias) external view returns (Chain memory chain);
 1709 |     | 
 1710 |     |     /// Returns a Chain struct for specific chainId
 1711 |     |     function getChain(uint256 chainId) external view returns (Chain memory chain);
 1712 |     | 
 1713 |     |     /// Returns the Foundry version.
 1714 |     |     /// Format: <cargo_version>-<tag>+<git_sha_short>.<unix_build_timestamp>.<profile>
 1715 |     |     /// Sample output: 0.3.0-nightly+3cb96bde9b.1737036656.debug
 1716 |     |     /// Note: Build timestamps may vary slightly across platforms due to separate CI jobs.
 1717 |     |     /// For reliable version comparisons, use UNIX format (e.g., >= 1700000000)
 1718 |     |     /// to compare timestamps while ignoring minor time differences.
 1719 |     |     function getFoundryVersion() external view returns (string memory version);
 1720 |     | 
 1721 |     |     /// Returns the RPC url for the given alias.
 1722 |     |     function rpcUrl(string calldata rpcAlias) external view returns (string memory json);
 1723 |     | 
 1724 |     |     /// Returns all rpc urls and their aliases as structs.
 1725 |     |     function rpcUrlStructs() external view returns (Rpc[] memory urls);
 1726 |     | 
 1727 |     |     /// Returns all rpc urls and their aliases `[alias, url][]`.
 1728 |     |     function rpcUrls() external view returns (string[2][] memory urls);
 1729 |     | 
 1730 |     |     /// Suspends execution of the main thread for `duration` milliseconds.
 1731 |     |     function sleep(uint256 duration) external;
 1732 |     | 
 1733 |     |     // ======== Toml ========
 1734 |     | 
 1735 |     |     /// Checks if `key` exists in a TOML table.
 1736 |     |     function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);
 1737 |     | 
 1738 |     |     /// Parses a string of TOML data at `key` and coerces it to `address`.
 1739 |     |     function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);
 1740 |     | 
 1741 |     |     /// Parses a string of TOML data at `key` and coerces it to `address[]`.
 1742 |     |     function parseTomlAddressArray(string calldata toml, string calldata key)
 1743 |     |         external
 1744 |     |         pure
 1745 |     |         returns (address[] memory);
 1746 |     | 
 1747 |     |     /// Parses a string of TOML data at `key` and coerces it to `bool`.
 1748 |     |     function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);
 1749 |     | 
 1750 |     |     /// Parses a string of TOML data at `key` and coerces it to `bool[]`.
 1751 |     |     function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);
 1752 |     | 
 1753 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes`.
 1754 |     |     function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);
 1755 |     | 
 1756 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes32`.
 1757 |     |     function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);
 1758 |     | 
 1759 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
 1760 |     |     function parseTomlBytes32Array(string calldata toml, string calldata key)
 1761 |     |         external
 1762 |     |         pure
 1763 |     |         returns (bytes32[] memory);
 1764 |     | 
 1765 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.
 1766 |     |     function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);
 1767 |     | 
 1768 |     |     /// Parses a string of TOML data at `key` and coerces it to `int256`.
 1769 |     |     function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);
 1770 |     | 
 1771 |     |     /// Parses a string of TOML data at `key` and coerces it to `int256[]`.
 1772 |     |     function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);
 1773 |     | 
 1774 |     |     /// Returns an array of all the keys in a TOML table.
 1775 |     |     function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);
 1776 |     | 
 1777 |     |     /// Parses a string of TOML data at `key` and coerces it to `string`.
 1778 |     |     function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);
 1779 |     | 
 1780 |     |     /// Parses a string of TOML data at `key` and coerces it to `string[]`.
 1781 |     |     function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);
 1782 |     | 
 1783 |     |     /// Parses a string of TOML data at `key` and coerces it to type array corresponding to `typeDescription`.
 1784 |     |     function parseTomlTypeArray(string calldata toml, string calldata key, string calldata typeDescription)
 1785 |     |         external
 1786 |     |         pure
 1787 |     |         returns (bytes memory);
 1788 |     | 
 1789 |     |     /// Parses a string of TOML data and coerces it to type corresponding to `typeDescription`.
 1790 |     |     function parseTomlType(string calldata toml, string calldata typeDescription)
 1791 |     |         external
 1792 |     |         pure
 1793 |     |         returns (bytes memory);
 1794 |     | 
 1795 |     |     /// Parses a string of TOML data at `key` and coerces it to type corresponding to `typeDescription`.
 1796 |     |     function parseTomlType(string calldata toml, string calldata key, string calldata typeDescription)
 1797 |     |         external
 1798 |     |         pure
 1799 |     |         returns (bytes memory);
 1800 |     | 
 1801 |     |     /// Parses a string of TOML data at `key` and coerces it to `uint256`.
 1802 |     |     function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);
 1803 |     | 
 1804 |     |     /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.
 1805 |     |     function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);
 1806 |     | 
 1807 |     |     /// ABI-encodes a TOML table.
 1808 |     |     function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);
 1809 |     | 
 1810 |     |     /// ABI-encodes a TOML table at `key`.
 1811 |     |     function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);
 1812 |     | 
 1813 |     |     /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
 1814 |     |     function writeToml(string calldata json, string calldata path) external;
 1815 |     | 
 1816 |     |     /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.>
 1817 |     |     /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
 1818 |     |     function writeToml(string calldata json, string calldata path, string calldata valueKey) external;
 1819 |     | 
 1820 |     |     // ======== Utilities ========
 1821 |     | 
 1822 |     |     /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
 1823 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)
 1824 |     |         external
 1825 |     |         pure
 1826 |     |         returns (address);
 1827 |     | 
 1828 |     |     /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
 1829 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);
 1830 |     | 
 1831 |     |     /// Compute the address a contract will be deployed at for a given deployer address and nonce.
 1832 |     |     function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);
 1833 |     | 
 1834 |     |     /// Utility cheatcode to copy storage of `from` contract to another `to` contract.
 1835 |     |     function copyStorage(address from, address to) external;
 1836 |     | 
 1837 |     |     /// Returns ENS namehash for provided string.
 1838 |     |     function ensNamehash(string calldata name) external pure returns (bytes32);
 1839 |     | 
 1840 |     |     /// Gets the label for the specified address.
 1841 |     |     function getLabel(address account) external view returns (string memory currentLabel);
 1842 |     | 
 1843 |     |     /// Labels an address in call traces.
 1844 |     |     function label(address account, string calldata newLabel) external;
 1845 |     | 
 1846 |     |     /// Pauses collection of call traces. Useful in cases when you want to skip tracing of
 1847 |     |     /// complex calls which are not useful for debugging.
 1848 |     |     function pauseTracing() external view;
 1849 |     | 
 1850 |     |     /// Returns a random `address`.
 1851 |     |     function randomAddress() external returns (address);
 1852 |     | 
 1853 |     |     /// Returns a random `bool`.
 1854 |     |     function randomBool() external view returns (bool);
 1855 |     | 
 1856 |     |     /// Returns a random byte array value of the given length.
 1857 |     |     function randomBytes(uint256 len) external view returns (bytes memory);
 1858 |     | 
 1859 |     |     /// Returns a random fixed-size byte array of length 4.
 1860 |     |     function randomBytes4() external view returns (bytes4);
 1861 |     | 
 1862 |     |     /// Returns a random fixed-size byte array of length 8.
 1863 |     |     function randomBytes8() external view returns (bytes8);
 1864 |     | 
 1865 |     |     /// Returns a random `int256` value.
 1866 |     |     function randomInt() external view returns (int256);
 1867 |     | 
 1868 |     |     /// Returns a random `int256` value of given bits.
 1869 |     |     function randomInt(uint256 bits) external view returns (int256);
 1870 |     | 
 1871 |     |     /// Returns a random uint256 value.
 1872 |     |     function randomUint() external returns (uint256);
 1873 |     | 
 1874 |     |     /// Returns random uint256 value between the provided range (=min..=max).
 1875 |     |     function randomUint(uint256 min, uint256 max) external returns (uint256);
 1876 |     | 
 1877 |     |     /// Returns a random `uint256` value of given bits.
 1878 |     |     function randomUint(uint256 bits) external view returns (uint256);
 1879 |     | 
 1880 |     |     /// Unpauses collection of call traces.
 1881 |     |     function resumeTracing() external view;
 1882 |     | 
 1883 |     |     /// Utility cheatcode to set arbitrary storage for given target address.
 1884 |     |     function setArbitraryStorage(address target) external;
 1885 |     | 
 1886 |     |     /// Utility cheatcode to set arbitrary storage for given target address and overwrite
 1887 |     |     /// any storage slots that have been previously set.
 1888 |     |     function setArbitraryStorage(address target, bool overwrite) external;
 1889 |     | 
 1890 |     |     /// Randomly shuffles an array.
 1891 |     |     function shuffle(uint256[] calldata array) external returns (uint256[] memory);
 1892 |     | 
 1893 |     |     /// Sorts an array in ascending order.
 1894 |     |     function sort(uint256[] calldata array) external returns (uint256[] memory);
 1895 |     | 
 1896 |     |     /// Encodes a `bytes` value to a base64url string.
 1897 |     |     function toBase64URL(bytes calldata data) external pure returns (string memory);
 1898 |     | 
 1899 |     |     /// Encodes a `string` value to a base64url string.
 1900 |     |     function toBase64URL(string calldata data) external pure returns (string memory);
 1901 |     | 
 1902 |     |     /// Encodes a `bytes` value to a base64 string.
 1903 |     |     function toBase64(bytes calldata data) external pure returns (string memory);
 1904 |     | 
 1905 |     |     /// Encodes a `string` value to a base64 string.
 1906 |     |     function toBase64(string calldata data) external pure returns (string memory);
 1907 |     | }
 1908 |     | 
 1909 |     | /// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used
 1910 |     | /// in tests, but it is not recommended to use these cheats in scripts.
 1911 |     | interface Vm is VmSafe {
 1912 |     |     // ======== EVM ========
 1913 |     | 
 1914 |     |     /// Utility cheatcode to set an EIP-2930 access list for all subsequent transactions.
 1915 |     |     function accessList(AccessListItem[] calldata access) external;
 1916 |     | 
 1917 |     |     /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.
 1918 |     |     function activeFork() external view returns (uint256 forkId);
 1919 |     | 
 1920 |     |     /// In forking mode, explicitly grant the given address cheatcode access.
 1921 |     |     function allowCheatcodes(address account) external;
 1922 |     | 
 1923 |     |     /// Sets `block.blobbasefee`
 1924 |     |     function blobBaseFee(uint256 newBlobBaseFee) external;
 1925 |     | 
 1926 |     |     /// Sets the blobhashes in the transaction.
 1927 |     |     /// Not available on EVM versions before Cancun.
 1928 |     |     /// If used on unsupported EVM versions it will revert.
 1929 |     |     function blobhashes(bytes32[] calldata hashes) external;
 1930 |     | 
 1931 |     |     /// Sets `block.chainid`.
 1932 |     |     function chainId(uint256 newChainId) external;
 1933 |     | 
 1934 |     |     /// Clears all mocked calls.
 1935 |     |     function clearMockedCalls() external;
 1936 |     | 
 1937 |     |     /// Clones a source account code, state, balance and nonce to a target account and updates in-memory EVM state.
 1938 |     |     function cloneAccount(address source, address target) external;
 1939 |     | 
 1940 |     |     /// Sets `block.coinbase`.
 1941 |     |     function coinbase(address newCoinbase) external;
 1942 |     | 
 1943 |     |     /// Marks the slots of an account and the account address as cold.
 1944 |     |     function cool(address target) external;
 1945 |     | 
 1946 |     |     /// Utility cheatcode to mark specific storage slot as cold, simulating no prior read.
 1947 |     |     function coolSlot(address target, bytes32 slot) external;
 1948 |     | 
 1949 |     |     /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.
 1950 |     |     function createFork(string calldata urlOrAlias) external returns (uint256 forkId);
 1951 |     | 
 1952 |     |     /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.
 1953 |     |     function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 1954 |     | 
 1955 |     |     /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,
 1956 |     |     /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.
 1957 |     |     function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 1958 |     | 
 1959 |     |     /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.
 1960 |     |     function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);
 1961 |     | 
 1962 |     |     /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.
 1963 |     |     function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 1964 |     | 
 1965 |     |     /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,
 1966 |     |     /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.
 1967 |     |     function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 1968 |     | 
 1969 |     |     /// Sets an address' balance.
 1970 |     |     function deal(address account, uint256 newBalance) external;
 1971 |     | 
 1972 |     |     /// Removes the snapshot with the given ID created by `snapshot`.
 1973 |     |     /// Takes the snapshot ID to delete.
 1974 |     |     /// Returns `true` if the snapshot was successfully deleted.
 1975 |     |     /// Returns `false` if the snapshot does not exist.
 1976 |     |     function deleteStateSnapshot(uint256 snapshotId) external returns (bool success);
 1977 |     | 
 1978 |     |     /// Removes _all_ snapshots previously created by `snapshot`.
 1979 |     |     function deleteStateSnapshots() external;
 1980 |     | 
 1981 |     |     /// Sets `block.difficulty`.
 1982 |     |     /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.
 1983 |     |     /// Reverts if used on unsupported EVM versions.
 1984 |     |     function difficulty(uint256 newDifficulty) external;
 1985 |     | 
 1986 |     |     /// Dump a genesis JSON file's `allocs` to disk.
 1987 |     |     function dumpState(string calldata pathToStateJson) external;
 1988 |     | 
 1989 |     |     /// Sets an address' code.
 1990 |     |     function etch(address target, bytes calldata newRuntimeBytecode) external;
 1991 |     | 
 1992 |     |     /// Sets `block.basefee`.
 1993 |     |     function fee(uint256 newBasefee) external;
 1994 |     | 
 1995 |     |     /// Gets the blockhashes from the current transaction.
 1996 |     |     /// Not available on EVM versions before Cancun.
 1997 |     |     /// If used on unsupported EVM versions it will revert.
 1998 |     |     function getBlobhashes() external view returns (bytes32[] memory hashes);
 1999 |     | 
 2000 |     |     /// Returns true if the account is marked as persistent.
 2001 |     |     function isPersistent(address account) external view returns (bool persistent);
 2002 |     | 
 2003 |     |     /// Load a genesis JSON file's `allocs` into the in-memory EVM state.
 2004 |     |     function loadAllocs(string calldata pathToAllocsJson) external;
 2005 |     | 
 2006 |     |     /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup
 2007 |     |     /// Meaning, changes made to the state of this account will be kept when switching forks.
 2008 |     |     function makePersistent(address account) external;
 2009 |     | 
 2010 |     |     /// See `makePersistent(address)`.
 2011 |     |     function makePersistent(address account0, address account1) external;
 2012 |     | 
 2013 |     |     /// See `makePersistent(address)`.
 2014 |     |     function makePersistent(address account0, address account1, address account2) external;
 2015 |     | 
 2016 |     |     /// See `makePersistent(address)`.
 2017 |     |     function makePersistent(address[] calldata accounts) external;
 2018 |     | 
 2019 |     |     /// Reverts a call to an address with specified revert data.
 2020 |     |     function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;
 2021 |     | 
 2022 |     |     /// Reverts a call to an address with a specific `msg.value`, with specified revert data.
 2023 |     |     function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)
 2024 |     |         external;
 2025 |     | 
 2026 |     |     /// Reverts a call to an address with specified revert data.
 2027 |     |     /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.
 2028 |     |     function mockCallRevert(address callee, bytes4 data, bytes calldata revertData) external;
 2029 |     | 
 2030 |     |     /// Reverts a call to an address with a specific `msg.value`, with specified revert data.
 2031 |     |     /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.
 2032 |     |     function mockCallRevert(address callee, uint256 msgValue, bytes4 data, bytes calldata revertData) external;
 2033 |     | 
 2034 |     |     /// Mocks a call to an address, returning specified data.
 2035 |     |     /// Calldata can either be strict or a partial match, e.g. if you only
 2036 |     |     /// pass a Solidity selector to the expected calldata, then the entire Solidity
 2037 |     |     /// function will be mocked.
 2038 |     |     function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;
 2039 |     | 
 2040 |     |     /// Mocks a call to an address with a specific `msg.value`, returning specified data.
 2041 |     |     /// Calldata match takes precedence over `msg.value` in case of ambiguity.
 2042 |     |     function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;
 2043 |     | 
 2044 |     |     /// Mocks a call to an address, returning specified data.
 2045 |     |     /// Calldata can either be strict or a partial match, e.g. if you only
 2046 |     |     /// pass a Solidity selector to the expected calldata, then the entire Solidity
 2047 |     |     /// function will be mocked.
 2048 |     |     /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.
 2049 |     |     function mockCall(address callee, bytes4 data, bytes calldata returnData) external;
 2050 |     | 
 2051 |     |     /// Mocks a call to an address with a specific `msg.value`, returning specified data.
 2052 |     |     /// Calldata match takes precedence over `msg.value` in case of ambiguity.
 2053 |     |     /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.
 2054 |     |     function mockCall(address callee, uint256 msgValue, bytes4 data, bytes calldata returnData) external;
 2055 |     | 
 2056 |     |     /// Mocks multiple calls to an address, returning specified data for each call.
 2057 |     |     function mockCalls(address callee, bytes calldata data, bytes[] calldata returnData) external;
 2058 |     | 
 2059 |     |     /// Mocks multiple calls to an address with a specific `msg.value`, returning specified data for each call.
 2060 |     |     function mockCalls(address callee, uint256 msgValue, bytes calldata data, bytes[] calldata returnData) external;
 2061 |     | 
 2062 |     |     /// Whenever a call is made to `callee` with calldata `data`, this cheatcode instead calls
 2063 |     |     /// `target` with the same calldata. This functionality is similar to a delegate call made to
 2064 |     |     /// `target` contract from `callee`.
 2065 |     |     /// Can be used to substitute a call to a function with another implementation that captures
 2066 |     |     /// the primary logic of the original function but is easier to reason about.
 2067 |     |     /// If calldata is not a strict match then partial match by selector is attempted.
 2068 |     |     function mockFunction(address callee, address target, bytes calldata data) external;
 2069 |     | 
 2070 |     |     /// Utility cheatcode to remove any EIP-2930 access list set by `accessList` cheatcode.
 2071 |     |     function noAccessList() external;
 2072 |     | 
 2073 |     |     /// Sets the *next* call's `msg.sender` to be the input address.
 2074 |     |     function prank(address msgSender) external;
 2075 |     | 
 2076 |     |     /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
 2077 |     |     function prank(address msgSender, address txOrigin) external;
 2078 |     | 
 2079 |     |     /// Sets the *next* delegate call's `msg.sender` to be the input address.
 2080 |     |     function prank(address msgSender, bool delegateCall) external;
 2081 |     | 
 2082 |     |     /// Sets the *next* delegate call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
 2083 |     |     function prank(address msgSender, address txOrigin, bool delegateCall) external;
 2084 |     | 
 2085 |     |     /// Sets `block.prevrandao`.
 2086 |     |     /// Not available on EVM versions before Paris. Use `difficulty` instead.
 2087 |     |     /// If used on unsupported EVM versions it will revert.
 2088 |     |     function prevrandao(bytes32 newPrevrandao) external;
 2089 |     | 
 2090 |     |     /// Sets `block.prevrandao`.
 2091 |     |     /// Not available on EVM versions before Paris. Use `difficulty` instead.
 2092 |     |     /// If used on unsupported EVM versions it will revert.
 2093 |     |     function prevrandao(uint256 newPrevrandao) external;
 2094 |     | 
 2095 |     |     /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.
 2096 |     |     function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);
 2097 |     | 
 2098 |     |     /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.
 2099 |     |     function resetNonce(address account) external;
 2100 |     | 
 2101 |     |     /// Revert the state of the EVM to a previous snapshot
 2102 |     |     /// Takes the snapshot ID to revert to.
 2103 |     |     /// Returns `true` if the snapshot was successfully reverted.
 2104 |     |     /// Returns `false` if the snapshot does not exist.
 2105 |     |     /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteStateSnapshot`.
 2106 |     |     function revertToState(uint256 snapshotId) external returns (bool success);
 2107 |     | 
 2108 |     |     /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots
 2109 |     |     /// Takes the snapshot ID to revert to.
 2110 |     |     /// Returns `true` if the snapshot was successfully reverted and deleted.
 2111 |     |     /// Returns `false` if the snapshot does not exist.
 2112 |     |     function revertToStateAndDelete(uint256 snapshotId) external returns (bool success);
 2113 |     | 
 2114 |     |     /// Revokes persistent status from the address, previously added via `makePersistent`.
 2115 |     |     function revokePersistent(address account) external;
 2116 |     | 
 2117 |     |     /// See `revokePersistent(address)`.
 2118 |     |     function revokePersistent(address[] calldata accounts) external;
 2119 |     | 
 2120 |     |     /// Sets `block.height`.
 2121 |     |     function roll(uint256 newHeight) external;
 2122 |     | 
 2123 |     |     /// Updates the currently active fork to given block number
 2124 |     |     /// This is similar to `roll` but for the currently active fork.
 2125 |     |     function rollFork(uint256 blockNumber) external;
 2126 |     | 
 2127 |     |     /// Updates the currently active fork to given transaction. This will `rollFork` with the number
 2128 |     |     /// of the block the transaction was mined in and replays all transaction mined before it in the block.
 2129 |     |     function rollFork(bytes32 txHash) external;
 2130 |     | 
 2131 |     |     /// Updates the given fork to given block number.
 2132 |     |     function rollFork(uint256 forkId, uint256 blockNumber) external;
 2133 |     | 
 2134 |     |     /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.
 2135 |     |     function rollFork(uint256 forkId, bytes32 txHash) external;
 2136 |     | 
 2137 |     |     /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
 2138 |     |     function selectFork(uint256 forkId) external;
 2139 |     | 
 2140 |     |     /// Set blockhash for the current block.
 2141 |     |     /// It only sets the blockhash for blocks where `block.number - 256 <= number < block.number`.
 2142 |     |     function setBlockhash(uint256 blockNumber, bytes32 blockHash) external;
 2143 |     | 
 2144 |     |     /// Sets the nonce of an account. Must be higher than the current nonce of the account.
 2145 |     |     function setNonce(address account, uint64 newNonce) external;
 2146 |     | 
 2147 |     |     /// Sets the nonce of an account to an arbitrary value.
 2148 |     |     function setNonceUnsafe(address account, uint64 newNonce) external;
 2149 |     | 
 2150 |     |     /// Snapshot capture the gas usage of the last call by name from the callee perspective.
 2151 |     |     function snapshotGasLastCall(string calldata name) external returns (uint256 gasUsed);
 2152 |     | 
 2153 |     |     /// Snapshot capture the gas usage of the last call by name in a group from the callee perspective.
 2154 |     |     function snapshotGasLastCall(string calldata group, string calldata name) external returns (uint256 gasUsed);
 2155 |     | 
 2156 |     |     /// Snapshot the current state of the evm.
 2157 |     |     /// Returns the ID of the snapshot that was created.
 2158 |     |     /// To revert a snapshot use `revertToState`.
 2159 |     |     function snapshotState() external returns (uint256 snapshotId);
 2160 |     | 
 2161 |     |     /// Snapshot capture an arbitrary numerical value by name.
 2162 |     |     /// The group name is derived from the contract name.
 2163 |     |     function snapshotValue(string calldata name, uint256 value) external;
 2164 |     | 
 2165 |     |     /// Snapshot capture an arbitrary numerical value by name in a group.
 2166 |     |     function snapshotValue(string calldata group, string calldata name, uint256 value) external;
 2167 |     | 
 2168 |     |     /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.
 2169 |     |     function startPrank(address msgSender) external;
 2170 |     | 
 2171 |     |     /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
 2172 |     |     function startPrank(address msgSender, address txOrigin) external;
 2173 |     | 
 2174 |     |     /// Sets all subsequent delegate calls' `msg.sender` to be the input address until `stopPrank` is called.
 2175 |     |     function startPrank(address msgSender, bool delegateCall) external;
 2176 |     | 
 2177 |     |     /// Sets all subsequent delegate calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
 2178 |     |     function startPrank(address msgSender, address txOrigin, bool delegateCall) external;
 2179 |     | 
 2180 |     |     /// Start a snapshot capture of the current gas usage by name.
 2181 |     |     /// The group name is derived from the contract name.
 2182 |     |     function startSnapshotGas(string calldata name) external;
 2183 |     | 
 2184 |     |     /// Start a snapshot capture of the current gas usage by name in a group.
 2185 |     |     function startSnapshotGas(string calldata group, string calldata name) external;
 2186 |     | 
 2187 |     |     /// Resets subsequent calls' `msg.sender` to be `address(this)`.
 2188 |     |     function stopPrank() external;
 2189 |     | 
 2190 |     |     /// Stop the snapshot capture of the current gas by latest snapshot name, capturing the gas used since the start.
 2191 |     |     function stopSnapshotGas() external returns (uint256 gasUsed);
 2192 |     | 
 2193 |     |     /// Stop the snapshot capture of the current gas usage by name, capturing the gas used since the start.
 2194 |     |     /// The group name is derived from the contract name.
 2195 |     |     function stopSnapshotGas(string calldata name) external returns (uint256 gasUsed);
 2196 |     | 
 2197 |     |     /// Stop the snapshot capture of the current gas usage by name in a group, capturing the gas used since the start.
 2198 |     |     function stopSnapshotGas(string calldata group, string calldata name) external returns (uint256 gasUsed);
 2199 |     | 
 2200 |     |     /// Stores a value to an address' storage slot.
 2201 |     |     function store(address target, bytes32 slot, bytes32 value) external;
 2202 |     | 
 2203 |     |     /// Fetches the given transaction from the active fork and executes it on the current state.
 2204 |     |     function transact(bytes32 txHash) external;
 2205 |     | 
 2206 |     |     /// Fetches the given transaction from the given fork and executes it on the current state.
 2207 |     |     function transact(uint256 forkId, bytes32 txHash) external;
 2208 |     | 
 2209 |     |     /// Sets `tx.gasprice`.
 2210 |     |     function txGasPrice(uint256 newGasPrice) external;
 2211 |     | 
 2212 |     |     /// Utility cheatcode to mark specific storage slot as warm, simulating a prior read.
 2213 |     |     function warmSlot(address target, bytes32 slot) external;
 2214 |     | 
 2215 |     |     /// Sets `block.timestamp`.
 2216 |     |     function warp(uint256 newTimestamp) external;
 2217 |     | 
 2218 |     |     /// `deleteSnapshot` is being deprecated in favor of `deleteStateSnapshot`. It will be removed in future versions.
 2219 |     |     function deleteSnapshot(uint256 snapshotId) external returns (bool success);
 2220 |     | 
 2221 |     |     /// `deleteSnapshots` is being deprecated in favor of `deleteStateSnapshots`. It will be removed in future versions.
 2222 |     |     function deleteSnapshots() external;
 2223 |     | 
 2224 |     |     /// `revertToAndDelete` is being deprecated in favor of `revertToStateAndDelete`. It will be removed in future versions.
 2225 |     |     function revertToAndDelete(uint256 snapshotId) external returns (bool success);
 2226 |     | 
 2227 |     |     /// `revertTo` is being deprecated in favor of `revertToState`. It will be removed in future versions.
 2228 |     |     function revertTo(uint256 snapshotId) external returns (bool success);
 2229 |     | 
 2230 |     |     /// `snapshot` is being deprecated in favor of `snapshotState`. It will be removed in future versions.
 2231 |     |     function snapshot() external returns (uint256 snapshotId);
 2232 |     | 
 2233 |     |     // ======== Testing ========
 2234 |     | 
 2235 |     |     /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
 2236 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;
 2237 |     | 
 2238 |     |     /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
 2239 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)
 2240 |     |         external;
 2241 |     | 
 2242 |     |     /// Expects a call to an address with the specified calldata.
 2243 |     |     /// Calldata can either be a strict or a partial match.
 2244 |     |     function expectCall(address callee, bytes calldata data) external;
 2245 |     | 
 2246 |     |     /// Expects given number of calls to an address with the specified calldata.
 2247 |     |     function expectCall(address callee, bytes calldata data, uint64 count) external;
 2248 |     | 
 2249 |     |     /// Expects a call to an address with the specified `msg.value` and calldata.
 2250 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data) external;
 2251 |     | 
 2252 |     |     /// Expects given number of calls to an address with the specified `msg.value` and calldata.
 2253 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;
 2254 |     | 
 2255 |     |     /// Expect a call to an address with the specified `msg.value`, gas, and calldata.
 2256 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;
 2257 |     | 
 2258 |     |     /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.
 2259 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;
 2260 |     | 
 2261 |     |     /// Expects the deployment of the specified bytecode by the specified address using the CREATE opcode
 2262 |     |     function expectCreate(bytes calldata bytecode, address deployer) external;
 2263 |     | 
 2264 |     |     /// Expects the deployment of the specified bytecode by the specified address using the CREATE2 opcode
 2265 |     |     function expectCreate2(bytes calldata bytecode, address deployer) external;
 2266 |     | 
 2267 |     |     /// Prepare an expected anonymous log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).
 2268 |     |     /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if
 2269 |     |     /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
 2270 |     |     function expectEmitAnonymous(bool checkTopic0, bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData)
 2271 |     |         external;
 2272 |     | 
 2273 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 2274 |     |     function expectEmitAnonymous(
 2275 |     |         bool checkTopic0,
 2276 |     |         bool checkTopic1,
 2277 |     |         bool checkTopic2,
 2278 |     |         bool checkTopic3,
 2279 |     |         bool checkData,
 2280 |     |         address emitter
 2281 |     |     ) external;
 2282 |     | 
 2283 |     |     /// Prepare an expected anonymous log with all topic and data checks enabled.
 2284 |     |     /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if
 2285 |     |     /// logs were emitted in the expected order with the expected topics and data.
 2286 |     |     function expectEmitAnonymous() external;
 2287 |     | 
 2288 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 2289 |     |     function expectEmitAnonymous(address emitter) external;
 2290 |     | 
 2291 |     |     /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).
 2292 |     |     /// Call this function, then emit an event, then call a function. Internally after the call, we check if
 2293 |     |     /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
 2294 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;
 2295 |     | 
 2296 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 2297 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)
 2298 |     |         external;
 2299 |     | 
 2300 |     |     /// Prepare an expected log with all topic and data checks enabled.
 2301 |     |     /// Call this function, then emit an event, then call a function. Internally after the call, we check if
 2302 |     |     /// logs were emitted in the expected order with the expected topics and data.
 2303 |     |     function expectEmit() external;
 2304 |     | 
 2305 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 2306 |     |     function expectEmit(address emitter) external;
 2307 |     | 
 2308 |     |     /// Expect a given number of logs with the provided topics.
 2309 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, uint64 count) external;
 2310 |     | 
 2311 |     |     /// Expect a given number of logs from a specific emitter with the provided topics.
 2312 |     |     function expectEmit(
 2313 |     |         bool checkTopic1,
 2314 |     |         bool checkTopic2,
 2315 |     |         bool checkTopic3,
 2316 |     |         bool checkData,
 2317 |     |         address emitter,
 2318 |     |         uint64 count
 2319 |     |     ) external;
 2320 |     | 
 2321 |     |     /// Expect a given number of logs with all topic and data checks enabled.
 2322 |     |     function expectEmit(uint64 count) external;
 2323 |     | 
 2324 |     |     /// Expect a given number of logs from a specific emitter with all topic and data checks enabled.
 2325 |     |     function expectEmit(address emitter, uint64 count) external;
 2326 |     | 
 2327 |     |     /// Expects an error on next call that starts with the revert data.
 2328 |     |     function expectPartialRevert(bytes4 revertData) external;
 2329 |     | 
 2330 |     |     /// Expects an error on next call to reverter address, that starts with the revert data.
 2331 |     |     function expectPartialRevert(bytes4 revertData, address reverter) external;
 2332 |     | 
 2333 |     |     /// Expects an error on next call with any revert data.
 2334 |     |     function expectRevert() external;
 2335 |     | 
 2336 |     |     /// Expects an error on next call that exactly matches the revert data.
 2337 |     |     function expectRevert(bytes4 revertData) external;
 2338 |     | 
 2339 |     |     /// Expects a `count` number of reverts from the upcoming calls from the reverter address that match the revert data.
 2340 |     |     function expectRevert(bytes4 revertData, address reverter, uint64 count) external;
 2341 |     | 
 2342 |     |     /// Expects a `count` number of reverts from the upcoming calls from the reverter address that exactly match the revert data.
 2343 |     |     function expectRevert(bytes calldata revertData, address reverter, uint64 count) external;
 2344 |     | 
 2345 |     |     /// Expects an error on next call that exactly matches the revert data.
 2346 |     |     function expectRevert(bytes calldata revertData) external;
 2347 |     | 
 2348 |     |     /// Expects an error with any revert data on next call to reverter address.
 2349 |     |     function expectRevert(address reverter) external;
 2350 |     | 
 2351 |     |     /// Expects an error from reverter address on next call, with any revert data.
 2352 |     |     function expectRevert(bytes4 revertData, address reverter) external;
 2353 |     | 
 2354 |     |     /// Expects an error from reverter address on next call, that exactly matches the revert data.
 2355 |     |     function expectRevert(bytes calldata revertData, address reverter) external;
 2356 |     | 
 2357 |     |     /// Expects a `count` number of reverts from the upcoming calls with any revert data or reverter.
 2358 |     |     function expectRevert(uint64 count) external;
 2359 |     | 
 2360 |     |     /// Expects a `count` number of reverts from the upcoming calls that match the revert data.
 2361 |     |     function expectRevert(bytes4 revertData, uint64 count) external;
 2362 |     | 
 2363 |     |     /// Expects a `count` number of reverts from the upcoming calls that exactly match the revert data.
 2364 |     |     function expectRevert(bytes calldata revertData, uint64 count) external;
 2365 |     | 
 2366 |     |     /// Expects a `count` number of reverts from the upcoming calls from the reverter address.
 2367 |     |     function expectRevert(address reverter, uint64 count) external;
 2368 |     | 
 2369 |     |     /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other
 2370 |     |     /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
 2371 |     |     function expectSafeMemory(uint64 min, uint64 max) external;
 2372 |     | 
 2373 |     |     /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext.
 2374 |     |     /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges
 2375 |     |     /// to the set.
 2376 |     |     function expectSafeMemoryCall(uint64 min, uint64 max) external;
 2377 |     | 
 2378 |     |     /// Marks a test as skipped. Must be called at the top level of a test.
 2379 |     |     function skip(bool skipTest) external;
 2380 |     | 
 2381 |     |     /// Marks a test as skipped with a reason. Must be called at the top level of a test.
 2382 |     |     function skip(bool skipTest, string calldata reason) external;
 2383 |     | 
 2384 |     |     /// Stops all safe memory expectation in the current subcontext.
 2385 |     |     function stopExpectSafeMemory() external;
 2386 |     | 
 2387 |     |     // ======== Utilities ========
 2388 |     | 
 2389 |     |     /// Causes the next contract creation (via new) to fail and return its initcode in the returndata buffer.
 2390 |     |     /// This allows type-safe access to the initcode payload that would be used for contract creation.
 2391 |     |     /// Example usage:
 2392 |     |     /// vm.interceptInitcode();
 2393 |     |     /// bytes memory initcode;
 2394 |     |     /// try new MyContract(param1, param2) { assert(false); }
 2395 |     |     /// catch (bytes memory interceptedInitcode) { initcode = interceptedInitcode; }
 2396 |     |     function interceptInitcode() external;
 2397 |     | }
 2398 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 |     |     address constant CONSOLE_ADDRESS =
    6 | *   |         0x000000000000000000636F6e736F6c652e6c6f67;
    7 |     | 
    8 | *   |     function _sendLogPayloadImplementation(bytes memory payload) internal view {
    9 | *   |         address consoleAddress = CONSOLE_ADDRESS;
   10 |     |         /// @solidity memory-safe-assembly
   11 | *   |         assembly {
   12 | *   |             pop(
   13 | *   |                 staticcall(
   14 | *   |                     gas(),
   15 | *   |                     consoleAddress,
   16 | *   |                     add(payload, 32),
   17 | *   |                     mload(payload),
   18 | *   |                     0,
   19 | *   |                     0
   20 |     |                 )
   21 |     |             )
   22 |     |         }
   23 |     |     }
   24 |     | 
   25 | *   |     function _castToPure(
   26 |     |       function(bytes memory) internal view fnIn
   27 | *   |     ) internal pure returns (function(bytes memory) pure fnOut) {
   28 |     |         assembly {
   29 | *   |             fnOut := fnIn
   30 |     |         }
   31 |     |     }
   32 |     | 
   33 | *   |     function _sendLogPayload(bytes memory payload) internal pure {
   34 | *   |         _castToPure(_sendLogPayloadImplementation)(payload);
   35 |     |     }
   36 |     | 
   37 |     |     function log() internal pure {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   39 |     |     }
   40 |     | 
   41 |     |     function logInt(int256 p0) internal pure {
   42 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
   43 |     |     }
   44 |     | 
   45 |     |     function logUint(uint256 p0) internal pure {
   46 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
   47 |     |     }
   48 |     | 
   49 |     |     function logString(string memory p0) internal pure {
   50 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   51 |     |     }
   52 |     | 
   53 |     |     function logBool(bool p0) internal pure {
   54 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   55 |     |     }
   56 |     | 
   57 |     |     function logAddress(address p0) internal pure {
   58 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   59 |     |     }
   60 |     | 
   61 |     |     function logBytes(bytes memory p0) internal pure {
   62 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   63 |     |     }
   64 |     | 
   65 |     |     function logBytes1(bytes1 p0) internal pure {
   66 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   67 |     |     }
   68 |     | 
   69 |     |     function logBytes2(bytes2 p0) internal pure {
   70 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   71 |     |     }
   72 |     | 
   73 |     |     function logBytes3(bytes3 p0) internal pure {
   74 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   75 |     |     }
   76 |     | 
   77 |     |     function logBytes4(bytes4 p0) internal pure {
   78 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   79 |     |     }
   80 |     | 
   81 |     |     function logBytes5(bytes5 p0) internal pure {
   82 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   83 |     |     }
   84 |     | 
   85 |     |     function logBytes6(bytes6 p0) internal pure {
   86 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   87 |     |     }
   88 |     | 
   89 |     |     function logBytes7(bytes7 p0) internal pure {
   90 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   91 |     |     }
   92 |     | 
   93 |     |     function logBytes8(bytes8 p0) internal pure {
   94 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   95 |     |     }
   96 |     | 
   97 |     |     function logBytes9(bytes9 p0) internal pure {
   98 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   99 |     |     }
  100 |     | 
  101 |     |     function logBytes10(bytes10 p0) internal pure {
  102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
  103 |     |     }
  104 |     | 
  105 |     |     function logBytes11(bytes11 p0) internal pure {
  106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
  107 |     |     }
  108 |     | 
  109 |     |     function logBytes12(bytes12 p0) internal pure {
  110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
  111 |     |     }
  112 |     | 
  113 |     |     function logBytes13(bytes13 p0) internal pure {
  114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
  115 |     |     }
  116 |     | 
  117 |     |     function logBytes14(bytes14 p0) internal pure {
  118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
  119 |     |     }
  120 |     | 
  121 |     |     function logBytes15(bytes15 p0) internal pure {
  122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  123 |     |     }
  124 |     | 
  125 |     |     function logBytes16(bytes16 p0) internal pure {
  126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  127 |     |     }
  128 |     | 
  129 |     |     function logBytes17(bytes17 p0) internal pure {
  130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  131 |     |     }
  132 |     | 
  133 |     |     function logBytes18(bytes18 p0) internal pure {
  134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  135 |     |     }
  136 |     | 
  137 |     |     function logBytes19(bytes19 p0) internal pure {
  138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  139 |     |     }
  140 |     | 
  141 |     |     function logBytes20(bytes20 p0) internal pure {
  142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  143 |     |     }
  144 |     | 
  145 |     |     function logBytes21(bytes21 p0) internal pure {
  146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  147 |     |     }
  148 |     | 
  149 |     |     function logBytes22(bytes22 p0) internal pure {
  150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  151 |     |     }
  152 |     | 
  153 |     |     function logBytes23(bytes23 p0) internal pure {
  154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  155 |     |     }
  156 |     | 
  157 |     |     function logBytes24(bytes24 p0) internal pure {
  158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  159 |     |     }
  160 |     | 
  161 |     |     function logBytes25(bytes25 p0) internal pure {
  162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  163 |     |     }
  164 |     | 
  165 |     |     function logBytes26(bytes26 p0) internal pure {
  166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  167 |     |     }
  168 |     | 
  169 |     |     function logBytes27(bytes27 p0) internal pure {
  170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  171 |     |     }
  172 |     | 
  173 |     |     function logBytes28(bytes28 p0) internal pure {
  174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  175 |     |     }
  176 |     | 
  177 |     |     function logBytes29(bytes29 p0) internal pure {
  178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  179 |     |     }
  180 |     | 
  181 |     |     function logBytes30(bytes30 p0) internal pure {
  182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  183 |     |     }
  184 |     | 
  185 |     |     function logBytes31(bytes31 p0) internal pure {
  186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  187 |     |     }
  188 |     | 
  189 | *   |     function logBytes32(bytes32 p0) internal pure {
  190 | *   |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  191 |     |     }
  192 |     | 
  193 |     |     function log(uint256 p0) internal pure {
  194 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
  195 |     |     }
  196 |     | 
  197 |     |     function log(int256 p0) internal pure {
  198 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
  199 |     |     }
  200 |     | 
  201 | *   |     function log(string memory p0) internal pure {
  202 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  203 |     |     }
  204 |     | 
  205 |     |     function log(bool p0) internal pure {
  206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  207 |     |     }
  208 |     | 
  209 |     |     function log(address p0) internal pure {
  210 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  211 |     |     }
  212 |     | 
  213 |     |     function log(uint256 p0, uint256 p1) internal pure {
  214 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
  215 |     |     }
  216 |     | 
  217 |     |     function log(uint256 p0, string memory p1) internal pure {
  218 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
  219 |     |     }
  220 |     | 
  221 |     |     function log(uint256 p0, bool p1) internal pure {
  222 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
  223 |     |     }
  224 |     | 
  225 |     |     function log(uint256 p0, address p1) internal pure {
  226 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
  227 |     |     }
  228 |     | 
  229 | *   |     function log(string memory p0, uint256 p1) internal pure {
  230 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
  231 |     |     }
  232 |     | 
  233 | *   |     function log(string memory p0, int256 p1) internal pure {
  234 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string,int256)", p0, p1));
  235 |     |     }
  236 |     | 
  237 | *   |     function log(string memory p0, string memory p1) internal pure {
  238 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  239 |     |     }
  240 |     | 
  241 |     |     function log(string memory p0, bool p1) internal pure {
  242 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  243 |     |     }
  244 |     | 
  245 | *   |     function log(string memory p0, address p1) internal pure {
  246 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  247 |     |     }
  248 |     | 
  249 |     |     function log(bool p0, uint256 p1) internal pure {
  250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
  251 |     |     }
  252 |     | 
  253 |     |     function log(bool p0, string memory p1) internal pure {
  254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  255 |     |     }
  256 |     | 
  257 |     |     function log(bool p0, bool p1) internal pure {
  258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  259 |     |     }
  260 |     | 
  261 |     |     function log(bool p0, address p1) internal pure {
  262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  263 |     |     }
  264 |     | 
  265 |     |     function log(address p0, uint256 p1) internal pure {
  266 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
  267 |     |     }
  268 |     | 
  269 |     |     function log(address p0, string memory p1) internal pure {
  270 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  271 |     |     }
  272 |     | 
  273 |     |     function log(address p0, bool p1) internal pure {
  274 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  275 |     |     }
  276 |     | 
  277 |     |     function log(address p0, address p1) internal pure {
  278 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  279 |     |     }
  280 |     | 
  281 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal pure {
  282 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
  283 |     |     }
  284 |     | 
  285 |     |     function log(uint256 p0, uint256 p1, string memory p2) internal pure {
  286 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
  287 |     |     }
  288 |     | 
  289 |     |     function log(uint256 p0, uint256 p1, bool p2) internal pure {
  290 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
  291 |     |     }
  292 |     | 
  293 |     |     function log(uint256 p0, uint256 p1, address p2) internal pure {
  294 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
  295 |     |     }
  296 |     | 
  297 |     |     function log(uint256 p0, string memory p1, uint256 p2) internal pure {
  298 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
  299 |     |     }
  300 |     | 
  301 |     |     function log(uint256 p0, string memory p1, string memory p2) internal pure {
  302 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
  303 |     |     }
  304 |     | 
  305 |     |     function log(uint256 p0, string memory p1, bool p2) internal pure {
  306 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
  307 |     |     }
  308 |     | 
  309 |     |     function log(uint256 p0, string memory p1, address p2) internal pure {
  310 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
  311 |     |     }
  312 |     | 
  313 |     |     function log(uint256 p0, bool p1, uint256 p2) internal pure {
  314 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
  315 |     |     }
  316 |     | 
  317 |     |     function log(uint256 p0, bool p1, string memory p2) internal pure {
  318 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
  319 |     |     }
  320 |     | 
  321 |     |     function log(uint256 p0, bool p1, bool p2) internal pure {
  322 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
  323 |     |     }
  324 |     | 
  325 |     |     function log(uint256 p0, bool p1, address p2) internal pure {
  326 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
  327 |     |     }
  328 |     | 
  329 |     |     function log(uint256 p0, address p1, uint256 p2) internal pure {
  330 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
  331 |     |     }
  332 |     | 
  333 |     |     function log(uint256 p0, address p1, string memory p2) internal pure {
  334 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
  335 |     |     }
  336 |     | 
  337 |     |     function log(uint256 p0, address p1, bool p2) internal pure {
  338 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
  339 |     |     }
  340 |     | 
  341 |     |     function log(uint256 p0, address p1, address p2) internal pure {
  342 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
  343 |     |     }
  344 |     | 
  345 |     |     function log(string memory p0, uint256 p1, uint256 p2) internal pure {
  346 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
  347 |     |     }
  348 |     | 
  349 |     |     function log(string memory p0, uint256 p1, string memory p2) internal pure {
  350 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
  351 |     |     }
  352 |     | 
  353 |     |     function log(string memory p0, uint256 p1, bool p2) internal pure {
  354 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
  355 |     |     }
  356 |     | 
  357 |     |     function log(string memory p0, uint256 p1, address p2) internal pure {
  358 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
  359 |     |     }
  360 |     | 
  361 |     |     function log(string memory p0, string memory p1, uint256 p2) internal pure {
  362 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
  363 |     |     }
  364 |     | 
  365 |     |     function log(string memory p0, string memory p1, string memory p2) internal pure {
  366 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  367 |     |     }
  368 |     | 
  369 |     |     function log(string memory p0, string memory p1, bool p2) internal pure {
  370 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  371 |     |     }
  372 |     | 
  373 |     |     function log(string memory p0, string memory p1, address p2) internal pure {
  374 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  375 |     |     }
  376 |     | 
  377 |     |     function log(string memory p0, bool p1, uint256 p2) internal pure {
  378 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
  379 |     |     }
  380 |     | 
  381 |     |     function log(string memory p0, bool p1, string memory p2) internal pure {
  382 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  383 |     |     }
  384 |     | 
  385 |     |     function log(string memory p0, bool p1, bool p2) internal pure {
  386 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  387 |     |     }
  388 |     | 
  389 |     |     function log(string memory p0, bool p1, address p2) internal pure {
  390 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  391 |     |     }
  392 |     | 
  393 |     |     function log(string memory p0, address p1, uint256 p2) internal pure {
  394 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
  395 |     |     }
  396 |     | 
  397 |     |     function log(string memory p0, address p1, string memory p2) internal pure {
  398 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  399 |     |     }
  400 |     | 
  401 |     |     function log(string memory p0, address p1, bool p2) internal pure {
  402 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  403 |     |     }
  404 |     | 
  405 |     |     function log(string memory p0, address p1, address p2) internal pure {
  406 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  407 |     |     }
  408 |     | 
  409 |     |     function log(bool p0, uint256 p1, uint256 p2) internal pure {
  410 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
  411 |     |     }
  412 |     | 
  413 |     |     function log(bool p0, uint256 p1, string memory p2) internal pure {
  414 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
  415 |     |     }
  416 |     | 
  417 |     |     function log(bool p0, uint256 p1, bool p2) internal pure {
  418 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
  419 |     |     }
  420 |     | 
  421 |     |     function log(bool p0, uint256 p1, address p2) internal pure {
  422 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
  423 |     |     }
  424 |     | 
  425 |     |     function log(bool p0, string memory p1, uint256 p2) internal pure {
  426 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
  427 |     |     }
  428 |     | 
  429 |     |     function log(bool p0, string memory p1, string memory p2) internal pure {
  430 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  431 |     |     }
  432 |     | 
  433 |     |     function log(bool p0, string memory p1, bool p2) internal pure {
  434 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  435 |     |     }
  436 |     | 
  437 |     |     function log(bool p0, string memory p1, address p2) internal pure {
  438 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  439 |     |     }
  440 |     | 
  441 |     |     function log(bool p0, bool p1, uint256 p2) internal pure {
  442 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
  443 |     |     }
  444 |     | 
  445 |     |     function log(bool p0, bool p1, string memory p2) internal pure {
  446 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  447 |     |     }
  448 |     | 
  449 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  450 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  451 |     |     }
  452 |     | 
  453 |     |     function log(bool p0, bool p1, address p2) internal pure {
  454 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  455 |     |     }
  456 |     | 
  457 |     |     function log(bool p0, address p1, uint256 p2) internal pure {
  458 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
  459 |     |     }
  460 |     | 
  461 |     |     function log(bool p0, address p1, string memory p2) internal pure {
  462 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  463 |     |     }
  464 |     | 
  465 |     |     function log(bool p0, address p1, bool p2) internal pure {
  466 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  467 |     |     }
  468 |     | 
  469 |     |     function log(bool p0, address p1, address p2) internal pure {
  470 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  471 |     |     }
  472 |     | 
  473 |     |     function log(address p0, uint256 p1, uint256 p2) internal pure {
  474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
  475 |     |     }
  476 |     | 
  477 |     |     function log(address p0, uint256 p1, string memory p2) internal pure {
  478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
  479 |     |     }
  480 |     | 
  481 |     |     function log(address p0, uint256 p1, bool p2) internal pure {
  482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
  483 |     |     }
  484 |     | 
  485 |     |     function log(address p0, uint256 p1, address p2) internal pure {
  486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
  487 |     |     }
  488 |     | 
  489 |     |     function log(address p0, string memory p1, uint256 p2) internal pure {
  490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
  491 |     |     }
  492 |     | 
  493 |     |     function log(address p0, string memory p1, string memory p2) internal pure {
  494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  495 |     |     }
  496 |     | 
  497 |     |     function log(address p0, string memory p1, bool p2) internal pure {
  498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  499 |     |     }
  500 |     | 
  501 |     |     function log(address p0, string memory p1, address p2) internal pure {
  502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  503 |     |     }
  504 |     | 
  505 |     |     function log(address p0, bool p1, uint256 p2) internal pure {
  506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
  507 |     |     }
  508 |     | 
  509 |     |     function log(address p0, bool p1, string memory p2) internal pure {
  510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  511 |     |     }
  512 |     | 
  513 |     |     function log(address p0, bool p1, bool p2) internal pure {
  514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  515 |     |     }
  516 |     | 
  517 |     |     function log(address p0, bool p1, address p2) internal pure {
  518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  519 |     |     }
  520 |     | 
  521 |     |     function log(address p0, address p1, uint256 p2) internal pure {
  522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
  523 |     |     }
  524 |     | 
  525 |     |     function log(address p0, address p1, string memory p2) internal pure {
  526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  527 |     |     }
  528 |     | 
  529 |     |     function log(address p0, address p1, bool p2) internal pure {
  530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  531 |     |     }
  532 |     | 
  533 |     |     function log(address p0, address p1, address p2) internal pure {
  534 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  535 |     |     }
  536 |     | 
  537 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  538 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
  539 |     |     }
  540 |     | 
  541 |     |     function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {
  542 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
  543 |     |     }
  544 |     | 
  545 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {
  546 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
  547 |     |     }
  548 |     | 
  549 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {
  550 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
  551 |     |     }
  552 |     | 
  553 |     |     function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {
  554 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
  555 |     |     }
  556 |     | 
  557 |     |     function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {
  558 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
  559 |     |     }
  560 |     | 
  561 |     |     function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {
  562 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
  563 |     |     }
  564 |     | 
  565 |     |     function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {
  566 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
  567 |     |     }
  568 |     | 
  569 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {
  570 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
  571 |     |     }
  572 |     | 
  573 |     |     function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {
  574 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
  575 |     |     }
  576 |     | 
  577 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {
  578 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
  579 |     |     }
  580 |     | 
  581 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {
  582 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
  583 |     |     }
  584 |     | 
  585 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {
  586 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
  587 |     |     }
  588 |     | 
  589 |     |     function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {
  590 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
  591 |     |     }
  592 |     | 
  593 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {
  594 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
  595 |     |     }
  596 |     | 
  597 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {
  598 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
  599 |     |     }
  600 |     | 
  601 |     |     function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {
  602 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
  603 |     |     }
  604 |     | 
  605 |     |     function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {
  606 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
  607 |     |     }
  608 |     | 
  609 |     |     function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {
  610 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
  611 |     |     }
  612 |     | 
  613 |     |     function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {
  614 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
  615 |     |     }
  616 |     | 
  617 |     |     function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {
  618 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
  619 |     |     }
  620 |     | 
  621 |     |     function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {
  622 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
  623 |     |     }
  624 |     | 
  625 |     |     function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {
  626 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
  627 |     |     }
  628 |     | 
  629 |     |     function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {
  630 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
  631 |     |     }
  632 |     | 
  633 |     |     function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {
  634 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
  635 |     |     }
  636 |     | 
  637 |     |     function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {
  638 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
  639 |     |     }
  640 |     | 
  641 |     |     function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {
  642 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
  643 |     |     }
  644 |     | 
  645 |     |     function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {
  646 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
  647 |     |     }
  648 |     | 
  649 |     |     function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {
  650 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
  651 |     |     }
  652 |     | 
  653 |     |     function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {
  654 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
  655 |     |     }
  656 |     | 
  657 |     |     function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {
  658 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
  659 |     |     }
  660 |     | 
  661 |     |     function log(uint256 p0, string memory p1, address p2, address p3) internal pure {
  662 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
  663 |     |     }
  664 |     | 
  665 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {
  666 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
  667 |     |     }
  668 |     | 
  669 |     |     function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {
  670 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
  671 |     |     }
  672 |     | 
  673 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {
  674 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
  675 |     |     }
  676 |     | 
  677 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {
  678 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
  679 |     |     }
  680 |     | 
  681 |     |     function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {
  682 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
  683 |     |     }
  684 |     | 
  685 |     |     function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {
  686 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
  687 |     |     }
  688 |     | 
  689 |     |     function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {
  690 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
  691 |     |     }
  692 |     | 
  693 |     |     function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {
  694 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
  695 |     |     }
  696 |     | 
  697 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {
  698 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
  699 |     |     }
  700 |     | 
  701 |     |     function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {
  702 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
  703 |     |     }
  704 |     | 
  705 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {
  706 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
  707 |     |     }
  708 |     | 
  709 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal pure {
  710 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
  711 |     |     }
  712 |     | 
  713 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {
  714 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
  715 |     |     }
  716 |     | 
  717 |     |     function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {
  718 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
  719 |     |     }
  720 |     | 
  721 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal pure {
  722 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
  723 |     |     }
  724 |     | 
  725 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal pure {
  726 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
  727 |     |     }
  728 |     | 
  729 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {
  730 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
  731 |     |     }
  732 |     | 
  733 |     |     function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {
  734 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
  735 |     |     }
  736 |     | 
  737 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {
  738 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
  739 |     |     }
  740 |     | 
  741 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {
  742 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
  743 |     |     }
  744 |     | 
  745 |     |     function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {
  746 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
  747 |     |     }
  748 |     | 
  749 |     |     function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {
  750 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
  751 |     |     }
  752 |     | 
  753 |     |     function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {
  754 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
  755 |     |     }
  756 |     | 
  757 |     |     function log(uint256 p0, address p1, string memory p2, address p3) internal pure {
  758 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
  759 |     |     }
  760 |     | 
  761 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {
  762 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
  763 |     |     }
  764 |     | 
  765 |     |     function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {
  766 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
  767 |     |     }
  768 |     | 
  769 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal pure {
  770 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
  771 |     |     }
  772 |     | 
  773 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal pure {
  774 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
  775 |     |     }
  776 |     | 
  777 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {
  778 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
  779 |     |     }
  780 |     | 
  781 |     |     function log(uint256 p0, address p1, address p2, string memory p3) internal pure {
  782 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
  783 |     |     }
  784 |     | 
  785 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal pure {
  786 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
  787 |     |     }
  788 |     | 
  789 |     |     function log(uint256 p0, address p1, address p2, address p3) internal pure {
  790 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
  791 |     |     }
  792 |     | 
  793 |     |     function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  794 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
  795 |     |     }
  796 |     | 
  797 |     |     function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {
  798 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
  799 |     |     }
  800 |     | 
  801 |     |     function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {
  802 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
  803 |     |     }
  804 |     | 
  805 |     |     function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {
  806 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
  807 |     |     }
  808 |     | 
  809 |     |     function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {
  810 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
  811 |     |     }
  812 |     | 
  813 |     |     function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {
  814 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
  815 |     |     }
  816 |     | 
  817 |     |     function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {
  818 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
  819 |     |     }
  820 |     | 
  821 |     |     function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {
  822 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
  823 |     |     }
  824 |     | 
  825 |     |     function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {
  826 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
  827 |     |     }
  828 |     | 
  829 |     |     function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {
  830 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
  831 |     |     }
  832 |     | 
  833 |     |     function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {
  834 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
  835 |     |     }
  836 |     | 
  837 |     |     function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {
  838 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
  839 |     |     }
  840 |     | 
  841 |     |     function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {
  842 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
  843 |     |     }
  844 |     | 
  845 |     |     function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {
  846 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
  847 |     |     }
  848 |     | 
  849 |     |     function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {
  850 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
  851 |     |     }
  852 |     | 
  853 |     |     function log(string memory p0, uint256 p1, address p2, address p3) internal pure {
  854 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
  855 |     |     }
  856 |     | 
  857 |     |     function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {
  858 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
  859 |     |     }
  860 |     | 
  861 |     |     function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {
  862 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
  863 |     |     }
  864 |     | 
  865 |     |     function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {
  866 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
  867 |     |     }
  868 |     | 
  869 |     |     function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {
  870 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
  871 |     |     }
  872 |     | 
  873 |     |     function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {
  874 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
  875 |     |     }
  876 |     | 
  877 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {
  878 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  879 |     |     }
  880 |     | 
  881 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {
  882 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  883 |     |     }
  884 |     | 
  885 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {
  886 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  887 |     |     }
  888 |     | 
  889 |     |     function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {
  890 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
  891 |     |     }
  892 |     | 
  893 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {
  894 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  895 |     |     }
  896 |     | 
  897 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {
  898 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  899 |     |     }
  900 |     | 
  901 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal pure {
  902 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  903 |     |     }
  904 |     | 
  905 |     |     function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {
  906 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
  907 |     |     }
  908 |     | 
  909 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {
  910 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  911 |     |     }
  912 |     | 
  913 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal pure {
  914 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  915 |     |     }
  916 |     | 
  917 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal pure {
  918 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  919 |     |     }
  920 |     | 
  921 |     |     function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {
  922 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
  923 |     |     }
  924 |     | 
  925 |     |     function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {
  926 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
  927 |     |     }
  928 |     | 
  929 |     |     function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {
  930 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
  931 |     |     }
  932 |     | 
  933 |     |     function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {
  934 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
  935 |     |     }
  936 |     | 
  937 |     |     function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {
  938 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
  939 |     |     }
  940 |     | 
  941 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {
  942 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  943 |     |     }
  944 |     | 
  945 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {
  946 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  947 |     |     }
  948 |     | 
  949 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal pure {
  950 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  951 |     |     }
  952 |     | 
  953 |     |     function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {
  954 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
  955 |     |     }
  956 |     | 
  957 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {
  958 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  959 |     |     }
  960 |     | 
  961 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal pure {
  962 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  963 |     |     }
  964 |     | 
  965 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal pure {
  966 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  967 |     |     }
  968 |     | 
  969 |     |     function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {
  970 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
  971 |     |     }
  972 |     | 
  973 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal pure {
  974 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  975 |     |     }
  976 |     | 
  977 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal pure {
  978 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  979 |     |     }
  980 |     | 
  981 |     |     function log(string memory p0, bool p1, address p2, address p3) internal pure {
  982 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  983 |     |     }
  984 |     | 
  985 |     |     function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {
  986 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
  987 |     |     }
  988 |     | 
  989 |     |     function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {
  990 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
  991 |     |     }
  992 |     | 
  993 |     |     function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {
  994 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
  995 |     |     }
  996 |     | 
  997 |     |     function log(string memory p0, address p1, uint256 p2, address p3) internal pure {
  998 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
  999 |     |     }
 1000 |     | 
 1001 |     |     function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {
 1002 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
 1003 |     |     }
 1004 |     | 
 1005 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {
 1006 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
 1007 |     |     }
 1008 |     | 
 1009 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal pure {
 1010 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
 1011 |     |     }
 1012 |     | 
 1013 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal pure {
 1014 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
 1015 |     |     }
 1016 |     | 
 1017 |     |     function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {
 1018 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
 1019 |     |     }
 1020 |     | 
 1021 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal pure {
 1022 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
 1023 |     |     }
 1024 |     | 
 1025 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal pure {
 1026 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
 1027 |     |     }
 1028 |     | 
 1029 |     |     function log(string memory p0, address p1, bool p2, address p3) internal pure {
 1030 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1031 |     |     }
 1032 |     | 
 1033 |     |     function log(string memory p0, address p1, address p2, uint256 p3) internal pure {
 1034 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
 1035 |     |     }
 1036 |     | 
 1037 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal pure {
 1038 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1039 |     |     }
 1040 |     | 
 1041 |     |     function log(string memory p0, address p1, address p2, bool p3) internal pure {
 1042 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1043 |     |     }
 1044 |     | 
 1045 |     |     function log(string memory p0, address p1, address p2, address p3) internal pure {
 1046 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1047 |     |     }
 1048 |     | 
 1049 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 1050 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
 1051 |     |     }
 1052 |     | 
 1053 |     |     function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {
 1054 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
 1055 |     |     }
 1056 |     | 
 1057 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {
 1058 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
 1059 |     |     }
 1060 |     | 
 1061 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {
 1062 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
 1063 |     |     }
 1064 |     | 
 1065 |     |     function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {
 1066 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
 1067 |     |     }
 1068 |     | 
 1069 |     |     function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {
 1070 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
 1071 |     |     }
 1072 |     | 
 1073 |     |     function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {
 1074 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
 1075 |     |     }
 1076 |     | 
 1077 |     |     function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {
 1078 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
 1079 |     |     }
 1080 |     | 
 1081 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {
 1082 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
 1083 |     |     }
 1084 |     | 
 1085 |     |     function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {
 1086 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
 1087 |     |     }
 1088 |     | 
 1089 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {
 1090 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
 1091 |     |     }
 1092 |     | 
 1093 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal pure {
 1094 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
 1095 |     |     }
 1096 |     | 
 1097 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {
 1098 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
 1099 |     |     }
 1100 |     | 
 1101 |     |     function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {
 1102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
 1103 |     |     }
 1104 |     | 
 1105 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal pure {
 1106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
 1107 |     |     }
 1108 |     | 
 1109 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal pure {
 1110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
 1111 |     |     }
 1112 |     | 
 1113 |     |     function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {
 1114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
 1115 |     |     }
 1116 |     | 
 1117 |     |     function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {
 1118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
 1119 |     |     }
 1120 |     | 
 1121 |     |     function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {
 1122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
 1123 |     |     }
 1124 |     | 
 1125 |     |     function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {
 1126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
 1127 |     |     }
 1128 |     | 
 1129 |     |     function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {
 1130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
 1131 |     |     }
 1132 |     | 
 1133 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {
 1134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1135 |     |     }
 1136 |     | 
 1137 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {
 1138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1139 |     |     }
 1140 |     | 
 1141 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal pure {
 1142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1143 |     |     }
 1144 |     | 
 1145 |     |     function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {
 1146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
 1147 |     |     }
 1148 |     | 
 1149 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {
 1150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1151 |     |     }
 1152 |     | 
 1153 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal pure {
 1154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1155 |     |     }
 1156 |     | 
 1157 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal pure {
 1158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1159 |     |     }
 1160 |     | 
 1161 |     |     function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {
 1162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
 1163 |     |     }
 1164 |     | 
 1165 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal pure {
 1166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1167 |     |     }
 1168 |     | 
 1169 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal pure {
 1170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1171 |     |     }
 1172 |     | 
 1173 |     |     function log(bool p0, string memory p1, address p2, address p3) internal pure {
 1174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1175 |     |     }
 1176 |     | 
 1177 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {
 1178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
 1179 |     |     }
 1180 |     | 
 1181 |     |     function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {
 1182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
 1183 |     |     }
 1184 |     | 
 1185 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {
 1186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
 1187 |     |     }
 1188 |     | 
 1189 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal pure {
 1190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
 1191 |     |     }
 1192 |     | 
 1193 |     |     function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {
 1194 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
 1195 |     |     }
 1196 |     | 
 1197 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {
 1198 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1199 |     |     }
 1200 |     | 
 1201 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal pure {
 1202 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1203 |     |     }
 1204 |     | 
 1205 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal pure {
 1206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1207 |     |     }
 1208 |     | 
 1209 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {
 1210 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
 1211 |     |     }
 1212 |     | 
 1213 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal pure {
 1214 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1215 |     |     }
 1216 |     | 
 1217 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
 1218 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1219 |     |     }
 1220 |     | 
 1221 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
 1222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1223 |     |     }
 1224 |     | 
 1225 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal pure {
 1226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
 1227 |     |     }
 1228 |     | 
 1229 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal pure {
 1230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1231 |     |     }
 1232 |     | 
 1233 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
 1234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1235 |     |     }
 1236 |     | 
 1237 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
 1238 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1239 |     |     }
 1240 |     | 
 1241 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {
 1242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
 1243 |     |     }
 1244 |     | 
 1245 |     |     function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {
 1246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
 1247 |     |     }
 1248 |     | 
 1249 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal pure {
 1250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
 1251 |     |     }
 1252 |     | 
 1253 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal pure {
 1254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
 1255 |     |     }
 1256 |     | 
 1257 |     |     function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {
 1258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
 1259 |     |     }
 1260 |     | 
 1261 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal pure {
 1262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1263 |     |     }
 1264 |     | 
 1265 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal pure {
 1266 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1267 |     |     }
 1268 |     | 
 1269 |     |     function log(bool p0, address p1, string memory p2, address p3) internal pure {
 1270 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1271 |     |     }
 1272 |     | 
 1273 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal pure {
 1274 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
 1275 |     |     }
 1276 |     | 
 1277 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal pure {
 1278 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1279 |     |     }
 1280 |     | 
 1281 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
 1282 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1283 |     |     }
 1284 |     | 
 1285 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
 1286 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1287 |     |     }
 1288 |     | 
 1289 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal pure {
 1290 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
 1291 |     |     }
 1292 |     | 
 1293 |     |     function log(bool p0, address p1, address p2, string memory p3) internal pure {
 1294 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1295 |     |     }
 1296 |     | 
 1297 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
 1298 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1299 |     |     }
 1300 |     | 
 1301 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
 1302 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1303 |     |     }
 1304 |     | 
 1305 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 1306 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
 1307 |     |     }
 1308 |     | 
 1309 |     |     function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {
 1310 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
 1311 |     |     }
 1312 |     | 
 1313 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {
 1314 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
 1315 |     |     }
 1316 |     | 
 1317 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {
 1318 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
 1319 |     |     }
 1320 |     | 
 1321 |     |     function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {
 1322 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
 1323 |     |     }
 1324 |     | 
 1325 |     |     function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {
 1326 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
 1327 |     |     }
 1328 |     | 
 1329 |     |     function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {
 1330 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
 1331 |     |     }
 1332 |     | 
 1333 |     |     function log(address p0, uint256 p1, string memory p2, address p3) internal pure {
 1334 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
 1335 |     |     }
 1336 |     | 
 1337 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {
 1338 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
 1339 |     |     }
 1340 |     | 
 1341 |     |     function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {
 1342 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
 1343 |     |     }
 1344 |     | 
 1345 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal pure {
 1346 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
 1347 |     |     }
 1348 |     | 
 1349 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal pure {
 1350 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
 1351 |     |     }
 1352 |     | 
 1353 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {
 1354 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
 1355 |     |     }
 1356 |     | 
 1357 |     |     function log(address p0, uint256 p1, address p2, string memory p3) internal pure {
 1358 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
 1359 |     |     }
 1360 |     | 
 1361 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal pure {
 1362 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
 1363 |     |     }
 1364 |     | 
 1365 |     |     function log(address p0, uint256 p1, address p2, address p3) internal pure {
 1366 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
 1367 |     |     }
 1368 |     | 
 1369 |     |     function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {
 1370 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
 1371 |     |     }
 1372 |     | 
 1373 |     |     function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {
 1374 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
 1375 |     |     }
 1376 |     | 
 1377 |     |     function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {
 1378 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
 1379 |     |     }
 1380 |     | 
 1381 |     |     function log(address p0, string memory p1, uint256 p2, address p3) internal pure {
 1382 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
 1383 |     |     }
 1384 |     | 
 1385 |     |     function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {
 1386 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
 1387 |     |     }
 1388 |     | 
 1389 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {
 1390 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1391 |     |     }
 1392 |     | 
 1393 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal pure {
 1394 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1395 |     |     }
 1396 |     | 
 1397 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal pure {
 1398 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1399 |     |     }
 1400 |     | 
 1401 |     |     function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {
 1402 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
 1403 |     |     }
 1404 |     | 
 1405 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal pure {
 1406 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1407 |     |     }
 1408 |     | 
 1409 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal pure {
 1410 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1411 |     |     }
 1412 |     | 
 1413 |     |     function log(address p0, string memory p1, bool p2, address p3) internal pure {
 1414 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1415 |     |     }
 1416 |     | 
 1417 |     |     function log(address p0, string memory p1, address p2, uint256 p3) internal pure {
 1418 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
 1419 |     |     }
 1420 |     | 
 1421 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal pure {
 1422 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1423 |     |     }
 1424 |     | 
 1425 |     |     function log(address p0, string memory p1, address p2, bool p3) internal pure {
 1426 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1427 |     |     }
 1428 |     | 
 1429 |     |     function log(address p0, string memory p1, address p2, address p3) internal pure {
 1430 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1431 |     |     }
 1432 |     | 
 1433 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {
 1434 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
 1435 |     |     }
 1436 |     | 
 1437 |     |     function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {
 1438 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
 1439 |     |     }
 1440 |     | 
 1441 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal pure {
 1442 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
 1443 |     |     }
 1444 |     | 
 1445 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal pure {
 1446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
 1447 |     |     }
 1448 |     | 
 1449 |     |     function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {
 1450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
 1451 |     |     }
 1452 |     | 
 1453 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal pure {
 1454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1455 |     |     }
 1456 |     | 
 1457 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal pure {
 1458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1459 |     |     }
 1460 |     | 
 1461 |     |     function log(address p0, bool p1, string memory p2, address p3) internal pure {
 1462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1463 |     |     }
 1464 |     | 
 1465 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal pure {
 1466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
 1467 |     |     }
 1468 |     | 
 1469 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal pure {
 1470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1471 |     |     }
 1472 |     | 
 1473 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
 1474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1475 |     |     }
 1476 |     | 
 1477 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
 1478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1479 |     |     }
 1480 |     | 
 1481 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal pure {
 1482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
 1483 |     |     }
 1484 |     | 
 1485 |     |     function log(address p0, bool p1, address p2, string memory p3) internal pure {
 1486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1487 |     |     }
 1488 |     | 
 1489 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
 1490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1491 |     |     }
 1492 |     | 
 1493 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
 1494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1495 |     |     }
 1496 |     | 
 1497 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {
 1498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
 1499 |     |     }
 1500 |     | 
 1501 |     |     function log(address p0, address p1, uint256 p2, string memory p3) internal pure {
 1502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
 1503 |     |     }
 1504 |     | 
 1505 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal pure {
 1506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
 1507 |     |     }
 1508 |     | 
 1509 |     |     function log(address p0, address p1, uint256 p2, address p3) internal pure {
 1510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
 1511 |     |     }
 1512 |     | 
 1513 |     |     function log(address p0, address p1, string memory p2, uint256 p3) internal pure {
 1514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
 1515 |     |     }
 1516 |     | 
 1517 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal pure {
 1518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1519 |     |     }
 1520 |     | 
 1521 |     |     function log(address p0, address p1, string memory p2, bool p3) internal pure {
 1522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1523 |     |     }
 1524 |     | 
 1525 |     |     function log(address p0, address p1, string memory p2, address p3) internal pure {
 1526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1527 |     |     }
 1528 |     | 
 1529 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal pure {
 1530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
 1531 |     |     }
 1532 |     | 
 1533 |     |     function log(address p0, address p1, bool p2, string memory p3) internal pure {
 1534 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1535 |     |     }
 1536 |     | 
 1537 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
 1538 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1539 |     |     }
 1540 |     | 
 1541 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
 1542 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1543 |     |     }
 1544 |     | 
 1545 |     |     function log(address p0, address p1, address p2, uint256 p3) internal pure {
 1546 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
 1547 |     |     }
 1548 |     | 
 1549 |     |     function log(address p0, address p1, address p2, string memory p3) internal pure {
 1550 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1551 |     |     }
 1552 |     | 
 1553 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
 1554 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1555 |     |     }
 1556 |     | 
 1557 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
 1558 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1559 |     |     }
 1560 |     | }
 1561 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/console2.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity >=0.4.22 <0.9.0;
 3 |     | 
 4 |     | import {console as console2} from "./console.sol";
 5 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/interfaces/IMulticall3.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | interface IMulticall3 {
  7 |     |     struct Call {
  8 |     |         address target;
  9 |     |         bytes callData;
 10 |     |     }
 11 |     | 
 12 |     |     struct Call3 {
 13 |     |         address target;
 14 |     |         bool allowFailure;
 15 |     |         bytes callData;
 16 |     |     }
 17 |     | 
 18 |     |     struct Call3Value {
 19 |     |         address target;
 20 |     |         bool allowFailure;
 21 |     |         uint256 value;
 22 |     |         bytes callData;
 23 |     |     }
 24 |     | 
 25 |     |     struct Result {
 26 |     |         bool success;
 27 |     |         bytes returnData;
 28 |     |     }
 29 |     | 
 30 |     |     function aggregate(Call[] calldata calls)
 31 |     |         external
 32 |     |         payable
 33 |     |         returns (uint256 blockNumber, bytes[] memory returnData);
 34 |     | 
 35 |     |     function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);
 36 |     | 
 37 |     |     function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);
 38 |     | 
 39 |     |     function blockAndAggregate(Call[] calldata calls)
 40 |     |         external
 41 |     |         payable
 42 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 43 |     | 
 44 |     |     function getBasefee() external view returns (uint256 basefee);
 45 |     | 
 46 |     |     function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);
 47 |     | 
 48 |     |     function getBlockNumber() external view returns (uint256 blockNumber);
 49 |     | 
 50 |     |     function getChainId() external view returns (uint256 chainid);
 51 |     | 
 52 |     |     function getCurrentBlockCoinbase() external view returns (address coinbase);
 53 |     | 
 54 |     |     function getCurrentBlockDifficulty() external view returns (uint256 difficulty);
 55 |     | 
 56 |     |     function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);
 57 |     | 
 58 |     |     function getCurrentBlockTimestamp() external view returns (uint256 timestamp);
 59 |     | 
 60 |     |     function getEthBalance(address addr) external view returns (uint256 balance);
 61 |     | 
 62 |     |     function getLastBlockHash() external view returns (bytes32 blockHash);
 63 |     | 
 64 |     |     function tryAggregate(bool requireSuccess, Call[] calldata calls)
 65 |     |         external
 66 |     |         payable
 67 |     |         returns (Result[] memory returnData);
 68 |     | 
 69 |     |     function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)
 70 |     |         external
 71 |     |         payable
 72 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 73 |     | }
 74 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/forge-std/src/safeconsole.sol
     1 |     | // SPDX-License-Identifier: MIT
     2 |     | pragma solidity >=0.6.2 <0.9.0;
     3 |     | 
     4 |     | /// @author philogy <https://github.com/philogy>
     5 |     | /// @dev Code generated automatically by script.
     6 |     | library safeconsole {
     7 |     |     uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;
     8 |     | 
     9 |     |     // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)
    10 |     |     // for the view-to-pure log trick.
    11 |     |     function _sendLogPayload(uint256 offset, uint256 size) private pure {
    12 |     |         function(uint256, uint256) internal view fnIn = _sendLogPayloadView;
    13 |     |         function(uint256, uint256) internal pure pureSendLogPayload;
    14 |     |         /// @solidity memory-safe-assembly
    15 |     |         assembly {
    16 |     |             pureSendLogPayload := fnIn
    17 |     |         }
    18 |     |         pureSendLogPayload(offset, size);
    19 |     |     }
    20 |     | 
    21 |     |     function _sendLogPayloadView(uint256 offset, uint256 size) private view {
    22 |     |         /// @solidity memory-safe-assembly
    23 |     |         assembly {
    24 |     |             pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))
    25 |     |         }
    26 |     |     }
    27 |     | 
    28 |     |     function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {
    29 |     |         function(uint256, uint256, uint256) internal view fnIn = _memcopyView;
    30 |     |         function(uint256, uint256, uint256) internal pure pureMemcopy;
    31 |     |         /// @solidity memory-safe-assembly
    32 |     |         assembly {
    33 |     |             pureMemcopy := fnIn
    34 |     |         }
    35 |     |         pureMemcopy(fromOffset, toOffset, length);
    36 |     |     }
    37 |     | 
    38 |     |     function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {
    39 |     |         /// @solidity memory-safe-assembly
    40 |     |         assembly {
    41 |     |             pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))
    42 |     |         }
    43 |     |     }
    44 |     | 
    45 |     |     function logMemory(uint256 offset, uint256 length) internal pure {
    46 |     |         if (offset >= 0x60) {
    47 |     |             // Sufficient memory before slice to prepare call header.
    48 |     |             bytes32 m0;
    49 |     |             bytes32 m1;
    50 |     |             bytes32 m2;
    51 |     |             /// @solidity memory-safe-assembly
    52 |     |             assembly {
    53 |     |                 m0 := mload(sub(offset, 0x60))
    54 |     |                 m1 := mload(sub(offset, 0x40))
    55 |     |                 m2 := mload(sub(offset, 0x20))
    56 |     |                 // Selector of `log(bytes)`.
    57 |     |                 mstore(sub(offset, 0x60), 0x0be77f56)
    58 |     |                 mstore(sub(offset, 0x40), 0x20)
    59 |     |                 mstore(sub(offset, 0x20), length)
    60 |     |             }
    61 |     |             _sendLogPayload(offset - 0x44, length + 0x44);
    62 |     |             /// @solidity memory-safe-assembly
    63 |     |             assembly {
    64 |     |                 mstore(sub(offset, 0x60), m0)
    65 |     |                 mstore(sub(offset, 0x40), m1)
    66 |     |                 mstore(sub(offset, 0x20), m2)
    67 |     |             }
    68 |     |         } else {
    69 |     |             // Insufficient space, so copy slice forward, add header and reverse.
    70 |     |             bytes32 m0;
    71 |     |             bytes32 m1;
    72 |     |             bytes32 m2;
    73 |     |             uint256 endOffset = offset + length;
    74 |     |             /// @solidity memory-safe-assembly
    75 |     |             assembly {
    76 |     |                 m0 := mload(add(endOffset, 0x00))
    77 |     |                 m1 := mload(add(endOffset, 0x20))
    78 |     |                 m2 := mload(add(endOffset, 0x40))
    79 |     |             }
    80 |     |             _memcopy(offset, offset + 0x60, length);
    81 |     |             /// @solidity memory-safe-assembly
    82 |     |             assembly {
    83 |     |                 // Selector of `log(bytes)`.
    84 |     |                 mstore(add(offset, 0x00), 0x0be77f56)
    85 |     |                 mstore(add(offset, 0x20), 0x20)
    86 |     |                 mstore(add(offset, 0x40), length)
    87 |     |             }
    88 |     |             _sendLogPayload(offset + 0x1c, length + 0x44);
    89 |     |             _memcopy(offset + 0x60, offset, length);
    90 |     |             /// @solidity memory-safe-assembly
    91 |     |             assembly {
    92 |     |                 mstore(add(endOffset, 0x00), m0)
    93 |     |                 mstore(add(endOffset, 0x20), m1)
    94 |     |                 mstore(add(endOffset, 0x40), m2)
    95 |     |             }
    96 |     |         }
    97 |     |     }
    98 |     | 
    99 |     |     function log(address p0) internal pure {
   100 |     |         bytes32 m0;
   101 |     |         bytes32 m1;
   102 |     |         /// @solidity memory-safe-assembly
   103 |     |         assembly {
   104 |     |             m0 := mload(0x00)
   105 |     |             m1 := mload(0x20)
   106 |     |             // Selector of `log(address)`.
   107 |     |             mstore(0x00, 0x2c2ecbc2)
   108 |     |             mstore(0x20, p0)
   109 |     |         }
   110 |     |         _sendLogPayload(0x1c, 0x24);
   111 |     |         /// @solidity memory-safe-assembly
   112 |     |         assembly {
   113 |     |             mstore(0x00, m0)
   114 |     |             mstore(0x20, m1)
   115 |     |         }
   116 |     |     }
   117 |     | 
   118 |     |     function log(bool p0) internal pure {
   119 |     |         bytes32 m0;
   120 |     |         bytes32 m1;
   121 |     |         /// @solidity memory-safe-assembly
   122 |     |         assembly {
   123 |     |             m0 := mload(0x00)
   124 |     |             m1 := mload(0x20)
   125 |     |             // Selector of `log(bool)`.
   126 |     |             mstore(0x00, 0x32458eed)
   127 |     |             mstore(0x20, p0)
   128 |     |         }
   129 |     |         _sendLogPayload(0x1c, 0x24);
   130 |     |         /// @solidity memory-safe-assembly
   131 |     |         assembly {
   132 |     |             mstore(0x00, m0)
   133 |     |             mstore(0x20, m1)
   134 |     |         }
   135 |     |     }
   136 |     | 
   137 |     |     function log(uint256 p0) internal pure {
   138 |     |         bytes32 m0;
   139 |     |         bytes32 m1;
   140 |     |         /// @solidity memory-safe-assembly
   141 |     |         assembly {
   142 |     |             m0 := mload(0x00)
   143 |     |             m1 := mload(0x20)
   144 |     |             // Selector of `log(uint256)`.
   145 |     |             mstore(0x00, 0xf82c50f1)
   146 |     |             mstore(0x20, p0)
   147 |     |         }
   148 |     |         _sendLogPayload(0x1c, 0x24);
   149 |     |         /// @solidity memory-safe-assembly
   150 |     |         assembly {
   151 |     |             mstore(0x00, m0)
   152 |     |             mstore(0x20, m1)
   153 |     |         }
   154 |     |     }
   155 |     | 
   156 |     |     function log(bytes32 p0) internal pure {
   157 |     |         bytes32 m0;
   158 |     |         bytes32 m1;
   159 |     |         bytes32 m2;
   160 |     |         bytes32 m3;
   161 |     |         /// @solidity memory-safe-assembly
   162 |     |         assembly {
   163 |     |             function writeString(pos, w) {
   164 |     |                 let length := 0
   165 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   166 |     |                 mstore(pos, length)
   167 |     |                 let shift := sub(256, shl(3, length))
   168 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   169 |     |             }
   170 |     |             m0 := mload(0x00)
   171 |     |             m1 := mload(0x20)
   172 |     |             m2 := mload(0x40)
   173 |     |             m3 := mload(0x60)
   174 |     |             // Selector of `log(string)`.
   175 |     |             mstore(0x00, 0x41304fac)
   176 |     |             mstore(0x20, 0x20)
   177 |     |             writeString(0x40, p0)
   178 |     |         }
   179 |     |         _sendLogPayload(0x1c, 0x64);
   180 |     |         /// @solidity memory-safe-assembly
   181 |     |         assembly {
   182 |     |             mstore(0x00, m0)
   183 |     |             mstore(0x20, m1)
   184 |     |             mstore(0x40, m2)
   185 |     |             mstore(0x60, m3)
   186 |     |         }
   187 |     |     }
   188 |     | 
   189 |     |     function log(address p0, address p1) internal pure {
   190 |     |         bytes32 m0;
   191 |     |         bytes32 m1;
   192 |     |         bytes32 m2;
   193 |     |         /// @solidity memory-safe-assembly
   194 |     |         assembly {
   195 |     |             m0 := mload(0x00)
   196 |     |             m1 := mload(0x20)
   197 |     |             m2 := mload(0x40)
   198 |     |             // Selector of `log(address,address)`.
   199 |     |             mstore(0x00, 0xdaf0d4aa)
   200 |     |             mstore(0x20, p0)
   201 |     |             mstore(0x40, p1)
   202 |     |         }
   203 |     |         _sendLogPayload(0x1c, 0x44);
   204 |     |         /// @solidity memory-safe-assembly
   205 |     |         assembly {
   206 |     |             mstore(0x00, m0)
   207 |     |             mstore(0x20, m1)
   208 |     |             mstore(0x40, m2)
   209 |     |         }
   210 |     |     }
   211 |     | 
   212 |     |     function log(address p0, bool p1) internal pure {
   213 |     |         bytes32 m0;
   214 |     |         bytes32 m1;
   215 |     |         bytes32 m2;
   216 |     |         /// @solidity memory-safe-assembly
   217 |     |         assembly {
   218 |     |             m0 := mload(0x00)
   219 |     |             m1 := mload(0x20)
   220 |     |             m2 := mload(0x40)
   221 |     |             // Selector of `log(address,bool)`.
   222 |     |             mstore(0x00, 0x75b605d3)
   223 |     |             mstore(0x20, p0)
   224 |     |             mstore(0x40, p1)
   225 |     |         }
   226 |     |         _sendLogPayload(0x1c, 0x44);
   227 |     |         /// @solidity memory-safe-assembly
   228 |     |         assembly {
   229 |     |             mstore(0x00, m0)
   230 |     |             mstore(0x20, m1)
   231 |     |             mstore(0x40, m2)
   232 |     |         }
   233 |     |     }
   234 |     | 
   235 |     |     function log(address p0, uint256 p1) internal pure {
   236 |     |         bytes32 m0;
   237 |     |         bytes32 m1;
   238 |     |         bytes32 m2;
   239 |     |         /// @solidity memory-safe-assembly
   240 |     |         assembly {
   241 |     |             m0 := mload(0x00)
   242 |     |             m1 := mload(0x20)
   243 |     |             m2 := mload(0x40)
   244 |     |             // Selector of `log(address,uint256)`.
   245 |     |             mstore(0x00, 0x8309e8a8)
   246 |     |             mstore(0x20, p0)
   247 |     |             mstore(0x40, p1)
   248 |     |         }
   249 |     |         _sendLogPayload(0x1c, 0x44);
   250 |     |         /// @solidity memory-safe-assembly
   251 |     |         assembly {
   252 |     |             mstore(0x00, m0)
   253 |     |             mstore(0x20, m1)
   254 |     |             mstore(0x40, m2)
   255 |     |         }
   256 |     |     }
   257 |     | 
   258 |     |     function log(address p0, bytes32 p1) internal pure {
   259 |     |         bytes32 m0;
   260 |     |         bytes32 m1;
   261 |     |         bytes32 m2;
   262 |     |         bytes32 m3;
   263 |     |         bytes32 m4;
   264 |     |         /// @solidity memory-safe-assembly
   265 |     |         assembly {
   266 |     |             function writeString(pos, w) {
   267 |     |                 let length := 0
   268 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   269 |     |                 mstore(pos, length)
   270 |     |                 let shift := sub(256, shl(3, length))
   271 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   272 |     |             }
   273 |     |             m0 := mload(0x00)
   274 |     |             m1 := mload(0x20)
   275 |     |             m2 := mload(0x40)
   276 |     |             m3 := mload(0x60)
   277 |     |             m4 := mload(0x80)
   278 |     |             // Selector of `log(address,string)`.
   279 |     |             mstore(0x00, 0x759f86bb)
   280 |     |             mstore(0x20, p0)
   281 |     |             mstore(0x40, 0x40)
   282 |     |             writeString(0x60, p1)
   283 |     |         }
   284 |     |         _sendLogPayload(0x1c, 0x84);
   285 |     |         /// @solidity memory-safe-assembly
   286 |     |         assembly {
   287 |     |             mstore(0x00, m0)
   288 |     |             mstore(0x20, m1)
   289 |     |             mstore(0x40, m2)
   290 |     |             mstore(0x60, m3)
   291 |     |             mstore(0x80, m4)
   292 |     |         }
   293 |     |     }
   294 |     | 
   295 |     |     function log(bool p0, address p1) internal pure {
   296 |     |         bytes32 m0;
   297 |     |         bytes32 m1;
   298 |     |         bytes32 m2;
   299 |     |         /// @solidity memory-safe-assembly
   300 |     |         assembly {
   301 |     |             m0 := mload(0x00)
   302 |     |             m1 := mload(0x20)
   303 |     |             m2 := mload(0x40)
   304 |     |             // Selector of `log(bool,address)`.
   305 |     |             mstore(0x00, 0x853c4849)
   306 |     |             mstore(0x20, p0)
   307 |     |             mstore(0x40, p1)
   308 |     |         }
   309 |     |         _sendLogPayload(0x1c, 0x44);
   310 |     |         /// @solidity memory-safe-assembly
   311 |     |         assembly {
   312 |     |             mstore(0x00, m0)
   313 |     |             mstore(0x20, m1)
   314 |     |             mstore(0x40, m2)
   315 |     |         }
   316 |     |     }
   317 |     | 
   318 |     |     function log(bool p0, bool p1) internal pure {
   319 |     |         bytes32 m0;
   320 |     |         bytes32 m1;
   321 |     |         bytes32 m2;
   322 |     |         /// @solidity memory-safe-assembly
   323 |     |         assembly {
   324 |     |             m0 := mload(0x00)
   325 |     |             m1 := mload(0x20)
   326 |     |             m2 := mload(0x40)
   327 |     |             // Selector of `log(bool,bool)`.
   328 |     |             mstore(0x00, 0x2a110e83)
   329 |     |             mstore(0x20, p0)
   330 |     |             mstore(0x40, p1)
   331 |     |         }
   332 |     |         _sendLogPayload(0x1c, 0x44);
   333 |     |         /// @solidity memory-safe-assembly
   334 |     |         assembly {
   335 |     |             mstore(0x00, m0)
   336 |     |             mstore(0x20, m1)
   337 |     |             mstore(0x40, m2)
   338 |     |         }
   339 |     |     }
   340 |     | 
   341 |     |     function log(bool p0, uint256 p1) internal pure {
   342 |     |         bytes32 m0;
   343 |     |         bytes32 m1;
   344 |     |         bytes32 m2;
   345 |     |         /// @solidity memory-safe-assembly
   346 |     |         assembly {
   347 |     |             m0 := mload(0x00)
   348 |     |             m1 := mload(0x20)
   349 |     |             m2 := mload(0x40)
   350 |     |             // Selector of `log(bool,uint256)`.
   351 |     |             mstore(0x00, 0x399174d3)
   352 |     |             mstore(0x20, p0)
   353 |     |             mstore(0x40, p1)
   354 |     |         }
   355 |     |         _sendLogPayload(0x1c, 0x44);
   356 |     |         /// @solidity memory-safe-assembly
   357 |     |         assembly {
   358 |     |             mstore(0x00, m0)
   359 |     |             mstore(0x20, m1)
   360 |     |             mstore(0x40, m2)
   361 |     |         }
   362 |     |     }
   363 |     | 
   364 |     |     function log(bool p0, bytes32 p1) internal pure {
   365 |     |         bytes32 m0;
   366 |     |         bytes32 m1;
   367 |     |         bytes32 m2;
   368 |     |         bytes32 m3;
   369 |     |         bytes32 m4;
   370 |     |         /// @solidity memory-safe-assembly
   371 |     |         assembly {
   372 |     |             function writeString(pos, w) {
   373 |     |                 let length := 0
   374 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   375 |     |                 mstore(pos, length)
   376 |     |                 let shift := sub(256, shl(3, length))
   377 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   378 |     |             }
   379 |     |             m0 := mload(0x00)
   380 |     |             m1 := mload(0x20)
   381 |     |             m2 := mload(0x40)
   382 |     |             m3 := mload(0x60)
   383 |     |             m4 := mload(0x80)
   384 |     |             // Selector of `log(bool,string)`.
   385 |     |             mstore(0x00, 0x8feac525)
   386 |     |             mstore(0x20, p0)
   387 |     |             mstore(0x40, 0x40)
   388 |     |             writeString(0x60, p1)
   389 |     |         }
   390 |     |         _sendLogPayload(0x1c, 0x84);
   391 |     |         /// @solidity memory-safe-assembly
   392 |     |         assembly {
   393 |     |             mstore(0x00, m0)
   394 |     |             mstore(0x20, m1)
   395 |     |             mstore(0x40, m2)
   396 |     |             mstore(0x60, m3)
   397 |     |             mstore(0x80, m4)
   398 |     |         }
   399 |     |     }
   400 |     | 
   401 |     |     function log(uint256 p0, address p1) internal pure {
   402 |     |         bytes32 m0;
   403 |     |         bytes32 m1;
   404 |     |         bytes32 m2;
   405 |     |         /// @solidity memory-safe-assembly
   406 |     |         assembly {
   407 |     |             m0 := mload(0x00)
   408 |     |             m1 := mload(0x20)
   409 |     |             m2 := mload(0x40)
   410 |     |             // Selector of `log(uint256,address)`.
   411 |     |             mstore(0x00, 0x69276c86)
   412 |     |             mstore(0x20, p0)
   413 |     |             mstore(0x40, p1)
   414 |     |         }
   415 |     |         _sendLogPayload(0x1c, 0x44);
   416 |     |         /// @solidity memory-safe-assembly
   417 |     |         assembly {
   418 |     |             mstore(0x00, m0)
   419 |     |             mstore(0x20, m1)
   420 |     |             mstore(0x40, m2)
   421 |     |         }
   422 |     |     }
   423 |     | 
   424 |     |     function log(uint256 p0, bool p1) internal pure {
   425 |     |         bytes32 m0;
   426 |     |         bytes32 m1;
   427 |     |         bytes32 m2;
   428 |     |         /// @solidity memory-safe-assembly
   429 |     |         assembly {
   430 |     |             m0 := mload(0x00)
   431 |     |             m1 := mload(0x20)
   432 |     |             m2 := mload(0x40)
   433 |     |             // Selector of `log(uint256,bool)`.
   434 |     |             mstore(0x00, 0x1c9d7eb3)
   435 |     |             mstore(0x20, p0)
   436 |     |             mstore(0x40, p1)
   437 |     |         }
   438 |     |         _sendLogPayload(0x1c, 0x44);
   439 |     |         /// @solidity memory-safe-assembly
   440 |     |         assembly {
   441 |     |             mstore(0x00, m0)
   442 |     |             mstore(0x20, m1)
   443 |     |             mstore(0x40, m2)
   444 |     |         }
   445 |     |     }
   446 |     | 
   447 |     |     function log(uint256 p0, uint256 p1) internal pure {
   448 |     |         bytes32 m0;
   449 |     |         bytes32 m1;
   450 |     |         bytes32 m2;
   451 |     |         /// @solidity memory-safe-assembly
   452 |     |         assembly {
   453 |     |             m0 := mload(0x00)
   454 |     |             m1 := mload(0x20)
   455 |     |             m2 := mload(0x40)
   456 |     |             // Selector of `log(uint256,uint256)`.
   457 |     |             mstore(0x00, 0xf666715a)
   458 |     |             mstore(0x20, p0)
   459 |     |             mstore(0x40, p1)
   460 |     |         }
   461 |     |         _sendLogPayload(0x1c, 0x44);
   462 |     |         /// @solidity memory-safe-assembly
   463 |     |         assembly {
   464 |     |             mstore(0x00, m0)
   465 |     |             mstore(0x20, m1)
   466 |     |             mstore(0x40, m2)
   467 |     |         }
   468 |     |     }
   469 |     | 
   470 |     |     function log(uint256 p0, bytes32 p1) internal pure {
   471 |     |         bytes32 m0;
   472 |     |         bytes32 m1;
   473 |     |         bytes32 m2;
   474 |     |         bytes32 m3;
   475 |     |         bytes32 m4;
   476 |     |         /// @solidity memory-safe-assembly
   477 |     |         assembly {
   478 |     |             function writeString(pos, w) {
   479 |     |                 let length := 0
   480 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   481 |     |                 mstore(pos, length)
   482 |     |                 let shift := sub(256, shl(3, length))
   483 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   484 |     |             }
   485 |     |             m0 := mload(0x00)
   486 |     |             m1 := mload(0x20)
   487 |     |             m2 := mload(0x40)
   488 |     |             m3 := mload(0x60)
   489 |     |             m4 := mload(0x80)
   490 |     |             // Selector of `log(uint256,string)`.
   491 |     |             mstore(0x00, 0x643fd0df)
   492 |     |             mstore(0x20, p0)
   493 |     |             mstore(0x40, 0x40)
   494 |     |             writeString(0x60, p1)
   495 |     |         }
   496 |     |         _sendLogPayload(0x1c, 0x84);
   497 |     |         /// @solidity memory-safe-assembly
   498 |     |         assembly {
   499 |     |             mstore(0x00, m0)
   500 |     |             mstore(0x20, m1)
   501 |     |             mstore(0x40, m2)
   502 |     |             mstore(0x60, m3)
   503 |     |             mstore(0x80, m4)
   504 |     |         }
   505 |     |     }
   506 |     | 
   507 |     |     function log(bytes32 p0, address p1) internal pure {
   508 |     |         bytes32 m0;
   509 |     |         bytes32 m1;
   510 |     |         bytes32 m2;
   511 |     |         bytes32 m3;
   512 |     |         bytes32 m4;
   513 |     |         /// @solidity memory-safe-assembly
   514 |     |         assembly {
   515 |     |             function writeString(pos, w) {
   516 |     |                 let length := 0
   517 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   518 |     |                 mstore(pos, length)
   519 |     |                 let shift := sub(256, shl(3, length))
   520 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   521 |     |             }
   522 |     |             m0 := mload(0x00)
   523 |     |             m1 := mload(0x20)
   524 |     |             m2 := mload(0x40)
   525 |     |             m3 := mload(0x60)
   526 |     |             m4 := mload(0x80)
   527 |     |             // Selector of `log(string,address)`.
   528 |     |             mstore(0x00, 0x319af333)
   529 |     |             mstore(0x20, 0x40)
   530 |     |             mstore(0x40, p1)
   531 |     |             writeString(0x60, p0)
   532 |     |         }
   533 |     |         _sendLogPayload(0x1c, 0x84);
   534 |     |         /// @solidity memory-safe-assembly
   535 |     |         assembly {
   536 |     |             mstore(0x00, m0)
   537 |     |             mstore(0x20, m1)
   538 |     |             mstore(0x40, m2)
   539 |     |             mstore(0x60, m3)
   540 |     |             mstore(0x80, m4)
   541 |     |         }
   542 |     |     }
   543 |     | 
   544 |     |     function log(bytes32 p0, bool p1) internal pure {
   545 |     |         bytes32 m0;
   546 |     |         bytes32 m1;
   547 |     |         bytes32 m2;
   548 |     |         bytes32 m3;
   549 |     |         bytes32 m4;
   550 |     |         /// @solidity memory-safe-assembly
   551 |     |         assembly {
   552 |     |             function writeString(pos, w) {
   553 |     |                 let length := 0
   554 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   555 |     |                 mstore(pos, length)
   556 |     |                 let shift := sub(256, shl(3, length))
   557 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   558 |     |             }
   559 |     |             m0 := mload(0x00)
   560 |     |             m1 := mload(0x20)
   561 |     |             m2 := mload(0x40)
   562 |     |             m3 := mload(0x60)
   563 |     |             m4 := mload(0x80)
   564 |     |             // Selector of `log(string,bool)`.
   565 |     |             mstore(0x00, 0xc3b55635)
   566 |     |             mstore(0x20, 0x40)
   567 |     |             mstore(0x40, p1)
   568 |     |             writeString(0x60, p0)
   569 |     |         }
   570 |     |         _sendLogPayload(0x1c, 0x84);
   571 |     |         /// @solidity memory-safe-assembly
   572 |     |         assembly {
   573 |     |             mstore(0x00, m0)
   574 |     |             mstore(0x20, m1)
   575 |     |             mstore(0x40, m2)
   576 |     |             mstore(0x60, m3)
   577 |     |             mstore(0x80, m4)
   578 |     |         }
   579 |     |     }
   580 |     | 
   581 |     |     function log(bytes32 p0, uint256 p1) internal pure {
   582 |     |         bytes32 m0;
   583 |     |         bytes32 m1;
   584 |     |         bytes32 m2;
   585 |     |         bytes32 m3;
   586 |     |         bytes32 m4;
   587 |     |         /// @solidity memory-safe-assembly
   588 |     |         assembly {
   589 |     |             function writeString(pos, w) {
   590 |     |                 let length := 0
   591 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   592 |     |                 mstore(pos, length)
   593 |     |                 let shift := sub(256, shl(3, length))
   594 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   595 |     |             }
   596 |     |             m0 := mload(0x00)
   597 |     |             m1 := mload(0x20)
   598 |     |             m2 := mload(0x40)
   599 |     |             m3 := mload(0x60)
   600 |     |             m4 := mload(0x80)
   601 |     |             // Selector of `log(string,uint256)`.
   602 |     |             mstore(0x00, 0xb60e72cc)
   603 |     |             mstore(0x20, 0x40)
   604 |     |             mstore(0x40, p1)
   605 |     |             writeString(0x60, p0)
   606 |     |         }
   607 |     |         _sendLogPayload(0x1c, 0x84);
   608 |     |         /// @solidity memory-safe-assembly
   609 |     |         assembly {
   610 |     |             mstore(0x00, m0)
   611 |     |             mstore(0x20, m1)
   612 |     |             mstore(0x40, m2)
   613 |     |             mstore(0x60, m3)
   614 |     |             mstore(0x80, m4)
   615 |     |         }
   616 |     |     }
   617 |     | 
   618 |     |     function log(bytes32 p0, bytes32 p1) internal pure {
   619 |     |         bytes32 m0;
   620 |     |         bytes32 m1;
   621 |     |         bytes32 m2;
   622 |     |         bytes32 m3;
   623 |     |         bytes32 m4;
   624 |     |         bytes32 m5;
   625 |     |         bytes32 m6;
   626 |     |         /// @solidity memory-safe-assembly
   627 |     |         assembly {
   628 |     |             function writeString(pos, w) {
   629 |     |                 let length := 0
   630 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   631 |     |                 mstore(pos, length)
   632 |     |                 let shift := sub(256, shl(3, length))
   633 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   634 |     |             }
   635 |     |             m0 := mload(0x00)
   636 |     |             m1 := mload(0x20)
   637 |     |             m2 := mload(0x40)
   638 |     |             m3 := mload(0x60)
   639 |     |             m4 := mload(0x80)
   640 |     |             m5 := mload(0xa0)
   641 |     |             m6 := mload(0xc0)
   642 |     |             // Selector of `log(string,string)`.
   643 |     |             mstore(0x00, 0x4b5c4277)
   644 |     |             mstore(0x20, 0x40)
   645 |     |             mstore(0x40, 0x80)
   646 |     |             writeString(0x60, p0)
   647 |     |             writeString(0xa0, p1)
   648 |     |         }
   649 |     |         _sendLogPayload(0x1c, 0xc4);
   650 |     |         /// @solidity memory-safe-assembly
   651 |     |         assembly {
   652 |     |             mstore(0x00, m0)
   653 |     |             mstore(0x20, m1)
   654 |     |             mstore(0x40, m2)
   655 |     |             mstore(0x60, m3)
   656 |     |             mstore(0x80, m4)
   657 |     |             mstore(0xa0, m5)
   658 |     |             mstore(0xc0, m6)
   659 |     |         }
   660 |     |     }
   661 |     | 
   662 |     |     function log(address p0, address p1, address p2) internal pure {
   663 |     |         bytes32 m0;
   664 |     |         bytes32 m1;
   665 |     |         bytes32 m2;
   666 |     |         bytes32 m3;
   667 |     |         /// @solidity memory-safe-assembly
   668 |     |         assembly {
   669 |     |             m0 := mload(0x00)
   670 |     |             m1 := mload(0x20)
   671 |     |             m2 := mload(0x40)
   672 |     |             m3 := mload(0x60)
   673 |     |             // Selector of `log(address,address,address)`.
   674 |     |             mstore(0x00, 0x018c84c2)
   675 |     |             mstore(0x20, p0)
   676 |     |             mstore(0x40, p1)
   677 |     |             mstore(0x60, p2)
   678 |     |         }
   679 |     |         _sendLogPayload(0x1c, 0x64);
   680 |     |         /// @solidity memory-safe-assembly
   681 |     |         assembly {
   682 |     |             mstore(0x00, m0)
   683 |     |             mstore(0x20, m1)
   684 |     |             mstore(0x40, m2)
   685 |     |             mstore(0x60, m3)
   686 |     |         }
   687 |     |     }
   688 |     | 
   689 |     |     function log(address p0, address p1, bool p2) internal pure {
   690 |     |         bytes32 m0;
   691 |     |         bytes32 m1;
   692 |     |         bytes32 m2;
   693 |     |         bytes32 m3;
   694 |     |         /// @solidity memory-safe-assembly
   695 |     |         assembly {
   696 |     |             m0 := mload(0x00)
   697 |     |             m1 := mload(0x20)
   698 |     |             m2 := mload(0x40)
   699 |     |             m3 := mload(0x60)
   700 |     |             // Selector of `log(address,address,bool)`.
   701 |     |             mstore(0x00, 0xf2a66286)
   702 |     |             mstore(0x20, p0)
   703 |     |             mstore(0x40, p1)
   704 |     |             mstore(0x60, p2)
   705 |     |         }
   706 |     |         _sendLogPayload(0x1c, 0x64);
   707 |     |         /// @solidity memory-safe-assembly
   708 |     |         assembly {
   709 |     |             mstore(0x00, m0)
   710 |     |             mstore(0x20, m1)
   711 |     |             mstore(0x40, m2)
   712 |     |             mstore(0x60, m3)
   713 |     |         }
   714 |     |     }
   715 |     | 
   716 |     |     function log(address p0, address p1, uint256 p2) internal pure {
   717 |     |         bytes32 m0;
   718 |     |         bytes32 m1;
   719 |     |         bytes32 m2;
   720 |     |         bytes32 m3;
   721 |     |         /// @solidity memory-safe-assembly
   722 |     |         assembly {
   723 |     |             m0 := mload(0x00)
   724 |     |             m1 := mload(0x20)
   725 |     |             m2 := mload(0x40)
   726 |     |             m3 := mload(0x60)
   727 |     |             // Selector of `log(address,address,uint256)`.
   728 |     |             mstore(0x00, 0x17fe6185)
   729 |     |             mstore(0x20, p0)
   730 |     |             mstore(0x40, p1)
   731 |     |             mstore(0x60, p2)
   732 |     |         }
   733 |     |         _sendLogPayload(0x1c, 0x64);
   734 |     |         /// @solidity memory-safe-assembly
   735 |     |         assembly {
   736 |     |             mstore(0x00, m0)
   737 |     |             mstore(0x20, m1)
   738 |     |             mstore(0x40, m2)
   739 |     |             mstore(0x60, m3)
   740 |     |         }
   741 |     |     }
   742 |     | 
   743 |     |     function log(address p0, address p1, bytes32 p2) internal pure {
   744 |     |         bytes32 m0;
   745 |     |         bytes32 m1;
   746 |     |         bytes32 m2;
   747 |     |         bytes32 m3;
   748 |     |         bytes32 m4;
   749 |     |         bytes32 m5;
   750 |     |         /// @solidity memory-safe-assembly
   751 |     |         assembly {
   752 |     |             function writeString(pos, w) {
   753 |     |                 let length := 0
   754 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   755 |     |                 mstore(pos, length)
   756 |     |                 let shift := sub(256, shl(3, length))
   757 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   758 |     |             }
   759 |     |             m0 := mload(0x00)
   760 |     |             m1 := mload(0x20)
   761 |     |             m2 := mload(0x40)
   762 |     |             m3 := mload(0x60)
   763 |     |             m4 := mload(0x80)
   764 |     |             m5 := mload(0xa0)
   765 |     |             // Selector of `log(address,address,string)`.
   766 |     |             mstore(0x00, 0x007150be)
   767 |     |             mstore(0x20, p0)
   768 |     |             mstore(0x40, p1)
   769 |     |             mstore(0x60, 0x60)
   770 |     |             writeString(0x80, p2)
   771 |     |         }
   772 |     |         _sendLogPayload(0x1c, 0xa4);
   773 |     |         /// @solidity memory-safe-assembly
   774 |     |         assembly {
   775 |     |             mstore(0x00, m0)
   776 |     |             mstore(0x20, m1)
   777 |     |             mstore(0x40, m2)
   778 |     |             mstore(0x60, m3)
   779 |     |             mstore(0x80, m4)
   780 |     |             mstore(0xa0, m5)
   781 |     |         }
   782 |     |     }
   783 |     | 
   784 |     |     function log(address p0, bool p1, address p2) internal pure {
   785 |     |         bytes32 m0;
   786 |     |         bytes32 m1;
   787 |     |         bytes32 m2;
   788 |     |         bytes32 m3;
   789 |     |         /// @solidity memory-safe-assembly
   790 |     |         assembly {
   791 |     |             m0 := mload(0x00)
   792 |     |             m1 := mload(0x20)
   793 |     |             m2 := mload(0x40)
   794 |     |             m3 := mload(0x60)
   795 |     |             // Selector of `log(address,bool,address)`.
   796 |     |             mstore(0x00, 0xf11699ed)
   797 |     |             mstore(0x20, p0)
   798 |     |             mstore(0x40, p1)
   799 |     |             mstore(0x60, p2)
   800 |     |         }
   801 |     |         _sendLogPayload(0x1c, 0x64);
   802 |     |         /// @solidity memory-safe-assembly
   803 |     |         assembly {
   804 |     |             mstore(0x00, m0)
   805 |     |             mstore(0x20, m1)
   806 |     |             mstore(0x40, m2)
   807 |     |             mstore(0x60, m3)
   808 |     |         }
   809 |     |     }
   810 |     | 
   811 |     |     function log(address p0, bool p1, bool p2) internal pure {
   812 |     |         bytes32 m0;
   813 |     |         bytes32 m1;
   814 |     |         bytes32 m2;
   815 |     |         bytes32 m3;
   816 |     |         /// @solidity memory-safe-assembly
   817 |     |         assembly {
   818 |     |             m0 := mload(0x00)
   819 |     |             m1 := mload(0x20)
   820 |     |             m2 := mload(0x40)
   821 |     |             m3 := mload(0x60)
   822 |     |             // Selector of `log(address,bool,bool)`.
   823 |     |             mstore(0x00, 0xeb830c92)
   824 |     |             mstore(0x20, p0)
   825 |     |             mstore(0x40, p1)
   826 |     |             mstore(0x60, p2)
   827 |     |         }
   828 |     |         _sendLogPayload(0x1c, 0x64);
   829 |     |         /// @solidity memory-safe-assembly
   830 |     |         assembly {
   831 |     |             mstore(0x00, m0)
   832 |     |             mstore(0x20, m1)
   833 |     |             mstore(0x40, m2)
   834 |     |             mstore(0x60, m3)
   835 |     |         }
   836 |     |     }
   837 |     | 
   838 |     |     function log(address p0, bool p1, uint256 p2) internal pure {
   839 |     |         bytes32 m0;
   840 |     |         bytes32 m1;
   841 |     |         bytes32 m2;
   842 |     |         bytes32 m3;
   843 |     |         /// @solidity memory-safe-assembly
   844 |     |         assembly {
   845 |     |             m0 := mload(0x00)
   846 |     |             m1 := mload(0x20)
   847 |     |             m2 := mload(0x40)
   848 |     |             m3 := mload(0x60)
   849 |     |             // Selector of `log(address,bool,uint256)`.
   850 |     |             mstore(0x00, 0x9c4f99fb)
   851 |     |             mstore(0x20, p0)
   852 |     |             mstore(0x40, p1)
   853 |     |             mstore(0x60, p2)
   854 |     |         }
   855 |     |         _sendLogPayload(0x1c, 0x64);
   856 |     |         /// @solidity memory-safe-assembly
   857 |     |         assembly {
   858 |     |             mstore(0x00, m0)
   859 |     |             mstore(0x20, m1)
   860 |     |             mstore(0x40, m2)
   861 |     |             mstore(0x60, m3)
   862 |     |         }
   863 |     |     }
   864 |     | 
   865 |     |     function log(address p0, bool p1, bytes32 p2) internal pure {
   866 |     |         bytes32 m0;
   867 |     |         bytes32 m1;
   868 |     |         bytes32 m2;
   869 |     |         bytes32 m3;
   870 |     |         bytes32 m4;
   871 |     |         bytes32 m5;
   872 |     |         /// @solidity memory-safe-assembly
   873 |     |         assembly {
   874 |     |             function writeString(pos, w) {
   875 |     |                 let length := 0
   876 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   877 |     |                 mstore(pos, length)
   878 |     |                 let shift := sub(256, shl(3, length))
   879 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   880 |     |             }
   881 |     |             m0 := mload(0x00)
   882 |     |             m1 := mload(0x20)
   883 |     |             m2 := mload(0x40)
   884 |     |             m3 := mload(0x60)
   885 |     |             m4 := mload(0x80)
   886 |     |             m5 := mload(0xa0)
   887 |     |             // Selector of `log(address,bool,string)`.
   888 |     |             mstore(0x00, 0x212255cc)
   889 |     |             mstore(0x20, p0)
   890 |     |             mstore(0x40, p1)
   891 |     |             mstore(0x60, 0x60)
   892 |     |             writeString(0x80, p2)
   893 |     |         }
   894 |     |         _sendLogPayload(0x1c, 0xa4);
   895 |     |         /// @solidity memory-safe-assembly
   896 |     |         assembly {
   897 |     |             mstore(0x00, m0)
   898 |     |             mstore(0x20, m1)
   899 |     |             mstore(0x40, m2)
   900 |     |             mstore(0x60, m3)
   901 |     |             mstore(0x80, m4)
   902 |     |             mstore(0xa0, m5)
   903 |     |         }
   904 |     |     }
   905 |     | 
   906 |     |     function log(address p0, uint256 p1, address p2) internal pure {
   907 |     |         bytes32 m0;
   908 |     |         bytes32 m1;
   909 |     |         bytes32 m2;
   910 |     |         bytes32 m3;
   911 |     |         /// @solidity memory-safe-assembly
   912 |     |         assembly {
   913 |     |             m0 := mload(0x00)
   914 |     |             m1 := mload(0x20)
   915 |     |             m2 := mload(0x40)
   916 |     |             m3 := mload(0x60)
   917 |     |             // Selector of `log(address,uint256,address)`.
   918 |     |             mstore(0x00, 0x7bc0d848)
   919 |     |             mstore(0x20, p0)
   920 |     |             mstore(0x40, p1)
   921 |     |             mstore(0x60, p2)
   922 |     |         }
   923 |     |         _sendLogPayload(0x1c, 0x64);
   924 |     |         /// @solidity memory-safe-assembly
   925 |     |         assembly {
   926 |     |             mstore(0x00, m0)
   927 |     |             mstore(0x20, m1)
   928 |     |             mstore(0x40, m2)
   929 |     |             mstore(0x60, m3)
   930 |     |         }
   931 |     |     }
   932 |     | 
   933 |     |     function log(address p0, uint256 p1, bool p2) internal pure {
   934 |     |         bytes32 m0;
   935 |     |         bytes32 m1;
   936 |     |         bytes32 m2;
   937 |     |         bytes32 m3;
   938 |     |         /// @solidity memory-safe-assembly
   939 |     |         assembly {
   940 |     |             m0 := mload(0x00)
   941 |     |             m1 := mload(0x20)
   942 |     |             m2 := mload(0x40)
   943 |     |             m3 := mload(0x60)
   944 |     |             // Selector of `log(address,uint256,bool)`.
   945 |     |             mstore(0x00, 0x678209a8)
   946 |     |             mstore(0x20, p0)
   947 |     |             mstore(0x40, p1)
   948 |     |             mstore(0x60, p2)
   949 |     |         }
   950 |     |         _sendLogPayload(0x1c, 0x64);
   951 |     |         /// @solidity memory-safe-assembly
   952 |     |         assembly {
   953 |     |             mstore(0x00, m0)
   954 |     |             mstore(0x20, m1)
   955 |     |             mstore(0x40, m2)
   956 |     |             mstore(0x60, m3)
   957 |     |         }
   958 |     |     }
   959 |     | 
   960 |     |     function log(address p0, uint256 p1, uint256 p2) internal pure {
   961 |     |         bytes32 m0;
   962 |     |         bytes32 m1;
   963 |     |         bytes32 m2;
   964 |     |         bytes32 m3;
   965 |     |         /// @solidity memory-safe-assembly
   966 |     |         assembly {
   967 |     |             m0 := mload(0x00)
   968 |     |             m1 := mload(0x20)
   969 |     |             m2 := mload(0x40)
   970 |     |             m3 := mload(0x60)
   971 |     |             // Selector of `log(address,uint256,uint256)`.
   972 |     |             mstore(0x00, 0xb69bcaf6)
   973 |     |             mstore(0x20, p0)
   974 |     |             mstore(0x40, p1)
   975 |     |             mstore(0x60, p2)
   976 |     |         }
   977 |     |         _sendLogPayload(0x1c, 0x64);
   978 |     |         /// @solidity memory-safe-assembly
   979 |     |         assembly {
   980 |     |             mstore(0x00, m0)
   981 |     |             mstore(0x20, m1)
   982 |     |             mstore(0x40, m2)
   983 |     |             mstore(0x60, m3)
   984 |     |         }
   985 |     |     }
   986 |     | 
   987 |     |     function log(address p0, uint256 p1, bytes32 p2) internal pure {
   988 |     |         bytes32 m0;
   989 |     |         bytes32 m1;
   990 |     |         bytes32 m2;
   991 |     |         bytes32 m3;
   992 |     |         bytes32 m4;
   993 |     |         bytes32 m5;
   994 |     |         /// @solidity memory-safe-assembly
   995 |     |         assembly {
   996 |     |             function writeString(pos, w) {
   997 |     |                 let length := 0
   998 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   999 |     |                 mstore(pos, length)
  1000 |     |                 let shift := sub(256, shl(3, length))
  1001 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1002 |     |             }
  1003 |     |             m0 := mload(0x00)
  1004 |     |             m1 := mload(0x20)
  1005 |     |             m2 := mload(0x40)
  1006 |     |             m3 := mload(0x60)
  1007 |     |             m4 := mload(0x80)
  1008 |     |             m5 := mload(0xa0)
  1009 |     |             // Selector of `log(address,uint256,string)`.
  1010 |     |             mstore(0x00, 0xa1f2e8aa)
  1011 |     |             mstore(0x20, p0)
  1012 |     |             mstore(0x40, p1)
  1013 |     |             mstore(0x60, 0x60)
  1014 |     |             writeString(0x80, p2)
  1015 |     |         }
  1016 |     |         _sendLogPayload(0x1c, 0xa4);
  1017 |     |         /// @solidity memory-safe-assembly
  1018 |     |         assembly {
  1019 |     |             mstore(0x00, m0)
  1020 |     |             mstore(0x20, m1)
  1021 |     |             mstore(0x40, m2)
  1022 |     |             mstore(0x60, m3)
  1023 |     |             mstore(0x80, m4)
  1024 |     |             mstore(0xa0, m5)
  1025 |     |         }
  1026 |     |     }
  1027 |     | 
  1028 |     |     function log(address p0, bytes32 p1, address p2) internal pure {
  1029 |     |         bytes32 m0;
  1030 |     |         bytes32 m1;
  1031 |     |         bytes32 m2;
  1032 |     |         bytes32 m3;
  1033 |     |         bytes32 m4;
  1034 |     |         bytes32 m5;
  1035 |     |         /// @solidity memory-safe-assembly
  1036 |     |         assembly {
  1037 |     |             function writeString(pos, w) {
  1038 |     |                 let length := 0
  1039 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1040 |     |                 mstore(pos, length)
  1041 |     |                 let shift := sub(256, shl(3, length))
  1042 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1043 |     |             }
  1044 |     |             m0 := mload(0x00)
  1045 |     |             m1 := mload(0x20)
  1046 |     |             m2 := mload(0x40)
  1047 |     |             m3 := mload(0x60)
  1048 |     |             m4 := mload(0x80)
  1049 |     |             m5 := mload(0xa0)
  1050 |     |             // Selector of `log(address,string,address)`.
  1051 |     |             mstore(0x00, 0xf08744e8)
  1052 |     |             mstore(0x20, p0)
  1053 |     |             mstore(0x40, 0x60)
  1054 |     |             mstore(0x60, p2)
  1055 |     |             writeString(0x80, p1)
  1056 |     |         }
  1057 |     |         _sendLogPayload(0x1c, 0xa4);
  1058 |     |         /// @solidity memory-safe-assembly
  1059 |     |         assembly {
  1060 |     |             mstore(0x00, m0)
  1061 |     |             mstore(0x20, m1)
  1062 |     |             mstore(0x40, m2)
  1063 |     |             mstore(0x60, m3)
  1064 |     |             mstore(0x80, m4)
  1065 |     |             mstore(0xa0, m5)
  1066 |     |         }
  1067 |     |     }
  1068 |     | 
  1069 |     |     function log(address p0, bytes32 p1, bool p2) internal pure {
  1070 |     |         bytes32 m0;
  1071 |     |         bytes32 m1;
  1072 |     |         bytes32 m2;
  1073 |     |         bytes32 m3;
  1074 |     |         bytes32 m4;
  1075 |     |         bytes32 m5;
  1076 |     |         /// @solidity memory-safe-assembly
  1077 |     |         assembly {
  1078 |     |             function writeString(pos, w) {
  1079 |     |                 let length := 0
  1080 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1081 |     |                 mstore(pos, length)
  1082 |     |                 let shift := sub(256, shl(3, length))
  1083 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1084 |     |             }
  1085 |     |             m0 := mload(0x00)
  1086 |     |             m1 := mload(0x20)
  1087 |     |             m2 := mload(0x40)
  1088 |     |             m3 := mload(0x60)
  1089 |     |             m4 := mload(0x80)
  1090 |     |             m5 := mload(0xa0)
  1091 |     |             // Selector of `log(address,string,bool)`.
  1092 |     |             mstore(0x00, 0xcf020fb1)
  1093 |     |             mstore(0x20, p0)
  1094 |     |             mstore(0x40, 0x60)
  1095 |     |             mstore(0x60, p2)
  1096 |     |             writeString(0x80, p1)
  1097 |     |         }
  1098 |     |         _sendLogPayload(0x1c, 0xa4);
  1099 |     |         /// @solidity memory-safe-assembly
  1100 |     |         assembly {
  1101 |     |             mstore(0x00, m0)
  1102 |     |             mstore(0x20, m1)
  1103 |     |             mstore(0x40, m2)
  1104 |     |             mstore(0x60, m3)
  1105 |     |             mstore(0x80, m4)
  1106 |     |             mstore(0xa0, m5)
  1107 |     |         }
  1108 |     |     }
  1109 |     | 
  1110 |     |     function log(address p0, bytes32 p1, uint256 p2) internal pure {
  1111 |     |         bytes32 m0;
  1112 |     |         bytes32 m1;
  1113 |     |         bytes32 m2;
  1114 |     |         bytes32 m3;
  1115 |     |         bytes32 m4;
  1116 |     |         bytes32 m5;
  1117 |     |         /// @solidity memory-safe-assembly
  1118 |     |         assembly {
  1119 |     |             function writeString(pos, w) {
  1120 |     |                 let length := 0
  1121 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1122 |     |                 mstore(pos, length)
  1123 |     |                 let shift := sub(256, shl(3, length))
  1124 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1125 |     |             }
  1126 |     |             m0 := mload(0x00)
  1127 |     |             m1 := mload(0x20)
  1128 |     |             m2 := mload(0x40)
  1129 |     |             m3 := mload(0x60)
  1130 |     |             m4 := mload(0x80)
  1131 |     |             m5 := mload(0xa0)
  1132 |     |             // Selector of `log(address,string,uint256)`.
  1133 |     |             mstore(0x00, 0x67dd6ff1)
  1134 |     |             mstore(0x20, p0)
  1135 |     |             mstore(0x40, 0x60)
  1136 |     |             mstore(0x60, p2)
  1137 |     |             writeString(0x80, p1)
  1138 |     |         }
  1139 |     |         _sendLogPayload(0x1c, 0xa4);
  1140 |     |         /// @solidity memory-safe-assembly
  1141 |     |         assembly {
  1142 |     |             mstore(0x00, m0)
  1143 |     |             mstore(0x20, m1)
  1144 |     |             mstore(0x40, m2)
  1145 |     |             mstore(0x60, m3)
  1146 |     |             mstore(0x80, m4)
  1147 |     |             mstore(0xa0, m5)
  1148 |     |         }
  1149 |     |     }
  1150 |     | 
  1151 |     |     function log(address p0, bytes32 p1, bytes32 p2) internal pure {
  1152 |     |         bytes32 m0;
  1153 |     |         bytes32 m1;
  1154 |     |         bytes32 m2;
  1155 |     |         bytes32 m3;
  1156 |     |         bytes32 m4;
  1157 |     |         bytes32 m5;
  1158 |     |         bytes32 m6;
  1159 |     |         bytes32 m7;
  1160 |     |         /// @solidity memory-safe-assembly
  1161 |     |         assembly {
  1162 |     |             function writeString(pos, w) {
  1163 |     |                 let length := 0
  1164 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1165 |     |                 mstore(pos, length)
  1166 |     |                 let shift := sub(256, shl(3, length))
  1167 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1168 |     |             }
  1169 |     |             m0 := mload(0x00)
  1170 |     |             m1 := mload(0x20)
  1171 |     |             m2 := mload(0x40)
  1172 |     |             m3 := mload(0x60)
  1173 |     |             m4 := mload(0x80)
  1174 |     |             m5 := mload(0xa0)
  1175 |     |             m6 := mload(0xc0)
  1176 |     |             m7 := mload(0xe0)
  1177 |     |             // Selector of `log(address,string,string)`.
  1178 |     |             mstore(0x00, 0xfb772265)
  1179 |     |             mstore(0x20, p0)
  1180 |     |             mstore(0x40, 0x60)
  1181 |     |             mstore(0x60, 0xa0)
  1182 |     |             writeString(0x80, p1)
  1183 |     |             writeString(0xc0, p2)
  1184 |     |         }
  1185 |     |         _sendLogPayload(0x1c, 0xe4);
  1186 |     |         /// @solidity memory-safe-assembly
  1187 |     |         assembly {
  1188 |     |             mstore(0x00, m0)
  1189 |     |             mstore(0x20, m1)
  1190 |     |             mstore(0x40, m2)
  1191 |     |             mstore(0x60, m3)
  1192 |     |             mstore(0x80, m4)
  1193 |     |             mstore(0xa0, m5)
  1194 |     |             mstore(0xc0, m6)
  1195 |     |             mstore(0xe0, m7)
  1196 |     |         }
  1197 |     |     }
  1198 |     | 
  1199 |     |     function log(bool p0, address p1, address p2) internal pure {
  1200 |     |         bytes32 m0;
  1201 |     |         bytes32 m1;
  1202 |     |         bytes32 m2;
  1203 |     |         bytes32 m3;
  1204 |     |         /// @solidity memory-safe-assembly
  1205 |     |         assembly {
  1206 |     |             m0 := mload(0x00)
  1207 |     |             m1 := mload(0x20)
  1208 |     |             m2 := mload(0x40)
  1209 |     |             m3 := mload(0x60)
  1210 |     |             // Selector of `log(bool,address,address)`.
  1211 |     |             mstore(0x00, 0xd2763667)
  1212 |     |             mstore(0x20, p0)
  1213 |     |             mstore(0x40, p1)
  1214 |     |             mstore(0x60, p2)
  1215 |     |         }
  1216 |     |         _sendLogPayload(0x1c, 0x64);
  1217 |     |         /// @solidity memory-safe-assembly
  1218 |     |         assembly {
  1219 |     |             mstore(0x00, m0)
  1220 |     |             mstore(0x20, m1)
  1221 |     |             mstore(0x40, m2)
  1222 |     |             mstore(0x60, m3)
  1223 |     |         }
  1224 |     |     }
  1225 |     | 
  1226 |     |     function log(bool p0, address p1, bool p2) internal pure {
  1227 |     |         bytes32 m0;
  1228 |     |         bytes32 m1;
  1229 |     |         bytes32 m2;
  1230 |     |         bytes32 m3;
  1231 |     |         /// @solidity memory-safe-assembly
  1232 |     |         assembly {
  1233 |     |             m0 := mload(0x00)
  1234 |     |             m1 := mload(0x20)
  1235 |     |             m2 := mload(0x40)
  1236 |     |             m3 := mload(0x60)
  1237 |     |             // Selector of `log(bool,address,bool)`.
  1238 |     |             mstore(0x00, 0x18c9c746)
  1239 |     |             mstore(0x20, p0)
  1240 |     |             mstore(0x40, p1)
  1241 |     |             mstore(0x60, p2)
  1242 |     |         }
  1243 |     |         _sendLogPayload(0x1c, 0x64);
  1244 |     |         /// @solidity memory-safe-assembly
  1245 |     |         assembly {
  1246 |     |             mstore(0x00, m0)
  1247 |     |             mstore(0x20, m1)
  1248 |     |             mstore(0x40, m2)
  1249 |     |             mstore(0x60, m3)
  1250 |     |         }
  1251 |     |     }
  1252 |     | 
  1253 |     |     function log(bool p0, address p1, uint256 p2) internal pure {
  1254 |     |         bytes32 m0;
  1255 |     |         bytes32 m1;
  1256 |     |         bytes32 m2;
  1257 |     |         bytes32 m3;
  1258 |     |         /// @solidity memory-safe-assembly
  1259 |     |         assembly {
  1260 |     |             m0 := mload(0x00)
  1261 |     |             m1 := mload(0x20)
  1262 |     |             m2 := mload(0x40)
  1263 |     |             m3 := mload(0x60)
  1264 |     |             // Selector of `log(bool,address,uint256)`.
  1265 |     |             mstore(0x00, 0x5f7b9afb)
  1266 |     |             mstore(0x20, p0)
  1267 |     |             mstore(0x40, p1)
  1268 |     |             mstore(0x60, p2)
  1269 |     |         }
  1270 |     |         _sendLogPayload(0x1c, 0x64);
  1271 |     |         /// @solidity memory-safe-assembly
  1272 |     |         assembly {
  1273 |     |             mstore(0x00, m0)
  1274 |     |             mstore(0x20, m1)
  1275 |     |             mstore(0x40, m2)
  1276 |     |             mstore(0x60, m3)
  1277 |     |         }
  1278 |     |     }
  1279 |     | 
  1280 |     |     function log(bool p0, address p1, bytes32 p2) internal pure {
  1281 |     |         bytes32 m0;
  1282 |     |         bytes32 m1;
  1283 |     |         bytes32 m2;
  1284 |     |         bytes32 m3;
  1285 |     |         bytes32 m4;
  1286 |     |         bytes32 m5;
  1287 |     |         /// @solidity memory-safe-assembly
  1288 |     |         assembly {
  1289 |     |             function writeString(pos, w) {
  1290 |     |                 let length := 0
  1291 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1292 |     |                 mstore(pos, length)
  1293 |     |                 let shift := sub(256, shl(3, length))
  1294 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1295 |     |             }
  1296 |     |             m0 := mload(0x00)
  1297 |     |             m1 := mload(0x20)
  1298 |     |             m2 := mload(0x40)
  1299 |     |             m3 := mload(0x60)
  1300 |     |             m4 := mload(0x80)
  1301 |     |             m5 := mload(0xa0)
  1302 |     |             // Selector of `log(bool,address,string)`.
  1303 |     |             mstore(0x00, 0xde9a9270)
  1304 |     |             mstore(0x20, p0)
  1305 |     |             mstore(0x40, p1)
  1306 |     |             mstore(0x60, 0x60)
  1307 |     |             writeString(0x80, p2)
  1308 |     |         }
  1309 |     |         _sendLogPayload(0x1c, 0xa4);
  1310 |     |         /// @solidity memory-safe-assembly
  1311 |     |         assembly {
  1312 |     |             mstore(0x00, m0)
  1313 |     |             mstore(0x20, m1)
  1314 |     |             mstore(0x40, m2)
  1315 |     |             mstore(0x60, m3)
  1316 |     |             mstore(0x80, m4)
  1317 |     |             mstore(0xa0, m5)
  1318 |     |         }
  1319 |     |     }
  1320 |     | 
  1321 |     |     function log(bool p0, bool p1, address p2) internal pure {
  1322 |     |         bytes32 m0;
  1323 |     |         bytes32 m1;
  1324 |     |         bytes32 m2;
  1325 |     |         bytes32 m3;
  1326 |     |         /// @solidity memory-safe-assembly
  1327 |     |         assembly {
  1328 |     |             m0 := mload(0x00)
  1329 |     |             m1 := mload(0x20)
  1330 |     |             m2 := mload(0x40)
  1331 |     |             m3 := mload(0x60)
  1332 |     |             // Selector of `log(bool,bool,address)`.
  1333 |     |             mstore(0x00, 0x1078f68d)
  1334 |     |             mstore(0x20, p0)
  1335 |     |             mstore(0x40, p1)
  1336 |     |             mstore(0x60, p2)
  1337 |     |         }
  1338 |     |         _sendLogPayload(0x1c, 0x64);
  1339 |     |         /// @solidity memory-safe-assembly
  1340 |     |         assembly {
  1341 |     |             mstore(0x00, m0)
  1342 |     |             mstore(0x20, m1)
  1343 |     |             mstore(0x40, m2)
  1344 |     |             mstore(0x60, m3)
  1345 |     |         }
  1346 |     |     }
  1347 |     | 
  1348 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  1349 |     |         bytes32 m0;
  1350 |     |         bytes32 m1;
  1351 |     |         bytes32 m2;
  1352 |     |         bytes32 m3;
  1353 |     |         /// @solidity memory-safe-assembly
  1354 |     |         assembly {
  1355 |     |             m0 := mload(0x00)
  1356 |     |             m1 := mload(0x20)
  1357 |     |             m2 := mload(0x40)
  1358 |     |             m3 := mload(0x60)
  1359 |     |             // Selector of `log(bool,bool,bool)`.
  1360 |     |             mstore(0x00, 0x50709698)
  1361 |     |             mstore(0x20, p0)
  1362 |     |             mstore(0x40, p1)
  1363 |     |             mstore(0x60, p2)
  1364 |     |         }
  1365 |     |         _sendLogPayload(0x1c, 0x64);
  1366 |     |         /// @solidity memory-safe-assembly
  1367 |     |         assembly {
  1368 |     |             mstore(0x00, m0)
  1369 |     |             mstore(0x20, m1)
  1370 |     |             mstore(0x40, m2)
  1371 |     |             mstore(0x60, m3)
  1372 |     |         }
  1373 |     |     }
  1374 |     | 
  1375 |     |     function log(bool p0, bool p1, uint256 p2) internal pure {
  1376 |     |         bytes32 m0;
  1377 |     |         bytes32 m1;
  1378 |     |         bytes32 m2;
  1379 |     |         bytes32 m3;
  1380 |     |         /// @solidity memory-safe-assembly
  1381 |     |         assembly {
  1382 |     |             m0 := mload(0x00)
  1383 |     |             m1 := mload(0x20)
  1384 |     |             m2 := mload(0x40)
  1385 |     |             m3 := mload(0x60)
  1386 |     |             // Selector of `log(bool,bool,uint256)`.
  1387 |     |             mstore(0x00, 0x12f21602)
  1388 |     |             mstore(0x20, p0)
  1389 |     |             mstore(0x40, p1)
  1390 |     |             mstore(0x60, p2)
  1391 |     |         }
  1392 |     |         _sendLogPayload(0x1c, 0x64);
  1393 |     |         /// @solidity memory-safe-assembly
  1394 |     |         assembly {
  1395 |     |             mstore(0x00, m0)
  1396 |     |             mstore(0x20, m1)
  1397 |     |             mstore(0x40, m2)
  1398 |     |             mstore(0x60, m3)
  1399 |     |         }
  1400 |     |     }
  1401 |     | 
  1402 |     |     function log(bool p0, bool p1, bytes32 p2) internal pure {
  1403 |     |         bytes32 m0;
  1404 |     |         bytes32 m1;
  1405 |     |         bytes32 m2;
  1406 |     |         bytes32 m3;
  1407 |     |         bytes32 m4;
  1408 |     |         bytes32 m5;
  1409 |     |         /// @solidity memory-safe-assembly
  1410 |     |         assembly {
  1411 |     |             function writeString(pos, w) {
  1412 |     |                 let length := 0
  1413 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1414 |     |                 mstore(pos, length)
  1415 |     |                 let shift := sub(256, shl(3, length))
  1416 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1417 |     |             }
  1418 |     |             m0 := mload(0x00)
  1419 |     |             m1 := mload(0x20)
  1420 |     |             m2 := mload(0x40)
  1421 |     |             m3 := mload(0x60)
  1422 |     |             m4 := mload(0x80)
  1423 |     |             m5 := mload(0xa0)
  1424 |     |             // Selector of `log(bool,bool,string)`.
  1425 |     |             mstore(0x00, 0x2555fa46)
  1426 |     |             mstore(0x20, p0)
  1427 |     |             mstore(0x40, p1)
  1428 |     |             mstore(0x60, 0x60)
  1429 |     |             writeString(0x80, p2)
  1430 |     |         }
  1431 |     |         _sendLogPayload(0x1c, 0xa4);
  1432 |     |         /// @solidity memory-safe-assembly
  1433 |     |         assembly {
  1434 |     |             mstore(0x00, m0)
  1435 |     |             mstore(0x20, m1)
  1436 |     |             mstore(0x40, m2)
  1437 |     |             mstore(0x60, m3)
  1438 |     |             mstore(0x80, m4)
  1439 |     |             mstore(0xa0, m5)
  1440 |     |         }
  1441 |     |     }
  1442 |     | 
  1443 |     |     function log(bool p0, uint256 p1, address p2) internal pure {
  1444 |     |         bytes32 m0;
  1445 |     |         bytes32 m1;
  1446 |     |         bytes32 m2;
  1447 |     |         bytes32 m3;
  1448 |     |         /// @solidity memory-safe-assembly
  1449 |     |         assembly {
  1450 |     |             m0 := mload(0x00)
  1451 |     |             m1 := mload(0x20)
  1452 |     |             m2 := mload(0x40)
  1453 |     |             m3 := mload(0x60)
  1454 |     |             // Selector of `log(bool,uint256,address)`.
  1455 |     |             mstore(0x00, 0x088ef9d2)
  1456 |     |             mstore(0x20, p0)
  1457 |     |             mstore(0x40, p1)
  1458 |     |             mstore(0x60, p2)
  1459 |     |         }
  1460 |     |         _sendLogPayload(0x1c, 0x64);
  1461 |     |         /// @solidity memory-safe-assembly
  1462 |     |         assembly {
  1463 |     |             mstore(0x00, m0)
  1464 |     |             mstore(0x20, m1)
  1465 |     |             mstore(0x40, m2)
  1466 |     |             mstore(0x60, m3)
  1467 |     |         }
  1468 |     |     }
  1469 |     | 
  1470 |     |     function log(bool p0, uint256 p1, bool p2) internal pure {
  1471 |     |         bytes32 m0;
  1472 |     |         bytes32 m1;
  1473 |     |         bytes32 m2;
  1474 |     |         bytes32 m3;
  1475 |     |         /// @solidity memory-safe-assembly
  1476 |     |         assembly {
  1477 |     |             m0 := mload(0x00)
  1478 |     |             m1 := mload(0x20)
  1479 |     |             m2 := mload(0x40)
  1480 |     |             m3 := mload(0x60)
  1481 |     |             // Selector of `log(bool,uint256,bool)`.
  1482 |     |             mstore(0x00, 0xe8defba9)
  1483 |     |             mstore(0x20, p0)
  1484 |     |             mstore(0x40, p1)
  1485 |     |             mstore(0x60, p2)
  1486 |     |         }
  1487 |     |         _sendLogPayload(0x1c, 0x64);
  1488 |     |         /// @solidity memory-safe-assembly
  1489 |     |         assembly {
  1490 |     |             mstore(0x00, m0)
  1491 |     |             mstore(0x20, m1)
  1492 |     |             mstore(0x40, m2)
  1493 |     |             mstore(0x60, m3)
  1494 |     |         }
  1495 |     |     }
  1496 |     | 
  1497 |     |     function log(bool p0, uint256 p1, uint256 p2) internal pure {
  1498 |     |         bytes32 m0;
  1499 |     |         bytes32 m1;
  1500 |     |         bytes32 m2;
  1501 |     |         bytes32 m3;
  1502 |     |         /// @solidity memory-safe-assembly
  1503 |     |         assembly {
  1504 |     |             m0 := mload(0x00)
  1505 |     |             m1 := mload(0x20)
  1506 |     |             m2 := mload(0x40)
  1507 |     |             m3 := mload(0x60)
  1508 |     |             // Selector of `log(bool,uint256,uint256)`.
  1509 |     |             mstore(0x00, 0x37103367)
  1510 |     |             mstore(0x20, p0)
  1511 |     |             mstore(0x40, p1)
  1512 |     |             mstore(0x60, p2)
  1513 |     |         }
  1514 |     |         _sendLogPayload(0x1c, 0x64);
  1515 |     |         /// @solidity memory-safe-assembly
  1516 |     |         assembly {
  1517 |     |             mstore(0x00, m0)
  1518 |     |             mstore(0x20, m1)
  1519 |     |             mstore(0x40, m2)
  1520 |     |             mstore(0x60, m3)
  1521 |     |         }
  1522 |     |     }
  1523 |     | 
  1524 |     |     function log(bool p0, uint256 p1, bytes32 p2) internal pure {
  1525 |     |         bytes32 m0;
  1526 |     |         bytes32 m1;
  1527 |     |         bytes32 m2;
  1528 |     |         bytes32 m3;
  1529 |     |         bytes32 m4;
  1530 |     |         bytes32 m5;
  1531 |     |         /// @solidity memory-safe-assembly
  1532 |     |         assembly {
  1533 |     |             function writeString(pos, w) {
  1534 |     |                 let length := 0
  1535 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1536 |     |                 mstore(pos, length)
  1537 |     |                 let shift := sub(256, shl(3, length))
  1538 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1539 |     |             }
  1540 |     |             m0 := mload(0x00)
  1541 |     |             m1 := mload(0x20)
  1542 |     |             m2 := mload(0x40)
  1543 |     |             m3 := mload(0x60)
  1544 |     |             m4 := mload(0x80)
  1545 |     |             m5 := mload(0xa0)
  1546 |     |             // Selector of `log(bool,uint256,string)`.
  1547 |     |             mstore(0x00, 0xc3fc3970)
  1548 |     |             mstore(0x20, p0)
  1549 |     |             mstore(0x40, p1)
  1550 |     |             mstore(0x60, 0x60)
  1551 |     |             writeString(0x80, p2)
  1552 |     |         }
  1553 |     |         _sendLogPayload(0x1c, 0xa4);
  1554 |     |         /// @solidity memory-safe-assembly
  1555 |     |         assembly {
  1556 |     |             mstore(0x00, m0)
  1557 |     |             mstore(0x20, m1)
  1558 |     |             mstore(0x40, m2)
  1559 |     |             mstore(0x60, m3)
  1560 |     |             mstore(0x80, m4)
  1561 |     |             mstore(0xa0, m5)
  1562 |     |         }
  1563 |     |     }
  1564 |     | 
  1565 |     |     function log(bool p0, bytes32 p1, address p2) internal pure {
  1566 |     |         bytes32 m0;
  1567 |     |         bytes32 m1;
  1568 |     |         bytes32 m2;
  1569 |     |         bytes32 m3;
  1570 |     |         bytes32 m4;
  1571 |     |         bytes32 m5;
  1572 |     |         /// @solidity memory-safe-assembly
  1573 |     |         assembly {
  1574 |     |             function writeString(pos, w) {
  1575 |     |                 let length := 0
  1576 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1577 |     |                 mstore(pos, length)
  1578 |     |                 let shift := sub(256, shl(3, length))
  1579 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1580 |     |             }
  1581 |     |             m0 := mload(0x00)
  1582 |     |             m1 := mload(0x20)
  1583 |     |             m2 := mload(0x40)
  1584 |     |             m3 := mload(0x60)
  1585 |     |             m4 := mload(0x80)
  1586 |     |             m5 := mload(0xa0)
  1587 |     |             // Selector of `log(bool,string,address)`.
  1588 |     |             mstore(0x00, 0x9591b953)
  1589 |     |             mstore(0x20, p0)
  1590 |     |             mstore(0x40, 0x60)
  1591 |     |             mstore(0x60, p2)
  1592 |     |             writeString(0x80, p1)
  1593 |     |         }
  1594 |     |         _sendLogPayload(0x1c, 0xa4);
  1595 |     |         /// @solidity memory-safe-assembly
  1596 |     |         assembly {
  1597 |     |             mstore(0x00, m0)
  1598 |     |             mstore(0x20, m1)
  1599 |     |             mstore(0x40, m2)
  1600 |     |             mstore(0x60, m3)
  1601 |     |             mstore(0x80, m4)
  1602 |     |             mstore(0xa0, m5)
  1603 |     |         }
  1604 |     |     }
  1605 |     | 
  1606 |     |     function log(bool p0, bytes32 p1, bool p2) internal pure {
  1607 |     |         bytes32 m0;
  1608 |     |         bytes32 m1;
  1609 |     |         bytes32 m2;
  1610 |     |         bytes32 m3;
  1611 |     |         bytes32 m4;
  1612 |     |         bytes32 m5;
  1613 |     |         /// @solidity memory-safe-assembly
  1614 |     |         assembly {
  1615 |     |             function writeString(pos, w) {
  1616 |     |                 let length := 0
  1617 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1618 |     |                 mstore(pos, length)
  1619 |     |                 let shift := sub(256, shl(3, length))
  1620 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1621 |     |             }
  1622 |     |             m0 := mload(0x00)
  1623 |     |             m1 := mload(0x20)
  1624 |     |             m2 := mload(0x40)
  1625 |     |             m3 := mload(0x60)
  1626 |     |             m4 := mload(0x80)
  1627 |     |             m5 := mload(0xa0)
  1628 |     |             // Selector of `log(bool,string,bool)`.
  1629 |     |             mstore(0x00, 0xdbb4c247)
  1630 |     |             mstore(0x20, p0)
  1631 |     |             mstore(0x40, 0x60)
  1632 |     |             mstore(0x60, p2)
  1633 |     |             writeString(0x80, p1)
  1634 |     |         }
  1635 |     |         _sendLogPayload(0x1c, 0xa4);
  1636 |     |         /// @solidity memory-safe-assembly
  1637 |     |         assembly {
  1638 |     |             mstore(0x00, m0)
  1639 |     |             mstore(0x20, m1)
  1640 |     |             mstore(0x40, m2)
  1641 |     |             mstore(0x60, m3)
  1642 |     |             mstore(0x80, m4)
  1643 |     |             mstore(0xa0, m5)
  1644 |     |         }
  1645 |     |     }
  1646 |     | 
  1647 |     |     function log(bool p0, bytes32 p1, uint256 p2) internal pure {
  1648 |     |         bytes32 m0;
  1649 |     |         bytes32 m1;
  1650 |     |         bytes32 m2;
  1651 |     |         bytes32 m3;
  1652 |     |         bytes32 m4;
  1653 |     |         bytes32 m5;
  1654 |     |         /// @solidity memory-safe-assembly
  1655 |     |         assembly {
  1656 |     |             function writeString(pos, w) {
  1657 |     |                 let length := 0
  1658 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1659 |     |                 mstore(pos, length)
  1660 |     |                 let shift := sub(256, shl(3, length))
  1661 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1662 |     |             }
  1663 |     |             m0 := mload(0x00)
  1664 |     |             m1 := mload(0x20)
  1665 |     |             m2 := mload(0x40)
  1666 |     |             m3 := mload(0x60)
  1667 |     |             m4 := mload(0x80)
  1668 |     |             m5 := mload(0xa0)
  1669 |     |             // Selector of `log(bool,string,uint256)`.
  1670 |     |             mstore(0x00, 0x1093ee11)
  1671 |     |             mstore(0x20, p0)
  1672 |     |             mstore(0x40, 0x60)
  1673 |     |             mstore(0x60, p2)
  1674 |     |             writeString(0x80, p1)
  1675 |     |         }
  1676 |     |         _sendLogPayload(0x1c, 0xa4);
  1677 |     |         /// @solidity memory-safe-assembly
  1678 |     |         assembly {
  1679 |     |             mstore(0x00, m0)
  1680 |     |             mstore(0x20, m1)
  1681 |     |             mstore(0x40, m2)
  1682 |     |             mstore(0x60, m3)
  1683 |     |             mstore(0x80, m4)
  1684 |     |             mstore(0xa0, m5)
  1685 |     |         }
  1686 |     |     }
  1687 |     | 
  1688 |     |     function log(bool p0, bytes32 p1, bytes32 p2) internal pure {
  1689 |     |         bytes32 m0;
  1690 |     |         bytes32 m1;
  1691 |     |         bytes32 m2;
  1692 |     |         bytes32 m3;
  1693 |     |         bytes32 m4;
  1694 |     |         bytes32 m5;
  1695 |     |         bytes32 m6;
  1696 |     |         bytes32 m7;
  1697 |     |         /// @solidity memory-safe-assembly
  1698 |     |         assembly {
  1699 |     |             function writeString(pos, w) {
  1700 |     |                 let length := 0
  1701 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1702 |     |                 mstore(pos, length)
  1703 |     |                 let shift := sub(256, shl(3, length))
  1704 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1705 |     |             }
  1706 |     |             m0 := mload(0x00)
  1707 |     |             m1 := mload(0x20)
  1708 |     |             m2 := mload(0x40)
  1709 |     |             m3 := mload(0x60)
  1710 |     |             m4 := mload(0x80)
  1711 |     |             m5 := mload(0xa0)
  1712 |     |             m6 := mload(0xc0)
  1713 |     |             m7 := mload(0xe0)
  1714 |     |             // Selector of `log(bool,string,string)`.
  1715 |     |             mstore(0x00, 0xb076847f)
  1716 |     |             mstore(0x20, p0)
  1717 |     |             mstore(0x40, 0x60)
  1718 |     |             mstore(0x60, 0xa0)
  1719 |     |             writeString(0x80, p1)
  1720 |     |             writeString(0xc0, p2)
  1721 |     |         }
  1722 |     |         _sendLogPayload(0x1c, 0xe4);
  1723 |     |         /// @solidity memory-safe-assembly
  1724 |     |         assembly {
  1725 |     |             mstore(0x00, m0)
  1726 |     |             mstore(0x20, m1)
  1727 |     |             mstore(0x40, m2)
  1728 |     |             mstore(0x60, m3)
  1729 |     |             mstore(0x80, m4)
  1730 |     |             mstore(0xa0, m5)
  1731 |     |             mstore(0xc0, m6)
  1732 |     |             mstore(0xe0, m7)
  1733 |     |         }
  1734 |     |     }
  1735 |     | 
  1736 |     |     function log(uint256 p0, address p1, address p2) internal pure {
  1737 |     |         bytes32 m0;
  1738 |     |         bytes32 m1;
  1739 |     |         bytes32 m2;
  1740 |     |         bytes32 m3;
  1741 |     |         /// @solidity memory-safe-assembly
  1742 |     |         assembly {
  1743 |     |             m0 := mload(0x00)
  1744 |     |             m1 := mload(0x20)
  1745 |     |             m2 := mload(0x40)
  1746 |     |             m3 := mload(0x60)
  1747 |     |             // Selector of `log(uint256,address,address)`.
  1748 |     |             mstore(0x00, 0xbcfd9be0)
  1749 |     |             mstore(0x20, p0)
  1750 |     |             mstore(0x40, p1)
  1751 |     |             mstore(0x60, p2)
  1752 |     |         }
  1753 |     |         _sendLogPayload(0x1c, 0x64);
  1754 |     |         /// @solidity memory-safe-assembly
  1755 |     |         assembly {
  1756 |     |             mstore(0x00, m0)
  1757 |     |             mstore(0x20, m1)
  1758 |     |             mstore(0x40, m2)
  1759 |     |             mstore(0x60, m3)
  1760 |     |         }
  1761 |     |     }
  1762 |     | 
  1763 |     |     function log(uint256 p0, address p1, bool p2) internal pure {
  1764 |     |         bytes32 m0;
  1765 |     |         bytes32 m1;
  1766 |     |         bytes32 m2;
  1767 |     |         bytes32 m3;
  1768 |     |         /// @solidity memory-safe-assembly
  1769 |     |         assembly {
  1770 |     |             m0 := mload(0x00)
  1771 |     |             m1 := mload(0x20)
  1772 |     |             m2 := mload(0x40)
  1773 |     |             m3 := mload(0x60)
  1774 |     |             // Selector of `log(uint256,address,bool)`.
  1775 |     |             mstore(0x00, 0x9b6ec042)
  1776 |     |             mstore(0x20, p0)
  1777 |     |             mstore(0x40, p1)
  1778 |     |             mstore(0x60, p2)
  1779 |     |         }
  1780 |     |         _sendLogPayload(0x1c, 0x64);
  1781 |     |         /// @solidity memory-safe-assembly
  1782 |     |         assembly {
  1783 |     |             mstore(0x00, m0)
  1784 |     |             mstore(0x20, m1)
  1785 |     |             mstore(0x40, m2)
  1786 |     |             mstore(0x60, m3)
  1787 |     |         }
  1788 |     |     }
  1789 |     | 
  1790 |     |     function log(uint256 p0, address p1, uint256 p2) internal pure {
  1791 |     |         bytes32 m0;
  1792 |     |         bytes32 m1;
  1793 |     |         bytes32 m2;
  1794 |     |         bytes32 m3;
  1795 |     |         /// @solidity memory-safe-assembly
  1796 |     |         assembly {
  1797 |     |             m0 := mload(0x00)
  1798 |     |             m1 := mload(0x20)
  1799 |     |             m2 := mload(0x40)
  1800 |     |             m3 := mload(0x60)
  1801 |     |             // Selector of `log(uint256,address,uint256)`.
  1802 |     |             mstore(0x00, 0x5a9b5ed5)
  1803 |     |             mstore(0x20, p0)
  1804 |     |             mstore(0x40, p1)
  1805 |     |             mstore(0x60, p2)
  1806 |     |         }
  1807 |     |         _sendLogPayload(0x1c, 0x64);
  1808 |     |         /// @solidity memory-safe-assembly
  1809 |     |         assembly {
  1810 |     |             mstore(0x00, m0)
  1811 |     |             mstore(0x20, m1)
  1812 |     |             mstore(0x40, m2)
  1813 |     |             mstore(0x60, m3)
  1814 |     |         }
  1815 |     |     }
  1816 |     | 
  1817 |     |     function log(uint256 p0, address p1, bytes32 p2) internal pure {
  1818 |     |         bytes32 m0;
  1819 |     |         bytes32 m1;
  1820 |     |         bytes32 m2;
  1821 |     |         bytes32 m3;
  1822 |     |         bytes32 m4;
  1823 |     |         bytes32 m5;
  1824 |     |         /// @solidity memory-safe-assembly
  1825 |     |         assembly {
  1826 |     |             function writeString(pos, w) {
  1827 |     |                 let length := 0
  1828 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1829 |     |                 mstore(pos, length)
  1830 |     |                 let shift := sub(256, shl(3, length))
  1831 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1832 |     |             }
  1833 |     |             m0 := mload(0x00)
  1834 |     |             m1 := mload(0x20)
  1835 |     |             m2 := mload(0x40)
  1836 |     |             m3 := mload(0x60)
  1837 |     |             m4 := mload(0x80)
  1838 |     |             m5 := mload(0xa0)
  1839 |     |             // Selector of `log(uint256,address,string)`.
  1840 |     |             mstore(0x00, 0x63cb41f9)
  1841 |     |             mstore(0x20, p0)
  1842 |     |             mstore(0x40, p1)
  1843 |     |             mstore(0x60, 0x60)
  1844 |     |             writeString(0x80, p2)
  1845 |     |         }
  1846 |     |         _sendLogPayload(0x1c, 0xa4);
  1847 |     |         /// @solidity memory-safe-assembly
  1848 |     |         assembly {
  1849 |     |             mstore(0x00, m0)
  1850 |     |             mstore(0x20, m1)
  1851 |     |             mstore(0x40, m2)
  1852 |     |             mstore(0x60, m3)
  1853 |     |             mstore(0x80, m4)
  1854 |     |             mstore(0xa0, m5)
  1855 |     |         }
  1856 |     |     }
  1857 |     | 
  1858 |     |     function log(uint256 p0, bool p1, address p2) internal pure {
  1859 |     |         bytes32 m0;
  1860 |     |         bytes32 m1;
  1861 |     |         bytes32 m2;
  1862 |     |         bytes32 m3;
  1863 |     |         /// @solidity memory-safe-assembly
  1864 |     |         assembly {
  1865 |     |             m0 := mload(0x00)
  1866 |     |             m1 := mload(0x20)
  1867 |     |             m2 := mload(0x40)
  1868 |     |             m3 := mload(0x60)
  1869 |     |             // Selector of `log(uint256,bool,address)`.
  1870 |     |             mstore(0x00, 0x35085f7b)
  1871 |     |             mstore(0x20, p0)
  1872 |     |             mstore(0x40, p1)
  1873 |     |             mstore(0x60, p2)
  1874 |     |         }
  1875 |     |         _sendLogPayload(0x1c, 0x64);
  1876 |     |         /// @solidity memory-safe-assembly
  1877 |     |         assembly {
  1878 |     |             mstore(0x00, m0)
  1879 |     |             mstore(0x20, m1)
  1880 |     |             mstore(0x40, m2)
  1881 |     |             mstore(0x60, m3)
  1882 |     |         }
  1883 |     |     }
  1884 |     | 
  1885 |     |     function log(uint256 p0, bool p1, bool p2) internal pure {
  1886 |     |         bytes32 m0;
  1887 |     |         bytes32 m1;
  1888 |     |         bytes32 m2;
  1889 |     |         bytes32 m3;
  1890 |     |         /// @solidity memory-safe-assembly
  1891 |     |         assembly {
  1892 |     |             m0 := mload(0x00)
  1893 |     |             m1 := mload(0x20)
  1894 |     |             m2 := mload(0x40)
  1895 |     |             m3 := mload(0x60)
  1896 |     |             // Selector of `log(uint256,bool,bool)`.
  1897 |     |             mstore(0x00, 0x20718650)
  1898 |     |             mstore(0x20, p0)
  1899 |     |             mstore(0x40, p1)
  1900 |     |             mstore(0x60, p2)
  1901 |     |         }
  1902 |     |         _sendLogPayload(0x1c, 0x64);
  1903 |     |         /// @solidity memory-safe-assembly
  1904 |     |         assembly {
  1905 |     |             mstore(0x00, m0)
  1906 |     |             mstore(0x20, m1)
  1907 |     |             mstore(0x40, m2)
  1908 |     |             mstore(0x60, m3)
  1909 |     |         }
  1910 |     |     }
  1911 |     | 
  1912 |     |     function log(uint256 p0, bool p1, uint256 p2) internal pure {
  1913 |     |         bytes32 m0;
  1914 |     |         bytes32 m1;
  1915 |     |         bytes32 m2;
  1916 |     |         bytes32 m3;
  1917 |     |         /// @solidity memory-safe-assembly
  1918 |     |         assembly {
  1919 |     |             m0 := mload(0x00)
  1920 |     |             m1 := mload(0x20)
  1921 |     |             m2 := mload(0x40)
  1922 |     |             m3 := mload(0x60)
  1923 |     |             // Selector of `log(uint256,bool,uint256)`.
  1924 |     |             mstore(0x00, 0x20098014)
  1925 |     |             mstore(0x20, p0)
  1926 |     |             mstore(0x40, p1)
  1927 |     |             mstore(0x60, p2)
  1928 |     |         }
  1929 |     |         _sendLogPayload(0x1c, 0x64);
  1930 |     |         /// @solidity memory-safe-assembly
  1931 |     |         assembly {
  1932 |     |             mstore(0x00, m0)
  1933 |     |             mstore(0x20, m1)
  1934 |     |             mstore(0x40, m2)
  1935 |     |             mstore(0x60, m3)
  1936 |     |         }
  1937 |     |     }
  1938 |     | 
  1939 |     |     function log(uint256 p0, bool p1, bytes32 p2) internal pure {
  1940 |     |         bytes32 m0;
  1941 |     |         bytes32 m1;
  1942 |     |         bytes32 m2;
  1943 |     |         bytes32 m3;
  1944 |     |         bytes32 m4;
  1945 |     |         bytes32 m5;
  1946 |     |         /// @solidity memory-safe-assembly
  1947 |     |         assembly {
  1948 |     |             function writeString(pos, w) {
  1949 |     |                 let length := 0
  1950 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1951 |     |                 mstore(pos, length)
  1952 |     |                 let shift := sub(256, shl(3, length))
  1953 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1954 |     |             }
  1955 |     |             m0 := mload(0x00)
  1956 |     |             m1 := mload(0x20)
  1957 |     |             m2 := mload(0x40)
  1958 |     |             m3 := mload(0x60)
  1959 |     |             m4 := mload(0x80)
  1960 |     |             m5 := mload(0xa0)
  1961 |     |             // Selector of `log(uint256,bool,string)`.
  1962 |     |             mstore(0x00, 0x85775021)
  1963 |     |             mstore(0x20, p0)
  1964 |     |             mstore(0x40, p1)
  1965 |     |             mstore(0x60, 0x60)
  1966 |     |             writeString(0x80, p2)
  1967 |     |         }
  1968 |     |         _sendLogPayload(0x1c, 0xa4);
  1969 |     |         /// @solidity memory-safe-assembly
  1970 |     |         assembly {
  1971 |     |             mstore(0x00, m0)
  1972 |     |             mstore(0x20, m1)
  1973 |     |             mstore(0x40, m2)
  1974 |     |             mstore(0x60, m3)
  1975 |     |             mstore(0x80, m4)
  1976 |     |             mstore(0xa0, m5)
  1977 |     |         }
  1978 |     |     }
  1979 |     | 
  1980 |     |     function log(uint256 p0, uint256 p1, address p2) internal pure {
  1981 |     |         bytes32 m0;
  1982 |     |         bytes32 m1;
  1983 |     |         bytes32 m2;
  1984 |     |         bytes32 m3;
  1985 |     |         /// @solidity memory-safe-assembly
  1986 |     |         assembly {
  1987 |     |             m0 := mload(0x00)
  1988 |     |             m1 := mload(0x20)
  1989 |     |             m2 := mload(0x40)
  1990 |     |             m3 := mload(0x60)
  1991 |     |             // Selector of `log(uint256,uint256,address)`.
  1992 |     |             mstore(0x00, 0x5c96b331)
  1993 |     |             mstore(0x20, p0)
  1994 |     |             mstore(0x40, p1)
  1995 |     |             mstore(0x60, p2)
  1996 |     |         }
  1997 |     |         _sendLogPayload(0x1c, 0x64);
  1998 |     |         /// @solidity memory-safe-assembly
  1999 |     |         assembly {
  2000 |     |             mstore(0x00, m0)
  2001 |     |             mstore(0x20, m1)
  2002 |     |             mstore(0x40, m2)
  2003 |     |             mstore(0x60, m3)
  2004 |     |         }
  2005 |     |     }
  2006 |     | 
  2007 |     |     function log(uint256 p0, uint256 p1, bool p2) internal pure {
  2008 |     |         bytes32 m0;
  2009 |     |         bytes32 m1;
  2010 |     |         bytes32 m2;
  2011 |     |         bytes32 m3;
  2012 |     |         /// @solidity memory-safe-assembly
  2013 |     |         assembly {
  2014 |     |             m0 := mload(0x00)
  2015 |     |             m1 := mload(0x20)
  2016 |     |             m2 := mload(0x40)
  2017 |     |             m3 := mload(0x60)
  2018 |     |             // Selector of `log(uint256,uint256,bool)`.
  2019 |     |             mstore(0x00, 0x4766da72)
  2020 |     |             mstore(0x20, p0)
  2021 |     |             mstore(0x40, p1)
  2022 |     |             mstore(0x60, p2)
  2023 |     |         }
  2024 |     |         _sendLogPayload(0x1c, 0x64);
  2025 |     |         /// @solidity memory-safe-assembly
  2026 |     |         assembly {
  2027 |     |             mstore(0x00, m0)
  2028 |     |             mstore(0x20, m1)
  2029 |     |             mstore(0x40, m2)
  2030 |     |             mstore(0x60, m3)
  2031 |     |         }
  2032 |     |     }
  2033 |     | 
  2034 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal pure {
  2035 |     |         bytes32 m0;
  2036 |     |         bytes32 m1;
  2037 |     |         bytes32 m2;
  2038 |     |         bytes32 m3;
  2039 |     |         /// @solidity memory-safe-assembly
  2040 |     |         assembly {
  2041 |     |             m0 := mload(0x00)
  2042 |     |             m1 := mload(0x20)
  2043 |     |             m2 := mload(0x40)
  2044 |     |             m3 := mload(0x60)
  2045 |     |             // Selector of `log(uint256,uint256,uint256)`.
  2046 |     |             mstore(0x00, 0xd1ed7a3c)
  2047 |     |             mstore(0x20, p0)
  2048 |     |             mstore(0x40, p1)
  2049 |     |             mstore(0x60, p2)
  2050 |     |         }
  2051 |     |         _sendLogPayload(0x1c, 0x64);
  2052 |     |         /// @solidity memory-safe-assembly
  2053 |     |         assembly {
  2054 |     |             mstore(0x00, m0)
  2055 |     |             mstore(0x20, m1)
  2056 |     |             mstore(0x40, m2)
  2057 |     |             mstore(0x60, m3)
  2058 |     |         }
  2059 |     |     }
  2060 |     | 
  2061 |     |     function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {
  2062 |     |         bytes32 m0;
  2063 |     |         bytes32 m1;
  2064 |     |         bytes32 m2;
  2065 |     |         bytes32 m3;
  2066 |     |         bytes32 m4;
  2067 |     |         bytes32 m5;
  2068 |     |         /// @solidity memory-safe-assembly
  2069 |     |         assembly {
  2070 |     |             function writeString(pos, w) {
  2071 |     |                 let length := 0
  2072 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2073 |     |                 mstore(pos, length)
  2074 |     |                 let shift := sub(256, shl(3, length))
  2075 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2076 |     |             }
  2077 |     |             m0 := mload(0x00)
  2078 |     |             m1 := mload(0x20)
  2079 |     |             m2 := mload(0x40)
  2080 |     |             m3 := mload(0x60)
  2081 |     |             m4 := mload(0x80)
  2082 |     |             m5 := mload(0xa0)
  2083 |     |             // Selector of `log(uint256,uint256,string)`.
  2084 |     |             mstore(0x00, 0x71d04af2)
  2085 |     |             mstore(0x20, p0)
  2086 |     |             mstore(0x40, p1)
  2087 |     |             mstore(0x60, 0x60)
  2088 |     |             writeString(0x80, p2)
  2089 |     |         }
  2090 |     |         _sendLogPayload(0x1c, 0xa4);
  2091 |     |         /// @solidity memory-safe-assembly
  2092 |     |         assembly {
  2093 |     |             mstore(0x00, m0)
  2094 |     |             mstore(0x20, m1)
  2095 |     |             mstore(0x40, m2)
  2096 |     |             mstore(0x60, m3)
  2097 |     |             mstore(0x80, m4)
  2098 |     |             mstore(0xa0, m5)
  2099 |     |         }
  2100 |     |     }
  2101 |     | 
  2102 |     |     function log(uint256 p0, bytes32 p1, address p2) internal pure {
  2103 |     |         bytes32 m0;
  2104 |     |         bytes32 m1;
  2105 |     |         bytes32 m2;
  2106 |     |         bytes32 m3;
  2107 |     |         bytes32 m4;
  2108 |     |         bytes32 m5;
  2109 |     |         /// @solidity memory-safe-assembly
  2110 |     |         assembly {
  2111 |     |             function writeString(pos, w) {
  2112 |     |                 let length := 0
  2113 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2114 |     |                 mstore(pos, length)
  2115 |     |                 let shift := sub(256, shl(3, length))
  2116 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2117 |     |             }
  2118 |     |             m0 := mload(0x00)
  2119 |     |             m1 := mload(0x20)
  2120 |     |             m2 := mload(0x40)
  2121 |     |             m3 := mload(0x60)
  2122 |     |             m4 := mload(0x80)
  2123 |     |             m5 := mload(0xa0)
  2124 |     |             // Selector of `log(uint256,string,address)`.
  2125 |     |             mstore(0x00, 0x7afac959)
  2126 |     |             mstore(0x20, p0)
  2127 |     |             mstore(0x40, 0x60)
  2128 |     |             mstore(0x60, p2)
  2129 |     |             writeString(0x80, p1)
  2130 |     |         }
  2131 |     |         _sendLogPayload(0x1c, 0xa4);
  2132 |     |         /// @solidity memory-safe-assembly
  2133 |     |         assembly {
  2134 |     |             mstore(0x00, m0)
  2135 |     |             mstore(0x20, m1)
  2136 |     |             mstore(0x40, m2)
  2137 |     |             mstore(0x60, m3)
  2138 |     |             mstore(0x80, m4)
  2139 |     |             mstore(0xa0, m5)
  2140 |     |         }
  2141 |     |     }
  2142 |     | 
  2143 |     |     function log(uint256 p0, bytes32 p1, bool p2) internal pure {
  2144 |     |         bytes32 m0;
  2145 |     |         bytes32 m1;
  2146 |     |         bytes32 m2;
  2147 |     |         bytes32 m3;
  2148 |     |         bytes32 m4;
  2149 |     |         bytes32 m5;
  2150 |     |         /// @solidity memory-safe-assembly
  2151 |     |         assembly {
  2152 |     |             function writeString(pos, w) {
  2153 |     |                 let length := 0
  2154 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2155 |     |                 mstore(pos, length)
  2156 |     |                 let shift := sub(256, shl(3, length))
  2157 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2158 |     |             }
  2159 |     |             m0 := mload(0x00)
  2160 |     |             m1 := mload(0x20)
  2161 |     |             m2 := mload(0x40)
  2162 |     |             m3 := mload(0x60)
  2163 |     |             m4 := mload(0x80)
  2164 |     |             m5 := mload(0xa0)
  2165 |     |             // Selector of `log(uint256,string,bool)`.
  2166 |     |             mstore(0x00, 0x4ceda75a)
  2167 |     |             mstore(0x20, p0)
  2168 |     |             mstore(0x40, 0x60)
  2169 |     |             mstore(0x60, p2)
  2170 |     |             writeString(0x80, p1)
  2171 |     |         }
  2172 |     |         _sendLogPayload(0x1c, 0xa4);
  2173 |     |         /// @solidity memory-safe-assembly
  2174 |     |         assembly {
  2175 |     |             mstore(0x00, m0)
  2176 |     |             mstore(0x20, m1)
  2177 |     |             mstore(0x40, m2)
  2178 |     |             mstore(0x60, m3)
  2179 |     |             mstore(0x80, m4)
  2180 |     |             mstore(0xa0, m5)
  2181 |     |         }
  2182 |     |     }
  2183 |     | 
  2184 |     |     function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {
  2185 |     |         bytes32 m0;
  2186 |     |         bytes32 m1;
  2187 |     |         bytes32 m2;
  2188 |     |         bytes32 m3;
  2189 |     |         bytes32 m4;
  2190 |     |         bytes32 m5;
  2191 |     |         /// @solidity memory-safe-assembly
  2192 |     |         assembly {
  2193 |     |             function writeString(pos, w) {
  2194 |     |                 let length := 0
  2195 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2196 |     |                 mstore(pos, length)
  2197 |     |                 let shift := sub(256, shl(3, length))
  2198 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2199 |     |             }
  2200 |     |             m0 := mload(0x00)
  2201 |     |             m1 := mload(0x20)
  2202 |     |             m2 := mload(0x40)
  2203 |     |             m3 := mload(0x60)
  2204 |     |             m4 := mload(0x80)
  2205 |     |             m5 := mload(0xa0)
  2206 |     |             // Selector of `log(uint256,string,uint256)`.
  2207 |     |             mstore(0x00, 0x37aa7d4c)
  2208 |     |             mstore(0x20, p0)
  2209 |     |             mstore(0x40, 0x60)
  2210 |     |             mstore(0x60, p2)
  2211 |     |             writeString(0x80, p1)
  2212 |     |         }
  2213 |     |         _sendLogPayload(0x1c, 0xa4);
  2214 |     |         /// @solidity memory-safe-assembly
  2215 |     |         assembly {
  2216 |     |             mstore(0x00, m0)
  2217 |     |             mstore(0x20, m1)
  2218 |     |             mstore(0x40, m2)
  2219 |     |             mstore(0x60, m3)
  2220 |     |             mstore(0x80, m4)
  2221 |     |             mstore(0xa0, m5)
  2222 |     |         }
  2223 |     |     }
  2224 |     | 
  2225 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {
  2226 |     |         bytes32 m0;
  2227 |     |         bytes32 m1;
  2228 |     |         bytes32 m2;
  2229 |     |         bytes32 m3;
  2230 |     |         bytes32 m4;
  2231 |     |         bytes32 m5;
  2232 |     |         bytes32 m6;
  2233 |     |         bytes32 m7;
  2234 |     |         /// @solidity memory-safe-assembly
  2235 |     |         assembly {
  2236 |     |             function writeString(pos, w) {
  2237 |     |                 let length := 0
  2238 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2239 |     |                 mstore(pos, length)
  2240 |     |                 let shift := sub(256, shl(3, length))
  2241 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2242 |     |             }
  2243 |     |             m0 := mload(0x00)
  2244 |     |             m1 := mload(0x20)
  2245 |     |             m2 := mload(0x40)
  2246 |     |             m3 := mload(0x60)
  2247 |     |             m4 := mload(0x80)
  2248 |     |             m5 := mload(0xa0)
  2249 |     |             m6 := mload(0xc0)
  2250 |     |             m7 := mload(0xe0)
  2251 |     |             // Selector of `log(uint256,string,string)`.
  2252 |     |             mstore(0x00, 0xb115611f)
  2253 |     |             mstore(0x20, p0)
  2254 |     |             mstore(0x40, 0x60)
  2255 |     |             mstore(0x60, 0xa0)
  2256 |     |             writeString(0x80, p1)
  2257 |     |             writeString(0xc0, p2)
  2258 |     |         }
  2259 |     |         _sendLogPayload(0x1c, 0xe4);
  2260 |     |         /// @solidity memory-safe-assembly
  2261 |     |         assembly {
  2262 |     |             mstore(0x00, m0)
  2263 |     |             mstore(0x20, m1)
  2264 |     |             mstore(0x40, m2)
  2265 |     |             mstore(0x60, m3)
  2266 |     |             mstore(0x80, m4)
  2267 |     |             mstore(0xa0, m5)
  2268 |     |             mstore(0xc0, m6)
  2269 |     |             mstore(0xe0, m7)
  2270 |     |         }
  2271 |     |     }
  2272 |     | 
  2273 |     |     function log(bytes32 p0, address p1, address p2) internal pure {
  2274 |     |         bytes32 m0;
  2275 |     |         bytes32 m1;
  2276 |     |         bytes32 m2;
  2277 |     |         bytes32 m3;
  2278 |     |         bytes32 m4;
  2279 |     |         bytes32 m5;
  2280 |     |         /// @solidity memory-safe-assembly
  2281 |     |         assembly {
  2282 |     |             function writeString(pos, w) {
  2283 |     |                 let length := 0
  2284 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2285 |     |                 mstore(pos, length)
  2286 |     |                 let shift := sub(256, shl(3, length))
  2287 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2288 |     |             }
  2289 |     |             m0 := mload(0x00)
  2290 |     |             m1 := mload(0x20)
  2291 |     |             m2 := mload(0x40)
  2292 |     |             m3 := mload(0x60)
  2293 |     |             m4 := mload(0x80)
  2294 |     |             m5 := mload(0xa0)
  2295 |     |             // Selector of `log(string,address,address)`.
  2296 |     |             mstore(0x00, 0xfcec75e0)
  2297 |     |             mstore(0x20, 0x60)
  2298 |     |             mstore(0x40, p1)
  2299 |     |             mstore(0x60, p2)
  2300 |     |             writeString(0x80, p0)
  2301 |     |         }
  2302 |     |         _sendLogPayload(0x1c, 0xa4);
  2303 |     |         /// @solidity memory-safe-assembly
  2304 |     |         assembly {
  2305 |     |             mstore(0x00, m0)
  2306 |     |             mstore(0x20, m1)
  2307 |     |             mstore(0x40, m2)
  2308 |     |             mstore(0x60, m3)
  2309 |     |             mstore(0x80, m4)
  2310 |     |             mstore(0xa0, m5)
  2311 |     |         }
  2312 |     |     }
  2313 |     | 
  2314 |     |     function log(bytes32 p0, address p1, bool p2) internal pure {
  2315 |     |         bytes32 m0;
  2316 |     |         bytes32 m1;
  2317 |     |         bytes32 m2;
  2318 |     |         bytes32 m3;
  2319 |     |         bytes32 m4;
  2320 |     |         bytes32 m5;
  2321 |     |         /// @solidity memory-safe-assembly
  2322 |     |         assembly {
  2323 |     |             function writeString(pos, w) {
  2324 |     |                 let length := 0
  2325 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2326 |     |                 mstore(pos, length)
  2327 |     |                 let shift := sub(256, shl(3, length))
  2328 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2329 |     |             }
  2330 |     |             m0 := mload(0x00)
  2331 |     |             m1 := mload(0x20)
  2332 |     |             m2 := mload(0x40)
  2333 |     |             m3 := mload(0x60)
  2334 |     |             m4 := mload(0x80)
  2335 |     |             m5 := mload(0xa0)
  2336 |     |             // Selector of `log(string,address,bool)`.
  2337 |     |             mstore(0x00, 0xc91d5ed4)
  2338 |     |             mstore(0x20, 0x60)
  2339 |     |             mstore(0x40, p1)
  2340 |     |             mstore(0x60, p2)
  2341 |     |             writeString(0x80, p0)
  2342 |     |         }
  2343 |     |         _sendLogPayload(0x1c, 0xa4);
  2344 |     |         /// @solidity memory-safe-assembly
  2345 |     |         assembly {
  2346 |     |             mstore(0x00, m0)
  2347 |     |             mstore(0x20, m1)
  2348 |     |             mstore(0x40, m2)
  2349 |     |             mstore(0x60, m3)
  2350 |     |             mstore(0x80, m4)
  2351 |     |             mstore(0xa0, m5)
  2352 |     |         }
  2353 |     |     }
  2354 |     | 
  2355 |     |     function log(bytes32 p0, address p1, uint256 p2) internal pure {
  2356 |     |         bytes32 m0;
  2357 |     |         bytes32 m1;
  2358 |     |         bytes32 m2;
  2359 |     |         bytes32 m3;
  2360 |     |         bytes32 m4;
  2361 |     |         bytes32 m5;
  2362 |     |         /// @solidity memory-safe-assembly
  2363 |     |         assembly {
  2364 |     |             function writeString(pos, w) {
  2365 |     |                 let length := 0
  2366 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2367 |     |                 mstore(pos, length)
  2368 |     |                 let shift := sub(256, shl(3, length))
  2369 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2370 |     |             }
  2371 |     |             m0 := mload(0x00)
  2372 |     |             m1 := mload(0x20)
  2373 |     |             m2 := mload(0x40)
  2374 |     |             m3 := mload(0x60)
  2375 |     |             m4 := mload(0x80)
  2376 |     |             m5 := mload(0xa0)
  2377 |     |             // Selector of `log(string,address,uint256)`.
  2378 |     |             mstore(0x00, 0x0d26b925)
  2379 |     |             mstore(0x20, 0x60)
  2380 |     |             mstore(0x40, p1)
  2381 |     |             mstore(0x60, p2)
  2382 |     |             writeString(0x80, p0)
  2383 |     |         }
  2384 |     |         _sendLogPayload(0x1c, 0xa4);
  2385 |     |         /// @solidity memory-safe-assembly
  2386 |     |         assembly {
  2387 |     |             mstore(0x00, m0)
  2388 |     |             mstore(0x20, m1)
  2389 |     |             mstore(0x40, m2)
  2390 |     |             mstore(0x60, m3)
  2391 |     |             mstore(0x80, m4)
  2392 |     |             mstore(0xa0, m5)
  2393 |     |         }
  2394 |     |     }
  2395 |     | 
  2396 |     |     function log(bytes32 p0, address p1, bytes32 p2) internal pure {
  2397 |     |         bytes32 m0;
  2398 |     |         bytes32 m1;
  2399 |     |         bytes32 m2;
  2400 |     |         bytes32 m3;
  2401 |     |         bytes32 m4;
  2402 |     |         bytes32 m5;
  2403 |     |         bytes32 m6;
  2404 |     |         bytes32 m7;
  2405 |     |         /// @solidity memory-safe-assembly
  2406 |     |         assembly {
  2407 |     |             function writeString(pos, w) {
  2408 |     |                 let length := 0
  2409 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2410 |     |                 mstore(pos, length)
  2411 |     |                 let shift := sub(256, shl(3, length))
  2412 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2413 |     |             }
  2414 |     |             m0 := mload(0x00)
  2415 |     |             m1 := mload(0x20)
  2416 |     |             m2 := mload(0x40)
  2417 |     |             m3 := mload(0x60)
  2418 |     |             m4 := mload(0x80)
  2419 |     |             m5 := mload(0xa0)
  2420 |     |             m6 := mload(0xc0)
  2421 |     |             m7 := mload(0xe0)
  2422 |     |             // Selector of `log(string,address,string)`.
  2423 |     |             mstore(0x00, 0xe0e9ad4f)
  2424 |     |             mstore(0x20, 0x60)
  2425 |     |             mstore(0x40, p1)
  2426 |     |             mstore(0x60, 0xa0)
  2427 |     |             writeString(0x80, p0)
  2428 |     |             writeString(0xc0, p2)
  2429 |     |         }
  2430 |     |         _sendLogPayload(0x1c, 0xe4);
  2431 |     |         /// @solidity memory-safe-assembly
  2432 |     |         assembly {
  2433 |     |             mstore(0x00, m0)
  2434 |     |             mstore(0x20, m1)
  2435 |     |             mstore(0x40, m2)
  2436 |     |             mstore(0x60, m3)
  2437 |     |             mstore(0x80, m4)
  2438 |     |             mstore(0xa0, m5)
  2439 |     |             mstore(0xc0, m6)
  2440 |     |             mstore(0xe0, m7)
  2441 |     |         }
  2442 |     |     }
  2443 |     | 
  2444 |     |     function log(bytes32 p0, bool p1, address p2) internal pure {
  2445 |     |         bytes32 m0;
  2446 |     |         bytes32 m1;
  2447 |     |         bytes32 m2;
  2448 |     |         bytes32 m3;
  2449 |     |         bytes32 m4;
  2450 |     |         bytes32 m5;
  2451 |     |         /// @solidity memory-safe-assembly
  2452 |     |         assembly {
  2453 |     |             function writeString(pos, w) {
  2454 |     |                 let length := 0
  2455 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2456 |     |                 mstore(pos, length)
  2457 |     |                 let shift := sub(256, shl(3, length))
  2458 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2459 |     |             }
  2460 |     |             m0 := mload(0x00)
  2461 |     |             m1 := mload(0x20)
  2462 |     |             m2 := mload(0x40)
  2463 |     |             m3 := mload(0x60)
  2464 |     |             m4 := mload(0x80)
  2465 |     |             m5 := mload(0xa0)
  2466 |     |             // Selector of `log(string,bool,address)`.
  2467 |     |             mstore(0x00, 0x932bbb38)
  2468 |     |             mstore(0x20, 0x60)
  2469 |     |             mstore(0x40, p1)
  2470 |     |             mstore(0x60, p2)
  2471 |     |             writeString(0x80, p0)
  2472 |     |         }
  2473 |     |         _sendLogPayload(0x1c, 0xa4);
  2474 |     |         /// @solidity memory-safe-assembly
  2475 |     |         assembly {
  2476 |     |             mstore(0x00, m0)
  2477 |     |             mstore(0x20, m1)
  2478 |     |             mstore(0x40, m2)
  2479 |     |             mstore(0x60, m3)
  2480 |     |             mstore(0x80, m4)
  2481 |     |             mstore(0xa0, m5)
  2482 |     |         }
  2483 |     |     }
  2484 |     | 
  2485 |     |     function log(bytes32 p0, bool p1, bool p2) internal pure {
  2486 |     |         bytes32 m0;
  2487 |     |         bytes32 m1;
  2488 |     |         bytes32 m2;
  2489 |     |         bytes32 m3;
  2490 |     |         bytes32 m4;
  2491 |     |         bytes32 m5;
  2492 |     |         /// @solidity memory-safe-assembly
  2493 |     |         assembly {
  2494 |     |             function writeString(pos, w) {
  2495 |     |                 let length := 0
  2496 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2497 |     |                 mstore(pos, length)
  2498 |     |                 let shift := sub(256, shl(3, length))
  2499 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2500 |     |             }
  2501 |     |             m0 := mload(0x00)
  2502 |     |             m1 := mload(0x20)
  2503 |     |             m2 := mload(0x40)
  2504 |     |             m3 := mload(0x60)
  2505 |     |             m4 := mload(0x80)
  2506 |     |             m5 := mload(0xa0)
  2507 |     |             // Selector of `log(string,bool,bool)`.
  2508 |     |             mstore(0x00, 0x850b7ad6)
  2509 |     |             mstore(0x20, 0x60)
  2510 |     |             mstore(0x40, p1)
  2511 |     |             mstore(0x60, p2)
  2512 |     |             writeString(0x80, p0)
  2513 |     |         }
  2514 |     |         _sendLogPayload(0x1c, 0xa4);
  2515 |     |         /// @solidity memory-safe-assembly
  2516 |     |         assembly {
  2517 |     |             mstore(0x00, m0)
  2518 |     |             mstore(0x20, m1)
  2519 |     |             mstore(0x40, m2)
  2520 |     |             mstore(0x60, m3)
  2521 |     |             mstore(0x80, m4)
  2522 |     |             mstore(0xa0, m5)
  2523 |     |         }
  2524 |     |     }
  2525 |     | 
  2526 |     |     function log(bytes32 p0, bool p1, uint256 p2) internal pure {
  2527 |     |         bytes32 m0;
  2528 |     |         bytes32 m1;
  2529 |     |         bytes32 m2;
  2530 |     |         bytes32 m3;
  2531 |     |         bytes32 m4;
  2532 |     |         bytes32 m5;
  2533 |     |         /// @solidity memory-safe-assembly
  2534 |     |         assembly {
  2535 |     |             function writeString(pos, w) {
  2536 |     |                 let length := 0
  2537 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2538 |     |                 mstore(pos, length)
  2539 |     |                 let shift := sub(256, shl(3, length))
  2540 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2541 |     |             }
  2542 |     |             m0 := mload(0x00)
  2543 |     |             m1 := mload(0x20)
  2544 |     |             m2 := mload(0x40)
  2545 |     |             m3 := mload(0x60)
  2546 |     |             m4 := mload(0x80)
  2547 |     |             m5 := mload(0xa0)
  2548 |     |             // Selector of `log(string,bool,uint256)`.
  2549 |     |             mstore(0x00, 0xc95958d6)
  2550 |     |             mstore(0x20, 0x60)
  2551 |     |             mstore(0x40, p1)
  2552 |     |             mstore(0x60, p2)
  2553 |     |             writeString(0x80, p0)
  2554 |     |         }
  2555 |     |         _sendLogPayload(0x1c, 0xa4);
  2556 |     |         /// @solidity memory-safe-assembly
  2557 |     |         assembly {
  2558 |     |             mstore(0x00, m0)
  2559 |     |             mstore(0x20, m1)
  2560 |     |             mstore(0x40, m2)
  2561 |     |             mstore(0x60, m3)
  2562 |     |             mstore(0x80, m4)
  2563 |     |             mstore(0xa0, m5)
  2564 |     |         }
  2565 |     |     }
  2566 |     | 
  2567 |     |     function log(bytes32 p0, bool p1, bytes32 p2) internal pure {
  2568 |     |         bytes32 m0;
  2569 |     |         bytes32 m1;
  2570 |     |         bytes32 m2;
  2571 |     |         bytes32 m3;
  2572 |     |         bytes32 m4;
  2573 |     |         bytes32 m5;
  2574 |     |         bytes32 m6;
  2575 |     |         bytes32 m7;
  2576 |     |         /// @solidity memory-safe-assembly
  2577 |     |         assembly {
  2578 |     |             function writeString(pos, w) {
  2579 |     |                 let length := 0
  2580 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2581 |     |                 mstore(pos, length)
  2582 |     |                 let shift := sub(256, shl(3, length))
  2583 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2584 |     |             }
  2585 |     |             m0 := mload(0x00)
  2586 |     |             m1 := mload(0x20)
  2587 |     |             m2 := mload(0x40)
  2588 |     |             m3 := mload(0x60)
  2589 |     |             m4 := mload(0x80)
  2590 |     |             m5 := mload(0xa0)
  2591 |     |             m6 := mload(0xc0)
  2592 |     |             m7 := mload(0xe0)
  2593 |     |             // Selector of `log(string,bool,string)`.
  2594 |     |             mstore(0x00, 0xe298f47d)
  2595 |     |             mstore(0x20, 0x60)
  2596 |     |             mstore(0x40, p1)
  2597 |     |             mstore(0x60, 0xa0)
  2598 |     |             writeString(0x80, p0)
  2599 |     |             writeString(0xc0, p2)
  2600 |     |         }
  2601 |     |         _sendLogPayload(0x1c, 0xe4);
  2602 |     |         /// @solidity memory-safe-assembly
  2603 |     |         assembly {
  2604 |     |             mstore(0x00, m0)
  2605 |     |             mstore(0x20, m1)
  2606 |     |             mstore(0x40, m2)
  2607 |     |             mstore(0x60, m3)
  2608 |     |             mstore(0x80, m4)
  2609 |     |             mstore(0xa0, m5)
  2610 |     |             mstore(0xc0, m6)
  2611 |     |             mstore(0xe0, m7)
  2612 |     |         }
  2613 |     |     }
  2614 |     | 
  2615 |     |     function log(bytes32 p0, uint256 p1, address p2) internal pure {
  2616 |     |         bytes32 m0;
  2617 |     |         bytes32 m1;
  2618 |     |         bytes32 m2;
  2619 |     |         bytes32 m3;
  2620 |     |         bytes32 m4;
  2621 |     |         bytes32 m5;
  2622 |     |         /// @solidity memory-safe-assembly
  2623 |     |         assembly {
  2624 |     |             function writeString(pos, w) {
  2625 |     |                 let length := 0
  2626 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2627 |     |                 mstore(pos, length)
  2628 |     |                 let shift := sub(256, shl(3, length))
  2629 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2630 |     |             }
  2631 |     |             m0 := mload(0x00)
  2632 |     |             m1 := mload(0x20)
  2633 |     |             m2 := mload(0x40)
  2634 |     |             m3 := mload(0x60)
  2635 |     |             m4 := mload(0x80)
  2636 |     |             m5 := mload(0xa0)
  2637 |     |             // Selector of `log(string,uint256,address)`.
  2638 |     |             mstore(0x00, 0x1c7ec448)
  2639 |     |             mstore(0x20, 0x60)
  2640 |     |             mstore(0x40, p1)
  2641 |     |             mstore(0x60, p2)
  2642 |     |             writeString(0x80, p0)
  2643 |     |         }
  2644 |     |         _sendLogPayload(0x1c, 0xa4);
  2645 |     |         /// @solidity memory-safe-assembly
  2646 |     |         assembly {
  2647 |     |             mstore(0x00, m0)
  2648 |     |             mstore(0x20, m1)
  2649 |     |             mstore(0x40, m2)
  2650 |     |             mstore(0x60, m3)
  2651 |     |             mstore(0x80, m4)
  2652 |     |             mstore(0xa0, m5)
  2653 |     |         }
  2654 |     |     }
  2655 |     | 
  2656 |     |     function log(bytes32 p0, uint256 p1, bool p2) internal pure {
  2657 |     |         bytes32 m0;
  2658 |     |         bytes32 m1;
  2659 |     |         bytes32 m2;
  2660 |     |         bytes32 m3;
  2661 |     |         bytes32 m4;
  2662 |     |         bytes32 m5;
  2663 |     |         /// @solidity memory-safe-assembly
  2664 |     |         assembly {
  2665 |     |             function writeString(pos, w) {
  2666 |     |                 let length := 0
  2667 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2668 |     |                 mstore(pos, length)
  2669 |     |                 let shift := sub(256, shl(3, length))
  2670 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2671 |     |             }
  2672 |     |             m0 := mload(0x00)
  2673 |     |             m1 := mload(0x20)
  2674 |     |             m2 := mload(0x40)
  2675 |     |             m3 := mload(0x60)
  2676 |     |             m4 := mload(0x80)
  2677 |     |             m5 := mload(0xa0)
  2678 |     |             // Selector of `log(string,uint256,bool)`.
  2679 |     |             mstore(0x00, 0xca7733b1)
  2680 |     |             mstore(0x20, 0x60)
  2681 |     |             mstore(0x40, p1)
  2682 |     |             mstore(0x60, p2)
  2683 |     |             writeString(0x80, p0)
  2684 |     |         }
  2685 |     |         _sendLogPayload(0x1c, 0xa4);
  2686 |     |         /// @solidity memory-safe-assembly
  2687 |     |         assembly {
  2688 |     |             mstore(0x00, m0)
  2689 |     |             mstore(0x20, m1)
  2690 |     |             mstore(0x40, m2)
  2691 |     |             mstore(0x60, m3)
  2692 |     |             mstore(0x80, m4)
  2693 |     |             mstore(0xa0, m5)
  2694 |     |         }
  2695 |     |     }
  2696 |     | 
  2697 |     |     function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {
  2698 |     |         bytes32 m0;
  2699 |     |         bytes32 m1;
  2700 |     |         bytes32 m2;
  2701 |     |         bytes32 m3;
  2702 |     |         bytes32 m4;
  2703 |     |         bytes32 m5;
  2704 |     |         /// @solidity memory-safe-assembly
  2705 |     |         assembly {
  2706 |     |             function writeString(pos, w) {
  2707 |     |                 let length := 0
  2708 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2709 |     |                 mstore(pos, length)
  2710 |     |                 let shift := sub(256, shl(3, length))
  2711 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2712 |     |             }
  2713 |     |             m0 := mload(0x00)
  2714 |     |             m1 := mload(0x20)
  2715 |     |             m2 := mload(0x40)
  2716 |     |             m3 := mload(0x60)
  2717 |     |             m4 := mload(0x80)
  2718 |     |             m5 := mload(0xa0)
  2719 |     |             // Selector of `log(string,uint256,uint256)`.
  2720 |     |             mstore(0x00, 0xca47c4eb)
  2721 |     |             mstore(0x20, 0x60)
  2722 |     |             mstore(0x40, p1)
  2723 |     |             mstore(0x60, p2)
  2724 |     |             writeString(0x80, p0)
  2725 |     |         }
  2726 |     |         _sendLogPayload(0x1c, 0xa4);
  2727 |     |         /// @solidity memory-safe-assembly
  2728 |     |         assembly {
  2729 |     |             mstore(0x00, m0)
  2730 |     |             mstore(0x20, m1)
  2731 |     |             mstore(0x40, m2)
  2732 |     |             mstore(0x60, m3)
  2733 |     |             mstore(0x80, m4)
  2734 |     |             mstore(0xa0, m5)
  2735 |     |         }
  2736 |     |     }
  2737 |     | 
  2738 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {
  2739 |     |         bytes32 m0;
  2740 |     |         bytes32 m1;
  2741 |     |         bytes32 m2;
  2742 |     |         bytes32 m3;
  2743 |     |         bytes32 m4;
  2744 |     |         bytes32 m5;
  2745 |     |         bytes32 m6;
  2746 |     |         bytes32 m7;
  2747 |     |         /// @solidity memory-safe-assembly
  2748 |     |         assembly {
  2749 |     |             function writeString(pos, w) {
  2750 |     |                 let length := 0
  2751 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2752 |     |                 mstore(pos, length)
  2753 |     |                 let shift := sub(256, shl(3, length))
  2754 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2755 |     |             }
  2756 |     |             m0 := mload(0x00)
  2757 |     |             m1 := mload(0x20)
  2758 |     |             m2 := mload(0x40)
  2759 |     |             m3 := mload(0x60)
  2760 |     |             m4 := mload(0x80)
  2761 |     |             m5 := mload(0xa0)
  2762 |     |             m6 := mload(0xc0)
  2763 |     |             m7 := mload(0xe0)
  2764 |     |             // Selector of `log(string,uint256,string)`.
  2765 |     |             mstore(0x00, 0x5970e089)
  2766 |     |             mstore(0x20, 0x60)
  2767 |     |             mstore(0x40, p1)
  2768 |     |             mstore(0x60, 0xa0)
  2769 |     |             writeString(0x80, p0)
  2770 |     |             writeString(0xc0, p2)
  2771 |     |         }
  2772 |     |         _sendLogPayload(0x1c, 0xe4);
  2773 |     |         /// @solidity memory-safe-assembly
  2774 |     |         assembly {
  2775 |     |             mstore(0x00, m0)
  2776 |     |             mstore(0x20, m1)
  2777 |     |             mstore(0x40, m2)
  2778 |     |             mstore(0x60, m3)
  2779 |     |             mstore(0x80, m4)
  2780 |     |             mstore(0xa0, m5)
  2781 |     |             mstore(0xc0, m6)
  2782 |     |             mstore(0xe0, m7)
  2783 |     |         }
  2784 |     |     }
  2785 |     | 
  2786 |     |     function log(bytes32 p0, bytes32 p1, address p2) internal pure {
  2787 |     |         bytes32 m0;
  2788 |     |         bytes32 m1;
  2789 |     |         bytes32 m2;
  2790 |     |         bytes32 m3;
  2791 |     |         bytes32 m4;
  2792 |     |         bytes32 m5;
  2793 |     |         bytes32 m6;
  2794 |     |         bytes32 m7;
  2795 |     |         /// @solidity memory-safe-assembly
  2796 |     |         assembly {
  2797 |     |             function writeString(pos, w) {
  2798 |     |                 let length := 0
  2799 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2800 |     |                 mstore(pos, length)
  2801 |     |                 let shift := sub(256, shl(3, length))
  2802 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2803 |     |             }
  2804 |     |             m0 := mload(0x00)
  2805 |     |             m1 := mload(0x20)
  2806 |     |             m2 := mload(0x40)
  2807 |     |             m3 := mload(0x60)
  2808 |     |             m4 := mload(0x80)
  2809 |     |             m5 := mload(0xa0)
  2810 |     |             m6 := mload(0xc0)
  2811 |     |             m7 := mload(0xe0)
  2812 |     |             // Selector of `log(string,string,address)`.
  2813 |     |             mstore(0x00, 0x95ed0195)
  2814 |     |             mstore(0x20, 0x60)
  2815 |     |             mstore(0x40, 0xa0)
  2816 |     |             mstore(0x60, p2)
  2817 |     |             writeString(0x80, p0)
  2818 |     |             writeString(0xc0, p1)
  2819 |     |         }
  2820 |     |         _sendLogPayload(0x1c, 0xe4);
  2821 |     |         /// @solidity memory-safe-assembly
  2822 |     |         assembly {
  2823 |     |             mstore(0x00, m0)
  2824 |     |             mstore(0x20, m1)
  2825 |     |             mstore(0x40, m2)
  2826 |     |             mstore(0x60, m3)
  2827 |     |             mstore(0x80, m4)
  2828 |     |             mstore(0xa0, m5)
  2829 |     |             mstore(0xc0, m6)
  2830 |     |             mstore(0xe0, m7)
  2831 |     |         }
  2832 |     |     }
  2833 |     | 
  2834 |     |     function log(bytes32 p0, bytes32 p1, bool p2) internal pure {
  2835 |     |         bytes32 m0;
  2836 |     |         bytes32 m1;
  2837 |     |         bytes32 m2;
  2838 |     |         bytes32 m3;
  2839 |     |         bytes32 m4;
  2840 |     |         bytes32 m5;
  2841 |     |         bytes32 m6;
  2842 |     |         bytes32 m7;
  2843 |     |         /// @solidity memory-safe-assembly
  2844 |     |         assembly {
  2845 |     |             function writeString(pos, w) {
  2846 |     |                 let length := 0
  2847 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2848 |     |                 mstore(pos, length)
  2849 |     |                 let shift := sub(256, shl(3, length))
  2850 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2851 |     |             }
  2852 |     |             m0 := mload(0x00)
  2853 |     |             m1 := mload(0x20)
  2854 |     |             m2 := mload(0x40)
  2855 |     |             m3 := mload(0x60)
  2856 |     |             m4 := mload(0x80)
  2857 |     |             m5 := mload(0xa0)
  2858 |     |             m6 := mload(0xc0)
  2859 |     |             m7 := mload(0xe0)
  2860 |     |             // Selector of `log(string,string,bool)`.
  2861 |     |             mstore(0x00, 0xb0e0f9b5)
  2862 |     |             mstore(0x20, 0x60)
  2863 |     |             mstore(0x40, 0xa0)
  2864 |     |             mstore(0x60, p2)
  2865 |     |             writeString(0x80, p0)
  2866 |     |             writeString(0xc0, p1)
  2867 |     |         }
  2868 |     |         _sendLogPayload(0x1c, 0xe4);
  2869 |     |         /// @solidity memory-safe-assembly
  2870 |     |         assembly {
  2871 |     |             mstore(0x00, m0)
  2872 |     |             mstore(0x20, m1)
  2873 |     |             mstore(0x40, m2)
  2874 |     |             mstore(0x60, m3)
  2875 |     |             mstore(0x80, m4)
  2876 |     |             mstore(0xa0, m5)
  2877 |     |             mstore(0xc0, m6)
  2878 |     |             mstore(0xe0, m7)
  2879 |     |         }
  2880 |     |     }
  2881 |     | 
  2882 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {
  2883 |     |         bytes32 m0;
  2884 |     |         bytes32 m1;
  2885 |     |         bytes32 m2;
  2886 |     |         bytes32 m3;
  2887 |     |         bytes32 m4;
  2888 |     |         bytes32 m5;
  2889 |     |         bytes32 m6;
  2890 |     |         bytes32 m7;
  2891 |     |         /// @solidity memory-safe-assembly
  2892 |     |         assembly {
  2893 |     |             function writeString(pos, w) {
  2894 |     |                 let length := 0
  2895 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2896 |     |                 mstore(pos, length)
  2897 |     |                 let shift := sub(256, shl(3, length))
  2898 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2899 |     |             }
  2900 |     |             m0 := mload(0x00)
  2901 |     |             m1 := mload(0x20)
  2902 |     |             m2 := mload(0x40)
  2903 |     |             m3 := mload(0x60)
  2904 |     |             m4 := mload(0x80)
  2905 |     |             m5 := mload(0xa0)
  2906 |     |             m6 := mload(0xc0)
  2907 |     |             m7 := mload(0xe0)
  2908 |     |             // Selector of `log(string,string,uint256)`.
  2909 |     |             mstore(0x00, 0x5821efa1)
  2910 |     |             mstore(0x20, 0x60)
  2911 |     |             mstore(0x40, 0xa0)
  2912 |     |             mstore(0x60, p2)
  2913 |     |             writeString(0x80, p0)
  2914 |     |             writeString(0xc0, p1)
  2915 |     |         }
  2916 |     |         _sendLogPayload(0x1c, 0xe4);
  2917 |     |         /// @solidity memory-safe-assembly
  2918 |     |         assembly {
  2919 |     |             mstore(0x00, m0)
  2920 |     |             mstore(0x20, m1)
  2921 |     |             mstore(0x40, m2)
  2922 |     |             mstore(0x60, m3)
  2923 |     |             mstore(0x80, m4)
  2924 |     |             mstore(0xa0, m5)
  2925 |     |             mstore(0xc0, m6)
  2926 |     |             mstore(0xe0, m7)
  2927 |     |         }
  2928 |     |     }
  2929 |     | 
  2930 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {
  2931 |     |         bytes32 m0;
  2932 |     |         bytes32 m1;
  2933 |     |         bytes32 m2;
  2934 |     |         bytes32 m3;
  2935 |     |         bytes32 m4;
  2936 |     |         bytes32 m5;
  2937 |     |         bytes32 m6;
  2938 |     |         bytes32 m7;
  2939 |     |         bytes32 m8;
  2940 |     |         bytes32 m9;
  2941 |     |         /// @solidity memory-safe-assembly
  2942 |     |         assembly {
  2943 |     |             function writeString(pos, w) {
  2944 |     |                 let length := 0
  2945 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2946 |     |                 mstore(pos, length)
  2947 |     |                 let shift := sub(256, shl(3, length))
  2948 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2949 |     |             }
  2950 |     |             m0 := mload(0x00)
  2951 |     |             m1 := mload(0x20)
  2952 |     |             m2 := mload(0x40)
  2953 |     |             m3 := mload(0x60)
  2954 |     |             m4 := mload(0x80)
  2955 |     |             m5 := mload(0xa0)
  2956 |     |             m6 := mload(0xc0)
  2957 |     |             m7 := mload(0xe0)
  2958 |     |             m8 := mload(0x100)
  2959 |     |             m9 := mload(0x120)
  2960 |     |             // Selector of `log(string,string,string)`.
  2961 |     |             mstore(0x00, 0x2ced7cef)
  2962 |     |             mstore(0x20, 0x60)
  2963 |     |             mstore(0x40, 0xa0)
  2964 |     |             mstore(0x60, 0xe0)
  2965 |     |             writeString(0x80, p0)
  2966 |     |             writeString(0xc0, p1)
  2967 |     |             writeString(0x100, p2)
  2968 |     |         }
  2969 |     |         _sendLogPayload(0x1c, 0x124);
  2970 |     |         /// @solidity memory-safe-assembly
  2971 |     |         assembly {
  2972 |     |             mstore(0x00, m0)
  2973 |     |             mstore(0x20, m1)
  2974 |     |             mstore(0x40, m2)
  2975 |     |             mstore(0x60, m3)
  2976 |     |             mstore(0x80, m4)
  2977 |     |             mstore(0xa0, m5)
  2978 |     |             mstore(0xc0, m6)
  2979 |     |             mstore(0xe0, m7)
  2980 |     |             mstore(0x100, m8)
  2981 |     |             mstore(0x120, m9)
  2982 |     |         }
  2983 |     |     }
  2984 |     | 
  2985 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
  2986 |     |         bytes32 m0;
  2987 |     |         bytes32 m1;
  2988 |     |         bytes32 m2;
  2989 |     |         bytes32 m3;
  2990 |     |         bytes32 m4;
  2991 |     |         /// @solidity memory-safe-assembly
  2992 |     |         assembly {
  2993 |     |             m0 := mload(0x00)
  2994 |     |             m1 := mload(0x20)
  2995 |     |             m2 := mload(0x40)
  2996 |     |             m3 := mload(0x60)
  2997 |     |             m4 := mload(0x80)
  2998 |     |             // Selector of `log(address,address,address,address)`.
  2999 |     |             mstore(0x00, 0x665bf134)
  3000 |     |             mstore(0x20, p0)
  3001 |     |             mstore(0x40, p1)
  3002 |     |             mstore(0x60, p2)
  3003 |     |             mstore(0x80, p3)
  3004 |     |         }
  3005 |     |         _sendLogPayload(0x1c, 0x84);
  3006 |     |         /// @solidity memory-safe-assembly
  3007 |     |         assembly {
  3008 |     |             mstore(0x00, m0)
  3009 |     |             mstore(0x20, m1)
  3010 |     |             mstore(0x40, m2)
  3011 |     |             mstore(0x60, m3)
  3012 |     |             mstore(0x80, m4)
  3013 |     |         }
  3014 |     |     }
  3015 |     | 
  3016 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
  3017 |     |         bytes32 m0;
  3018 |     |         bytes32 m1;
  3019 |     |         bytes32 m2;
  3020 |     |         bytes32 m3;
  3021 |     |         bytes32 m4;
  3022 |     |         /// @solidity memory-safe-assembly
  3023 |     |         assembly {
  3024 |     |             m0 := mload(0x00)
  3025 |     |             m1 := mload(0x20)
  3026 |     |             m2 := mload(0x40)
  3027 |     |             m3 := mload(0x60)
  3028 |     |             m4 := mload(0x80)
  3029 |     |             // Selector of `log(address,address,address,bool)`.
  3030 |     |             mstore(0x00, 0x0e378994)
  3031 |     |             mstore(0x20, p0)
  3032 |     |             mstore(0x40, p1)
  3033 |     |             mstore(0x60, p2)
  3034 |     |             mstore(0x80, p3)
  3035 |     |         }
  3036 |     |         _sendLogPayload(0x1c, 0x84);
  3037 |     |         /// @solidity memory-safe-assembly
  3038 |     |         assembly {
  3039 |     |             mstore(0x00, m0)
  3040 |     |             mstore(0x20, m1)
  3041 |     |             mstore(0x40, m2)
  3042 |     |             mstore(0x60, m3)
  3043 |     |             mstore(0x80, m4)
  3044 |     |         }
  3045 |     |     }
  3046 |     | 
  3047 |     |     function log(address p0, address p1, address p2, uint256 p3) internal pure {
  3048 |     |         bytes32 m0;
  3049 |     |         bytes32 m1;
  3050 |     |         bytes32 m2;
  3051 |     |         bytes32 m3;
  3052 |     |         bytes32 m4;
  3053 |     |         /// @solidity memory-safe-assembly
  3054 |     |         assembly {
  3055 |     |             m0 := mload(0x00)
  3056 |     |             m1 := mload(0x20)
  3057 |     |             m2 := mload(0x40)
  3058 |     |             m3 := mload(0x60)
  3059 |     |             m4 := mload(0x80)
  3060 |     |             // Selector of `log(address,address,address,uint256)`.
  3061 |     |             mstore(0x00, 0x94250d77)
  3062 |     |             mstore(0x20, p0)
  3063 |     |             mstore(0x40, p1)
  3064 |     |             mstore(0x60, p2)
  3065 |     |             mstore(0x80, p3)
  3066 |     |         }
  3067 |     |         _sendLogPayload(0x1c, 0x84);
  3068 |     |         /// @solidity memory-safe-assembly
  3069 |     |         assembly {
  3070 |     |             mstore(0x00, m0)
  3071 |     |             mstore(0x20, m1)
  3072 |     |             mstore(0x40, m2)
  3073 |     |             mstore(0x60, m3)
  3074 |     |             mstore(0x80, m4)
  3075 |     |         }
  3076 |     |     }
  3077 |     | 
  3078 |     |     function log(address p0, address p1, address p2, bytes32 p3) internal pure {
  3079 |     |         bytes32 m0;
  3080 |     |         bytes32 m1;
  3081 |     |         bytes32 m2;
  3082 |     |         bytes32 m3;
  3083 |     |         bytes32 m4;
  3084 |     |         bytes32 m5;
  3085 |     |         bytes32 m6;
  3086 |     |         /// @solidity memory-safe-assembly
  3087 |     |         assembly {
  3088 |     |             function writeString(pos, w) {
  3089 |     |                 let length := 0
  3090 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3091 |     |                 mstore(pos, length)
  3092 |     |                 let shift := sub(256, shl(3, length))
  3093 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3094 |     |             }
  3095 |     |             m0 := mload(0x00)
  3096 |     |             m1 := mload(0x20)
  3097 |     |             m2 := mload(0x40)
  3098 |     |             m3 := mload(0x60)
  3099 |     |             m4 := mload(0x80)
  3100 |     |             m5 := mload(0xa0)
  3101 |     |             m6 := mload(0xc0)
  3102 |     |             // Selector of `log(address,address,address,string)`.
  3103 |     |             mstore(0x00, 0xf808da20)
  3104 |     |             mstore(0x20, p0)
  3105 |     |             mstore(0x40, p1)
  3106 |     |             mstore(0x60, p2)
  3107 |     |             mstore(0x80, 0x80)
  3108 |     |             writeString(0xa0, p3)
  3109 |     |         }
  3110 |     |         _sendLogPayload(0x1c, 0xc4);
  3111 |     |         /// @solidity memory-safe-assembly
  3112 |     |         assembly {
  3113 |     |             mstore(0x00, m0)
  3114 |     |             mstore(0x20, m1)
  3115 |     |             mstore(0x40, m2)
  3116 |     |             mstore(0x60, m3)
  3117 |     |             mstore(0x80, m4)
  3118 |     |             mstore(0xa0, m5)
  3119 |     |             mstore(0xc0, m6)
  3120 |     |         }
  3121 |     |     }
  3122 |     | 
  3123 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
  3124 |     |         bytes32 m0;
  3125 |     |         bytes32 m1;
  3126 |     |         bytes32 m2;
  3127 |     |         bytes32 m3;
  3128 |     |         bytes32 m4;
  3129 |     |         /// @solidity memory-safe-assembly
  3130 |     |         assembly {
  3131 |     |             m0 := mload(0x00)
  3132 |     |             m1 := mload(0x20)
  3133 |     |             m2 := mload(0x40)
  3134 |     |             m3 := mload(0x60)
  3135 |     |             m4 := mload(0x80)
  3136 |     |             // Selector of `log(address,address,bool,address)`.
  3137 |     |             mstore(0x00, 0x9f1bc36e)
  3138 |     |             mstore(0x20, p0)
  3139 |     |             mstore(0x40, p1)
  3140 |     |             mstore(0x60, p2)
  3141 |     |             mstore(0x80, p3)
  3142 |     |         }
  3143 |     |         _sendLogPayload(0x1c, 0x84);
  3144 |     |         /// @solidity memory-safe-assembly
  3145 |     |         assembly {
  3146 |     |             mstore(0x00, m0)
  3147 |     |             mstore(0x20, m1)
  3148 |     |             mstore(0x40, m2)
  3149 |     |             mstore(0x60, m3)
  3150 |     |             mstore(0x80, m4)
  3151 |     |         }
  3152 |     |     }
  3153 |     | 
  3154 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
  3155 |     |         bytes32 m0;
  3156 |     |         bytes32 m1;
  3157 |     |         bytes32 m2;
  3158 |     |         bytes32 m3;
  3159 |     |         bytes32 m4;
  3160 |     |         /// @solidity memory-safe-assembly
  3161 |     |         assembly {
  3162 |     |             m0 := mload(0x00)
  3163 |     |             m1 := mload(0x20)
  3164 |     |             m2 := mload(0x40)
  3165 |     |             m3 := mload(0x60)
  3166 |     |             m4 := mload(0x80)
  3167 |     |             // Selector of `log(address,address,bool,bool)`.
  3168 |     |             mstore(0x00, 0x2cd4134a)
  3169 |     |             mstore(0x20, p0)
  3170 |     |             mstore(0x40, p1)
  3171 |     |             mstore(0x60, p2)
  3172 |     |             mstore(0x80, p3)
  3173 |     |         }
  3174 |     |         _sendLogPayload(0x1c, 0x84);
  3175 |     |         /// @solidity memory-safe-assembly
  3176 |     |         assembly {
  3177 |     |             mstore(0x00, m0)
  3178 |     |             mstore(0x20, m1)
  3179 |     |             mstore(0x40, m2)
  3180 |     |             mstore(0x60, m3)
  3181 |     |             mstore(0x80, m4)
  3182 |     |         }
  3183 |     |     }
  3184 |     | 
  3185 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal pure {
  3186 |     |         bytes32 m0;
  3187 |     |         bytes32 m1;
  3188 |     |         bytes32 m2;
  3189 |     |         bytes32 m3;
  3190 |     |         bytes32 m4;
  3191 |     |         /// @solidity memory-safe-assembly
  3192 |     |         assembly {
  3193 |     |             m0 := mload(0x00)
  3194 |     |             m1 := mload(0x20)
  3195 |     |             m2 := mload(0x40)
  3196 |     |             m3 := mload(0x60)
  3197 |     |             m4 := mload(0x80)
  3198 |     |             // Selector of `log(address,address,bool,uint256)`.
  3199 |     |             mstore(0x00, 0x3971e78c)
  3200 |     |             mstore(0x20, p0)
  3201 |     |             mstore(0x40, p1)
  3202 |     |             mstore(0x60, p2)
  3203 |     |             mstore(0x80, p3)
  3204 |     |         }
  3205 |     |         _sendLogPayload(0x1c, 0x84);
  3206 |     |         /// @solidity memory-safe-assembly
  3207 |     |         assembly {
  3208 |     |             mstore(0x00, m0)
  3209 |     |             mstore(0x20, m1)
  3210 |     |             mstore(0x40, m2)
  3211 |     |             mstore(0x60, m3)
  3212 |     |             mstore(0x80, m4)
  3213 |     |         }
  3214 |     |     }
  3215 |     | 
  3216 |     |     function log(address p0, address p1, bool p2, bytes32 p3) internal pure {
  3217 |     |         bytes32 m0;
  3218 |     |         bytes32 m1;
  3219 |     |         bytes32 m2;
  3220 |     |         bytes32 m3;
  3221 |     |         bytes32 m4;
  3222 |     |         bytes32 m5;
  3223 |     |         bytes32 m6;
  3224 |     |         /// @solidity memory-safe-assembly
  3225 |     |         assembly {
  3226 |     |             function writeString(pos, w) {
  3227 |     |                 let length := 0
  3228 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3229 |     |                 mstore(pos, length)
  3230 |     |                 let shift := sub(256, shl(3, length))
  3231 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3232 |     |             }
  3233 |     |             m0 := mload(0x00)
  3234 |     |             m1 := mload(0x20)
  3235 |     |             m2 := mload(0x40)
  3236 |     |             m3 := mload(0x60)
  3237 |     |             m4 := mload(0x80)
  3238 |     |             m5 := mload(0xa0)
  3239 |     |             m6 := mload(0xc0)
  3240 |     |             // Selector of `log(address,address,bool,string)`.
  3241 |     |             mstore(0x00, 0xaa6540c8)
  3242 |     |             mstore(0x20, p0)
  3243 |     |             mstore(0x40, p1)
  3244 |     |             mstore(0x60, p2)
  3245 |     |             mstore(0x80, 0x80)
  3246 |     |             writeString(0xa0, p3)
  3247 |     |         }
  3248 |     |         _sendLogPayload(0x1c, 0xc4);
  3249 |     |         /// @solidity memory-safe-assembly
  3250 |     |         assembly {
  3251 |     |             mstore(0x00, m0)
  3252 |     |             mstore(0x20, m1)
  3253 |     |             mstore(0x40, m2)
  3254 |     |             mstore(0x60, m3)
  3255 |     |             mstore(0x80, m4)
  3256 |     |             mstore(0xa0, m5)
  3257 |     |             mstore(0xc0, m6)
  3258 |     |         }
  3259 |     |     }
  3260 |     | 
  3261 |     |     function log(address p0, address p1, uint256 p2, address p3) internal pure {
  3262 |     |         bytes32 m0;
  3263 |     |         bytes32 m1;
  3264 |     |         bytes32 m2;
  3265 |     |         bytes32 m3;
  3266 |     |         bytes32 m4;
  3267 |     |         /// @solidity memory-safe-assembly
  3268 |     |         assembly {
  3269 |     |             m0 := mload(0x00)
  3270 |     |             m1 := mload(0x20)
  3271 |     |             m2 := mload(0x40)
  3272 |     |             m3 := mload(0x60)
  3273 |     |             m4 := mload(0x80)
  3274 |     |             // Selector of `log(address,address,uint256,address)`.
  3275 |     |             mstore(0x00, 0x8da6def5)
  3276 |     |             mstore(0x20, p0)
  3277 |     |             mstore(0x40, p1)
  3278 |     |             mstore(0x60, p2)
  3279 |     |             mstore(0x80, p3)
  3280 |     |         }
  3281 |     |         _sendLogPayload(0x1c, 0x84);
  3282 |     |         /// @solidity memory-safe-assembly
  3283 |     |         assembly {
  3284 |     |             mstore(0x00, m0)
  3285 |     |             mstore(0x20, m1)
  3286 |     |             mstore(0x40, m2)
  3287 |     |             mstore(0x60, m3)
  3288 |     |             mstore(0x80, m4)
  3289 |     |         }
  3290 |     |     }
  3291 |     | 
  3292 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal pure {
  3293 |     |         bytes32 m0;
  3294 |     |         bytes32 m1;
  3295 |     |         bytes32 m2;
  3296 |     |         bytes32 m3;
  3297 |     |         bytes32 m4;
  3298 |     |         /// @solidity memory-safe-assembly
  3299 |     |         assembly {
  3300 |     |             m0 := mload(0x00)
  3301 |     |             m1 := mload(0x20)
  3302 |     |             m2 := mload(0x40)
  3303 |     |             m3 := mload(0x60)
  3304 |     |             m4 := mload(0x80)
  3305 |     |             // Selector of `log(address,address,uint256,bool)`.
  3306 |     |             mstore(0x00, 0x9b4254e2)
  3307 |     |             mstore(0x20, p0)
  3308 |     |             mstore(0x40, p1)
  3309 |     |             mstore(0x60, p2)
  3310 |     |             mstore(0x80, p3)
  3311 |     |         }
  3312 |     |         _sendLogPayload(0x1c, 0x84);
  3313 |     |         /// @solidity memory-safe-assembly
  3314 |     |         assembly {
  3315 |     |             mstore(0x00, m0)
  3316 |     |             mstore(0x20, m1)
  3317 |     |             mstore(0x40, m2)
  3318 |     |             mstore(0x60, m3)
  3319 |     |             mstore(0x80, m4)
  3320 |     |         }
  3321 |     |     }
  3322 |     | 
  3323 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {
  3324 |     |         bytes32 m0;
  3325 |     |         bytes32 m1;
  3326 |     |         bytes32 m2;
  3327 |     |         bytes32 m3;
  3328 |     |         bytes32 m4;
  3329 |     |         /// @solidity memory-safe-assembly
  3330 |     |         assembly {
  3331 |     |             m0 := mload(0x00)
  3332 |     |             m1 := mload(0x20)
  3333 |     |             m2 := mload(0x40)
  3334 |     |             m3 := mload(0x60)
  3335 |     |             m4 := mload(0x80)
  3336 |     |             // Selector of `log(address,address,uint256,uint256)`.
  3337 |     |             mstore(0x00, 0xbe553481)
  3338 |     |             mstore(0x20, p0)
  3339 |     |             mstore(0x40, p1)
  3340 |     |             mstore(0x60, p2)
  3341 |     |             mstore(0x80, p3)
  3342 |     |         }
  3343 |     |         _sendLogPayload(0x1c, 0x84);
  3344 |     |         /// @solidity memory-safe-assembly
  3345 |     |         assembly {
  3346 |     |             mstore(0x00, m0)
  3347 |     |             mstore(0x20, m1)
  3348 |     |             mstore(0x40, m2)
  3349 |     |             mstore(0x60, m3)
  3350 |     |             mstore(0x80, m4)
  3351 |     |         }
  3352 |     |     }
  3353 |     | 
  3354 |     |     function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {
  3355 |     |         bytes32 m0;
  3356 |     |         bytes32 m1;
  3357 |     |         bytes32 m2;
  3358 |     |         bytes32 m3;
  3359 |     |         bytes32 m4;
  3360 |     |         bytes32 m5;
  3361 |     |         bytes32 m6;
  3362 |     |         /// @solidity memory-safe-assembly
  3363 |     |         assembly {
  3364 |     |             function writeString(pos, w) {
  3365 |     |                 let length := 0
  3366 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3367 |     |                 mstore(pos, length)
  3368 |     |                 let shift := sub(256, shl(3, length))
  3369 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3370 |     |             }
  3371 |     |             m0 := mload(0x00)
  3372 |     |             m1 := mload(0x20)
  3373 |     |             m2 := mload(0x40)
  3374 |     |             m3 := mload(0x60)
  3375 |     |             m4 := mload(0x80)
  3376 |     |             m5 := mload(0xa0)
  3377 |     |             m6 := mload(0xc0)
  3378 |     |             // Selector of `log(address,address,uint256,string)`.
  3379 |     |             mstore(0x00, 0xfdb4f990)
  3380 |     |             mstore(0x20, p0)
  3381 |     |             mstore(0x40, p1)
  3382 |     |             mstore(0x60, p2)
  3383 |     |             mstore(0x80, 0x80)
  3384 |     |             writeString(0xa0, p3)
  3385 |     |         }
  3386 |     |         _sendLogPayload(0x1c, 0xc4);
  3387 |     |         /// @solidity memory-safe-assembly
  3388 |     |         assembly {
  3389 |     |             mstore(0x00, m0)
  3390 |     |             mstore(0x20, m1)
  3391 |     |             mstore(0x40, m2)
  3392 |     |             mstore(0x60, m3)
  3393 |     |             mstore(0x80, m4)
  3394 |     |             mstore(0xa0, m5)
  3395 |     |             mstore(0xc0, m6)
  3396 |     |         }
  3397 |     |     }
  3398 |     | 
  3399 |     |     function log(address p0, address p1, bytes32 p2, address p3) internal pure {
  3400 |     |         bytes32 m0;
  3401 |     |         bytes32 m1;
  3402 |     |         bytes32 m2;
  3403 |     |         bytes32 m3;
  3404 |     |         bytes32 m4;
  3405 |     |         bytes32 m5;
  3406 |     |         bytes32 m6;
  3407 |     |         /// @solidity memory-safe-assembly
  3408 |     |         assembly {
  3409 |     |             function writeString(pos, w) {
  3410 |     |                 let length := 0
  3411 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3412 |     |                 mstore(pos, length)
  3413 |     |                 let shift := sub(256, shl(3, length))
  3414 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3415 |     |             }
  3416 |     |             m0 := mload(0x00)
  3417 |     |             m1 := mload(0x20)
  3418 |     |             m2 := mload(0x40)
  3419 |     |             m3 := mload(0x60)
  3420 |     |             m4 := mload(0x80)
  3421 |     |             m5 := mload(0xa0)
  3422 |     |             m6 := mload(0xc0)
  3423 |     |             // Selector of `log(address,address,string,address)`.
  3424 |     |             mstore(0x00, 0x8f736d16)
  3425 |     |             mstore(0x20, p0)
  3426 |     |             mstore(0x40, p1)
  3427 |     |             mstore(0x60, 0x80)
  3428 |     |             mstore(0x80, p3)
  3429 |     |             writeString(0xa0, p2)
  3430 |     |         }
  3431 |     |         _sendLogPayload(0x1c, 0xc4);
  3432 |     |         /// @solidity memory-safe-assembly
  3433 |     |         assembly {
  3434 |     |             mstore(0x00, m0)
  3435 |     |             mstore(0x20, m1)
  3436 |     |             mstore(0x40, m2)
  3437 |     |             mstore(0x60, m3)
  3438 |     |             mstore(0x80, m4)
  3439 |     |             mstore(0xa0, m5)
  3440 |     |             mstore(0xc0, m6)
  3441 |     |         }
  3442 |     |     }
  3443 |     | 
  3444 |     |     function log(address p0, address p1, bytes32 p2, bool p3) internal pure {
  3445 |     |         bytes32 m0;
  3446 |     |         bytes32 m1;
  3447 |     |         bytes32 m2;
  3448 |     |         bytes32 m3;
  3449 |     |         bytes32 m4;
  3450 |     |         bytes32 m5;
  3451 |     |         bytes32 m6;
  3452 |     |         /// @solidity memory-safe-assembly
  3453 |     |         assembly {
  3454 |     |             function writeString(pos, w) {
  3455 |     |                 let length := 0
  3456 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3457 |     |                 mstore(pos, length)
  3458 |     |                 let shift := sub(256, shl(3, length))
  3459 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3460 |     |             }
  3461 |     |             m0 := mload(0x00)
  3462 |     |             m1 := mload(0x20)
  3463 |     |             m2 := mload(0x40)
  3464 |     |             m3 := mload(0x60)
  3465 |     |             m4 := mload(0x80)
  3466 |     |             m5 := mload(0xa0)
  3467 |     |             m6 := mload(0xc0)
  3468 |     |             // Selector of `log(address,address,string,bool)`.
  3469 |     |             mstore(0x00, 0x6f1a594e)
  3470 |     |             mstore(0x20, p0)
  3471 |     |             mstore(0x40, p1)
  3472 |     |             mstore(0x60, 0x80)
  3473 |     |             mstore(0x80, p3)
  3474 |     |             writeString(0xa0, p2)
  3475 |     |         }
  3476 |     |         _sendLogPayload(0x1c, 0xc4);
  3477 |     |         /// @solidity memory-safe-assembly
  3478 |     |         assembly {
  3479 |     |             mstore(0x00, m0)
  3480 |     |             mstore(0x20, m1)
  3481 |     |             mstore(0x40, m2)
  3482 |     |             mstore(0x60, m3)
  3483 |     |             mstore(0x80, m4)
  3484 |     |             mstore(0xa0, m5)
  3485 |     |             mstore(0xc0, m6)
  3486 |     |         }
  3487 |     |     }
  3488 |     | 
  3489 |     |     function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {
  3490 |     |         bytes32 m0;
  3491 |     |         bytes32 m1;
  3492 |     |         bytes32 m2;
  3493 |     |         bytes32 m3;
  3494 |     |         bytes32 m4;
  3495 |     |         bytes32 m5;
  3496 |     |         bytes32 m6;
  3497 |     |         /// @solidity memory-safe-assembly
  3498 |     |         assembly {
  3499 |     |             function writeString(pos, w) {
  3500 |     |                 let length := 0
  3501 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3502 |     |                 mstore(pos, length)
  3503 |     |                 let shift := sub(256, shl(3, length))
  3504 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3505 |     |             }
  3506 |     |             m0 := mload(0x00)
  3507 |     |             m1 := mload(0x20)
  3508 |     |             m2 := mload(0x40)
  3509 |     |             m3 := mload(0x60)
  3510 |     |             m4 := mload(0x80)
  3511 |     |             m5 := mload(0xa0)
  3512 |     |             m6 := mload(0xc0)
  3513 |     |             // Selector of `log(address,address,string,uint256)`.
  3514 |     |             mstore(0x00, 0xef1cefe7)
  3515 |     |             mstore(0x20, p0)
  3516 |     |             mstore(0x40, p1)
  3517 |     |             mstore(0x60, 0x80)
  3518 |     |             mstore(0x80, p3)
  3519 |     |             writeString(0xa0, p2)
  3520 |     |         }
  3521 |     |         _sendLogPayload(0x1c, 0xc4);
  3522 |     |         /// @solidity memory-safe-assembly
  3523 |     |         assembly {
  3524 |     |             mstore(0x00, m0)
  3525 |     |             mstore(0x20, m1)
  3526 |     |             mstore(0x40, m2)
  3527 |     |             mstore(0x60, m3)
  3528 |     |             mstore(0x80, m4)
  3529 |     |             mstore(0xa0, m5)
  3530 |     |             mstore(0xc0, m6)
  3531 |     |         }
  3532 |     |     }
  3533 |     | 
  3534 |     |     function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  3535 |     |         bytes32 m0;
  3536 |     |         bytes32 m1;
  3537 |     |         bytes32 m2;
  3538 |     |         bytes32 m3;
  3539 |     |         bytes32 m4;
  3540 |     |         bytes32 m5;
  3541 |     |         bytes32 m6;
  3542 |     |         bytes32 m7;
  3543 |     |         bytes32 m8;
  3544 |     |         /// @solidity memory-safe-assembly
  3545 |     |         assembly {
  3546 |     |             function writeString(pos, w) {
  3547 |     |                 let length := 0
  3548 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3549 |     |                 mstore(pos, length)
  3550 |     |                 let shift := sub(256, shl(3, length))
  3551 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3552 |     |             }
  3553 |     |             m0 := mload(0x00)
  3554 |     |             m1 := mload(0x20)
  3555 |     |             m2 := mload(0x40)
  3556 |     |             m3 := mload(0x60)
  3557 |     |             m4 := mload(0x80)
  3558 |     |             m5 := mload(0xa0)
  3559 |     |             m6 := mload(0xc0)
  3560 |     |             m7 := mload(0xe0)
  3561 |     |             m8 := mload(0x100)
  3562 |     |             // Selector of `log(address,address,string,string)`.
  3563 |     |             mstore(0x00, 0x21bdaf25)
  3564 |     |             mstore(0x20, p0)
  3565 |     |             mstore(0x40, p1)
  3566 |     |             mstore(0x60, 0x80)
  3567 |     |             mstore(0x80, 0xc0)
  3568 |     |             writeString(0xa0, p2)
  3569 |     |             writeString(0xe0, p3)
  3570 |     |         }
  3571 |     |         _sendLogPayload(0x1c, 0x104);
  3572 |     |         /// @solidity memory-safe-assembly
  3573 |     |         assembly {
  3574 |     |             mstore(0x00, m0)
  3575 |     |             mstore(0x20, m1)
  3576 |     |             mstore(0x40, m2)
  3577 |     |             mstore(0x60, m3)
  3578 |     |             mstore(0x80, m4)
  3579 |     |             mstore(0xa0, m5)
  3580 |     |             mstore(0xc0, m6)
  3581 |     |             mstore(0xe0, m7)
  3582 |     |             mstore(0x100, m8)
  3583 |     |         }
  3584 |     |     }
  3585 |     | 
  3586 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
  3587 |     |         bytes32 m0;
  3588 |     |         bytes32 m1;
  3589 |     |         bytes32 m2;
  3590 |     |         bytes32 m3;
  3591 |     |         bytes32 m4;
  3592 |     |         /// @solidity memory-safe-assembly
  3593 |     |         assembly {
  3594 |     |             m0 := mload(0x00)
  3595 |     |             m1 := mload(0x20)
  3596 |     |             m2 := mload(0x40)
  3597 |     |             m3 := mload(0x60)
  3598 |     |             m4 := mload(0x80)
  3599 |     |             // Selector of `log(address,bool,address,address)`.
  3600 |     |             mstore(0x00, 0x660375dd)
  3601 |     |             mstore(0x20, p0)
  3602 |     |             mstore(0x40, p1)
  3603 |     |             mstore(0x60, p2)
  3604 |     |             mstore(0x80, p3)
  3605 |     |         }
  3606 |     |         _sendLogPayload(0x1c, 0x84);
  3607 |     |         /// @solidity memory-safe-assembly
  3608 |     |         assembly {
  3609 |     |             mstore(0x00, m0)
  3610 |     |             mstore(0x20, m1)
  3611 |     |             mstore(0x40, m2)
  3612 |     |             mstore(0x60, m3)
  3613 |     |             mstore(0x80, m4)
  3614 |     |         }
  3615 |     |     }
  3616 |     | 
  3617 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
  3618 |     |         bytes32 m0;
  3619 |     |         bytes32 m1;
  3620 |     |         bytes32 m2;
  3621 |     |         bytes32 m3;
  3622 |     |         bytes32 m4;
  3623 |     |         /// @solidity memory-safe-assembly
  3624 |     |         assembly {
  3625 |     |             m0 := mload(0x00)
  3626 |     |             m1 := mload(0x20)
  3627 |     |             m2 := mload(0x40)
  3628 |     |             m3 := mload(0x60)
  3629 |     |             m4 := mload(0x80)
  3630 |     |             // Selector of `log(address,bool,address,bool)`.
  3631 |     |             mstore(0x00, 0xa6f50b0f)
  3632 |     |             mstore(0x20, p0)
  3633 |     |             mstore(0x40, p1)
  3634 |     |             mstore(0x60, p2)
  3635 |     |             mstore(0x80, p3)
  3636 |     |         }
  3637 |     |         _sendLogPayload(0x1c, 0x84);
  3638 |     |         /// @solidity memory-safe-assembly
  3639 |     |         assembly {
  3640 |     |             mstore(0x00, m0)
  3641 |     |             mstore(0x20, m1)
  3642 |     |             mstore(0x40, m2)
  3643 |     |             mstore(0x60, m3)
  3644 |     |             mstore(0x80, m4)
  3645 |     |         }
  3646 |     |     }
  3647 |     | 
  3648 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal pure {
  3649 |     |         bytes32 m0;
  3650 |     |         bytes32 m1;
  3651 |     |         bytes32 m2;
  3652 |     |         bytes32 m3;
  3653 |     |         bytes32 m4;
  3654 |     |         /// @solidity memory-safe-assembly
  3655 |     |         assembly {
  3656 |     |             m0 := mload(0x00)
  3657 |     |             m1 := mload(0x20)
  3658 |     |             m2 := mload(0x40)
  3659 |     |             m3 := mload(0x60)
  3660 |     |             m4 := mload(0x80)
  3661 |     |             // Selector of `log(address,bool,address,uint256)`.
  3662 |     |             mstore(0x00, 0xa75c59de)
  3663 |     |             mstore(0x20, p0)
  3664 |     |             mstore(0x40, p1)
  3665 |     |             mstore(0x60, p2)
  3666 |     |             mstore(0x80, p3)
  3667 |     |         }
  3668 |     |         _sendLogPayload(0x1c, 0x84);
  3669 |     |         /// @solidity memory-safe-assembly
  3670 |     |         assembly {
  3671 |     |             mstore(0x00, m0)
  3672 |     |             mstore(0x20, m1)
  3673 |     |             mstore(0x40, m2)
  3674 |     |             mstore(0x60, m3)
  3675 |     |             mstore(0x80, m4)
  3676 |     |         }
  3677 |     |     }
  3678 |     | 
  3679 |     |     function log(address p0, bool p1, address p2, bytes32 p3) internal pure {
  3680 |     |         bytes32 m0;
  3681 |     |         bytes32 m1;
  3682 |     |         bytes32 m2;
  3683 |     |         bytes32 m3;
  3684 |     |         bytes32 m4;
  3685 |     |         bytes32 m5;
  3686 |     |         bytes32 m6;
  3687 |     |         /// @solidity memory-safe-assembly
  3688 |     |         assembly {
  3689 |     |             function writeString(pos, w) {
  3690 |     |                 let length := 0
  3691 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3692 |     |                 mstore(pos, length)
  3693 |     |                 let shift := sub(256, shl(3, length))
  3694 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3695 |     |             }
  3696 |     |             m0 := mload(0x00)
  3697 |     |             m1 := mload(0x20)
  3698 |     |             m2 := mload(0x40)
  3699 |     |             m3 := mload(0x60)
  3700 |     |             m4 := mload(0x80)
  3701 |     |             m5 := mload(0xa0)
  3702 |     |             m6 := mload(0xc0)
  3703 |     |             // Selector of `log(address,bool,address,string)`.
  3704 |     |             mstore(0x00, 0x2dd778e6)
  3705 |     |             mstore(0x20, p0)
  3706 |     |             mstore(0x40, p1)
  3707 |     |             mstore(0x60, p2)
  3708 |     |             mstore(0x80, 0x80)
  3709 |     |             writeString(0xa0, p3)
  3710 |     |         }
  3711 |     |         _sendLogPayload(0x1c, 0xc4);
  3712 |     |         /// @solidity memory-safe-assembly
  3713 |     |         assembly {
  3714 |     |             mstore(0x00, m0)
  3715 |     |             mstore(0x20, m1)
  3716 |     |             mstore(0x40, m2)
  3717 |     |             mstore(0x60, m3)
  3718 |     |             mstore(0x80, m4)
  3719 |     |             mstore(0xa0, m5)
  3720 |     |             mstore(0xc0, m6)
  3721 |     |         }
  3722 |     |     }
  3723 |     | 
  3724 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
  3725 |     |         bytes32 m0;
  3726 |     |         bytes32 m1;
  3727 |     |         bytes32 m2;
  3728 |     |         bytes32 m3;
  3729 |     |         bytes32 m4;
  3730 |     |         /// @solidity memory-safe-assembly
  3731 |     |         assembly {
  3732 |     |             m0 := mload(0x00)
  3733 |     |             m1 := mload(0x20)
  3734 |     |             m2 := mload(0x40)
  3735 |     |             m3 := mload(0x60)
  3736 |     |             m4 := mload(0x80)
  3737 |     |             // Selector of `log(address,bool,bool,address)`.
  3738 |     |             mstore(0x00, 0xcf394485)
  3739 |     |             mstore(0x20, p0)
  3740 |     |             mstore(0x40, p1)
  3741 |     |             mstore(0x60, p2)
  3742 |     |             mstore(0x80, p3)
  3743 |     |         }
  3744 |     |         _sendLogPayload(0x1c, 0x84);
  3745 |     |         /// @solidity memory-safe-assembly
  3746 |     |         assembly {
  3747 |     |             mstore(0x00, m0)
  3748 |     |             mstore(0x20, m1)
  3749 |     |             mstore(0x40, m2)
  3750 |     |             mstore(0x60, m3)
  3751 |     |             mstore(0x80, m4)
  3752 |     |         }
  3753 |     |     }
  3754 |     | 
  3755 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
  3756 |     |         bytes32 m0;
  3757 |     |         bytes32 m1;
  3758 |     |         bytes32 m2;
  3759 |     |         bytes32 m3;
  3760 |     |         bytes32 m4;
  3761 |     |         /// @solidity memory-safe-assembly
  3762 |     |         assembly {
  3763 |     |             m0 := mload(0x00)
  3764 |     |             m1 := mload(0x20)
  3765 |     |             m2 := mload(0x40)
  3766 |     |             m3 := mload(0x60)
  3767 |     |             m4 := mload(0x80)
  3768 |     |             // Selector of `log(address,bool,bool,bool)`.
  3769 |     |             mstore(0x00, 0xcac43479)
  3770 |     |             mstore(0x20, p0)
  3771 |     |             mstore(0x40, p1)
  3772 |     |             mstore(0x60, p2)
  3773 |     |             mstore(0x80, p3)
  3774 |     |         }
  3775 |     |         _sendLogPayload(0x1c, 0x84);
  3776 |     |         /// @solidity memory-safe-assembly
  3777 |     |         assembly {
  3778 |     |             mstore(0x00, m0)
  3779 |     |             mstore(0x20, m1)
  3780 |     |             mstore(0x40, m2)
  3781 |     |             mstore(0x60, m3)
  3782 |     |             mstore(0x80, m4)
  3783 |     |         }
  3784 |     |     }
  3785 |     | 
  3786 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal pure {
  3787 |     |         bytes32 m0;
  3788 |     |         bytes32 m1;
  3789 |     |         bytes32 m2;
  3790 |     |         bytes32 m3;
  3791 |     |         bytes32 m4;
  3792 |     |         /// @solidity memory-safe-assembly
  3793 |     |         assembly {
  3794 |     |             m0 := mload(0x00)
  3795 |     |             m1 := mload(0x20)
  3796 |     |             m2 := mload(0x40)
  3797 |     |             m3 := mload(0x60)
  3798 |     |             m4 := mload(0x80)
  3799 |     |             // Selector of `log(address,bool,bool,uint256)`.
  3800 |     |             mstore(0x00, 0x8c4e5de6)
  3801 |     |             mstore(0x20, p0)
  3802 |     |             mstore(0x40, p1)
  3803 |     |             mstore(0x60, p2)
  3804 |     |             mstore(0x80, p3)
  3805 |     |         }
  3806 |     |         _sendLogPayload(0x1c, 0x84);
  3807 |     |         /// @solidity memory-safe-assembly
  3808 |     |         assembly {
  3809 |     |             mstore(0x00, m0)
  3810 |     |             mstore(0x20, m1)
  3811 |     |             mstore(0x40, m2)
  3812 |     |             mstore(0x60, m3)
  3813 |     |             mstore(0x80, m4)
  3814 |     |         }
  3815 |     |     }
  3816 |     | 
  3817 |     |     function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {
  3818 |     |         bytes32 m0;
  3819 |     |         bytes32 m1;
  3820 |     |         bytes32 m2;
  3821 |     |         bytes32 m3;
  3822 |     |         bytes32 m4;
  3823 |     |         bytes32 m5;
  3824 |     |         bytes32 m6;
  3825 |     |         /// @solidity memory-safe-assembly
  3826 |     |         assembly {
  3827 |     |             function writeString(pos, w) {
  3828 |     |                 let length := 0
  3829 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3830 |     |                 mstore(pos, length)
  3831 |     |                 let shift := sub(256, shl(3, length))
  3832 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3833 |     |             }
  3834 |     |             m0 := mload(0x00)
  3835 |     |             m1 := mload(0x20)
  3836 |     |             m2 := mload(0x40)
  3837 |     |             m3 := mload(0x60)
  3838 |     |             m4 := mload(0x80)
  3839 |     |             m5 := mload(0xa0)
  3840 |     |             m6 := mload(0xc0)
  3841 |     |             // Selector of `log(address,bool,bool,string)`.
  3842 |     |             mstore(0x00, 0xdfc4a2e8)
  3843 |     |             mstore(0x20, p0)
  3844 |     |             mstore(0x40, p1)
  3845 |     |             mstore(0x60, p2)
  3846 |     |             mstore(0x80, 0x80)
  3847 |     |             writeString(0xa0, p3)
  3848 |     |         }
  3849 |     |         _sendLogPayload(0x1c, 0xc4);
  3850 |     |         /// @solidity memory-safe-assembly
  3851 |     |         assembly {
  3852 |     |             mstore(0x00, m0)
  3853 |     |             mstore(0x20, m1)
  3854 |     |             mstore(0x40, m2)
  3855 |     |             mstore(0x60, m3)
  3856 |     |             mstore(0x80, m4)
  3857 |     |             mstore(0xa0, m5)
  3858 |     |             mstore(0xc0, m6)
  3859 |     |         }
  3860 |     |     }
  3861 |     | 
  3862 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal pure {
  3863 |     |         bytes32 m0;
  3864 |     |         bytes32 m1;
  3865 |     |         bytes32 m2;
  3866 |     |         bytes32 m3;
  3867 |     |         bytes32 m4;
  3868 |     |         /// @solidity memory-safe-assembly
  3869 |     |         assembly {
  3870 |     |             m0 := mload(0x00)
  3871 |     |             m1 := mload(0x20)
  3872 |     |             m2 := mload(0x40)
  3873 |     |             m3 := mload(0x60)
  3874 |     |             m4 := mload(0x80)
  3875 |     |             // Selector of `log(address,bool,uint256,address)`.
  3876 |     |             mstore(0x00, 0xccf790a1)
  3877 |     |             mstore(0x20, p0)
  3878 |     |             mstore(0x40, p1)
  3879 |     |             mstore(0x60, p2)
  3880 |     |             mstore(0x80, p3)
  3881 |     |         }
  3882 |     |         _sendLogPayload(0x1c, 0x84);
  3883 |     |         /// @solidity memory-safe-assembly
  3884 |     |         assembly {
  3885 |     |             mstore(0x00, m0)
  3886 |     |             mstore(0x20, m1)
  3887 |     |             mstore(0x40, m2)
  3888 |     |             mstore(0x60, m3)
  3889 |     |             mstore(0x80, m4)
  3890 |     |         }
  3891 |     |     }
  3892 |     | 
  3893 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal pure {
  3894 |     |         bytes32 m0;
  3895 |     |         bytes32 m1;
  3896 |     |         bytes32 m2;
  3897 |     |         bytes32 m3;
  3898 |     |         bytes32 m4;
  3899 |     |         /// @solidity memory-safe-assembly
  3900 |     |         assembly {
  3901 |     |             m0 := mload(0x00)
  3902 |     |             m1 := mload(0x20)
  3903 |     |             m2 := mload(0x40)
  3904 |     |             m3 := mload(0x60)
  3905 |     |             m4 := mload(0x80)
  3906 |     |             // Selector of `log(address,bool,uint256,bool)`.
  3907 |     |             mstore(0x00, 0xc4643e20)
  3908 |     |             mstore(0x20, p0)
  3909 |     |             mstore(0x40, p1)
  3910 |     |             mstore(0x60, p2)
  3911 |     |             mstore(0x80, p3)
  3912 |     |         }
  3913 |     |         _sendLogPayload(0x1c, 0x84);
  3914 |     |         /// @solidity memory-safe-assembly
  3915 |     |         assembly {
  3916 |     |             mstore(0x00, m0)
  3917 |     |             mstore(0x20, m1)
  3918 |     |             mstore(0x40, m2)
  3919 |     |             mstore(0x60, m3)
  3920 |     |             mstore(0x80, m4)
  3921 |     |         }
  3922 |     |     }
  3923 |     | 
  3924 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {
  3925 |     |         bytes32 m0;
  3926 |     |         bytes32 m1;
  3927 |     |         bytes32 m2;
  3928 |     |         bytes32 m3;
  3929 |     |         bytes32 m4;
  3930 |     |         /// @solidity memory-safe-assembly
  3931 |     |         assembly {
  3932 |     |             m0 := mload(0x00)
  3933 |     |             m1 := mload(0x20)
  3934 |     |             m2 := mload(0x40)
  3935 |     |             m3 := mload(0x60)
  3936 |     |             m4 := mload(0x80)
  3937 |     |             // Selector of `log(address,bool,uint256,uint256)`.
  3938 |     |             mstore(0x00, 0x386ff5f4)
  3939 |     |             mstore(0x20, p0)
  3940 |     |             mstore(0x40, p1)
  3941 |     |             mstore(0x60, p2)
  3942 |     |             mstore(0x80, p3)
  3943 |     |         }
  3944 |     |         _sendLogPayload(0x1c, 0x84);
  3945 |     |         /// @solidity memory-safe-assembly
  3946 |     |         assembly {
  3947 |     |             mstore(0x00, m0)
  3948 |     |             mstore(0x20, m1)
  3949 |     |             mstore(0x40, m2)
  3950 |     |             mstore(0x60, m3)
  3951 |     |             mstore(0x80, m4)
  3952 |     |         }
  3953 |     |     }
  3954 |     | 
  3955 |     |     function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  3956 |     |         bytes32 m0;
  3957 |     |         bytes32 m1;
  3958 |     |         bytes32 m2;
  3959 |     |         bytes32 m3;
  3960 |     |         bytes32 m4;
  3961 |     |         bytes32 m5;
  3962 |     |         bytes32 m6;
  3963 |     |         /// @solidity memory-safe-assembly
  3964 |     |         assembly {
  3965 |     |             function writeString(pos, w) {
  3966 |     |                 let length := 0
  3967 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3968 |     |                 mstore(pos, length)
  3969 |     |                 let shift := sub(256, shl(3, length))
  3970 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3971 |     |             }
  3972 |     |             m0 := mload(0x00)
  3973 |     |             m1 := mload(0x20)
  3974 |     |             m2 := mload(0x40)
  3975 |     |             m3 := mload(0x60)
  3976 |     |             m4 := mload(0x80)
  3977 |     |             m5 := mload(0xa0)
  3978 |     |             m6 := mload(0xc0)
  3979 |     |             // Selector of `log(address,bool,uint256,string)`.
  3980 |     |             mstore(0x00, 0x0aa6cfad)
  3981 |     |             mstore(0x20, p0)
  3982 |     |             mstore(0x40, p1)
  3983 |     |             mstore(0x60, p2)
  3984 |     |             mstore(0x80, 0x80)
  3985 |     |             writeString(0xa0, p3)
  3986 |     |         }
  3987 |     |         _sendLogPayload(0x1c, 0xc4);
  3988 |     |         /// @solidity memory-safe-assembly
  3989 |     |         assembly {
  3990 |     |             mstore(0x00, m0)
  3991 |     |             mstore(0x20, m1)
  3992 |     |             mstore(0x40, m2)
  3993 |     |             mstore(0x60, m3)
  3994 |     |             mstore(0x80, m4)
  3995 |     |             mstore(0xa0, m5)
  3996 |     |             mstore(0xc0, m6)
  3997 |     |         }
  3998 |     |     }
  3999 |     | 
  4000 |     |     function log(address p0, bool p1, bytes32 p2, address p3) internal pure {
  4001 |     |         bytes32 m0;
  4002 |     |         bytes32 m1;
  4003 |     |         bytes32 m2;
  4004 |     |         bytes32 m3;
  4005 |     |         bytes32 m4;
  4006 |     |         bytes32 m5;
  4007 |     |         bytes32 m6;
  4008 |     |         /// @solidity memory-safe-assembly
  4009 |     |         assembly {
  4010 |     |             function writeString(pos, w) {
  4011 |     |                 let length := 0
  4012 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4013 |     |                 mstore(pos, length)
  4014 |     |                 let shift := sub(256, shl(3, length))
  4015 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4016 |     |             }
  4017 |     |             m0 := mload(0x00)
  4018 |     |             m1 := mload(0x20)
  4019 |     |             m2 := mload(0x40)
  4020 |     |             m3 := mload(0x60)
  4021 |     |             m4 := mload(0x80)
  4022 |     |             m5 := mload(0xa0)
  4023 |     |             m6 := mload(0xc0)
  4024 |     |             // Selector of `log(address,bool,string,address)`.
  4025 |     |             mstore(0x00, 0x19fd4956)
  4026 |     |             mstore(0x20, p0)
  4027 |     |             mstore(0x40, p1)
  4028 |     |             mstore(0x60, 0x80)
  4029 |     |             mstore(0x80, p3)
  4030 |     |             writeString(0xa0, p2)
  4031 |     |         }
  4032 |     |         _sendLogPayload(0x1c, 0xc4);
  4033 |     |         /// @solidity memory-safe-assembly
  4034 |     |         assembly {
  4035 |     |             mstore(0x00, m0)
  4036 |     |             mstore(0x20, m1)
  4037 |     |             mstore(0x40, m2)
  4038 |     |             mstore(0x60, m3)
  4039 |     |             mstore(0x80, m4)
  4040 |     |             mstore(0xa0, m5)
  4041 |     |             mstore(0xc0, m6)
  4042 |     |         }
  4043 |     |     }
  4044 |     | 
  4045 |     |     function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {
  4046 |     |         bytes32 m0;
  4047 |     |         bytes32 m1;
  4048 |     |         bytes32 m2;
  4049 |     |         bytes32 m3;
  4050 |     |         bytes32 m4;
  4051 |     |         bytes32 m5;
  4052 |     |         bytes32 m6;
  4053 |     |         /// @solidity memory-safe-assembly
  4054 |     |         assembly {
  4055 |     |             function writeString(pos, w) {
  4056 |     |                 let length := 0
  4057 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4058 |     |                 mstore(pos, length)
  4059 |     |                 let shift := sub(256, shl(3, length))
  4060 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4061 |     |             }
  4062 |     |             m0 := mload(0x00)
  4063 |     |             m1 := mload(0x20)
  4064 |     |             m2 := mload(0x40)
  4065 |     |             m3 := mload(0x60)
  4066 |     |             m4 := mload(0x80)
  4067 |     |             m5 := mload(0xa0)
  4068 |     |             m6 := mload(0xc0)
  4069 |     |             // Selector of `log(address,bool,string,bool)`.
  4070 |     |             mstore(0x00, 0x50ad461d)
  4071 |     |             mstore(0x20, p0)
  4072 |     |             mstore(0x40, p1)
  4073 |     |             mstore(0x60, 0x80)
  4074 |     |             mstore(0x80, p3)
  4075 |     |             writeString(0xa0, p2)
  4076 |     |         }
  4077 |     |         _sendLogPayload(0x1c, 0xc4);
  4078 |     |         /// @solidity memory-safe-assembly
  4079 |     |         assembly {
  4080 |     |             mstore(0x00, m0)
  4081 |     |             mstore(0x20, m1)
  4082 |     |             mstore(0x40, m2)
  4083 |     |             mstore(0x60, m3)
  4084 |     |             mstore(0x80, m4)
  4085 |     |             mstore(0xa0, m5)
  4086 |     |             mstore(0xc0, m6)
  4087 |     |         }
  4088 |     |     }
  4089 |     | 
  4090 |     |     function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  4091 |     |         bytes32 m0;
  4092 |     |         bytes32 m1;
  4093 |     |         bytes32 m2;
  4094 |     |         bytes32 m3;
  4095 |     |         bytes32 m4;
  4096 |     |         bytes32 m5;
  4097 |     |         bytes32 m6;
  4098 |     |         /// @solidity memory-safe-assembly
  4099 |     |         assembly {
  4100 |     |             function writeString(pos, w) {
  4101 |     |                 let length := 0
  4102 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4103 |     |                 mstore(pos, length)
  4104 |     |                 let shift := sub(256, shl(3, length))
  4105 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4106 |     |             }
  4107 |     |             m0 := mload(0x00)
  4108 |     |             m1 := mload(0x20)
  4109 |     |             m2 := mload(0x40)
  4110 |     |             m3 := mload(0x60)
  4111 |     |             m4 := mload(0x80)
  4112 |     |             m5 := mload(0xa0)
  4113 |     |             m6 := mload(0xc0)
  4114 |     |             // Selector of `log(address,bool,string,uint256)`.
  4115 |     |             mstore(0x00, 0x80e6a20b)
  4116 |     |             mstore(0x20, p0)
  4117 |     |             mstore(0x40, p1)
  4118 |     |             mstore(0x60, 0x80)
  4119 |     |             mstore(0x80, p3)
  4120 |     |             writeString(0xa0, p2)
  4121 |     |         }
  4122 |     |         _sendLogPayload(0x1c, 0xc4);
  4123 |     |         /// @solidity memory-safe-assembly
  4124 |     |         assembly {
  4125 |     |             mstore(0x00, m0)
  4126 |     |             mstore(0x20, m1)
  4127 |     |             mstore(0x40, m2)
  4128 |     |             mstore(0x60, m3)
  4129 |     |             mstore(0x80, m4)
  4130 |     |             mstore(0xa0, m5)
  4131 |     |             mstore(0xc0, m6)
  4132 |     |         }
  4133 |     |     }
  4134 |     | 
  4135 |     |     function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  4136 |     |         bytes32 m0;
  4137 |     |         bytes32 m1;
  4138 |     |         bytes32 m2;
  4139 |     |         bytes32 m3;
  4140 |     |         bytes32 m4;
  4141 |     |         bytes32 m5;
  4142 |     |         bytes32 m6;
  4143 |     |         bytes32 m7;
  4144 |     |         bytes32 m8;
  4145 |     |         /// @solidity memory-safe-assembly
  4146 |     |         assembly {
  4147 |     |             function writeString(pos, w) {
  4148 |     |                 let length := 0
  4149 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4150 |     |                 mstore(pos, length)
  4151 |     |                 let shift := sub(256, shl(3, length))
  4152 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4153 |     |             }
  4154 |     |             m0 := mload(0x00)
  4155 |     |             m1 := mload(0x20)
  4156 |     |             m2 := mload(0x40)
  4157 |     |             m3 := mload(0x60)
  4158 |     |             m4 := mload(0x80)
  4159 |     |             m5 := mload(0xa0)
  4160 |     |             m6 := mload(0xc0)
  4161 |     |             m7 := mload(0xe0)
  4162 |     |             m8 := mload(0x100)
  4163 |     |             // Selector of `log(address,bool,string,string)`.
  4164 |     |             mstore(0x00, 0x475c5c33)
  4165 |     |             mstore(0x20, p0)
  4166 |     |             mstore(0x40, p1)
  4167 |     |             mstore(0x60, 0x80)
  4168 |     |             mstore(0x80, 0xc0)
  4169 |     |             writeString(0xa0, p2)
  4170 |     |             writeString(0xe0, p3)
  4171 |     |         }
  4172 |     |         _sendLogPayload(0x1c, 0x104);
  4173 |     |         /// @solidity memory-safe-assembly
  4174 |     |         assembly {
  4175 |     |             mstore(0x00, m0)
  4176 |     |             mstore(0x20, m1)
  4177 |     |             mstore(0x40, m2)
  4178 |     |             mstore(0x60, m3)
  4179 |     |             mstore(0x80, m4)
  4180 |     |             mstore(0xa0, m5)
  4181 |     |             mstore(0xc0, m6)
  4182 |     |             mstore(0xe0, m7)
  4183 |     |             mstore(0x100, m8)
  4184 |     |         }
  4185 |     |     }
  4186 |     | 
  4187 |     |     function log(address p0, uint256 p1, address p2, address p3) internal pure {
  4188 |     |         bytes32 m0;
  4189 |     |         bytes32 m1;
  4190 |     |         bytes32 m2;
  4191 |     |         bytes32 m3;
  4192 |     |         bytes32 m4;
  4193 |     |         /// @solidity memory-safe-assembly
  4194 |     |         assembly {
  4195 |     |             m0 := mload(0x00)
  4196 |     |             m1 := mload(0x20)
  4197 |     |             m2 := mload(0x40)
  4198 |     |             m3 := mload(0x60)
  4199 |     |             m4 := mload(0x80)
  4200 |     |             // Selector of `log(address,uint256,address,address)`.
  4201 |     |             mstore(0x00, 0x478d1c62)
  4202 |     |             mstore(0x20, p0)
  4203 |     |             mstore(0x40, p1)
  4204 |     |             mstore(0x60, p2)
  4205 |     |             mstore(0x80, p3)
  4206 |     |         }
  4207 |     |         _sendLogPayload(0x1c, 0x84);
  4208 |     |         /// @solidity memory-safe-assembly
  4209 |     |         assembly {
  4210 |     |             mstore(0x00, m0)
  4211 |     |             mstore(0x20, m1)
  4212 |     |             mstore(0x40, m2)
  4213 |     |             mstore(0x60, m3)
  4214 |     |             mstore(0x80, m4)
  4215 |     |         }
  4216 |     |     }
  4217 |     | 
  4218 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal pure {
  4219 |     |         bytes32 m0;
  4220 |     |         bytes32 m1;
  4221 |     |         bytes32 m2;
  4222 |     |         bytes32 m3;
  4223 |     |         bytes32 m4;
  4224 |     |         /// @solidity memory-safe-assembly
  4225 |     |         assembly {
  4226 |     |             m0 := mload(0x00)
  4227 |     |             m1 := mload(0x20)
  4228 |     |             m2 := mload(0x40)
  4229 |     |             m3 := mload(0x60)
  4230 |     |             m4 := mload(0x80)
  4231 |     |             // Selector of `log(address,uint256,address,bool)`.
  4232 |     |             mstore(0x00, 0xa1bcc9b3)
  4233 |     |             mstore(0x20, p0)
  4234 |     |             mstore(0x40, p1)
  4235 |     |             mstore(0x60, p2)
  4236 |     |             mstore(0x80, p3)
  4237 |     |         }
  4238 |     |         _sendLogPayload(0x1c, 0x84);
  4239 |     |         /// @solidity memory-safe-assembly
  4240 |     |         assembly {
  4241 |     |             mstore(0x00, m0)
  4242 |     |             mstore(0x20, m1)
  4243 |     |             mstore(0x40, m2)
  4244 |     |             mstore(0x60, m3)
  4245 |     |             mstore(0x80, m4)
  4246 |     |         }
  4247 |     |     }
  4248 |     | 
  4249 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {
  4250 |     |         bytes32 m0;
  4251 |     |         bytes32 m1;
  4252 |     |         bytes32 m2;
  4253 |     |         bytes32 m3;
  4254 |     |         bytes32 m4;
  4255 |     |         /// @solidity memory-safe-assembly
  4256 |     |         assembly {
  4257 |     |             m0 := mload(0x00)
  4258 |     |             m1 := mload(0x20)
  4259 |     |             m2 := mload(0x40)
  4260 |     |             m3 := mload(0x60)
  4261 |     |             m4 := mload(0x80)
  4262 |     |             // Selector of `log(address,uint256,address,uint256)`.
  4263 |     |             mstore(0x00, 0x100f650e)
  4264 |     |             mstore(0x20, p0)
  4265 |     |             mstore(0x40, p1)
  4266 |     |             mstore(0x60, p2)
  4267 |     |             mstore(0x80, p3)
  4268 |     |         }
  4269 |     |         _sendLogPayload(0x1c, 0x84);
  4270 |     |         /// @solidity memory-safe-assembly
  4271 |     |         assembly {
  4272 |     |             mstore(0x00, m0)
  4273 |     |             mstore(0x20, m1)
  4274 |     |             mstore(0x40, m2)
  4275 |     |             mstore(0x60, m3)
  4276 |     |             mstore(0x80, m4)
  4277 |     |         }
  4278 |     |     }
  4279 |     | 
  4280 |     |     function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {
  4281 |     |         bytes32 m0;
  4282 |     |         bytes32 m1;
  4283 |     |         bytes32 m2;
  4284 |     |         bytes32 m3;
  4285 |     |         bytes32 m4;
  4286 |     |         bytes32 m5;
  4287 |     |         bytes32 m6;
  4288 |     |         /// @solidity memory-safe-assembly
  4289 |     |         assembly {
  4290 |     |             function writeString(pos, w) {
  4291 |     |                 let length := 0
  4292 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4293 |     |                 mstore(pos, length)
  4294 |     |                 let shift := sub(256, shl(3, length))
  4295 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4296 |     |             }
  4297 |     |             m0 := mload(0x00)
  4298 |     |             m1 := mload(0x20)
  4299 |     |             m2 := mload(0x40)
  4300 |     |             m3 := mload(0x60)
  4301 |     |             m4 := mload(0x80)
  4302 |     |             m5 := mload(0xa0)
  4303 |     |             m6 := mload(0xc0)
  4304 |     |             // Selector of `log(address,uint256,address,string)`.
  4305 |     |             mstore(0x00, 0x1da986ea)
  4306 |     |             mstore(0x20, p0)
  4307 |     |             mstore(0x40, p1)
  4308 |     |             mstore(0x60, p2)
  4309 |     |             mstore(0x80, 0x80)
  4310 |     |             writeString(0xa0, p3)
  4311 |     |         }
  4312 |     |         _sendLogPayload(0x1c, 0xc4);
  4313 |     |         /// @solidity memory-safe-assembly
  4314 |     |         assembly {
  4315 |     |             mstore(0x00, m0)
  4316 |     |             mstore(0x20, m1)
  4317 |     |             mstore(0x40, m2)
  4318 |     |             mstore(0x60, m3)
  4319 |     |             mstore(0x80, m4)
  4320 |     |             mstore(0xa0, m5)
  4321 |     |             mstore(0xc0, m6)
  4322 |     |         }
  4323 |     |     }
  4324 |     | 
  4325 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal pure {
  4326 |     |         bytes32 m0;
  4327 |     |         bytes32 m1;
  4328 |     |         bytes32 m2;
  4329 |     |         bytes32 m3;
  4330 |     |         bytes32 m4;
  4331 |     |         /// @solidity memory-safe-assembly
  4332 |     |         assembly {
  4333 |     |             m0 := mload(0x00)
  4334 |     |             m1 := mload(0x20)
  4335 |     |             m2 := mload(0x40)
  4336 |     |             m3 := mload(0x60)
  4337 |     |             m4 := mload(0x80)
  4338 |     |             // Selector of `log(address,uint256,bool,address)`.
  4339 |     |             mstore(0x00, 0xa31bfdcc)
  4340 |     |             mstore(0x20, p0)
  4341 |     |             mstore(0x40, p1)
  4342 |     |             mstore(0x60, p2)
  4343 |     |             mstore(0x80, p3)
  4344 |     |         }
  4345 |     |         _sendLogPayload(0x1c, 0x84);
  4346 |     |         /// @solidity memory-safe-assembly
  4347 |     |         assembly {
  4348 |     |             mstore(0x00, m0)
  4349 |     |             mstore(0x20, m1)
  4350 |     |             mstore(0x40, m2)
  4351 |     |             mstore(0x60, m3)
  4352 |     |             mstore(0x80, m4)
  4353 |     |         }
  4354 |     |     }
  4355 |     | 
  4356 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal pure {
  4357 |     |         bytes32 m0;
  4358 |     |         bytes32 m1;
  4359 |     |         bytes32 m2;
  4360 |     |         bytes32 m3;
  4361 |     |         bytes32 m4;
  4362 |     |         /// @solidity memory-safe-assembly
  4363 |     |         assembly {
  4364 |     |             m0 := mload(0x00)
  4365 |     |             m1 := mload(0x20)
  4366 |     |             m2 := mload(0x40)
  4367 |     |             m3 := mload(0x60)
  4368 |     |             m4 := mload(0x80)
  4369 |     |             // Selector of `log(address,uint256,bool,bool)`.
  4370 |     |             mstore(0x00, 0x3bf5e537)
  4371 |     |             mstore(0x20, p0)
  4372 |     |             mstore(0x40, p1)
  4373 |     |             mstore(0x60, p2)
  4374 |     |             mstore(0x80, p3)
  4375 |     |         }
  4376 |     |         _sendLogPayload(0x1c, 0x84);
  4377 |     |         /// @solidity memory-safe-assembly
  4378 |     |         assembly {
  4379 |     |             mstore(0x00, m0)
  4380 |     |             mstore(0x20, m1)
  4381 |     |             mstore(0x40, m2)
  4382 |     |             mstore(0x60, m3)
  4383 |     |             mstore(0x80, m4)
  4384 |     |         }
  4385 |     |     }
  4386 |     | 
  4387 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {
  4388 |     |         bytes32 m0;
  4389 |     |         bytes32 m1;
  4390 |     |         bytes32 m2;
  4391 |     |         bytes32 m3;
  4392 |     |         bytes32 m4;
  4393 |     |         /// @solidity memory-safe-assembly
  4394 |     |         assembly {
  4395 |     |             m0 := mload(0x00)
  4396 |     |             m1 := mload(0x20)
  4397 |     |             m2 := mload(0x40)
  4398 |     |             m3 := mload(0x60)
  4399 |     |             m4 := mload(0x80)
  4400 |     |             // Selector of `log(address,uint256,bool,uint256)`.
  4401 |     |             mstore(0x00, 0x22f6b999)
  4402 |     |             mstore(0x20, p0)
  4403 |     |             mstore(0x40, p1)
  4404 |     |             mstore(0x60, p2)
  4405 |     |             mstore(0x80, p3)
  4406 |     |         }
  4407 |     |         _sendLogPayload(0x1c, 0x84);
  4408 |     |         /// @solidity memory-safe-assembly
  4409 |     |         assembly {
  4410 |     |             mstore(0x00, m0)
  4411 |     |             mstore(0x20, m1)
  4412 |     |             mstore(0x40, m2)
  4413 |     |             mstore(0x60, m3)
  4414 |     |             mstore(0x80, m4)
  4415 |     |         }
  4416 |     |     }
  4417 |     | 
  4418 |     |     function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  4419 |     |         bytes32 m0;
  4420 |     |         bytes32 m1;
  4421 |     |         bytes32 m2;
  4422 |     |         bytes32 m3;
  4423 |     |         bytes32 m4;
  4424 |     |         bytes32 m5;
  4425 |     |         bytes32 m6;
  4426 |     |         /// @solidity memory-safe-assembly
  4427 |     |         assembly {
  4428 |     |             function writeString(pos, w) {
  4429 |     |                 let length := 0
  4430 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4431 |     |                 mstore(pos, length)
  4432 |     |                 let shift := sub(256, shl(3, length))
  4433 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4434 |     |             }
  4435 |     |             m0 := mload(0x00)
  4436 |     |             m1 := mload(0x20)
  4437 |     |             m2 := mload(0x40)
  4438 |     |             m3 := mload(0x60)
  4439 |     |             m4 := mload(0x80)
  4440 |     |             m5 := mload(0xa0)
  4441 |     |             m6 := mload(0xc0)
  4442 |     |             // Selector of `log(address,uint256,bool,string)`.
  4443 |     |             mstore(0x00, 0xc5ad85f9)
  4444 |     |             mstore(0x20, p0)
  4445 |     |             mstore(0x40, p1)
  4446 |     |             mstore(0x60, p2)
  4447 |     |             mstore(0x80, 0x80)
  4448 |     |             writeString(0xa0, p3)
  4449 |     |         }
  4450 |     |         _sendLogPayload(0x1c, 0xc4);
  4451 |     |         /// @solidity memory-safe-assembly
  4452 |     |         assembly {
  4453 |     |             mstore(0x00, m0)
  4454 |     |             mstore(0x20, m1)
  4455 |     |             mstore(0x40, m2)
  4456 |     |             mstore(0x60, m3)
  4457 |     |             mstore(0x80, m4)
  4458 |     |             mstore(0xa0, m5)
  4459 |     |             mstore(0xc0, m6)
  4460 |     |         }
  4461 |     |     }
  4462 |     | 
  4463 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {
  4464 |     |         bytes32 m0;
  4465 |     |         bytes32 m1;
  4466 |     |         bytes32 m2;
  4467 |     |         bytes32 m3;
  4468 |     |         bytes32 m4;
  4469 |     |         /// @solidity memory-safe-assembly
  4470 |     |         assembly {
  4471 |     |             m0 := mload(0x00)
  4472 |     |             m1 := mload(0x20)
  4473 |     |             m2 := mload(0x40)
  4474 |     |             m3 := mload(0x60)
  4475 |     |             m4 := mload(0x80)
  4476 |     |             // Selector of `log(address,uint256,uint256,address)`.
  4477 |     |             mstore(0x00, 0x20e3984d)
  4478 |     |             mstore(0x20, p0)
  4479 |     |             mstore(0x40, p1)
  4480 |     |             mstore(0x60, p2)
  4481 |     |             mstore(0x80, p3)
  4482 |     |         }
  4483 |     |         _sendLogPayload(0x1c, 0x84);
  4484 |     |         /// @solidity memory-safe-assembly
  4485 |     |         assembly {
  4486 |     |             mstore(0x00, m0)
  4487 |     |             mstore(0x20, m1)
  4488 |     |             mstore(0x40, m2)
  4489 |     |             mstore(0x60, m3)
  4490 |     |             mstore(0x80, m4)
  4491 |     |         }
  4492 |     |     }
  4493 |     | 
  4494 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {
  4495 |     |         bytes32 m0;
  4496 |     |         bytes32 m1;
  4497 |     |         bytes32 m2;
  4498 |     |         bytes32 m3;
  4499 |     |         bytes32 m4;
  4500 |     |         /// @solidity memory-safe-assembly
  4501 |     |         assembly {
  4502 |     |             m0 := mload(0x00)
  4503 |     |             m1 := mload(0x20)
  4504 |     |             m2 := mload(0x40)
  4505 |     |             m3 := mload(0x60)
  4506 |     |             m4 := mload(0x80)
  4507 |     |             // Selector of `log(address,uint256,uint256,bool)`.
  4508 |     |             mstore(0x00, 0x66f1bc67)
  4509 |     |             mstore(0x20, p0)
  4510 |     |             mstore(0x40, p1)
  4511 |     |             mstore(0x60, p2)
  4512 |     |             mstore(0x80, p3)
  4513 |     |         }
  4514 |     |         _sendLogPayload(0x1c, 0x84);
  4515 |     |         /// @solidity memory-safe-assembly
  4516 |     |         assembly {
  4517 |     |             mstore(0x00, m0)
  4518 |     |             mstore(0x20, m1)
  4519 |     |             mstore(0x40, m2)
  4520 |     |             mstore(0x60, m3)
  4521 |     |             mstore(0x80, m4)
  4522 |     |         }
  4523 |     |     }
  4524 |     | 
  4525 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  4526 |     |         bytes32 m0;
  4527 |     |         bytes32 m1;
  4528 |     |         bytes32 m2;
  4529 |     |         bytes32 m3;
  4530 |     |         bytes32 m4;
  4531 |     |         /// @solidity memory-safe-assembly
  4532 |     |         assembly {
  4533 |     |             m0 := mload(0x00)
  4534 |     |             m1 := mload(0x20)
  4535 |     |             m2 := mload(0x40)
  4536 |     |             m3 := mload(0x60)
  4537 |     |             m4 := mload(0x80)
  4538 |     |             // Selector of `log(address,uint256,uint256,uint256)`.
  4539 |     |             mstore(0x00, 0x34f0e636)
  4540 |     |             mstore(0x20, p0)
  4541 |     |             mstore(0x40, p1)
  4542 |     |             mstore(0x60, p2)
  4543 |     |             mstore(0x80, p3)
  4544 |     |         }
  4545 |     |         _sendLogPayload(0x1c, 0x84);
  4546 |     |         /// @solidity memory-safe-assembly
  4547 |     |         assembly {
  4548 |     |             mstore(0x00, m0)
  4549 |     |             mstore(0x20, m1)
  4550 |     |             mstore(0x40, m2)
  4551 |     |             mstore(0x60, m3)
  4552 |     |             mstore(0x80, m4)
  4553 |     |         }
  4554 |     |     }
  4555 |     | 
  4556 |     |     function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  4557 |     |         bytes32 m0;
  4558 |     |         bytes32 m1;
  4559 |     |         bytes32 m2;
  4560 |     |         bytes32 m3;
  4561 |     |         bytes32 m4;
  4562 |     |         bytes32 m5;
  4563 |     |         bytes32 m6;
  4564 |     |         /// @solidity memory-safe-assembly
  4565 |     |         assembly {
  4566 |     |             function writeString(pos, w) {
  4567 |     |                 let length := 0
  4568 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4569 |     |                 mstore(pos, length)
  4570 |     |                 let shift := sub(256, shl(3, length))
  4571 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4572 |     |             }
  4573 |     |             m0 := mload(0x00)
  4574 |     |             m1 := mload(0x20)
  4575 |     |             m2 := mload(0x40)
  4576 |     |             m3 := mload(0x60)
  4577 |     |             m4 := mload(0x80)
  4578 |     |             m5 := mload(0xa0)
  4579 |     |             m6 := mload(0xc0)
  4580 |     |             // Selector of `log(address,uint256,uint256,string)`.
  4581 |     |             mstore(0x00, 0x4a28c017)
  4582 |     |             mstore(0x20, p0)
  4583 |     |             mstore(0x40, p1)
  4584 |     |             mstore(0x60, p2)
  4585 |     |             mstore(0x80, 0x80)
  4586 |     |             writeString(0xa0, p3)
  4587 |     |         }
  4588 |     |         _sendLogPayload(0x1c, 0xc4);
  4589 |     |         /// @solidity memory-safe-assembly
  4590 |     |         assembly {
  4591 |     |             mstore(0x00, m0)
  4592 |     |             mstore(0x20, m1)
  4593 |     |             mstore(0x40, m2)
  4594 |     |             mstore(0x60, m3)
  4595 |     |             mstore(0x80, m4)
  4596 |     |             mstore(0xa0, m5)
  4597 |     |             mstore(0xc0, m6)
  4598 |     |         }
  4599 |     |     }
  4600 |     | 
  4601 |     |     function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {
  4602 |     |         bytes32 m0;
  4603 |     |         bytes32 m1;
  4604 |     |         bytes32 m2;
  4605 |     |         bytes32 m3;
  4606 |     |         bytes32 m4;
  4607 |     |         bytes32 m5;
  4608 |     |         bytes32 m6;
  4609 |     |         /// @solidity memory-safe-assembly
  4610 |     |         assembly {
  4611 |     |             function writeString(pos, w) {
  4612 |     |                 let length := 0
  4613 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4614 |     |                 mstore(pos, length)
  4615 |     |                 let shift := sub(256, shl(3, length))
  4616 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4617 |     |             }
  4618 |     |             m0 := mload(0x00)
  4619 |     |             m1 := mload(0x20)
  4620 |     |             m2 := mload(0x40)
  4621 |     |             m3 := mload(0x60)
  4622 |     |             m4 := mload(0x80)
  4623 |     |             m5 := mload(0xa0)
  4624 |     |             m6 := mload(0xc0)
  4625 |     |             // Selector of `log(address,uint256,string,address)`.
  4626 |     |             mstore(0x00, 0x5c430d47)
  4627 |     |             mstore(0x20, p0)
  4628 |     |             mstore(0x40, p1)
  4629 |     |             mstore(0x60, 0x80)
  4630 |     |             mstore(0x80, p3)
  4631 |     |             writeString(0xa0, p2)
  4632 |     |         }
  4633 |     |         _sendLogPayload(0x1c, 0xc4);
  4634 |     |         /// @solidity memory-safe-assembly
  4635 |     |         assembly {
  4636 |     |             mstore(0x00, m0)
  4637 |     |             mstore(0x20, m1)
  4638 |     |             mstore(0x40, m2)
  4639 |     |             mstore(0x60, m3)
  4640 |     |             mstore(0x80, m4)
  4641 |     |             mstore(0xa0, m5)
  4642 |     |             mstore(0xc0, m6)
  4643 |     |         }
  4644 |     |     }
  4645 |     | 
  4646 |     |     function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  4647 |     |         bytes32 m0;
  4648 |     |         bytes32 m1;
  4649 |     |         bytes32 m2;
  4650 |     |         bytes32 m3;
  4651 |     |         bytes32 m4;
  4652 |     |         bytes32 m5;
  4653 |     |         bytes32 m6;
  4654 |     |         /// @solidity memory-safe-assembly
  4655 |     |         assembly {
  4656 |     |             function writeString(pos, w) {
  4657 |     |                 let length := 0
  4658 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4659 |     |                 mstore(pos, length)
  4660 |     |                 let shift := sub(256, shl(3, length))
  4661 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4662 |     |             }
  4663 |     |             m0 := mload(0x00)
  4664 |     |             m1 := mload(0x20)
  4665 |     |             m2 := mload(0x40)
  4666 |     |             m3 := mload(0x60)
  4667 |     |             m4 := mload(0x80)
  4668 |     |             m5 := mload(0xa0)
  4669 |     |             m6 := mload(0xc0)
  4670 |     |             // Selector of `log(address,uint256,string,bool)`.
  4671 |     |             mstore(0x00, 0xcf18105c)
  4672 |     |             mstore(0x20, p0)
  4673 |     |             mstore(0x40, p1)
  4674 |     |             mstore(0x60, 0x80)
  4675 |     |             mstore(0x80, p3)
  4676 |     |             writeString(0xa0, p2)
  4677 |     |         }
  4678 |     |         _sendLogPayload(0x1c, 0xc4);
  4679 |     |         /// @solidity memory-safe-assembly
  4680 |     |         assembly {
  4681 |     |             mstore(0x00, m0)
  4682 |     |             mstore(0x20, m1)
  4683 |     |             mstore(0x40, m2)
  4684 |     |             mstore(0x60, m3)
  4685 |     |             mstore(0x80, m4)
  4686 |     |             mstore(0xa0, m5)
  4687 |     |             mstore(0xc0, m6)
  4688 |     |         }
  4689 |     |     }
  4690 |     | 
  4691 |     |     function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  4692 |     |         bytes32 m0;
  4693 |     |         bytes32 m1;
  4694 |     |         bytes32 m2;
  4695 |     |         bytes32 m3;
  4696 |     |         bytes32 m4;
  4697 |     |         bytes32 m5;
  4698 |     |         bytes32 m6;
  4699 |     |         /// @solidity memory-safe-assembly
  4700 |     |         assembly {
  4701 |     |             function writeString(pos, w) {
  4702 |     |                 let length := 0
  4703 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4704 |     |                 mstore(pos, length)
  4705 |     |                 let shift := sub(256, shl(3, length))
  4706 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4707 |     |             }
  4708 |     |             m0 := mload(0x00)
  4709 |     |             m1 := mload(0x20)
  4710 |     |             m2 := mload(0x40)
  4711 |     |             m3 := mload(0x60)
  4712 |     |             m4 := mload(0x80)
  4713 |     |             m5 := mload(0xa0)
  4714 |     |             m6 := mload(0xc0)
  4715 |     |             // Selector of `log(address,uint256,string,uint256)`.
  4716 |     |             mstore(0x00, 0xbf01f891)
  4717 |     |             mstore(0x20, p0)
  4718 |     |             mstore(0x40, p1)
  4719 |     |             mstore(0x60, 0x80)
  4720 |     |             mstore(0x80, p3)
  4721 |     |             writeString(0xa0, p2)
  4722 |     |         }
  4723 |     |         _sendLogPayload(0x1c, 0xc4);
  4724 |     |         /// @solidity memory-safe-assembly
  4725 |     |         assembly {
  4726 |     |             mstore(0x00, m0)
  4727 |     |             mstore(0x20, m1)
  4728 |     |             mstore(0x40, m2)
  4729 |     |             mstore(0x60, m3)
  4730 |     |             mstore(0x80, m4)
  4731 |     |             mstore(0xa0, m5)
  4732 |     |             mstore(0xc0, m6)
  4733 |     |         }
  4734 |     |     }
  4735 |     | 
  4736 |     |     function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  4737 |     |         bytes32 m0;
  4738 |     |         bytes32 m1;
  4739 |     |         bytes32 m2;
  4740 |     |         bytes32 m3;
  4741 |     |         bytes32 m4;
  4742 |     |         bytes32 m5;
  4743 |     |         bytes32 m6;
  4744 |     |         bytes32 m7;
  4745 |     |         bytes32 m8;
  4746 |     |         /// @solidity memory-safe-assembly
  4747 |     |         assembly {
  4748 |     |             function writeString(pos, w) {
  4749 |     |                 let length := 0
  4750 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4751 |     |                 mstore(pos, length)
  4752 |     |                 let shift := sub(256, shl(3, length))
  4753 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4754 |     |             }
  4755 |     |             m0 := mload(0x00)
  4756 |     |             m1 := mload(0x20)
  4757 |     |             m2 := mload(0x40)
  4758 |     |             m3 := mload(0x60)
  4759 |     |             m4 := mload(0x80)
  4760 |     |             m5 := mload(0xa0)
  4761 |     |             m6 := mload(0xc0)
  4762 |     |             m7 := mload(0xe0)
  4763 |     |             m8 := mload(0x100)
  4764 |     |             // Selector of `log(address,uint256,string,string)`.
  4765 |     |             mstore(0x00, 0x88a8c406)
  4766 |     |             mstore(0x20, p0)
  4767 |     |             mstore(0x40, p1)
  4768 |     |             mstore(0x60, 0x80)
  4769 |     |             mstore(0x80, 0xc0)
  4770 |     |             writeString(0xa0, p2)
  4771 |     |             writeString(0xe0, p3)
  4772 |     |         }
  4773 |     |         _sendLogPayload(0x1c, 0x104);
  4774 |     |         /// @solidity memory-safe-assembly
  4775 |     |         assembly {
  4776 |     |             mstore(0x00, m0)
  4777 |     |             mstore(0x20, m1)
  4778 |     |             mstore(0x40, m2)
  4779 |     |             mstore(0x60, m3)
  4780 |     |             mstore(0x80, m4)
  4781 |     |             mstore(0xa0, m5)
  4782 |     |             mstore(0xc0, m6)
  4783 |     |             mstore(0xe0, m7)
  4784 |     |             mstore(0x100, m8)
  4785 |     |         }
  4786 |     |     }
  4787 |     | 
  4788 |     |     function log(address p0, bytes32 p1, address p2, address p3) internal pure {
  4789 |     |         bytes32 m0;
  4790 |     |         bytes32 m1;
  4791 |     |         bytes32 m2;
  4792 |     |         bytes32 m3;
  4793 |     |         bytes32 m4;
  4794 |     |         bytes32 m5;
  4795 |     |         bytes32 m6;
  4796 |     |         /// @solidity memory-safe-assembly
  4797 |     |         assembly {
  4798 |     |             function writeString(pos, w) {
  4799 |     |                 let length := 0
  4800 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4801 |     |                 mstore(pos, length)
  4802 |     |                 let shift := sub(256, shl(3, length))
  4803 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4804 |     |             }
  4805 |     |             m0 := mload(0x00)
  4806 |     |             m1 := mload(0x20)
  4807 |     |             m2 := mload(0x40)
  4808 |     |             m3 := mload(0x60)
  4809 |     |             m4 := mload(0x80)
  4810 |     |             m5 := mload(0xa0)
  4811 |     |             m6 := mload(0xc0)
  4812 |     |             // Selector of `log(address,string,address,address)`.
  4813 |     |             mstore(0x00, 0x0d36fa20)
  4814 |     |             mstore(0x20, p0)
  4815 |     |             mstore(0x40, 0x80)
  4816 |     |             mstore(0x60, p2)
  4817 |     |             mstore(0x80, p3)
  4818 |     |             writeString(0xa0, p1)
  4819 |     |         }
  4820 |     |         _sendLogPayload(0x1c, 0xc4);
  4821 |     |         /// @solidity memory-safe-assembly
  4822 |     |         assembly {
  4823 |     |             mstore(0x00, m0)
  4824 |     |             mstore(0x20, m1)
  4825 |     |             mstore(0x40, m2)
  4826 |     |             mstore(0x60, m3)
  4827 |     |             mstore(0x80, m4)
  4828 |     |             mstore(0xa0, m5)
  4829 |     |             mstore(0xc0, m6)
  4830 |     |         }
  4831 |     |     }
  4832 |     | 
  4833 |     |     function log(address p0, bytes32 p1, address p2, bool p3) internal pure {
  4834 |     |         bytes32 m0;
  4835 |     |         bytes32 m1;
  4836 |     |         bytes32 m2;
  4837 |     |         bytes32 m3;
  4838 |     |         bytes32 m4;
  4839 |     |         bytes32 m5;
  4840 |     |         bytes32 m6;
  4841 |     |         /// @solidity memory-safe-assembly
  4842 |     |         assembly {
  4843 |     |             function writeString(pos, w) {
  4844 |     |                 let length := 0
  4845 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4846 |     |                 mstore(pos, length)
  4847 |     |                 let shift := sub(256, shl(3, length))
  4848 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4849 |     |             }
  4850 |     |             m0 := mload(0x00)
  4851 |     |             m1 := mload(0x20)
  4852 |     |             m2 := mload(0x40)
  4853 |     |             m3 := mload(0x60)
  4854 |     |             m4 := mload(0x80)
  4855 |     |             m5 := mload(0xa0)
  4856 |     |             m6 := mload(0xc0)
  4857 |     |             // Selector of `log(address,string,address,bool)`.
  4858 |     |             mstore(0x00, 0x0df12b76)
  4859 |     |             mstore(0x20, p0)
  4860 |     |             mstore(0x40, 0x80)
  4861 |     |             mstore(0x60, p2)
  4862 |     |             mstore(0x80, p3)
  4863 |     |             writeString(0xa0, p1)
  4864 |     |         }
  4865 |     |         _sendLogPayload(0x1c, 0xc4);
  4866 |     |         /// @solidity memory-safe-assembly
  4867 |     |         assembly {
  4868 |     |             mstore(0x00, m0)
  4869 |     |             mstore(0x20, m1)
  4870 |     |             mstore(0x40, m2)
  4871 |     |             mstore(0x60, m3)
  4872 |     |             mstore(0x80, m4)
  4873 |     |             mstore(0xa0, m5)
  4874 |     |             mstore(0xc0, m6)
  4875 |     |         }
  4876 |     |     }
  4877 |     | 
  4878 |     |     function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {
  4879 |     |         bytes32 m0;
  4880 |     |         bytes32 m1;
  4881 |     |         bytes32 m2;
  4882 |     |         bytes32 m3;
  4883 |     |         bytes32 m4;
  4884 |     |         bytes32 m5;
  4885 |     |         bytes32 m6;
  4886 |     |         /// @solidity memory-safe-assembly
  4887 |     |         assembly {
  4888 |     |             function writeString(pos, w) {
  4889 |     |                 let length := 0
  4890 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4891 |     |                 mstore(pos, length)
  4892 |     |                 let shift := sub(256, shl(3, length))
  4893 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4894 |     |             }
  4895 |     |             m0 := mload(0x00)
  4896 |     |             m1 := mload(0x20)
  4897 |     |             m2 := mload(0x40)
  4898 |     |             m3 := mload(0x60)
  4899 |     |             m4 := mload(0x80)
  4900 |     |             m5 := mload(0xa0)
  4901 |     |             m6 := mload(0xc0)
  4902 |     |             // Selector of `log(address,string,address,uint256)`.
  4903 |     |             mstore(0x00, 0x457fe3cf)
  4904 |     |             mstore(0x20, p0)
  4905 |     |             mstore(0x40, 0x80)
  4906 |     |             mstore(0x60, p2)
  4907 |     |             mstore(0x80, p3)
  4908 |     |             writeString(0xa0, p1)
  4909 |     |         }
  4910 |     |         _sendLogPayload(0x1c, 0xc4);
  4911 |     |         /// @solidity memory-safe-assembly
  4912 |     |         assembly {
  4913 |     |             mstore(0x00, m0)
  4914 |     |             mstore(0x20, m1)
  4915 |     |             mstore(0x40, m2)
  4916 |     |             mstore(0x60, m3)
  4917 |     |             mstore(0x80, m4)
  4918 |     |             mstore(0xa0, m5)
  4919 |     |             mstore(0xc0, m6)
  4920 |     |         }
  4921 |     |     }
  4922 |     | 
  4923 |     |     function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  4924 |     |         bytes32 m0;
  4925 |     |         bytes32 m1;
  4926 |     |         bytes32 m2;
  4927 |     |         bytes32 m3;
  4928 |     |         bytes32 m4;
  4929 |     |         bytes32 m5;
  4930 |     |         bytes32 m6;
  4931 |     |         bytes32 m7;
  4932 |     |         bytes32 m8;
  4933 |     |         /// @solidity memory-safe-assembly
  4934 |     |         assembly {
  4935 |     |             function writeString(pos, w) {
  4936 |     |                 let length := 0
  4937 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4938 |     |                 mstore(pos, length)
  4939 |     |                 let shift := sub(256, shl(3, length))
  4940 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4941 |     |             }
  4942 |     |             m0 := mload(0x00)
  4943 |     |             m1 := mload(0x20)
  4944 |     |             m2 := mload(0x40)
  4945 |     |             m3 := mload(0x60)
  4946 |     |             m4 := mload(0x80)
  4947 |     |             m5 := mload(0xa0)
  4948 |     |             m6 := mload(0xc0)
  4949 |     |             m7 := mload(0xe0)
  4950 |     |             m8 := mload(0x100)
  4951 |     |             // Selector of `log(address,string,address,string)`.
  4952 |     |             mstore(0x00, 0xf7e36245)
  4953 |     |             mstore(0x20, p0)
  4954 |     |             mstore(0x40, 0x80)
  4955 |     |             mstore(0x60, p2)
  4956 |     |             mstore(0x80, 0xc0)
  4957 |     |             writeString(0xa0, p1)
  4958 |     |             writeString(0xe0, p3)
  4959 |     |         }
  4960 |     |         _sendLogPayload(0x1c, 0x104);
  4961 |     |         /// @solidity memory-safe-assembly
  4962 |     |         assembly {
  4963 |     |             mstore(0x00, m0)
  4964 |     |             mstore(0x20, m1)
  4965 |     |             mstore(0x40, m2)
  4966 |     |             mstore(0x60, m3)
  4967 |     |             mstore(0x80, m4)
  4968 |     |             mstore(0xa0, m5)
  4969 |     |             mstore(0xc0, m6)
  4970 |     |             mstore(0xe0, m7)
  4971 |     |             mstore(0x100, m8)
  4972 |     |         }
  4973 |     |     }
  4974 |     | 
  4975 |     |     function log(address p0, bytes32 p1, bool p2, address p3) internal pure {
  4976 |     |         bytes32 m0;
  4977 |     |         bytes32 m1;
  4978 |     |         bytes32 m2;
  4979 |     |         bytes32 m3;
  4980 |     |         bytes32 m4;
  4981 |     |         bytes32 m5;
  4982 |     |         bytes32 m6;
  4983 |     |         /// @solidity memory-safe-assembly
  4984 |     |         assembly {
  4985 |     |             function writeString(pos, w) {
  4986 |     |                 let length := 0
  4987 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4988 |     |                 mstore(pos, length)
  4989 |     |                 let shift := sub(256, shl(3, length))
  4990 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4991 |     |             }
  4992 |     |             m0 := mload(0x00)
  4993 |     |             m1 := mload(0x20)
  4994 |     |             m2 := mload(0x40)
  4995 |     |             m3 := mload(0x60)
  4996 |     |             m4 := mload(0x80)
  4997 |     |             m5 := mload(0xa0)
  4998 |     |             m6 := mload(0xc0)
  4999 |     |             // Selector of `log(address,string,bool,address)`.
  5000 |     |             mstore(0x00, 0x205871c2)
  5001 |     |             mstore(0x20, p0)
  5002 |     |             mstore(0x40, 0x80)
  5003 |     |             mstore(0x60, p2)
  5004 |     |             mstore(0x80, p3)
  5005 |     |             writeString(0xa0, p1)
  5006 |     |         }
  5007 |     |         _sendLogPayload(0x1c, 0xc4);
  5008 |     |         /// @solidity memory-safe-assembly
  5009 |     |         assembly {
  5010 |     |             mstore(0x00, m0)
  5011 |     |             mstore(0x20, m1)
  5012 |     |             mstore(0x40, m2)
  5013 |     |             mstore(0x60, m3)
  5014 |     |             mstore(0x80, m4)
  5015 |     |             mstore(0xa0, m5)
  5016 |     |             mstore(0xc0, m6)
  5017 |     |         }
  5018 |     |     }
  5019 |     | 
  5020 |     |     function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {
  5021 |     |         bytes32 m0;
  5022 |     |         bytes32 m1;
  5023 |     |         bytes32 m2;
  5024 |     |         bytes32 m3;
  5025 |     |         bytes32 m4;
  5026 |     |         bytes32 m5;
  5027 |     |         bytes32 m6;
  5028 |     |         /// @solidity memory-safe-assembly
  5029 |     |         assembly {
  5030 |     |             function writeString(pos, w) {
  5031 |     |                 let length := 0
  5032 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5033 |     |                 mstore(pos, length)
  5034 |     |                 let shift := sub(256, shl(3, length))
  5035 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5036 |     |             }
  5037 |     |             m0 := mload(0x00)
  5038 |     |             m1 := mload(0x20)
  5039 |     |             m2 := mload(0x40)
  5040 |     |             m3 := mload(0x60)
  5041 |     |             m4 := mload(0x80)
  5042 |     |             m5 := mload(0xa0)
  5043 |     |             m6 := mload(0xc0)
  5044 |     |             // Selector of `log(address,string,bool,bool)`.
  5045 |     |             mstore(0x00, 0x5f1d5c9f)
  5046 |     |             mstore(0x20, p0)
  5047 |     |             mstore(0x40, 0x80)
  5048 |     |             mstore(0x60, p2)
  5049 |     |             mstore(0x80, p3)
  5050 |     |             writeString(0xa0, p1)
  5051 |     |         }
  5052 |     |         _sendLogPayload(0x1c, 0xc4);
  5053 |     |         /// @solidity memory-safe-assembly
  5054 |     |         assembly {
  5055 |     |             mstore(0x00, m0)
  5056 |     |             mstore(0x20, m1)
  5057 |     |             mstore(0x40, m2)
  5058 |     |             mstore(0x60, m3)
  5059 |     |             mstore(0x80, m4)
  5060 |     |             mstore(0xa0, m5)
  5061 |     |             mstore(0xc0, m6)
  5062 |     |         }
  5063 |     |     }
  5064 |     | 
  5065 |     |     function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  5066 |     |         bytes32 m0;
  5067 |     |         bytes32 m1;
  5068 |     |         bytes32 m2;
  5069 |     |         bytes32 m3;
  5070 |     |         bytes32 m4;
  5071 |     |         bytes32 m5;
  5072 |     |         bytes32 m6;
  5073 |     |         /// @solidity memory-safe-assembly
  5074 |     |         assembly {
  5075 |     |             function writeString(pos, w) {
  5076 |     |                 let length := 0
  5077 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5078 |     |                 mstore(pos, length)
  5079 |     |                 let shift := sub(256, shl(3, length))
  5080 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5081 |     |             }
  5082 |     |             m0 := mload(0x00)
  5083 |     |             m1 := mload(0x20)
  5084 |     |             m2 := mload(0x40)
  5085 |     |             m3 := mload(0x60)
  5086 |     |             m4 := mload(0x80)
  5087 |     |             m5 := mload(0xa0)
  5088 |     |             m6 := mload(0xc0)
  5089 |     |             // Selector of `log(address,string,bool,uint256)`.
  5090 |     |             mstore(0x00, 0x515e38b6)
  5091 |     |             mstore(0x20, p0)
  5092 |     |             mstore(0x40, 0x80)
  5093 |     |             mstore(0x60, p2)
  5094 |     |             mstore(0x80, p3)
  5095 |     |             writeString(0xa0, p1)
  5096 |     |         }
  5097 |     |         _sendLogPayload(0x1c, 0xc4);
  5098 |     |         /// @solidity memory-safe-assembly
  5099 |     |         assembly {
  5100 |     |             mstore(0x00, m0)
  5101 |     |             mstore(0x20, m1)
  5102 |     |             mstore(0x40, m2)
  5103 |     |             mstore(0x60, m3)
  5104 |     |             mstore(0x80, m4)
  5105 |     |             mstore(0xa0, m5)
  5106 |     |             mstore(0xc0, m6)
  5107 |     |         }
  5108 |     |     }
  5109 |     | 
  5110 |     |     function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  5111 |     |         bytes32 m0;
  5112 |     |         bytes32 m1;
  5113 |     |         bytes32 m2;
  5114 |     |         bytes32 m3;
  5115 |     |         bytes32 m4;
  5116 |     |         bytes32 m5;
  5117 |     |         bytes32 m6;
  5118 |     |         bytes32 m7;
  5119 |     |         bytes32 m8;
  5120 |     |         /// @solidity memory-safe-assembly
  5121 |     |         assembly {
  5122 |     |             function writeString(pos, w) {
  5123 |     |                 let length := 0
  5124 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5125 |     |                 mstore(pos, length)
  5126 |     |                 let shift := sub(256, shl(3, length))
  5127 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5128 |     |             }
  5129 |     |             m0 := mload(0x00)
  5130 |     |             m1 := mload(0x20)
  5131 |     |             m2 := mload(0x40)
  5132 |     |             m3 := mload(0x60)
  5133 |     |             m4 := mload(0x80)
  5134 |     |             m5 := mload(0xa0)
  5135 |     |             m6 := mload(0xc0)
  5136 |     |             m7 := mload(0xe0)
  5137 |     |             m8 := mload(0x100)
  5138 |     |             // Selector of `log(address,string,bool,string)`.
  5139 |     |             mstore(0x00, 0xbc0b61fe)
  5140 |     |             mstore(0x20, p0)
  5141 |     |             mstore(0x40, 0x80)
  5142 |     |             mstore(0x60, p2)
  5143 |     |             mstore(0x80, 0xc0)
  5144 |     |             writeString(0xa0, p1)
  5145 |     |             writeString(0xe0, p3)
  5146 |     |         }
  5147 |     |         _sendLogPayload(0x1c, 0x104);
  5148 |     |         /// @solidity memory-safe-assembly
  5149 |     |         assembly {
  5150 |     |             mstore(0x00, m0)
  5151 |     |             mstore(0x20, m1)
  5152 |     |             mstore(0x40, m2)
  5153 |     |             mstore(0x60, m3)
  5154 |     |             mstore(0x80, m4)
  5155 |     |             mstore(0xa0, m5)
  5156 |     |             mstore(0xc0, m6)
  5157 |     |             mstore(0xe0, m7)
  5158 |     |             mstore(0x100, m8)
  5159 |     |         }
  5160 |     |     }
  5161 |     | 
  5162 |     |     function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {
  5163 |     |         bytes32 m0;
  5164 |     |         bytes32 m1;
  5165 |     |         bytes32 m2;
  5166 |     |         bytes32 m3;
  5167 |     |         bytes32 m4;
  5168 |     |         bytes32 m5;
  5169 |     |         bytes32 m6;
  5170 |     |         /// @solidity memory-safe-assembly
  5171 |     |         assembly {
  5172 |     |             function writeString(pos, w) {
  5173 |     |                 let length := 0
  5174 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5175 |     |                 mstore(pos, length)
  5176 |     |                 let shift := sub(256, shl(3, length))
  5177 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5178 |     |             }
  5179 |     |             m0 := mload(0x00)
  5180 |     |             m1 := mload(0x20)
  5181 |     |             m2 := mload(0x40)
  5182 |     |             m3 := mload(0x60)
  5183 |     |             m4 := mload(0x80)
  5184 |     |             m5 := mload(0xa0)
  5185 |     |             m6 := mload(0xc0)
  5186 |     |             // Selector of `log(address,string,uint256,address)`.
  5187 |     |             mstore(0x00, 0x63183678)
  5188 |     |             mstore(0x20, p0)
  5189 |     |             mstore(0x40, 0x80)
  5190 |     |             mstore(0x60, p2)
  5191 |     |             mstore(0x80, p3)
  5192 |     |             writeString(0xa0, p1)
  5193 |     |         }
  5194 |     |         _sendLogPayload(0x1c, 0xc4);
  5195 |     |         /// @solidity memory-safe-assembly
  5196 |     |         assembly {
  5197 |     |             mstore(0x00, m0)
  5198 |     |             mstore(0x20, m1)
  5199 |     |             mstore(0x40, m2)
  5200 |     |             mstore(0x60, m3)
  5201 |     |             mstore(0x80, m4)
  5202 |     |             mstore(0xa0, m5)
  5203 |     |             mstore(0xc0, m6)
  5204 |     |         }
  5205 |     |     }
  5206 |     | 
  5207 |     |     function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  5208 |     |         bytes32 m0;
  5209 |     |         bytes32 m1;
  5210 |     |         bytes32 m2;
  5211 |     |         bytes32 m3;
  5212 |     |         bytes32 m4;
  5213 |     |         bytes32 m5;
  5214 |     |         bytes32 m6;
  5215 |     |         /// @solidity memory-safe-assembly
  5216 |     |         assembly {
  5217 |     |             function writeString(pos, w) {
  5218 |     |                 let length := 0
  5219 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5220 |     |                 mstore(pos, length)
  5221 |     |                 let shift := sub(256, shl(3, length))
  5222 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5223 |     |             }
  5224 |     |             m0 := mload(0x00)
  5225 |     |             m1 := mload(0x20)
  5226 |     |             m2 := mload(0x40)
  5227 |     |             m3 := mload(0x60)
  5228 |     |             m4 := mload(0x80)
  5229 |     |             m5 := mload(0xa0)
  5230 |     |             m6 := mload(0xc0)
  5231 |     |             // Selector of `log(address,string,uint256,bool)`.
  5232 |     |             mstore(0x00, 0x0ef7e050)
  5233 |     |             mstore(0x20, p0)
  5234 |     |             mstore(0x40, 0x80)
  5235 |     |             mstore(0x60, p2)
  5236 |     |             mstore(0x80, p3)
  5237 |     |             writeString(0xa0, p1)
  5238 |     |         }
  5239 |     |         _sendLogPayload(0x1c, 0xc4);
  5240 |     |         /// @solidity memory-safe-assembly
  5241 |     |         assembly {
  5242 |     |             mstore(0x00, m0)
  5243 |     |             mstore(0x20, m1)
  5244 |     |             mstore(0x40, m2)
  5245 |     |             mstore(0x60, m3)
  5246 |     |             mstore(0x80, m4)
  5247 |     |             mstore(0xa0, m5)
  5248 |     |             mstore(0xc0, m6)
  5249 |     |         }
  5250 |     |     }
  5251 |     | 
  5252 |     |     function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  5253 |     |         bytes32 m0;
  5254 |     |         bytes32 m1;
  5255 |     |         bytes32 m2;
  5256 |     |         bytes32 m3;
  5257 |     |         bytes32 m4;
  5258 |     |         bytes32 m5;
  5259 |     |         bytes32 m6;
  5260 |     |         /// @solidity memory-safe-assembly
  5261 |     |         assembly {
  5262 |     |             function writeString(pos, w) {
  5263 |     |                 let length := 0
  5264 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5265 |     |                 mstore(pos, length)
  5266 |     |                 let shift := sub(256, shl(3, length))
  5267 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5268 |     |             }
  5269 |     |             m0 := mload(0x00)
  5270 |     |             m1 := mload(0x20)
  5271 |     |             m2 := mload(0x40)
  5272 |     |             m3 := mload(0x60)
  5273 |     |             m4 := mload(0x80)
  5274 |     |             m5 := mload(0xa0)
  5275 |     |             m6 := mload(0xc0)
  5276 |     |             // Selector of `log(address,string,uint256,uint256)`.
  5277 |     |             mstore(0x00, 0x1dc8e1b8)
  5278 |     |             mstore(0x20, p0)
  5279 |     |             mstore(0x40, 0x80)
  5280 |     |             mstore(0x60, p2)
  5281 |     |             mstore(0x80, p3)
  5282 |     |             writeString(0xa0, p1)
  5283 |     |         }
  5284 |     |         _sendLogPayload(0x1c, 0xc4);
  5285 |     |         /// @solidity memory-safe-assembly
  5286 |     |         assembly {
  5287 |     |             mstore(0x00, m0)
  5288 |     |             mstore(0x20, m1)
  5289 |     |             mstore(0x40, m2)
  5290 |     |             mstore(0x60, m3)
  5291 |     |             mstore(0x80, m4)
  5292 |     |             mstore(0xa0, m5)
  5293 |     |             mstore(0xc0, m6)
  5294 |     |         }
  5295 |     |     }
  5296 |     | 
  5297 |     |     function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  5298 |     |         bytes32 m0;
  5299 |     |         bytes32 m1;
  5300 |     |         bytes32 m2;
  5301 |     |         bytes32 m3;
  5302 |     |         bytes32 m4;
  5303 |     |         bytes32 m5;
  5304 |     |         bytes32 m6;
  5305 |     |         bytes32 m7;
  5306 |     |         bytes32 m8;
  5307 |     |         /// @solidity memory-safe-assembly
  5308 |     |         assembly {
  5309 |     |             function writeString(pos, w) {
  5310 |     |                 let length := 0
  5311 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5312 |     |                 mstore(pos, length)
  5313 |     |                 let shift := sub(256, shl(3, length))
  5314 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5315 |     |             }
  5316 |     |             m0 := mload(0x00)
  5317 |     |             m1 := mload(0x20)
  5318 |     |             m2 := mload(0x40)
  5319 |     |             m3 := mload(0x60)
  5320 |     |             m4 := mload(0x80)
  5321 |     |             m5 := mload(0xa0)
  5322 |     |             m6 := mload(0xc0)
  5323 |     |             m7 := mload(0xe0)
  5324 |     |             m8 := mload(0x100)
  5325 |     |             // Selector of `log(address,string,uint256,string)`.
  5326 |     |             mstore(0x00, 0x448830a8)
  5327 |     |             mstore(0x20, p0)
  5328 |     |             mstore(0x40, 0x80)
  5329 |     |             mstore(0x60, p2)
  5330 |     |             mstore(0x80, 0xc0)
  5331 |     |             writeString(0xa0, p1)
  5332 |     |             writeString(0xe0, p3)
  5333 |     |         }
  5334 |     |         _sendLogPayload(0x1c, 0x104);
  5335 |     |         /// @solidity memory-safe-assembly
  5336 |     |         assembly {
  5337 |     |             mstore(0x00, m0)
  5338 |     |             mstore(0x20, m1)
  5339 |     |             mstore(0x40, m2)
  5340 |     |             mstore(0x60, m3)
  5341 |     |             mstore(0x80, m4)
  5342 |     |             mstore(0xa0, m5)
  5343 |     |             mstore(0xc0, m6)
  5344 |     |             mstore(0xe0, m7)
  5345 |     |             mstore(0x100, m8)
  5346 |     |         }
  5347 |     |     }
  5348 |     | 
  5349 |     |     function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  5350 |     |         bytes32 m0;
  5351 |     |         bytes32 m1;
  5352 |     |         bytes32 m2;
  5353 |     |         bytes32 m3;
  5354 |     |         bytes32 m4;
  5355 |     |         bytes32 m5;
  5356 |     |         bytes32 m6;
  5357 |     |         bytes32 m7;
  5358 |     |         bytes32 m8;
  5359 |     |         /// @solidity memory-safe-assembly
  5360 |     |         assembly {
  5361 |     |             function writeString(pos, w) {
  5362 |     |                 let length := 0
  5363 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5364 |     |                 mstore(pos, length)
  5365 |     |                 let shift := sub(256, shl(3, length))
  5366 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5367 |     |             }
  5368 |     |             m0 := mload(0x00)
  5369 |     |             m1 := mload(0x20)
  5370 |     |             m2 := mload(0x40)
  5371 |     |             m3 := mload(0x60)
  5372 |     |             m4 := mload(0x80)
  5373 |     |             m5 := mload(0xa0)
  5374 |     |             m6 := mload(0xc0)
  5375 |     |             m7 := mload(0xe0)
  5376 |     |             m8 := mload(0x100)
  5377 |     |             // Selector of `log(address,string,string,address)`.
  5378 |     |             mstore(0x00, 0xa04e2f87)
  5379 |     |             mstore(0x20, p0)
  5380 |     |             mstore(0x40, 0x80)
  5381 |     |             mstore(0x60, 0xc0)
  5382 |     |             mstore(0x80, p3)
  5383 |     |             writeString(0xa0, p1)
  5384 |     |             writeString(0xe0, p2)
  5385 |     |         }
  5386 |     |         _sendLogPayload(0x1c, 0x104);
  5387 |     |         /// @solidity memory-safe-assembly
  5388 |     |         assembly {
  5389 |     |             mstore(0x00, m0)
  5390 |     |             mstore(0x20, m1)
  5391 |     |             mstore(0x40, m2)
  5392 |     |             mstore(0x60, m3)
  5393 |     |             mstore(0x80, m4)
  5394 |     |             mstore(0xa0, m5)
  5395 |     |             mstore(0xc0, m6)
  5396 |     |             mstore(0xe0, m7)
  5397 |     |             mstore(0x100, m8)
  5398 |     |         }
  5399 |     |     }
  5400 |     | 
  5401 |     |     function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
  5402 |     |         bytes32 m0;
  5403 |     |         bytes32 m1;
  5404 |     |         bytes32 m2;
  5405 |     |         bytes32 m3;
  5406 |     |         bytes32 m4;
  5407 |     |         bytes32 m5;
  5408 |     |         bytes32 m6;
  5409 |     |         bytes32 m7;
  5410 |     |         bytes32 m8;
  5411 |     |         /// @solidity memory-safe-assembly
  5412 |     |         assembly {
  5413 |     |             function writeString(pos, w) {
  5414 |     |                 let length := 0
  5415 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5416 |     |                 mstore(pos, length)
  5417 |     |                 let shift := sub(256, shl(3, length))
  5418 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5419 |     |             }
  5420 |     |             m0 := mload(0x00)
  5421 |     |             m1 := mload(0x20)
  5422 |     |             m2 := mload(0x40)
  5423 |     |             m3 := mload(0x60)
  5424 |     |             m4 := mload(0x80)
  5425 |     |             m5 := mload(0xa0)
  5426 |     |             m6 := mload(0xc0)
  5427 |     |             m7 := mload(0xe0)
  5428 |     |             m8 := mload(0x100)
  5429 |     |             // Selector of `log(address,string,string,bool)`.
  5430 |     |             mstore(0x00, 0x35a5071f)
  5431 |     |             mstore(0x20, p0)
  5432 |     |             mstore(0x40, 0x80)
  5433 |     |             mstore(0x60, 0xc0)
  5434 |     |             mstore(0x80, p3)
  5435 |     |             writeString(0xa0, p1)
  5436 |     |             writeString(0xe0, p2)
  5437 |     |         }
  5438 |     |         _sendLogPayload(0x1c, 0x104);
  5439 |     |         /// @solidity memory-safe-assembly
  5440 |     |         assembly {
  5441 |     |             mstore(0x00, m0)
  5442 |     |             mstore(0x20, m1)
  5443 |     |             mstore(0x40, m2)
  5444 |     |             mstore(0x60, m3)
  5445 |     |             mstore(0x80, m4)
  5446 |     |             mstore(0xa0, m5)
  5447 |     |             mstore(0xc0, m6)
  5448 |     |             mstore(0xe0, m7)
  5449 |     |             mstore(0x100, m8)
  5450 |     |         }
  5451 |     |     }
  5452 |     | 
  5453 |     |     function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
  5454 |     |         bytes32 m0;
  5455 |     |         bytes32 m1;
  5456 |     |         bytes32 m2;
  5457 |     |         bytes32 m3;
  5458 |     |         bytes32 m4;
  5459 |     |         bytes32 m5;
  5460 |     |         bytes32 m6;
  5461 |     |         bytes32 m7;
  5462 |     |         bytes32 m8;
  5463 |     |         /// @solidity memory-safe-assembly
  5464 |     |         assembly {
  5465 |     |             function writeString(pos, w) {
  5466 |     |                 let length := 0
  5467 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5468 |     |                 mstore(pos, length)
  5469 |     |                 let shift := sub(256, shl(3, length))
  5470 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5471 |     |             }
  5472 |     |             m0 := mload(0x00)
  5473 |     |             m1 := mload(0x20)
  5474 |     |             m2 := mload(0x40)
  5475 |     |             m3 := mload(0x60)
  5476 |     |             m4 := mload(0x80)
  5477 |     |             m5 := mload(0xa0)
  5478 |     |             m6 := mload(0xc0)
  5479 |     |             m7 := mload(0xe0)
  5480 |     |             m8 := mload(0x100)
  5481 |     |             // Selector of `log(address,string,string,uint256)`.
  5482 |     |             mstore(0x00, 0x159f8927)
  5483 |     |             mstore(0x20, p0)
  5484 |     |             mstore(0x40, 0x80)
  5485 |     |             mstore(0x60, 0xc0)
  5486 |     |             mstore(0x80, p3)
  5487 |     |             writeString(0xa0, p1)
  5488 |     |             writeString(0xe0, p2)
  5489 |     |         }
  5490 |     |         _sendLogPayload(0x1c, 0x104);
  5491 |     |         /// @solidity memory-safe-assembly
  5492 |     |         assembly {
  5493 |     |             mstore(0x00, m0)
  5494 |     |             mstore(0x20, m1)
  5495 |     |             mstore(0x40, m2)
  5496 |     |             mstore(0x60, m3)
  5497 |     |             mstore(0x80, m4)
  5498 |     |             mstore(0xa0, m5)
  5499 |     |             mstore(0xc0, m6)
  5500 |     |             mstore(0xe0, m7)
  5501 |     |             mstore(0x100, m8)
  5502 |     |         }
  5503 |     |     }
  5504 |     | 
  5505 |     |     function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
  5506 |     |         bytes32 m0;
  5507 |     |         bytes32 m1;
  5508 |     |         bytes32 m2;
  5509 |     |         bytes32 m3;
  5510 |     |         bytes32 m4;
  5511 |     |         bytes32 m5;
  5512 |     |         bytes32 m6;
  5513 |     |         bytes32 m7;
  5514 |     |         bytes32 m8;
  5515 |     |         bytes32 m9;
  5516 |     |         bytes32 m10;
  5517 |     |         /// @solidity memory-safe-assembly
  5518 |     |         assembly {
  5519 |     |             function writeString(pos, w) {
  5520 |     |                 let length := 0
  5521 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5522 |     |                 mstore(pos, length)
  5523 |     |                 let shift := sub(256, shl(3, length))
  5524 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5525 |     |             }
  5526 |     |             m0 := mload(0x00)
  5527 |     |             m1 := mload(0x20)
  5528 |     |             m2 := mload(0x40)
  5529 |     |             m3 := mload(0x60)
  5530 |     |             m4 := mload(0x80)
  5531 |     |             m5 := mload(0xa0)
  5532 |     |             m6 := mload(0xc0)
  5533 |     |             m7 := mload(0xe0)
  5534 |     |             m8 := mload(0x100)
  5535 |     |             m9 := mload(0x120)
  5536 |     |             m10 := mload(0x140)
  5537 |     |             // Selector of `log(address,string,string,string)`.
  5538 |     |             mstore(0x00, 0x5d02c50b)
  5539 |     |             mstore(0x20, p0)
  5540 |     |             mstore(0x40, 0x80)
  5541 |     |             mstore(0x60, 0xc0)
  5542 |     |             mstore(0x80, 0x100)
  5543 |     |             writeString(0xa0, p1)
  5544 |     |             writeString(0xe0, p2)
  5545 |     |             writeString(0x120, p3)
  5546 |     |         }
  5547 |     |         _sendLogPayload(0x1c, 0x144);
  5548 |     |         /// @solidity memory-safe-assembly
  5549 |     |         assembly {
  5550 |     |             mstore(0x00, m0)
  5551 |     |             mstore(0x20, m1)
  5552 |     |             mstore(0x40, m2)
  5553 |     |             mstore(0x60, m3)
  5554 |     |             mstore(0x80, m4)
  5555 |     |             mstore(0xa0, m5)
  5556 |     |             mstore(0xc0, m6)
  5557 |     |             mstore(0xe0, m7)
  5558 |     |             mstore(0x100, m8)
  5559 |     |             mstore(0x120, m9)
  5560 |     |             mstore(0x140, m10)
  5561 |     |         }
  5562 |     |     }
  5563 |     | 
  5564 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
  5565 |     |         bytes32 m0;
  5566 |     |         bytes32 m1;
  5567 |     |         bytes32 m2;
  5568 |     |         bytes32 m3;
  5569 |     |         bytes32 m4;
  5570 |     |         /// @solidity memory-safe-assembly
  5571 |     |         assembly {
  5572 |     |             m0 := mload(0x00)
  5573 |     |             m1 := mload(0x20)
  5574 |     |             m2 := mload(0x40)
  5575 |     |             m3 := mload(0x60)
  5576 |     |             m4 := mload(0x80)
  5577 |     |             // Selector of `log(bool,address,address,address)`.
  5578 |     |             mstore(0x00, 0x1d14d001)
  5579 |     |             mstore(0x20, p0)
  5580 |     |             mstore(0x40, p1)
  5581 |     |             mstore(0x60, p2)
  5582 |     |             mstore(0x80, p3)
  5583 |     |         }
  5584 |     |         _sendLogPayload(0x1c, 0x84);
  5585 |     |         /// @solidity memory-safe-assembly
  5586 |     |         assembly {
  5587 |     |             mstore(0x00, m0)
  5588 |     |             mstore(0x20, m1)
  5589 |     |             mstore(0x40, m2)
  5590 |     |             mstore(0x60, m3)
  5591 |     |             mstore(0x80, m4)
  5592 |     |         }
  5593 |     |     }
  5594 |     | 
  5595 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
  5596 |     |         bytes32 m0;
  5597 |     |         bytes32 m1;
  5598 |     |         bytes32 m2;
  5599 |     |         bytes32 m3;
  5600 |     |         bytes32 m4;
  5601 |     |         /// @solidity memory-safe-assembly
  5602 |     |         assembly {
  5603 |     |             m0 := mload(0x00)
  5604 |     |             m1 := mload(0x20)
  5605 |     |             m2 := mload(0x40)
  5606 |     |             m3 := mload(0x60)
  5607 |     |             m4 := mload(0x80)
  5608 |     |             // Selector of `log(bool,address,address,bool)`.
  5609 |     |             mstore(0x00, 0x46600be0)
  5610 |     |             mstore(0x20, p0)
  5611 |     |             mstore(0x40, p1)
  5612 |     |             mstore(0x60, p2)
  5613 |     |             mstore(0x80, p3)
  5614 |     |         }
  5615 |     |         _sendLogPayload(0x1c, 0x84);
  5616 |     |         /// @solidity memory-safe-assembly
  5617 |     |         assembly {
  5618 |     |             mstore(0x00, m0)
  5619 |     |             mstore(0x20, m1)
  5620 |     |             mstore(0x40, m2)
  5621 |     |             mstore(0x60, m3)
  5622 |     |             mstore(0x80, m4)
  5623 |     |         }
  5624 |     |     }
  5625 |     | 
  5626 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal pure {
  5627 |     |         bytes32 m0;
  5628 |     |         bytes32 m1;
  5629 |     |         bytes32 m2;
  5630 |     |         bytes32 m3;
  5631 |     |         bytes32 m4;
  5632 |     |         /// @solidity memory-safe-assembly
  5633 |     |         assembly {
  5634 |     |             m0 := mload(0x00)
  5635 |     |             m1 := mload(0x20)
  5636 |     |             m2 := mload(0x40)
  5637 |     |             m3 := mload(0x60)
  5638 |     |             m4 := mload(0x80)
  5639 |     |             // Selector of `log(bool,address,address,uint256)`.
  5640 |     |             mstore(0x00, 0x0c66d1be)
  5641 |     |             mstore(0x20, p0)
  5642 |     |             mstore(0x40, p1)
  5643 |     |             mstore(0x60, p2)
  5644 |     |             mstore(0x80, p3)
  5645 |     |         }
  5646 |     |         _sendLogPayload(0x1c, 0x84);
  5647 |     |         /// @solidity memory-safe-assembly
  5648 |     |         assembly {
  5649 |     |             mstore(0x00, m0)
  5650 |     |             mstore(0x20, m1)
  5651 |     |             mstore(0x40, m2)
  5652 |     |             mstore(0x60, m3)
  5653 |     |             mstore(0x80, m4)
  5654 |     |         }
  5655 |     |     }
  5656 |     | 
  5657 |     |     function log(bool p0, address p1, address p2, bytes32 p3) internal pure {
  5658 |     |         bytes32 m0;
  5659 |     |         bytes32 m1;
  5660 |     |         bytes32 m2;
  5661 |     |         bytes32 m3;
  5662 |     |         bytes32 m4;
  5663 |     |         bytes32 m5;
  5664 |     |         bytes32 m6;
  5665 |     |         /// @solidity memory-safe-assembly
  5666 |     |         assembly {
  5667 |     |             function writeString(pos, w) {
  5668 |     |                 let length := 0
  5669 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5670 |     |                 mstore(pos, length)
  5671 |     |                 let shift := sub(256, shl(3, length))
  5672 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5673 |     |             }
  5674 |     |             m0 := mload(0x00)
  5675 |     |             m1 := mload(0x20)
  5676 |     |             m2 := mload(0x40)
  5677 |     |             m3 := mload(0x60)
  5678 |     |             m4 := mload(0x80)
  5679 |     |             m5 := mload(0xa0)
  5680 |     |             m6 := mload(0xc0)
  5681 |     |             // Selector of `log(bool,address,address,string)`.
  5682 |     |             mstore(0x00, 0xd812a167)
  5683 |     |             mstore(0x20, p0)
  5684 |     |             mstore(0x40, p1)
  5685 |     |             mstore(0x60, p2)
  5686 |     |             mstore(0x80, 0x80)
  5687 |     |             writeString(0xa0, p3)
  5688 |     |         }
  5689 |     |         _sendLogPayload(0x1c, 0xc4);
  5690 |     |         /// @solidity memory-safe-assembly
  5691 |     |         assembly {
  5692 |     |             mstore(0x00, m0)
  5693 |     |             mstore(0x20, m1)
  5694 |     |             mstore(0x40, m2)
  5695 |     |             mstore(0x60, m3)
  5696 |     |             mstore(0x80, m4)
  5697 |     |             mstore(0xa0, m5)
  5698 |     |             mstore(0xc0, m6)
  5699 |     |         }
  5700 |     |     }
  5701 |     | 
  5702 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
  5703 |     |         bytes32 m0;
  5704 |     |         bytes32 m1;
  5705 |     |         bytes32 m2;
  5706 |     |         bytes32 m3;
  5707 |     |         bytes32 m4;
  5708 |     |         /// @solidity memory-safe-assembly
  5709 |     |         assembly {
  5710 |     |             m0 := mload(0x00)
  5711 |     |             m1 := mload(0x20)
  5712 |     |             m2 := mload(0x40)
  5713 |     |             m3 := mload(0x60)
  5714 |     |             m4 := mload(0x80)
  5715 |     |             // Selector of `log(bool,address,bool,address)`.
  5716 |     |             mstore(0x00, 0x1c41a336)
  5717 |     |             mstore(0x20, p0)
  5718 |     |             mstore(0x40, p1)
  5719 |     |             mstore(0x60, p2)
  5720 |     |             mstore(0x80, p3)
  5721 |     |         }
  5722 |     |         _sendLogPayload(0x1c, 0x84);
  5723 |     |         /// @solidity memory-safe-assembly
  5724 |     |         assembly {
  5725 |     |             mstore(0x00, m0)
  5726 |     |             mstore(0x20, m1)
  5727 |     |             mstore(0x40, m2)
  5728 |     |             mstore(0x60, m3)
  5729 |     |             mstore(0x80, m4)
  5730 |     |         }
  5731 |     |     }
  5732 |     | 
  5733 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
  5734 |     |         bytes32 m0;
  5735 |     |         bytes32 m1;
  5736 |     |         bytes32 m2;
  5737 |     |         bytes32 m3;
  5738 |     |         bytes32 m4;
  5739 |     |         /// @solidity memory-safe-assembly
  5740 |     |         assembly {
  5741 |     |             m0 := mload(0x00)
  5742 |     |             m1 := mload(0x20)
  5743 |     |             m2 := mload(0x40)
  5744 |     |             m3 := mload(0x60)
  5745 |     |             m4 := mload(0x80)
  5746 |     |             // Selector of `log(bool,address,bool,bool)`.
  5747 |     |             mstore(0x00, 0x6a9c478b)
  5748 |     |             mstore(0x20, p0)
  5749 |     |             mstore(0x40, p1)
  5750 |     |             mstore(0x60, p2)
  5751 |     |             mstore(0x80, p3)
  5752 |     |         }
  5753 |     |         _sendLogPayload(0x1c, 0x84);
  5754 |     |         /// @solidity memory-safe-assembly
  5755 |     |         assembly {
  5756 |     |             mstore(0x00, m0)
  5757 |     |             mstore(0x20, m1)
  5758 |     |             mstore(0x40, m2)
  5759 |     |             mstore(0x60, m3)
  5760 |     |             mstore(0x80, m4)
  5761 |     |         }
  5762 |     |     }
  5763 |     | 
  5764 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal pure {
  5765 |     |         bytes32 m0;
  5766 |     |         bytes32 m1;
  5767 |     |         bytes32 m2;
  5768 |     |         bytes32 m3;
  5769 |     |         bytes32 m4;
  5770 |     |         /// @solidity memory-safe-assembly
  5771 |     |         assembly {
  5772 |     |             m0 := mload(0x00)
  5773 |     |             m1 := mload(0x20)
  5774 |     |             m2 := mload(0x40)
  5775 |     |             m3 := mload(0x60)
  5776 |     |             m4 := mload(0x80)
  5777 |     |             // Selector of `log(bool,address,bool,uint256)`.
  5778 |     |             mstore(0x00, 0x07831502)
  5779 |     |             mstore(0x20, p0)
  5780 |     |             mstore(0x40, p1)
  5781 |     |             mstore(0x60, p2)
  5782 |     |             mstore(0x80, p3)
  5783 |     |         }
  5784 |     |         _sendLogPayload(0x1c, 0x84);
  5785 |     |         /// @solidity memory-safe-assembly
  5786 |     |         assembly {
  5787 |     |             mstore(0x00, m0)
  5788 |     |             mstore(0x20, m1)
  5789 |     |             mstore(0x40, m2)
  5790 |     |             mstore(0x60, m3)
  5791 |     |             mstore(0x80, m4)
  5792 |     |         }
  5793 |     |     }
  5794 |     | 
  5795 |     |     function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {
  5796 |     |         bytes32 m0;
  5797 |     |         bytes32 m1;
  5798 |     |         bytes32 m2;
  5799 |     |         bytes32 m3;
  5800 |     |         bytes32 m4;
  5801 |     |         bytes32 m5;
  5802 |     |         bytes32 m6;
  5803 |     |         /// @solidity memory-safe-assembly
  5804 |     |         assembly {
  5805 |     |             function writeString(pos, w) {
  5806 |     |                 let length := 0
  5807 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5808 |     |                 mstore(pos, length)
  5809 |     |                 let shift := sub(256, shl(3, length))
  5810 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5811 |     |             }
  5812 |     |             m0 := mload(0x00)
  5813 |     |             m1 := mload(0x20)
  5814 |     |             m2 := mload(0x40)
  5815 |     |             m3 := mload(0x60)
  5816 |     |             m4 := mload(0x80)
  5817 |     |             m5 := mload(0xa0)
  5818 |     |             m6 := mload(0xc0)
  5819 |     |             // Selector of `log(bool,address,bool,string)`.
  5820 |     |             mstore(0x00, 0x4a66cb34)
  5821 |     |             mstore(0x20, p0)
  5822 |     |             mstore(0x40, p1)
  5823 |     |             mstore(0x60, p2)
  5824 |     |             mstore(0x80, 0x80)
  5825 |     |             writeString(0xa0, p3)
  5826 |     |         }
  5827 |     |         _sendLogPayload(0x1c, 0xc4);
  5828 |     |         /// @solidity memory-safe-assembly
  5829 |     |         assembly {
  5830 |     |             mstore(0x00, m0)
  5831 |     |             mstore(0x20, m1)
  5832 |     |             mstore(0x40, m2)
  5833 |     |             mstore(0x60, m3)
  5834 |     |             mstore(0x80, m4)
  5835 |     |             mstore(0xa0, m5)
  5836 |     |             mstore(0xc0, m6)
  5837 |     |         }
  5838 |     |     }
  5839 |     | 
  5840 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal pure {
  5841 |     |         bytes32 m0;
  5842 |     |         bytes32 m1;
  5843 |     |         bytes32 m2;
  5844 |     |         bytes32 m3;
  5845 |     |         bytes32 m4;
  5846 |     |         /// @solidity memory-safe-assembly
  5847 |     |         assembly {
  5848 |     |             m0 := mload(0x00)
  5849 |     |             m1 := mload(0x20)
  5850 |     |             m2 := mload(0x40)
  5851 |     |             m3 := mload(0x60)
  5852 |     |             m4 := mload(0x80)
  5853 |     |             // Selector of `log(bool,address,uint256,address)`.
  5854 |     |             mstore(0x00, 0x136b05dd)
  5855 |     |             mstore(0x20, p0)
  5856 |     |             mstore(0x40, p1)
  5857 |     |             mstore(0x60, p2)
  5858 |     |             mstore(0x80, p3)
  5859 |     |         }
  5860 |     |         _sendLogPayload(0x1c, 0x84);
  5861 |     |         /// @solidity memory-safe-assembly
  5862 |     |         assembly {
  5863 |     |             mstore(0x00, m0)
  5864 |     |             mstore(0x20, m1)
  5865 |     |             mstore(0x40, m2)
  5866 |     |             mstore(0x60, m3)
  5867 |     |             mstore(0x80, m4)
  5868 |     |         }
  5869 |     |     }
  5870 |     | 
  5871 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal pure {
  5872 |     |         bytes32 m0;
  5873 |     |         bytes32 m1;
  5874 |     |         bytes32 m2;
  5875 |     |         bytes32 m3;
  5876 |     |         bytes32 m4;
  5877 |     |         /// @solidity memory-safe-assembly
  5878 |     |         assembly {
  5879 |     |             m0 := mload(0x00)
  5880 |     |             m1 := mload(0x20)
  5881 |     |             m2 := mload(0x40)
  5882 |     |             m3 := mload(0x60)
  5883 |     |             m4 := mload(0x80)
  5884 |     |             // Selector of `log(bool,address,uint256,bool)`.
  5885 |     |             mstore(0x00, 0xd6019f1c)
  5886 |     |             mstore(0x20, p0)
  5887 |     |             mstore(0x40, p1)
  5888 |     |             mstore(0x60, p2)
  5889 |     |             mstore(0x80, p3)
  5890 |     |         }
  5891 |     |         _sendLogPayload(0x1c, 0x84);
  5892 |     |         /// @solidity memory-safe-assembly
  5893 |     |         assembly {
  5894 |     |             mstore(0x00, m0)
  5895 |     |             mstore(0x20, m1)
  5896 |     |             mstore(0x40, m2)
  5897 |     |             mstore(0x60, m3)
  5898 |     |             mstore(0x80, m4)
  5899 |     |         }
  5900 |     |     }
  5901 |     | 
  5902 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {
  5903 |     |         bytes32 m0;
  5904 |     |         bytes32 m1;
  5905 |     |         bytes32 m2;
  5906 |     |         bytes32 m3;
  5907 |     |         bytes32 m4;
  5908 |     |         /// @solidity memory-safe-assembly
  5909 |     |         assembly {
  5910 |     |             m0 := mload(0x00)
  5911 |     |             m1 := mload(0x20)
  5912 |     |             m2 := mload(0x40)
  5913 |     |             m3 := mload(0x60)
  5914 |     |             m4 := mload(0x80)
  5915 |     |             // Selector of `log(bool,address,uint256,uint256)`.
  5916 |     |             mstore(0x00, 0x7bf181a1)
  5917 |     |             mstore(0x20, p0)
  5918 |     |             mstore(0x40, p1)
  5919 |     |             mstore(0x60, p2)
  5920 |     |             mstore(0x80, p3)
  5921 |     |         }
  5922 |     |         _sendLogPayload(0x1c, 0x84);
  5923 |     |         /// @solidity memory-safe-assembly
  5924 |     |         assembly {
  5925 |     |             mstore(0x00, m0)
  5926 |     |             mstore(0x20, m1)
  5927 |     |             mstore(0x40, m2)
  5928 |     |             mstore(0x60, m3)
  5929 |     |             mstore(0x80, m4)
  5930 |     |         }
  5931 |     |     }
  5932 |     | 
  5933 |     |     function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {
  5934 |     |         bytes32 m0;
  5935 |     |         bytes32 m1;
  5936 |     |         bytes32 m2;
  5937 |     |         bytes32 m3;
  5938 |     |         bytes32 m4;
  5939 |     |         bytes32 m5;
  5940 |     |         bytes32 m6;
  5941 |     |         /// @solidity memory-safe-assembly
  5942 |     |         assembly {
  5943 |     |             function writeString(pos, w) {
  5944 |     |                 let length := 0
  5945 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5946 |     |                 mstore(pos, length)
  5947 |     |                 let shift := sub(256, shl(3, length))
  5948 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5949 |     |             }
  5950 |     |             m0 := mload(0x00)
  5951 |     |             m1 := mload(0x20)
  5952 |     |             m2 := mload(0x40)
  5953 |     |             m3 := mload(0x60)
  5954 |     |             m4 := mload(0x80)
  5955 |     |             m5 := mload(0xa0)
  5956 |     |             m6 := mload(0xc0)
  5957 |     |             // Selector of `log(bool,address,uint256,string)`.
  5958 |     |             mstore(0x00, 0x51f09ff8)
  5959 |     |             mstore(0x20, p0)
  5960 |     |             mstore(0x40, p1)
  5961 |     |             mstore(0x60, p2)
  5962 |     |             mstore(0x80, 0x80)
  5963 |     |             writeString(0xa0, p3)
  5964 |     |         }
  5965 |     |         _sendLogPayload(0x1c, 0xc4);
  5966 |     |         /// @solidity memory-safe-assembly
  5967 |     |         assembly {
  5968 |     |             mstore(0x00, m0)
  5969 |     |             mstore(0x20, m1)
  5970 |     |             mstore(0x40, m2)
  5971 |     |             mstore(0x60, m3)
  5972 |     |             mstore(0x80, m4)
  5973 |     |             mstore(0xa0, m5)
  5974 |     |             mstore(0xc0, m6)
  5975 |     |         }
  5976 |     |     }
  5977 |     | 
  5978 |     |     function log(bool p0, address p1, bytes32 p2, address p3) internal pure {
  5979 |     |         bytes32 m0;
  5980 |     |         bytes32 m1;
  5981 |     |         bytes32 m2;
  5982 |     |         bytes32 m3;
  5983 |     |         bytes32 m4;
  5984 |     |         bytes32 m5;
  5985 |     |         bytes32 m6;
  5986 |     |         /// @solidity memory-safe-assembly
  5987 |     |         assembly {
  5988 |     |             function writeString(pos, w) {
  5989 |     |                 let length := 0
  5990 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5991 |     |                 mstore(pos, length)
  5992 |     |                 let shift := sub(256, shl(3, length))
  5993 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5994 |     |             }
  5995 |     |             m0 := mload(0x00)
  5996 |     |             m1 := mload(0x20)
  5997 |     |             m2 := mload(0x40)
  5998 |     |             m3 := mload(0x60)
  5999 |     |             m4 := mload(0x80)
  6000 |     |             m5 := mload(0xa0)
  6001 |     |             m6 := mload(0xc0)
  6002 |     |             // Selector of `log(bool,address,string,address)`.
  6003 |     |             mstore(0x00, 0x6f7c603e)
  6004 |     |             mstore(0x20, p0)
  6005 |     |             mstore(0x40, p1)
  6006 |     |             mstore(0x60, 0x80)
  6007 |     |             mstore(0x80, p3)
  6008 |     |             writeString(0xa0, p2)
  6009 |     |         }
  6010 |     |         _sendLogPayload(0x1c, 0xc4);
  6011 |     |         /// @solidity memory-safe-assembly
  6012 |     |         assembly {
  6013 |     |             mstore(0x00, m0)
  6014 |     |             mstore(0x20, m1)
  6015 |     |             mstore(0x40, m2)
  6016 |     |             mstore(0x60, m3)
  6017 |     |             mstore(0x80, m4)
  6018 |     |             mstore(0xa0, m5)
  6019 |     |             mstore(0xc0, m6)
  6020 |     |         }
  6021 |     |     }
  6022 |     | 
  6023 |     |     function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {
  6024 |     |         bytes32 m0;
  6025 |     |         bytes32 m1;
  6026 |     |         bytes32 m2;
  6027 |     |         bytes32 m3;
  6028 |     |         bytes32 m4;
  6029 |     |         bytes32 m5;
  6030 |     |         bytes32 m6;
  6031 |     |         /// @solidity memory-safe-assembly
  6032 |     |         assembly {
  6033 |     |             function writeString(pos, w) {
  6034 |     |                 let length := 0
  6035 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6036 |     |                 mstore(pos, length)
  6037 |     |                 let shift := sub(256, shl(3, length))
  6038 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6039 |     |             }
  6040 |     |             m0 := mload(0x00)
  6041 |     |             m1 := mload(0x20)
  6042 |     |             m2 := mload(0x40)
  6043 |     |             m3 := mload(0x60)
  6044 |     |             m4 := mload(0x80)
  6045 |     |             m5 := mload(0xa0)
  6046 |     |             m6 := mload(0xc0)
  6047 |     |             // Selector of `log(bool,address,string,bool)`.
  6048 |     |             mstore(0x00, 0xe2bfd60b)
  6049 |     |             mstore(0x20, p0)
  6050 |     |             mstore(0x40, p1)
  6051 |     |             mstore(0x60, 0x80)
  6052 |     |             mstore(0x80, p3)
  6053 |     |             writeString(0xa0, p2)
  6054 |     |         }
  6055 |     |         _sendLogPayload(0x1c, 0xc4);
  6056 |     |         /// @solidity memory-safe-assembly
  6057 |     |         assembly {
  6058 |     |             mstore(0x00, m0)
  6059 |     |             mstore(0x20, m1)
  6060 |     |             mstore(0x40, m2)
  6061 |     |             mstore(0x60, m3)
  6062 |     |             mstore(0x80, m4)
  6063 |     |             mstore(0xa0, m5)
  6064 |     |             mstore(0xc0, m6)
  6065 |     |         }
  6066 |     |     }
  6067 |     | 
  6068 |     |     function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {
  6069 |     |         bytes32 m0;
  6070 |     |         bytes32 m1;
  6071 |     |         bytes32 m2;
  6072 |     |         bytes32 m3;
  6073 |     |         bytes32 m4;
  6074 |     |         bytes32 m5;
  6075 |     |         bytes32 m6;
  6076 |     |         /// @solidity memory-safe-assembly
  6077 |     |         assembly {
  6078 |     |             function writeString(pos, w) {
  6079 |     |                 let length := 0
  6080 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6081 |     |                 mstore(pos, length)
  6082 |     |                 let shift := sub(256, shl(3, length))
  6083 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6084 |     |             }
  6085 |     |             m0 := mload(0x00)
  6086 |     |             m1 := mload(0x20)
  6087 |     |             m2 := mload(0x40)
  6088 |     |             m3 := mload(0x60)
  6089 |     |             m4 := mload(0x80)
  6090 |     |             m5 := mload(0xa0)
  6091 |     |             m6 := mload(0xc0)
  6092 |     |             // Selector of `log(bool,address,string,uint256)`.
  6093 |     |             mstore(0x00, 0xc21f64c7)
  6094 |     |             mstore(0x20, p0)
  6095 |     |             mstore(0x40, p1)
  6096 |     |             mstore(0x60, 0x80)
  6097 |     |             mstore(0x80, p3)
  6098 |     |             writeString(0xa0, p2)
  6099 |     |         }
  6100 |     |         _sendLogPayload(0x1c, 0xc4);
  6101 |     |         /// @solidity memory-safe-assembly
  6102 |     |         assembly {
  6103 |     |             mstore(0x00, m0)
  6104 |     |             mstore(0x20, m1)
  6105 |     |             mstore(0x40, m2)
  6106 |     |             mstore(0x60, m3)
  6107 |     |             mstore(0x80, m4)
  6108 |     |             mstore(0xa0, m5)
  6109 |     |             mstore(0xc0, m6)
  6110 |     |         }
  6111 |     |     }
  6112 |     | 
  6113 |     |     function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  6114 |     |         bytes32 m0;
  6115 |     |         bytes32 m1;
  6116 |     |         bytes32 m2;
  6117 |     |         bytes32 m3;
  6118 |     |         bytes32 m4;
  6119 |     |         bytes32 m5;
  6120 |     |         bytes32 m6;
  6121 |     |         bytes32 m7;
  6122 |     |         bytes32 m8;
  6123 |     |         /// @solidity memory-safe-assembly
  6124 |     |         assembly {
  6125 |     |             function writeString(pos, w) {
  6126 |     |                 let length := 0
  6127 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6128 |     |                 mstore(pos, length)
  6129 |     |                 let shift := sub(256, shl(3, length))
  6130 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6131 |     |             }
  6132 |     |             m0 := mload(0x00)
  6133 |     |             m1 := mload(0x20)
  6134 |     |             m2 := mload(0x40)
  6135 |     |             m3 := mload(0x60)
  6136 |     |             m4 := mload(0x80)
  6137 |     |             m5 := mload(0xa0)
  6138 |     |             m6 := mload(0xc0)
  6139 |     |             m7 := mload(0xe0)
  6140 |     |             m8 := mload(0x100)
  6141 |     |             // Selector of `log(bool,address,string,string)`.
  6142 |     |             mstore(0x00, 0xa73c1db6)
  6143 |     |             mstore(0x20, p0)
  6144 |     |             mstore(0x40, p1)
  6145 |     |             mstore(0x60, 0x80)
  6146 |     |             mstore(0x80, 0xc0)
  6147 |     |             writeString(0xa0, p2)
  6148 |     |             writeString(0xe0, p3)
  6149 |     |         }
  6150 |     |         _sendLogPayload(0x1c, 0x104);
  6151 |     |         /// @solidity memory-safe-assembly
  6152 |     |         assembly {
  6153 |     |             mstore(0x00, m0)
  6154 |     |             mstore(0x20, m1)
  6155 |     |             mstore(0x40, m2)
  6156 |     |             mstore(0x60, m3)
  6157 |     |             mstore(0x80, m4)
  6158 |     |             mstore(0xa0, m5)
  6159 |     |             mstore(0xc0, m6)
  6160 |     |             mstore(0xe0, m7)
  6161 |     |             mstore(0x100, m8)
  6162 |     |         }
  6163 |     |     }
  6164 |     | 
  6165 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
  6166 |     |         bytes32 m0;
  6167 |     |         bytes32 m1;
  6168 |     |         bytes32 m2;
  6169 |     |         bytes32 m3;
  6170 |     |         bytes32 m4;
  6171 |     |         /// @solidity memory-safe-assembly
  6172 |     |         assembly {
  6173 |     |             m0 := mload(0x00)
  6174 |     |             m1 := mload(0x20)
  6175 |     |             m2 := mload(0x40)
  6176 |     |             m3 := mload(0x60)
  6177 |     |             m4 := mload(0x80)
  6178 |     |             // Selector of `log(bool,bool,address,address)`.
  6179 |     |             mstore(0x00, 0xf4880ea4)
  6180 |     |             mstore(0x20, p0)
  6181 |     |             mstore(0x40, p1)
  6182 |     |             mstore(0x60, p2)
  6183 |     |             mstore(0x80, p3)
  6184 |     |         }
  6185 |     |         _sendLogPayload(0x1c, 0x84);
  6186 |     |         /// @solidity memory-safe-assembly
  6187 |     |         assembly {
  6188 |     |             mstore(0x00, m0)
  6189 |     |             mstore(0x20, m1)
  6190 |     |             mstore(0x40, m2)
  6191 |     |             mstore(0x60, m3)
  6192 |     |             mstore(0x80, m4)
  6193 |     |         }
  6194 |     |     }
  6195 |     | 
  6196 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
  6197 |     |         bytes32 m0;
  6198 |     |         bytes32 m1;
  6199 |     |         bytes32 m2;
  6200 |     |         bytes32 m3;
  6201 |     |         bytes32 m4;
  6202 |     |         /// @solidity memory-safe-assembly
  6203 |     |         assembly {
  6204 |     |             m0 := mload(0x00)
  6205 |     |             m1 := mload(0x20)
  6206 |     |             m2 := mload(0x40)
  6207 |     |             m3 := mload(0x60)
  6208 |     |             m4 := mload(0x80)
  6209 |     |             // Selector of `log(bool,bool,address,bool)`.
  6210 |     |             mstore(0x00, 0xc0a302d8)
  6211 |     |             mstore(0x20, p0)
  6212 |     |             mstore(0x40, p1)
  6213 |     |             mstore(0x60, p2)
  6214 |     |             mstore(0x80, p3)
  6215 |     |         }
  6216 |     |         _sendLogPayload(0x1c, 0x84);
  6217 |     |         /// @solidity memory-safe-assembly
  6218 |     |         assembly {
  6219 |     |             mstore(0x00, m0)
  6220 |     |             mstore(0x20, m1)
  6221 |     |             mstore(0x40, m2)
  6222 |     |             mstore(0x60, m3)
  6223 |     |             mstore(0x80, m4)
  6224 |     |         }
  6225 |     |     }
  6226 |     | 
  6227 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal pure {
  6228 |     |         bytes32 m0;
  6229 |     |         bytes32 m1;
  6230 |     |         bytes32 m2;
  6231 |     |         bytes32 m3;
  6232 |     |         bytes32 m4;
  6233 |     |         /// @solidity memory-safe-assembly
  6234 |     |         assembly {
  6235 |     |             m0 := mload(0x00)
  6236 |     |             m1 := mload(0x20)
  6237 |     |             m2 := mload(0x40)
  6238 |     |             m3 := mload(0x60)
  6239 |     |             m4 := mload(0x80)
  6240 |     |             // Selector of `log(bool,bool,address,uint256)`.
  6241 |     |             mstore(0x00, 0x4c123d57)
  6242 |     |             mstore(0x20, p0)
  6243 |     |             mstore(0x40, p1)
  6244 |     |             mstore(0x60, p2)
  6245 |     |             mstore(0x80, p3)
  6246 |     |         }
  6247 |     |         _sendLogPayload(0x1c, 0x84);
  6248 |     |         /// @solidity memory-safe-assembly
  6249 |     |         assembly {
  6250 |     |             mstore(0x00, m0)
  6251 |     |             mstore(0x20, m1)
  6252 |     |             mstore(0x40, m2)
  6253 |     |             mstore(0x60, m3)
  6254 |     |             mstore(0x80, m4)
  6255 |     |         }
  6256 |     |     }
  6257 |     | 
  6258 |     |     function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {
  6259 |     |         bytes32 m0;
  6260 |     |         bytes32 m1;
  6261 |     |         bytes32 m2;
  6262 |     |         bytes32 m3;
  6263 |     |         bytes32 m4;
  6264 |     |         bytes32 m5;
  6265 |     |         bytes32 m6;
  6266 |     |         /// @solidity memory-safe-assembly
  6267 |     |         assembly {
  6268 |     |             function writeString(pos, w) {
  6269 |     |                 let length := 0
  6270 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6271 |     |                 mstore(pos, length)
  6272 |     |                 let shift := sub(256, shl(3, length))
  6273 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6274 |     |             }
  6275 |     |             m0 := mload(0x00)
  6276 |     |             m1 := mload(0x20)
  6277 |     |             m2 := mload(0x40)
  6278 |     |             m3 := mload(0x60)
  6279 |     |             m4 := mload(0x80)
  6280 |     |             m5 := mload(0xa0)
  6281 |     |             m6 := mload(0xc0)
  6282 |     |             // Selector of `log(bool,bool,address,string)`.
  6283 |     |             mstore(0x00, 0xa0a47963)
  6284 |     |             mstore(0x20, p0)
  6285 |     |             mstore(0x40, p1)
  6286 |     |             mstore(0x60, p2)
  6287 |     |             mstore(0x80, 0x80)
  6288 |     |             writeString(0xa0, p3)
  6289 |     |         }
  6290 |     |         _sendLogPayload(0x1c, 0xc4);
  6291 |     |         /// @solidity memory-safe-assembly
  6292 |     |         assembly {
  6293 |     |             mstore(0x00, m0)
  6294 |     |             mstore(0x20, m1)
  6295 |     |             mstore(0x40, m2)
  6296 |     |             mstore(0x60, m3)
  6297 |     |             mstore(0x80, m4)
  6298 |     |             mstore(0xa0, m5)
  6299 |     |             mstore(0xc0, m6)
  6300 |     |         }
  6301 |     |     }
  6302 |     | 
  6303 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
  6304 |     |         bytes32 m0;
  6305 |     |         bytes32 m1;
  6306 |     |         bytes32 m2;
  6307 |     |         bytes32 m3;
  6308 |     |         bytes32 m4;
  6309 |     |         /// @solidity memory-safe-assembly
  6310 |     |         assembly {
  6311 |     |             m0 := mload(0x00)
  6312 |     |             m1 := mload(0x20)
  6313 |     |             m2 := mload(0x40)
  6314 |     |             m3 := mload(0x60)
  6315 |     |             m4 := mload(0x80)
  6316 |     |             // Selector of `log(bool,bool,bool,address)`.
  6317 |     |             mstore(0x00, 0x8c329b1a)
  6318 |     |             mstore(0x20, p0)
  6319 |     |             mstore(0x40, p1)
  6320 |     |             mstore(0x60, p2)
  6321 |     |             mstore(0x80, p3)
  6322 |     |         }
  6323 |     |         _sendLogPayload(0x1c, 0x84);
  6324 |     |         /// @solidity memory-safe-assembly
  6325 |     |         assembly {
  6326 |     |             mstore(0x00, m0)
  6327 |     |             mstore(0x20, m1)
  6328 |     |             mstore(0x40, m2)
  6329 |     |             mstore(0x60, m3)
  6330 |     |             mstore(0x80, m4)
  6331 |     |         }
  6332 |     |     }
  6333 |     | 
  6334 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
  6335 |     |         bytes32 m0;
  6336 |     |         bytes32 m1;
  6337 |     |         bytes32 m2;
  6338 |     |         bytes32 m3;
  6339 |     |         bytes32 m4;
  6340 |     |         /// @solidity memory-safe-assembly
  6341 |     |         assembly {
  6342 |     |             m0 := mload(0x00)
  6343 |     |             m1 := mload(0x20)
  6344 |     |             m2 := mload(0x40)
  6345 |     |             m3 := mload(0x60)
  6346 |     |             m4 := mload(0x80)
  6347 |     |             // Selector of `log(bool,bool,bool,bool)`.
  6348 |     |             mstore(0x00, 0x3b2a5ce0)
  6349 |     |             mstore(0x20, p0)
  6350 |     |             mstore(0x40, p1)
  6351 |     |             mstore(0x60, p2)
  6352 |     |             mstore(0x80, p3)
  6353 |     |         }
  6354 |     |         _sendLogPayload(0x1c, 0x84);
  6355 |     |         /// @solidity memory-safe-assembly
  6356 |     |         assembly {
  6357 |     |             mstore(0x00, m0)
  6358 |     |             mstore(0x20, m1)
  6359 |     |             mstore(0x40, m2)
  6360 |     |             mstore(0x60, m3)
  6361 |     |             mstore(0x80, m4)
  6362 |     |         }
  6363 |     |     }
  6364 |     | 
  6365 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {
  6366 |     |         bytes32 m0;
  6367 |     |         bytes32 m1;
  6368 |     |         bytes32 m2;
  6369 |     |         bytes32 m3;
  6370 |     |         bytes32 m4;
  6371 |     |         /// @solidity memory-safe-assembly
  6372 |     |         assembly {
  6373 |     |             m0 := mload(0x00)
  6374 |     |             m1 := mload(0x20)
  6375 |     |             m2 := mload(0x40)
  6376 |     |             m3 := mload(0x60)
  6377 |     |             m4 := mload(0x80)
  6378 |     |             // Selector of `log(bool,bool,bool,uint256)`.
  6379 |     |             mstore(0x00, 0x6d7045c1)
  6380 |     |             mstore(0x20, p0)
  6381 |     |             mstore(0x40, p1)
  6382 |     |             mstore(0x60, p2)
  6383 |     |             mstore(0x80, p3)
  6384 |     |         }
  6385 |     |         _sendLogPayload(0x1c, 0x84);
  6386 |     |         /// @solidity memory-safe-assembly
  6387 |     |         assembly {
  6388 |     |             mstore(0x00, m0)
  6389 |     |             mstore(0x20, m1)
  6390 |     |             mstore(0x40, m2)
  6391 |     |             mstore(0x60, m3)
  6392 |     |             mstore(0x80, m4)
  6393 |     |         }
  6394 |     |     }
  6395 |     | 
  6396 |     |     function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {
  6397 |     |         bytes32 m0;
  6398 |     |         bytes32 m1;
  6399 |     |         bytes32 m2;
  6400 |     |         bytes32 m3;
  6401 |     |         bytes32 m4;
  6402 |     |         bytes32 m5;
  6403 |     |         bytes32 m6;
  6404 |     |         /// @solidity memory-safe-assembly
  6405 |     |         assembly {
  6406 |     |             function writeString(pos, w) {
  6407 |     |                 let length := 0
  6408 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6409 |     |                 mstore(pos, length)
  6410 |     |                 let shift := sub(256, shl(3, length))
  6411 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6412 |     |             }
  6413 |     |             m0 := mload(0x00)
  6414 |     |             m1 := mload(0x20)
  6415 |     |             m2 := mload(0x40)
  6416 |     |             m3 := mload(0x60)
  6417 |     |             m4 := mload(0x80)
  6418 |     |             m5 := mload(0xa0)
  6419 |     |             m6 := mload(0xc0)
  6420 |     |             // Selector of `log(bool,bool,bool,string)`.
  6421 |     |             mstore(0x00, 0x2ae408d4)
  6422 |     |             mstore(0x20, p0)
  6423 |     |             mstore(0x40, p1)
  6424 |     |             mstore(0x60, p2)
  6425 |     |             mstore(0x80, 0x80)
  6426 |     |             writeString(0xa0, p3)
  6427 |     |         }
  6428 |     |         _sendLogPayload(0x1c, 0xc4);
  6429 |     |         /// @solidity memory-safe-assembly
  6430 |     |         assembly {
  6431 |     |             mstore(0x00, m0)
  6432 |     |             mstore(0x20, m1)
  6433 |     |             mstore(0x40, m2)
  6434 |     |             mstore(0x60, m3)
  6435 |     |             mstore(0x80, m4)
  6436 |     |             mstore(0xa0, m5)
  6437 |     |             mstore(0xc0, m6)
  6438 |     |         }
  6439 |     |     }
  6440 |     | 
  6441 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal pure {
  6442 |     |         bytes32 m0;
  6443 |     |         bytes32 m1;
  6444 |     |         bytes32 m2;
  6445 |     |         bytes32 m3;
  6446 |     |         bytes32 m4;
  6447 |     |         /// @solidity memory-safe-assembly
  6448 |     |         assembly {
  6449 |     |             m0 := mload(0x00)
  6450 |     |             m1 := mload(0x20)
  6451 |     |             m2 := mload(0x40)
  6452 |     |             m3 := mload(0x60)
  6453 |     |             m4 := mload(0x80)
  6454 |     |             // Selector of `log(bool,bool,uint256,address)`.
  6455 |     |             mstore(0x00, 0x54a7a9a0)
  6456 |     |             mstore(0x20, p0)
  6457 |     |             mstore(0x40, p1)
  6458 |     |             mstore(0x60, p2)
  6459 |     |             mstore(0x80, p3)
  6460 |     |         }
  6461 |     |         _sendLogPayload(0x1c, 0x84);
  6462 |     |         /// @solidity memory-safe-assembly
  6463 |     |         assembly {
  6464 |     |             mstore(0x00, m0)
  6465 |     |             mstore(0x20, m1)
  6466 |     |             mstore(0x40, m2)
  6467 |     |             mstore(0x60, m3)
  6468 |     |             mstore(0x80, m4)
  6469 |     |         }
  6470 |     |     }
  6471 |     | 
  6472 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {
  6473 |     |         bytes32 m0;
  6474 |     |         bytes32 m1;
  6475 |     |         bytes32 m2;
  6476 |     |         bytes32 m3;
  6477 |     |         bytes32 m4;
  6478 |     |         /// @solidity memory-safe-assembly
  6479 |     |         assembly {
  6480 |     |             m0 := mload(0x00)
  6481 |     |             m1 := mload(0x20)
  6482 |     |             m2 := mload(0x40)
  6483 |     |             m3 := mload(0x60)
  6484 |     |             m4 := mload(0x80)
  6485 |     |             // Selector of `log(bool,bool,uint256,bool)`.
  6486 |     |             mstore(0x00, 0x619e4d0e)
  6487 |     |             mstore(0x20, p0)
  6488 |     |             mstore(0x40, p1)
  6489 |     |             mstore(0x60, p2)
  6490 |     |             mstore(0x80, p3)
  6491 |     |         }
  6492 |     |         _sendLogPayload(0x1c, 0x84);
  6493 |     |         /// @solidity memory-safe-assembly
  6494 |     |         assembly {
  6495 |     |             mstore(0x00, m0)
  6496 |     |             mstore(0x20, m1)
  6497 |     |             mstore(0x40, m2)
  6498 |     |             mstore(0x60, m3)
  6499 |     |             mstore(0x80, m4)
  6500 |     |         }
  6501 |     |     }
  6502 |     | 
  6503 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {
  6504 |     |         bytes32 m0;
  6505 |     |         bytes32 m1;
  6506 |     |         bytes32 m2;
  6507 |     |         bytes32 m3;
  6508 |     |         bytes32 m4;
  6509 |     |         /// @solidity memory-safe-assembly
  6510 |     |         assembly {
  6511 |     |             m0 := mload(0x00)
  6512 |     |             m1 := mload(0x20)
  6513 |     |             m2 := mload(0x40)
  6514 |     |             m3 := mload(0x60)
  6515 |     |             m4 := mload(0x80)
  6516 |     |             // Selector of `log(bool,bool,uint256,uint256)`.
  6517 |     |             mstore(0x00, 0x0bb00eab)
  6518 |     |             mstore(0x20, p0)
  6519 |     |             mstore(0x40, p1)
  6520 |     |             mstore(0x60, p2)
  6521 |     |             mstore(0x80, p3)
  6522 |     |         }
  6523 |     |         _sendLogPayload(0x1c, 0x84);
  6524 |     |         /// @solidity memory-safe-assembly
  6525 |     |         assembly {
  6526 |     |             mstore(0x00, m0)
  6527 |     |             mstore(0x20, m1)
  6528 |     |             mstore(0x40, m2)
  6529 |     |             mstore(0x60, m3)
  6530 |     |             mstore(0x80, m4)
  6531 |     |         }
  6532 |     |     }
  6533 |     | 
  6534 |     |     function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  6535 |     |         bytes32 m0;
  6536 |     |         bytes32 m1;
  6537 |     |         bytes32 m2;
  6538 |     |         bytes32 m3;
  6539 |     |         bytes32 m4;
  6540 |     |         bytes32 m5;
  6541 |     |         bytes32 m6;
  6542 |     |         /// @solidity memory-safe-assembly
  6543 |     |         assembly {
  6544 |     |             function writeString(pos, w) {
  6545 |     |                 let length := 0
  6546 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6547 |     |                 mstore(pos, length)
  6548 |     |                 let shift := sub(256, shl(3, length))
  6549 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6550 |     |             }
  6551 |     |             m0 := mload(0x00)
  6552 |     |             m1 := mload(0x20)
  6553 |     |             m2 := mload(0x40)
  6554 |     |             m3 := mload(0x60)
  6555 |     |             m4 := mload(0x80)
  6556 |     |             m5 := mload(0xa0)
  6557 |     |             m6 := mload(0xc0)
  6558 |     |             // Selector of `log(bool,bool,uint256,string)`.
  6559 |     |             mstore(0x00, 0x7dd4d0e0)
  6560 |     |             mstore(0x20, p0)
  6561 |     |             mstore(0x40, p1)
  6562 |     |             mstore(0x60, p2)
  6563 |     |             mstore(0x80, 0x80)
  6564 |     |             writeString(0xa0, p3)
  6565 |     |         }
  6566 |     |         _sendLogPayload(0x1c, 0xc4);
  6567 |     |         /// @solidity memory-safe-assembly
  6568 |     |         assembly {
  6569 |     |             mstore(0x00, m0)
  6570 |     |             mstore(0x20, m1)
  6571 |     |             mstore(0x40, m2)
  6572 |     |             mstore(0x60, m3)
  6573 |     |             mstore(0x80, m4)
  6574 |     |             mstore(0xa0, m5)
  6575 |     |             mstore(0xc0, m6)
  6576 |     |         }
  6577 |     |     }
  6578 |     | 
  6579 |     |     function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {
  6580 |     |         bytes32 m0;
  6581 |     |         bytes32 m1;
  6582 |     |         bytes32 m2;
  6583 |     |         bytes32 m3;
  6584 |     |         bytes32 m4;
  6585 |     |         bytes32 m5;
  6586 |     |         bytes32 m6;
  6587 |     |         /// @solidity memory-safe-assembly
  6588 |     |         assembly {
  6589 |     |             function writeString(pos, w) {
  6590 |     |                 let length := 0
  6591 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6592 |     |                 mstore(pos, length)
  6593 |     |                 let shift := sub(256, shl(3, length))
  6594 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6595 |     |             }
  6596 |     |             m0 := mload(0x00)
  6597 |     |             m1 := mload(0x20)
  6598 |     |             m2 := mload(0x40)
  6599 |     |             m3 := mload(0x60)
  6600 |     |             m4 := mload(0x80)
  6601 |     |             m5 := mload(0xa0)
  6602 |     |             m6 := mload(0xc0)
  6603 |     |             // Selector of `log(bool,bool,string,address)`.
  6604 |     |             mstore(0x00, 0xf9ad2b89)
  6605 |     |             mstore(0x20, p0)
  6606 |     |             mstore(0x40, p1)
  6607 |     |             mstore(0x60, 0x80)
  6608 |     |             mstore(0x80, p3)
  6609 |     |             writeString(0xa0, p2)
  6610 |     |         }
  6611 |     |         _sendLogPayload(0x1c, 0xc4);
  6612 |     |         /// @solidity memory-safe-assembly
  6613 |     |         assembly {
  6614 |     |             mstore(0x00, m0)
  6615 |     |             mstore(0x20, m1)
  6616 |     |             mstore(0x40, m2)
  6617 |     |             mstore(0x60, m3)
  6618 |     |             mstore(0x80, m4)
  6619 |     |             mstore(0xa0, m5)
  6620 |     |             mstore(0xc0, m6)
  6621 |     |         }
  6622 |     |     }
  6623 |     | 
  6624 |     |     function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {
  6625 |     |         bytes32 m0;
  6626 |     |         bytes32 m1;
  6627 |     |         bytes32 m2;
  6628 |     |         bytes32 m3;
  6629 |     |         bytes32 m4;
  6630 |     |         bytes32 m5;
  6631 |     |         bytes32 m6;
  6632 |     |         /// @solidity memory-safe-assembly
  6633 |     |         assembly {
  6634 |     |             function writeString(pos, w) {
  6635 |     |                 let length := 0
  6636 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6637 |     |                 mstore(pos, length)
  6638 |     |                 let shift := sub(256, shl(3, length))
  6639 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6640 |     |             }
  6641 |     |             m0 := mload(0x00)
  6642 |     |             m1 := mload(0x20)
  6643 |     |             m2 := mload(0x40)
  6644 |     |             m3 := mload(0x60)
  6645 |     |             m4 := mload(0x80)
  6646 |     |             m5 := mload(0xa0)
  6647 |     |             m6 := mload(0xc0)
  6648 |     |             // Selector of `log(bool,bool,string,bool)`.
  6649 |     |             mstore(0x00, 0xb857163a)
  6650 |     |             mstore(0x20, p0)
  6651 |     |             mstore(0x40, p1)
  6652 |     |             mstore(0x60, 0x80)
  6653 |     |             mstore(0x80, p3)
  6654 |     |             writeString(0xa0, p2)
  6655 |     |         }
  6656 |     |         _sendLogPayload(0x1c, 0xc4);
  6657 |     |         /// @solidity memory-safe-assembly
  6658 |     |         assembly {
  6659 |     |             mstore(0x00, m0)
  6660 |     |             mstore(0x20, m1)
  6661 |     |             mstore(0x40, m2)
  6662 |     |             mstore(0x60, m3)
  6663 |     |             mstore(0x80, m4)
  6664 |     |             mstore(0xa0, m5)
  6665 |     |             mstore(0xc0, m6)
  6666 |     |         }
  6667 |     |     }
  6668 |     | 
  6669 |     |     function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  6670 |     |         bytes32 m0;
  6671 |     |         bytes32 m1;
  6672 |     |         bytes32 m2;
  6673 |     |         bytes32 m3;
  6674 |     |         bytes32 m4;
  6675 |     |         bytes32 m5;
  6676 |     |         bytes32 m6;
  6677 |     |         /// @solidity memory-safe-assembly
  6678 |     |         assembly {
  6679 |     |             function writeString(pos, w) {
  6680 |     |                 let length := 0
  6681 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6682 |     |                 mstore(pos, length)
  6683 |     |                 let shift := sub(256, shl(3, length))
  6684 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6685 |     |             }
  6686 |     |             m0 := mload(0x00)
  6687 |     |             m1 := mload(0x20)
  6688 |     |             m2 := mload(0x40)
  6689 |     |             m3 := mload(0x60)
  6690 |     |             m4 := mload(0x80)
  6691 |     |             m5 := mload(0xa0)
  6692 |     |             m6 := mload(0xc0)
  6693 |     |             // Selector of `log(bool,bool,string,uint256)`.
  6694 |     |             mstore(0x00, 0xe3a9ca2f)
  6695 |     |             mstore(0x20, p0)
  6696 |     |             mstore(0x40, p1)
  6697 |     |             mstore(0x60, 0x80)
  6698 |     |             mstore(0x80, p3)
  6699 |     |             writeString(0xa0, p2)
  6700 |     |         }
  6701 |     |         _sendLogPayload(0x1c, 0xc4);
  6702 |     |         /// @solidity memory-safe-assembly
  6703 |     |         assembly {
  6704 |     |             mstore(0x00, m0)
  6705 |     |             mstore(0x20, m1)
  6706 |     |             mstore(0x40, m2)
  6707 |     |             mstore(0x60, m3)
  6708 |     |             mstore(0x80, m4)
  6709 |     |             mstore(0xa0, m5)
  6710 |     |             mstore(0xc0, m6)
  6711 |     |         }
  6712 |     |     }
  6713 |     | 
  6714 |     |     function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  6715 |     |         bytes32 m0;
  6716 |     |         bytes32 m1;
  6717 |     |         bytes32 m2;
  6718 |     |         bytes32 m3;
  6719 |     |         bytes32 m4;
  6720 |     |         bytes32 m5;
  6721 |     |         bytes32 m6;
  6722 |     |         bytes32 m7;
  6723 |     |         bytes32 m8;
  6724 |     |         /// @solidity memory-safe-assembly
  6725 |     |         assembly {
  6726 |     |             function writeString(pos, w) {
  6727 |     |                 let length := 0
  6728 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6729 |     |                 mstore(pos, length)
  6730 |     |                 let shift := sub(256, shl(3, length))
  6731 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6732 |     |             }
  6733 |     |             m0 := mload(0x00)
  6734 |     |             m1 := mload(0x20)
  6735 |     |             m2 := mload(0x40)
  6736 |     |             m3 := mload(0x60)
  6737 |     |             m4 := mload(0x80)
  6738 |     |             m5 := mload(0xa0)
  6739 |     |             m6 := mload(0xc0)
  6740 |     |             m7 := mload(0xe0)
  6741 |     |             m8 := mload(0x100)
  6742 |     |             // Selector of `log(bool,bool,string,string)`.
  6743 |     |             mstore(0x00, 0x6d1e8751)
  6744 |     |             mstore(0x20, p0)
  6745 |     |             mstore(0x40, p1)
  6746 |     |             mstore(0x60, 0x80)
  6747 |     |             mstore(0x80, 0xc0)
  6748 |     |             writeString(0xa0, p2)
  6749 |     |             writeString(0xe0, p3)
  6750 |     |         }
  6751 |     |         _sendLogPayload(0x1c, 0x104);
  6752 |     |         /// @solidity memory-safe-assembly
  6753 |     |         assembly {
  6754 |     |             mstore(0x00, m0)
  6755 |     |             mstore(0x20, m1)
  6756 |     |             mstore(0x40, m2)
  6757 |     |             mstore(0x60, m3)
  6758 |     |             mstore(0x80, m4)
  6759 |     |             mstore(0xa0, m5)
  6760 |     |             mstore(0xc0, m6)
  6761 |     |             mstore(0xe0, m7)
  6762 |     |             mstore(0x100, m8)
  6763 |     |         }
  6764 |     |     }
  6765 |     | 
  6766 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal pure {
  6767 |     |         bytes32 m0;
  6768 |     |         bytes32 m1;
  6769 |     |         bytes32 m2;
  6770 |     |         bytes32 m3;
  6771 |     |         bytes32 m4;
  6772 |     |         /// @solidity memory-safe-assembly
  6773 |     |         assembly {
  6774 |     |             m0 := mload(0x00)
  6775 |     |             m1 := mload(0x20)
  6776 |     |             m2 := mload(0x40)
  6777 |     |             m3 := mload(0x60)
  6778 |     |             m4 := mload(0x80)
  6779 |     |             // Selector of `log(bool,uint256,address,address)`.
  6780 |     |             mstore(0x00, 0x26f560a8)
  6781 |     |             mstore(0x20, p0)
  6782 |     |             mstore(0x40, p1)
  6783 |     |             mstore(0x60, p2)
  6784 |     |             mstore(0x80, p3)
  6785 |     |         }
  6786 |     |         _sendLogPayload(0x1c, 0x84);
  6787 |     |         /// @solidity memory-safe-assembly
  6788 |     |         assembly {
  6789 |     |             mstore(0x00, m0)
  6790 |     |             mstore(0x20, m1)
  6791 |     |             mstore(0x40, m2)
  6792 |     |             mstore(0x60, m3)
  6793 |     |             mstore(0x80, m4)
  6794 |     |         }
  6795 |     |     }
  6796 |     | 
  6797 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal pure {
  6798 |     |         bytes32 m0;
  6799 |     |         bytes32 m1;
  6800 |     |         bytes32 m2;
  6801 |     |         bytes32 m3;
  6802 |     |         bytes32 m4;
  6803 |     |         /// @solidity memory-safe-assembly
  6804 |     |         assembly {
  6805 |     |             m0 := mload(0x00)
  6806 |     |             m1 := mload(0x20)
  6807 |     |             m2 := mload(0x40)
  6808 |     |             m3 := mload(0x60)
  6809 |     |             m4 := mload(0x80)
  6810 |     |             // Selector of `log(bool,uint256,address,bool)`.
  6811 |     |             mstore(0x00, 0xb4c314ff)
  6812 |     |             mstore(0x20, p0)
  6813 |     |             mstore(0x40, p1)
  6814 |     |             mstore(0x60, p2)
  6815 |     |             mstore(0x80, p3)
  6816 |     |         }
  6817 |     |         _sendLogPayload(0x1c, 0x84);
  6818 |     |         /// @solidity memory-safe-assembly
  6819 |     |         assembly {
  6820 |     |             mstore(0x00, m0)
  6821 |     |             mstore(0x20, m1)
  6822 |     |             mstore(0x40, m2)
  6823 |     |             mstore(0x60, m3)
  6824 |     |             mstore(0x80, m4)
  6825 |     |         }
  6826 |     |     }
  6827 |     | 
  6828 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {
  6829 |     |         bytes32 m0;
  6830 |     |         bytes32 m1;
  6831 |     |         bytes32 m2;
  6832 |     |         bytes32 m3;
  6833 |     |         bytes32 m4;
  6834 |     |         /// @solidity memory-safe-assembly
  6835 |     |         assembly {
  6836 |     |             m0 := mload(0x00)
  6837 |     |             m1 := mload(0x20)
  6838 |     |             m2 := mload(0x40)
  6839 |     |             m3 := mload(0x60)
  6840 |     |             m4 := mload(0x80)
  6841 |     |             // Selector of `log(bool,uint256,address,uint256)`.
  6842 |     |             mstore(0x00, 0x1537dc87)
  6843 |     |             mstore(0x20, p0)
  6844 |     |             mstore(0x40, p1)
  6845 |     |             mstore(0x60, p2)
  6846 |     |             mstore(0x80, p3)
  6847 |     |         }
  6848 |     |         _sendLogPayload(0x1c, 0x84);
  6849 |     |         /// @solidity memory-safe-assembly
  6850 |     |         assembly {
  6851 |     |             mstore(0x00, m0)
  6852 |     |             mstore(0x20, m1)
  6853 |     |             mstore(0x40, m2)
  6854 |     |             mstore(0x60, m3)
  6855 |     |             mstore(0x80, m4)
  6856 |     |         }
  6857 |     |     }
  6858 |     | 
  6859 |     |     function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {
  6860 |     |         bytes32 m0;
  6861 |     |         bytes32 m1;
  6862 |     |         bytes32 m2;
  6863 |     |         bytes32 m3;
  6864 |     |         bytes32 m4;
  6865 |     |         bytes32 m5;
  6866 |     |         bytes32 m6;
  6867 |     |         /// @solidity memory-safe-assembly
  6868 |     |         assembly {
  6869 |     |             function writeString(pos, w) {
  6870 |     |                 let length := 0
  6871 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6872 |     |                 mstore(pos, length)
  6873 |     |                 let shift := sub(256, shl(3, length))
  6874 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6875 |     |             }
  6876 |     |             m0 := mload(0x00)
  6877 |     |             m1 := mload(0x20)
  6878 |     |             m2 := mload(0x40)
  6879 |     |             m3 := mload(0x60)
  6880 |     |             m4 := mload(0x80)
  6881 |     |             m5 := mload(0xa0)
  6882 |     |             m6 := mload(0xc0)
  6883 |     |             // Selector of `log(bool,uint256,address,string)`.
  6884 |     |             mstore(0x00, 0x1bb3b09a)
  6885 |     |             mstore(0x20, p0)
  6886 |     |             mstore(0x40, p1)
  6887 |     |             mstore(0x60, p2)
  6888 |     |             mstore(0x80, 0x80)
  6889 |     |             writeString(0xa0, p3)
  6890 |     |         }
  6891 |     |         _sendLogPayload(0x1c, 0xc4);
  6892 |     |         /// @solidity memory-safe-assembly
  6893 |     |         assembly {
  6894 |     |             mstore(0x00, m0)
  6895 |     |             mstore(0x20, m1)
  6896 |     |             mstore(0x40, m2)
  6897 |     |             mstore(0x60, m3)
  6898 |     |             mstore(0x80, m4)
  6899 |     |             mstore(0xa0, m5)
  6900 |     |             mstore(0xc0, m6)
  6901 |     |         }
  6902 |     |     }
  6903 |     | 
  6904 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal pure {
  6905 |     |         bytes32 m0;
  6906 |     |         bytes32 m1;
  6907 |     |         bytes32 m2;
  6908 |     |         bytes32 m3;
  6909 |     |         bytes32 m4;
  6910 |     |         /// @solidity memory-safe-assembly
  6911 |     |         assembly {
  6912 |     |             m0 := mload(0x00)
  6913 |     |             m1 := mload(0x20)
  6914 |     |             m2 := mload(0x40)
  6915 |     |             m3 := mload(0x60)
  6916 |     |             m4 := mload(0x80)
  6917 |     |             // Selector of `log(bool,uint256,bool,address)`.
  6918 |     |             mstore(0x00, 0x9acd3616)
  6919 |     |             mstore(0x20, p0)
  6920 |     |             mstore(0x40, p1)
  6921 |     |             mstore(0x60, p2)
  6922 |     |             mstore(0x80, p3)
  6923 |     |         }
  6924 |     |         _sendLogPayload(0x1c, 0x84);
  6925 |     |         /// @solidity memory-safe-assembly
  6926 |     |         assembly {
  6927 |     |             mstore(0x00, m0)
  6928 |     |             mstore(0x20, m1)
  6929 |     |             mstore(0x40, m2)
  6930 |     |             mstore(0x60, m3)
  6931 |     |             mstore(0x80, m4)
  6932 |     |         }
  6933 |     |     }
  6934 |     | 
  6935 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {
  6936 |     |         bytes32 m0;
  6937 |     |         bytes32 m1;
  6938 |     |         bytes32 m2;
  6939 |     |         bytes32 m3;
  6940 |     |         bytes32 m4;
  6941 |     |         /// @solidity memory-safe-assembly
  6942 |     |         assembly {
  6943 |     |             m0 := mload(0x00)
  6944 |     |             m1 := mload(0x20)
  6945 |     |             m2 := mload(0x40)
  6946 |     |             m3 := mload(0x60)
  6947 |     |             m4 := mload(0x80)
  6948 |     |             // Selector of `log(bool,uint256,bool,bool)`.
  6949 |     |             mstore(0x00, 0xceb5f4d7)
  6950 |     |             mstore(0x20, p0)
  6951 |     |             mstore(0x40, p1)
  6952 |     |             mstore(0x60, p2)
  6953 |     |             mstore(0x80, p3)
  6954 |     |         }
  6955 |     |         _sendLogPayload(0x1c, 0x84);
  6956 |     |         /// @solidity memory-safe-assembly
  6957 |     |         assembly {
  6958 |     |             mstore(0x00, m0)
  6959 |     |             mstore(0x20, m1)
  6960 |     |             mstore(0x40, m2)
  6961 |     |             mstore(0x60, m3)
  6962 |     |             mstore(0x80, m4)
  6963 |     |         }
  6964 |     |     }
  6965 |     | 
  6966 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {
  6967 |     |         bytes32 m0;
  6968 |     |         bytes32 m1;
  6969 |     |         bytes32 m2;
  6970 |     |         bytes32 m3;
  6971 |     |         bytes32 m4;
  6972 |     |         /// @solidity memory-safe-assembly
  6973 |     |         assembly {
  6974 |     |             m0 := mload(0x00)
  6975 |     |             m1 := mload(0x20)
  6976 |     |             m2 := mload(0x40)
  6977 |     |             m3 := mload(0x60)
  6978 |     |             m4 := mload(0x80)
  6979 |     |             // Selector of `log(bool,uint256,bool,uint256)`.
  6980 |     |             mstore(0x00, 0x7f9bbca2)
  6981 |     |             mstore(0x20, p0)
  6982 |     |             mstore(0x40, p1)
  6983 |     |             mstore(0x60, p2)
  6984 |     |             mstore(0x80, p3)
  6985 |     |         }
  6986 |     |         _sendLogPayload(0x1c, 0x84);
  6987 |     |         /// @solidity memory-safe-assembly
  6988 |     |         assembly {
  6989 |     |             mstore(0x00, m0)
  6990 |     |             mstore(0x20, m1)
  6991 |     |             mstore(0x40, m2)
  6992 |     |             mstore(0x60, m3)
  6993 |     |             mstore(0x80, m4)
  6994 |     |         }
  6995 |     |     }
  6996 |     | 
  6997 |     |     function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  6998 |     |         bytes32 m0;
  6999 |     |         bytes32 m1;
  7000 |     |         bytes32 m2;
  7001 |     |         bytes32 m3;
  7002 |     |         bytes32 m4;
  7003 |     |         bytes32 m5;
  7004 |     |         bytes32 m6;
  7005 |     |         /// @solidity memory-safe-assembly
  7006 |     |         assembly {
  7007 |     |             function writeString(pos, w) {
  7008 |     |                 let length := 0
  7009 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7010 |     |                 mstore(pos, length)
  7011 |     |                 let shift := sub(256, shl(3, length))
  7012 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7013 |     |             }
  7014 |     |             m0 := mload(0x00)
  7015 |     |             m1 := mload(0x20)
  7016 |     |             m2 := mload(0x40)
  7017 |     |             m3 := mload(0x60)
  7018 |     |             m4 := mload(0x80)
  7019 |     |             m5 := mload(0xa0)
  7020 |     |             m6 := mload(0xc0)
  7021 |     |             // Selector of `log(bool,uint256,bool,string)`.
  7022 |     |             mstore(0x00, 0x9143dbb1)
  7023 |     |             mstore(0x20, p0)
  7024 |     |             mstore(0x40, p1)
  7025 |     |             mstore(0x60, p2)
  7026 |     |             mstore(0x80, 0x80)
  7027 |     |             writeString(0xa0, p3)
  7028 |     |         }
  7029 |     |         _sendLogPayload(0x1c, 0xc4);
  7030 |     |         /// @solidity memory-safe-assembly
  7031 |     |         assembly {
  7032 |     |             mstore(0x00, m0)
  7033 |     |             mstore(0x20, m1)
  7034 |     |             mstore(0x40, m2)
  7035 |     |             mstore(0x60, m3)
  7036 |     |             mstore(0x80, m4)
  7037 |     |             mstore(0xa0, m5)
  7038 |     |             mstore(0xc0, m6)
  7039 |     |         }
  7040 |     |     }
  7041 |     | 
  7042 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {
  7043 |     |         bytes32 m0;
  7044 |     |         bytes32 m1;
  7045 |     |         bytes32 m2;
  7046 |     |         bytes32 m3;
  7047 |     |         bytes32 m4;
  7048 |     |         /// @solidity memory-safe-assembly
  7049 |     |         assembly {
  7050 |     |             m0 := mload(0x00)
  7051 |     |             m1 := mload(0x20)
  7052 |     |             m2 := mload(0x40)
  7053 |     |             m3 := mload(0x60)
  7054 |     |             m4 := mload(0x80)
  7055 |     |             // Selector of `log(bool,uint256,uint256,address)`.
  7056 |     |             mstore(0x00, 0x00dd87b9)
  7057 |     |             mstore(0x20, p0)
  7058 |     |             mstore(0x40, p1)
  7059 |     |             mstore(0x60, p2)
  7060 |     |             mstore(0x80, p3)
  7061 |     |         }
  7062 |     |         _sendLogPayload(0x1c, 0x84);
  7063 |     |         /// @solidity memory-safe-assembly
  7064 |     |         assembly {
  7065 |     |             mstore(0x00, m0)
  7066 |     |             mstore(0x20, m1)
  7067 |     |             mstore(0x40, m2)
  7068 |     |             mstore(0x60, m3)
  7069 |     |             mstore(0x80, m4)
  7070 |     |         }
  7071 |     |     }
  7072 |     | 
  7073 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {
  7074 |     |         bytes32 m0;
  7075 |     |         bytes32 m1;
  7076 |     |         bytes32 m2;
  7077 |     |         bytes32 m3;
  7078 |     |         bytes32 m4;
  7079 |     |         /// @solidity memory-safe-assembly
  7080 |     |         assembly {
  7081 |     |             m0 := mload(0x00)
  7082 |     |             m1 := mload(0x20)
  7083 |     |             m2 := mload(0x40)
  7084 |     |             m3 := mload(0x60)
  7085 |     |             m4 := mload(0x80)
  7086 |     |             // Selector of `log(bool,uint256,uint256,bool)`.
  7087 |     |             mstore(0x00, 0xbe984353)
  7088 |     |             mstore(0x20, p0)
  7089 |     |             mstore(0x40, p1)
  7090 |     |             mstore(0x60, p2)
  7091 |     |             mstore(0x80, p3)
  7092 |     |         }
  7093 |     |         _sendLogPayload(0x1c, 0x84);
  7094 |     |         /// @solidity memory-safe-assembly
  7095 |     |         assembly {
  7096 |     |             mstore(0x00, m0)
  7097 |     |             mstore(0x20, m1)
  7098 |     |             mstore(0x40, m2)
  7099 |     |             mstore(0x60, m3)
  7100 |     |             mstore(0x80, m4)
  7101 |     |         }
  7102 |     |     }
  7103 |     | 
  7104 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  7105 |     |         bytes32 m0;
  7106 |     |         bytes32 m1;
  7107 |     |         bytes32 m2;
  7108 |     |         bytes32 m3;
  7109 |     |         bytes32 m4;
  7110 |     |         /// @solidity memory-safe-assembly
  7111 |     |         assembly {
  7112 |     |             m0 := mload(0x00)
  7113 |     |             m1 := mload(0x20)
  7114 |     |             m2 := mload(0x40)
  7115 |     |             m3 := mload(0x60)
  7116 |     |             m4 := mload(0x80)
  7117 |     |             // Selector of `log(bool,uint256,uint256,uint256)`.
  7118 |     |             mstore(0x00, 0x374bb4b2)
  7119 |     |             mstore(0x20, p0)
  7120 |     |             mstore(0x40, p1)
  7121 |     |             mstore(0x60, p2)
  7122 |     |             mstore(0x80, p3)
  7123 |     |         }
  7124 |     |         _sendLogPayload(0x1c, 0x84);
  7125 |     |         /// @solidity memory-safe-assembly
  7126 |     |         assembly {
  7127 |     |             mstore(0x00, m0)
  7128 |     |             mstore(0x20, m1)
  7129 |     |             mstore(0x40, m2)
  7130 |     |             mstore(0x60, m3)
  7131 |     |             mstore(0x80, m4)
  7132 |     |         }
  7133 |     |     }
  7134 |     | 
  7135 |     |     function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  7136 |     |         bytes32 m0;
  7137 |     |         bytes32 m1;
  7138 |     |         bytes32 m2;
  7139 |     |         bytes32 m3;
  7140 |     |         bytes32 m4;
  7141 |     |         bytes32 m5;
  7142 |     |         bytes32 m6;
  7143 |     |         /// @solidity memory-safe-assembly
  7144 |     |         assembly {
  7145 |     |             function writeString(pos, w) {
  7146 |     |                 let length := 0
  7147 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7148 |     |                 mstore(pos, length)
  7149 |     |                 let shift := sub(256, shl(3, length))
  7150 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7151 |     |             }
  7152 |     |             m0 := mload(0x00)
  7153 |     |             m1 := mload(0x20)
  7154 |     |             m2 := mload(0x40)
  7155 |     |             m3 := mload(0x60)
  7156 |     |             m4 := mload(0x80)
  7157 |     |             m5 := mload(0xa0)
  7158 |     |             m6 := mload(0xc0)
  7159 |     |             // Selector of `log(bool,uint256,uint256,string)`.
  7160 |     |             mstore(0x00, 0x8e69fb5d)
  7161 |     |             mstore(0x20, p0)
  7162 |     |             mstore(0x40, p1)
  7163 |     |             mstore(0x60, p2)
  7164 |     |             mstore(0x80, 0x80)
  7165 |     |             writeString(0xa0, p3)
  7166 |     |         }
  7167 |     |         _sendLogPayload(0x1c, 0xc4);
  7168 |     |         /// @solidity memory-safe-assembly
  7169 |     |         assembly {
  7170 |     |             mstore(0x00, m0)
  7171 |     |             mstore(0x20, m1)
  7172 |     |             mstore(0x40, m2)
  7173 |     |             mstore(0x60, m3)
  7174 |     |             mstore(0x80, m4)
  7175 |     |             mstore(0xa0, m5)
  7176 |     |             mstore(0xc0, m6)
  7177 |     |         }
  7178 |     |     }
  7179 |     | 
  7180 |     |     function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {
  7181 |     |         bytes32 m0;
  7182 |     |         bytes32 m1;
  7183 |     |         bytes32 m2;
  7184 |     |         bytes32 m3;
  7185 |     |         bytes32 m4;
  7186 |     |         bytes32 m5;
  7187 |     |         bytes32 m6;
  7188 |     |         /// @solidity memory-safe-assembly
  7189 |     |         assembly {
  7190 |     |             function writeString(pos, w) {
  7191 |     |                 let length := 0
  7192 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7193 |     |                 mstore(pos, length)
  7194 |     |                 let shift := sub(256, shl(3, length))
  7195 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7196 |     |             }
  7197 |     |             m0 := mload(0x00)
  7198 |     |             m1 := mload(0x20)
  7199 |     |             m2 := mload(0x40)
  7200 |     |             m3 := mload(0x60)
  7201 |     |             m4 := mload(0x80)
  7202 |     |             m5 := mload(0xa0)
  7203 |     |             m6 := mload(0xc0)
  7204 |     |             // Selector of `log(bool,uint256,string,address)`.
  7205 |     |             mstore(0x00, 0xfedd1fff)
  7206 |     |             mstore(0x20, p0)
  7207 |     |             mstore(0x40, p1)
  7208 |     |             mstore(0x60, 0x80)
  7209 |     |             mstore(0x80, p3)
  7210 |     |             writeString(0xa0, p2)
  7211 |     |         }
  7212 |     |         _sendLogPayload(0x1c, 0xc4);
  7213 |     |         /// @solidity memory-safe-assembly
  7214 |     |         assembly {
  7215 |     |             mstore(0x00, m0)
  7216 |     |             mstore(0x20, m1)
  7217 |     |             mstore(0x40, m2)
  7218 |     |             mstore(0x60, m3)
  7219 |     |             mstore(0x80, m4)
  7220 |     |             mstore(0xa0, m5)
  7221 |     |             mstore(0xc0, m6)
  7222 |     |         }
  7223 |     |     }
  7224 |     | 
  7225 |     |     function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  7226 |     |         bytes32 m0;
  7227 |     |         bytes32 m1;
  7228 |     |         bytes32 m2;
  7229 |     |         bytes32 m3;
  7230 |     |         bytes32 m4;
  7231 |     |         bytes32 m5;
  7232 |     |         bytes32 m6;
  7233 |     |         /// @solidity memory-safe-assembly
  7234 |     |         assembly {
  7235 |     |             function writeString(pos, w) {
  7236 |     |                 let length := 0
  7237 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7238 |     |                 mstore(pos, length)
  7239 |     |                 let shift := sub(256, shl(3, length))
  7240 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7241 |     |             }
  7242 |     |             m0 := mload(0x00)
  7243 |     |             m1 := mload(0x20)
  7244 |     |             m2 := mload(0x40)
  7245 |     |             m3 := mload(0x60)
  7246 |     |             m4 := mload(0x80)
  7247 |     |             m5 := mload(0xa0)
  7248 |     |             m6 := mload(0xc0)
  7249 |     |             // Selector of `log(bool,uint256,string,bool)`.
  7250 |     |             mstore(0x00, 0xe5e70b2b)
  7251 |     |             mstore(0x20, p0)
  7252 |     |             mstore(0x40, p1)
  7253 |     |             mstore(0x60, 0x80)
  7254 |     |             mstore(0x80, p3)
  7255 |     |             writeString(0xa0, p2)
  7256 |     |         }
  7257 |     |         _sendLogPayload(0x1c, 0xc4);
  7258 |     |         /// @solidity memory-safe-assembly
  7259 |     |         assembly {
  7260 |     |             mstore(0x00, m0)
  7261 |     |             mstore(0x20, m1)
  7262 |     |             mstore(0x40, m2)
  7263 |     |             mstore(0x60, m3)
  7264 |     |             mstore(0x80, m4)
  7265 |     |             mstore(0xa0, m5)
  7266 |     |             mstore(0xc0, m6)
  7267 |     |         }
  7268 |     |     }
  7269 |     | 
  7270 |     |     function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  7271 |     |         bytes32 m0;
  7272 |     |         bytes32 m1;
  7273 |     |         bytes32 m2;
  7274 |     |         bytes32 m3;
  7275 |     |         bytes32 m4;
  7276 |     |         bytes32 m5;
  7277 |     |         bytes32 m6;
  7278 |     |         /// @solidity memory-safe-assembly
  7279 |     |         assembly {
  7280 |     |             function writeString(pos, w) {
  7281 |     |                 let length := 0
  7282 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7283 |     |                 mstore(pos, length)
  7284 |     |                 let shift := sub(256, shl(3, length))
  7285 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7286 |     |             }
  7287 |     |             m0 := mload(0x00)
  7288 |     |             m1 := mload(0x20)
  7289 |     |             m2 := mload(0x40)
  7290 |     |             m3 := mload(0x60)
  7291 |     |             m4 := mload(0x80)
  7292 |     |             m5 := mload(0xa0)
  7293 |     |             m6 := mload(0xc0)
  7294 |     |             // Selector of `log(bool,uint256,string,uint256)`.
  7295 |     |             mstore(0x00, 0x6a1199e2)
  7296 |     |             mstore(0x20, p0)
  7297 |     |             mstore(0x40, p1)
  7298 |     |             mstore(0x60, 0x80)
  7299 |     |             mstore(0x80, p3)
  7300 |     |             writeString(0xa0, p2)
  7301 |     |         }
  7302 |     |         _sendLogPayload(0x1c, 0xc4);
  7303 |     |         /// @solidity memory-safe-assembly
  7304 |     |         assembly {
  7305 |     |             mstore(0x00, m0)
  7306 |     |             mstore(0x20, m1)
  7307 |     |             mstore(0x40, m2)
  7308 |     |             mstore(0x60, m3)
  7309 |     |             mstore(0x80, m4)
  7310 |     |             mstore(0xa0, m5)
  7311 |     |             mstore(0xc0, m6)
  7312 |     |         }
  7313 |     |     }
  7314 |     | 
  7315 |     |     function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  7316 |     |         bytes32 m0;
  7317 |     |         bytes32 m1;
  7318 |     |         bytes32 m2;
  7319 |     |         bytes32 m3;
  7320 |     |         bytes32 m4;
  7321 |     |         bytes32 m5;
  7322 |     |         bytes32 m6;
  7323 |     |         bytes32 m7;
  7324 |     |         bytes32 m8;
  7325 |     |         /// @solidity memory-safe-assembly
  7326 |     |         assembly {
  7327 |     |             function writeString(pos, w) {
  7328 |     |                 let length := 0
  7329 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7330 |     |                 mstore(pos, length)
  7331 |     |                 let shift := sub(256, shl(3, length))
  7332 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7333 |     |             }
  7334 |     |             m0 := mload(0x00)
  7335 |     |             m1 := mload(0x20)
  7336 |     |             m2 := mload(0x40)
  7337 |     |             m3 := mload(0x60)
  7338 |     |             m4 := mload(0x80)
  7339 |     |             m5 := mload(0xa0)
  7340 |     |             m6 := mload(0xc0)
  7341 |     |             m7 := mload(0xe0)
  7342 |     |             m8 := mload(0x100)
  7343 |     |             // Selector of `log(bool,uint256,string,string)`.
  7344 |     |             mstore(0x00, 0xf5bc2249)
  7345 |     |             mstore(0x20, p0)
  7346 |     |             mstore(0x40, p1)
  7347 |     |             mstore(0x60, 0x80)
  7348 |     |             mstore(0x80, 0xc0)
  7349 |     |             writeString(0xa0, p2)
  7350 |     |             writeString(0xe0, p3)
  7351 |     |         }
  7352 |     |         _sendLogPayload(0x1c, 0x104);
  7353 |     |         /// @solidity memory-safe-assembly
  7354 |     |         assembly {
  7355 |     |             mstore(0x00, m0)
  7356 |     |             mstore(0x20, m1)
  7357 |     |             mstore(0x40, m2)
  7358 |     |             mstore(0x60, m3)
  7359 |     |             mstore(0x80, m4)
  7360 |     |             mstore(0xa0, m5)
  7361 |     |             mstore(0xc0, m6)
  7362 |     |             mstore(0xe0, m7)
  7363 |     |             mstore(0x100, m8)
  7364 |     |         }
  7365 |     |     }
  7366 |     | 
  7367 |     |     function log(bool p0, bytes32 p1, address p2, address p3) internal pure {
  7368 |     |         bytes32 m0;
  7369 |     |         bytes32 m1;
  7370 |     |         bytes32 m2;
  7371 |     |         bytes32 m3;
  7372 |     |         bytes32 m4;
  7373 |     |         bytes32 m5;
  7374 |     |         bytes32 m6;
  7375 |     |         /// @solidity memory-safe-assembly
  7376 |     |         assembly {
  7377 |     |             function writeString(pos, w) {
  7378 |     |                 let length := 0
  7379 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7380 |     |                 mstore(pos, length)
  7381 |     |                 let shift := sub(256, shl(3, length))
  7382 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7383 |     |             }
  7384 |     |             m0 := mload(0x00)
  7385 |     |             m1 := mload(0x20)
  7386 |     |             m2 := mload(0x40)
  7387 |     |             m3 := mload(0x60)
  7388 |     |             m4 := mload(0x80)
  7389 |     |             m5 := mload(0xa0)
  7390 |     |             m6 := mload(0xc0)
  7391 |     |             // Selector of `log(bool,string,address,address)`.
  7392 |     |             mstore(0x00, 0x2b2b18dc)
  7393 |     |             mstore(0x20, p0)
  7394 |     |             mstore(0x40, 0x80)
  7395 |     |             mstore(0x60, p2)
  7396 |     |             mstore(0x80, p3)
  7397 |     |             writeString(0xa0, p1)
  7398 |     |         }
  7399 |     |         _sendLogPayload(0x1c, 0xc4);
  7400 |     |         /// @solidity memory-safe-assembly
  7401 |     |         assembly {
  7402 |     |             mstore(0x00, m0)
  7403 |     |             mstore(0x20, m1)
  7404 |     |             mstore(0x40, m2)
  7405 |     |             mstore(0x60, m3)
  7406 |     |             mstore(0x80, m4)
  7407 |     |             mstore(0xa0, m5)
  7408 |     |             mstore(0xc0, m6)
  7409 |     |         }
  7410 |     |     }
  7411 |     | 
  7412 |     |     function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {
  7413 |     |         bytes32 m0;
  7414 |     |         bytes32 m1;
  7415 |     |         bytes32 m2;
  7416 |     |         bytes32 m3;
  7417 |     |         bytes32 m4;
  7418 |     |         bytes32 m5;
  7419 |     |         bytes32 m6;
  7420 |     |         /// @solidity memory-safe-assembly
  7421 |     |         assembly {
  7422 |     |             function writeString(pos, w) {
  7423 |     |                 let length := 0
  7424 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7425 |     |                 mstore(pos, length)
  7426 |     |                 let shift := sub(256, shl(3, length))
  7427 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7428 |     |             }
  7429 |     |             m0 := mload(0x00)
  7430 |     |             m1 := mload(0x20)
  7431 |     |             m2 := mload(0x40)
  7432 |     |             m3 := mload(0x60)
  7433 |     |             m4 := mload(0x80)
  7434 |     |             m5 := mload(0xa0)
  7435 |     |             m6 := mload(0xc0)
  7436 |     |             // Selector of `log(bool,string,address,bool)`.
  7437 |     |             mstore(0x00, 0x6dd434ca)
  7438 |     |             mstore(0x20, p0)
  7439 |     |             mstore(0x40, 0x80)
  7440 |     |             mstore(0x60, p2)
  7441 |     |             mstore(0x80, p3)
  7442 |     |             writeString(0xa0, p1)
  7443 |     |         }
  7444 |     |         _sendLogPayload(0x1c, 0xc4);
  7445 |     |         /// @solidity memory-safe-assembly
  7446 |     |         assembly {
  7447 |     |             mstore(0x00, m0)
  7448 |     |             mstore(0x20, m1)
  7449 |     |             mstore(0x40, m2)
  7450 |     |             mstore(0x60, m3)
  7451 |     |             mstore(0x80, m4)
  7452 |     |             mstore(0xa0, m5)
  7453 |     |             mstore(0xc0, m6)
  7454 |     |         }
  7455 |     |     }
  7456 |     | 
  7457 |     |     function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {
  7458 |     |         bytes32 m0;
  7459 |     |         bytes32 m1;
  7460 |     |         bytes32 m2;
  7461 |     |         bytes32 m3;
  7462 |     |         bytes32 m4;
  7463 |     |         bytes32 m5;
  7464 |     |         bytes32 m6;
  7465 |     |         /// @solidity memory-safe-assembly
  7466 |     |         assembly {
  7467 |     |             function writeString(pos, w) {
  7468 |     |                 let length := 0
  7469 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7470 |     |                 mstore(pos, length)
  7471 |     |                 let shift := sub(256, shl(3, length))
  7472 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7473 |     |             }
  7474 |     |             m0 := mload(0x00)
  7475 |     |             m1 := mload(0x20)
  7476 |     |             m2 := mload(0x40)
  7477 |     |             m3 := mload(0x60)
  7478 |     |             m4 := mload(0x80)
  7479 |     |             m5 := mload(0xa0)
  7480 |     |             m6 := mload(0xc0)
  7481 |     |             // Selector of `log(bool,string,address,uint256)`.
  7482 |     |             mstore(0x00, 0xa5cada94)
  7483 |     |             mstore(0x20, p0)
  7484 |     |             mstore(0x40, 0x80)
  7485 |     |             mstore(0x60, p2)
  7486 |     |             mstore(0x80, p3)
  7487 |     |             writeString(0xa0, p1)
  7488 |     |         }
  7489 |     |         _sendLogPayload(0x1c, 0xc4);
  7490 |     |         /// @solidity memory-safe-assembly
  7491 |     |         assembly {
  7492 |     |             mstore(0x00, m0)
  7493 |     |             mstore(0x20, m1)
  7494 |     |             mstore(0x40, m2)
  7495 |     |             mstore(0x60, m3)
  7496 |     |             mstore(0x80, m4)
  7497 |     |             mstore(0xa0, m5)
  7498 |     |             mstore(0xc0, m6)
  7499 |     |         }
  7500 |     |     }
  7501 |     | 
  7502 |     |     function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  7503 |     |         bytes32 m0;
  7504 |     |         bytes32 m1;
  7505 |     |         bytes32 m2;
  7506 |     |         bytes32 m3;
  7507 |     |         bytes32 m4;
  7508 |     |         bytes32 m5;
  7509 |     |         bytes32 m6;
  7510 |     |         bytes32 m7;
  7511 |     |         bytes32 m8;
  7512 |     |         /// @solidity memory-safe-assembly
  7513 |     |         assembly {
  7514 |     |             function writeString(pos, w) {
  7515 |     |                 let length := 0
  7516 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7517 |     |                 mstore(pos, length)
  7518 |     |                 let shift := sub(256, shl(3, length))
  7519 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7520 |     |             }
  7521 |     |             m0 := mload(0x00)
  7522 |     |             m1 := mload(0x20)
  7523 |     |             m2 := mload(0x40)
  7524 |     |             m3 := mload(0x60)
  7525 |     |             m4 := mload(0x80)
  7526 |     |             m5 := mload(0xa0)
  7527 |     |             m6 := mload(0xc0)
  7528 |     |             m7 := mload(0xe0)
  7529 |     |             m8 := mload(0x100)
  7530 |     |             // Selector of `log(bool,string,address,string)`.
  7531 |     |             mstore(0x00, 0x12d6c788)
  7532 |     |             mstore(0x20, p0)
  7533 |     |             mstore(0x40, 0x80)
  7534 |     |             mstore(0x60, p2)
  7535 |     |             mstore(0x80, 0xc0)
  7536 |     |             writeString(0xa0, p1)
  7537 |     |             writeString(0xe0, p3)
  7538 |     |         }
  7539 |     |         _sendLogPayload(0x1c, 0x104);
  7540 |     |         /// @solidity memory-safe-assembly
  7541 |     |         assembly {
  7542 |     |             mstore(0x00, m0)
  7543 |     |             mstore(0x20, m1)
  7544 |     |             mstore(0x40, m2)
  7545 |     |             mstore(0x60, m3)
  7546 |     |             mstore(0x80, m4)
  7547 |     |             mstore(0xa0, m5)
  7548 |     |             mstore(0xc0, m6)
  7549 |     |             mstore(0xe0, m7)
  7550 |     |             mstore(0x100, m8)
  7551 |     |         }
  7552 |     |     }
  7553 |     | 
  7554 |     |     function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {
  7555 |     |         bytes32 m0;
  7556 |     |         bytes32 m1;
  7557 |     |         bytes32 m2;
  7558 |     |         bytes32 m3;
  7559 |     |         bytes32 m4;
  7560 |     |         bytes32 m5;
  7561 |     |         bytes32 m6;
  7562 |     |         /// @solidity memory-safe-assembly
  7563 |     |         assembly {
  7564 |     |             function writeString(pos, w) {
  7565 |     |                 let length := 0
  7566 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7567 |     |                 mstore(pos, length)
  7568 |     |                 let shift := sub(256, shl(3, length))
  7569 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7570 |     |             }
  7571 |     |             m0 := mload(0x00)
  7572 |     |             m1 := mload(0x20)
  7573 |     |             m2 := mload(0x40)
  7574 |     |             m3 := mload(0x60)
  7575 |     |             m4 := mload(0x80)
  7576 |     |             m5 := mload(0xa0)
  7577 |     |             m6 := mload(0xc0)
  7578 |     |             // Selector of `log(bool,string,bool,address)`.
  7579 |     |             mstore(0x00, 0x538e06ab)
  7580 |     |             mstore(0x20, p0)
  7581 |     |             mstore(0x40, 0x80)
  7582 |     |             mstore(0x60, p2)
  7583 |     |             mstore(0x80, p3)
  7584 |     |             writeString(0xa0, p1)
  7585 |     |         }
  7586 |     |         _sendLogPayload(0x1c, 0xc4);
  7587 |     |         /// @solidity memory-safe-assembly
  7588 |     |         assembly {
  7589 |     |             mstore(0x00, m0)
  7590 |     |             mstore(0x20, m1)
  7591 |     |             mstore(0x40, m2)
  7592 |     |             mstore(0x60, m3)
  7593 |     |             mstore(0x80, m4)
  7594 |     |             mstore(0xa0, m5)
  7595 |     |             mstore(0xc0, m6)
  7596 |     |         }
  7597 |     |     }
  7598 |     | 
  7599 |     |     function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {
  7600 |     |         bytes32 m0;
  7601 |     |         bytes32 m1;
  7602 |     |         bytes32 m2;
  7603 |     |         bytes32 m3;
  7604 |     |         bytes32 m4;
  7605 |     |         bytes32 m5;
  7606 |     |         bytes32 m6;
  7607 |     |         /// @solidity memory-safe-assembly
  7608 |     |         assembly {
  7609 |     |             function writeString(pos, w) {
  7610 |     |                 let length := 0
  7611 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7612 |     |                 mstore(pos, length)
  7613 |     |                 let shift := sub(256, shl(3, length))
  7614 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7615 |     |             }
  7616 |     |             m0 := mload(0x00)
  7617 |     |             m1 := mload(0x20)
  7618 |     |             m2 := mload(0x40)
  7619 |     |             m3 := mload(0x60)
  7620 |     |             m4 := mload(0x80)
  7621 |     |             m5 := mload(0xa0)
  7622 |     |             m6 := mload(0xc0)
  7623 |     |             // Selector of `log(bool,string,bool,bool)`.
  7624 |     |             mstore(0x00, 0xdc5e935b)
  7625 |     |             mstore(0x20, p0)
  7626 |     |             mstore(0x40, 0x80)
  7627 |     |             mstore(0x60, p2)
  7628 |     |             mstore(0x80, p3)
  7629 |     |             writeString(0xa0, p1)
  7630 |     |         }
  7631 |     |         _sendLogPayload(0x1c, 0xc4);
  7632 |     |         /// @solidity memory-safe-assembly
  7633 |     |         assembly {
  7634 |     |             mstore(0x00, m0)
  7635 |     |             mstore(0x20, m1)
  7636 |     |             mstore(0x40, m2)
  7637 |     |             mstore(0x60, m3)
  7638 |     |             mstore(0x80, m4)
  7639 |     |             mstore(0xa0, m5)
  7640 |     |             mstore(0xc0, m6)
  7641 |     |         }
  7642 |     |     }
  7643 |     | 
  7644 |     |     function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  7645 |     |         bytes32 m0;
  7646 |     |         bytes32 m1;
  7647 |     |         bytes32 m2;
  7648 |     |         bytes32 m3;
  7649 |     |         bytes32 m4;
  7650 |     |         bytes32 m5;
  7651 |     |         bytes32 m6;
  7652 |     |         /// @solidity memory-safe-assembly
  7653 |     |         assembly {
  7654 |     |             function writeString(pos, w) {
  7655 |     |                 let length := 0
  7656 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7657 |     |                 mstore(pos, length)
  7658 |     |                 let shift := sub(256, shl(3, length))
  7659 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7660 |     |             }
  7661 |     |             m0 := mload(0x00)
  7662 |     |             m1 := mload(0x20)
  7663 |     |             m2 := mload(0x40)
  7664 |     |             m3 := mload(0x60)
  7665 |     |             m4 := mload(0x80)
  7666 |     |             m5 := mload(0xa0)
  7667 |     |             m6 := mload(0xc0)
  7668 |     |             // Selector of `log(bool,string,bool,uint256)`.
  7669 |     |             mstore(0x00, 0x1606a393)
  7670 |     |             mstore(0x20, p0)
  7671 |     |             mstore(0x40, 0x80)
  7672 |     |             mstore(0x60, p2)
  7673 |     |             mstore(0x80, p3)
  7674 |     |             writeString(0xa0, p1)
  7675 |     |         }
  7676 |     |         _sendLogPayload(0x1c, 0xc4);
  7677 |     |         /// @solidity memory-safe-assembly
  7678 |     |         assembly {
  7679 |     |             mstore(0x00, m0)
  7680 |     |             mstore(0x20, m1)
  7681 |     |             mstore(0x40, m2)
  7682 |     |             mstore(0x60, m3)
  7683 |     |             mstore(0x80, m4)
  7684 |     |             mstore(0xa0, m5)
  7685 |     |             mstore(0xc0, m6)
  7686 |     |         }
  7687 |     |     }
  7688 |     | 
  7689 |     |     function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  7690 |     |         bytes32 m0;
  7691 |     |         bytes32 m1;
  7692 |     |         bytes32 m2;
  7693 |     |         bytes32 m3;
  7694 |     |         bytes32 m4;
  7695 |     |         bytes32 m5;
  7696 |     |         bytes32 m6;
  7697 |     |         bytes32 m7;
  7698 |     |         bytes32 m8;
  7699 |     |         /// @solidity memory-safe-assembly
  7700 |     |         assembly {
  7701 |     |             function writeString(pos, w) {
  7702 |     |                 let length := 0
  7703 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7704 |     |                 mstore(pos, length)
  7705 |     |                 let shift := sub(256, shl(3, length))
  7706 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7707 |     |             }
  7708 |     |             m0 := mload(0x00)
  7709 |     |             m1 := mload(0x20)
  7710 |     |             m2 := mload(0x40)
  7711 |     |             m3 := mload(0x60)
  7712 |     |             m4 := mload(0x80)
  7713 |     |             m5 := mload(0xa0)
  7714 |     |             m6 := mload(0xc0)
  7715 |     |             m7 := mload(0xe0)
  7716 |     |             m8 := mload(0x100)
  7717 |     |             // Selector of `log(bool,string,bool,string)`.
  7718 |     |             mstore(0x00, 0x483d0416)
  7719 |     |             mstore(0x20, p0)
  7720 |     |             mstore(0x40, 0x80)
  7721 |     |             mstore(0x60, p2)
  7722 |     |             mstore(0x80, 0xc0)
  7723 |     |             writeString(0xa0, p1)
  7724 |     |             writeString(0xe0, p3)
  7725 |     |         }
  7726 |     |         _sendLogPayload(0x1c, 0x104);
  7727 |     |         /// @solidity memory-safe-assembly
  7728 |     |         assembly {
  7729 |     |             mstore(0x00, m0)
  7730 |     |             mstore(0x20, m1)
  7731 |     |             mstore(0x40, m2)
  7732 |     |             mstore(0x60, m3)
  7733 |     |             mstore(0x80, m4)
  7734 |     |             mstore(0xa0, m5)
  7735 |     |             mstore(0xc0, m6)
  7736 |     |             mstore(0xe0, m7)
  7737 |     |             mstore(0x100, m8)
  7738 |     |         }
  7739 |     |     }
  7740 |     | 
  7741 |     |     function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {
  7742 |     |         bytes32 m0;
  7743 |     |         bytes32 m1;
  7744 |     |         bytes32 m2;
  7745 |     |         bytes32 m3;
  7746 |     |         bytes32 m4;
  7747 |     |         bytes32 m5;
  7748 |     |         bytes32 m6;
  7749 |     |         /// @solidity memory-safe-assembly
  7750 |     |         assembly {
  7751 |     |             function writeString(pos, w) {
  7752 |     |                 let length := 0
  7753 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7754 |     |                 mstore(pos, length)
  7755 |     |                 let shift := sub(256, shl(3, length))
  7756 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7757 |     |             }
  7758 |     |             m0 := mload(0x00)
  7759 |     |             m1 := mload(0x20)
  7760 |     |             m2 := mload(0x40)
  7761 |     |             m3 := mload(0x60)
  7762 |     |             m4 := mload(0x80)
  7763 |     |             m5 := mload(0xa0)
  7764 |     |             m6 := mload(0xc0)
  7765 |     |             // Selector of `log(bool,string,uint256,address)`.
  7766 |     |             mstore(0x00, 0x1596a1ce)
  7767 |     |             mstore(0x20, p0)
  7768 |     |             mstore(0x40, 0x80)
  7769 |     |             mstore(0x60, p2)
  7770 |     |             mstore(0x80, p3)
  7771 |     |             writeString(0xa0, p1)
  7772 |     |         }
  7773 |     |         _sendLogPayload(0x1c, 0xc4);
  7774 |     |         /// @solidity memory-safe-assembly
  7775 |     |         assembly {
  7776 |     |             mstore(0x00, m0)
  7777 |     |             mstore(0x20, m1)
  7778 |     |             mstore(0x40, m2)
  7779 |     |             mstore(0x60, m3)
  7780 |     |             mstore(0x80, m4)
  7781 |     |             mstore(0xa0, m5)
  7782 |     |             mstore(0xc0, m6)
  7783 |     |         }
  7784 |     |     }
  7785 |     | 
  7786 |     |     function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  7787 |     |         bytes32 m0;
  7788 |     |         bytes32 m1;
  7789 |     |         bytes32 m2;
  7790 |     |         bytes32 m3;
  7791 |     |         bytes32 m4;
  7792 |     |         bytes32 m5;
  7793 |     |         bytes32 m6;
  7794 |     |         /// @solidity memory-safe-assembly
  7795 |     |         assembly {
  7796 |     |             function writeString(pos, w) {
  7797 |     |                 let length := 0
  7798 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7799 |     |                 mstore(pos, length)
  7800 |     |                 let shift := sub(256, shl(3, length))
  7801 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7802 |     |             }
  7803 |     |             m0 := mload(0x00)
  7804 |     |             m1 := mload(0x20)
  7805 |     |             m2 := mload(0x40)
  7806 |     |             m3 := mload(0x60)
  7807 |     |             m4 := mload(0x80)
  7808 |     |             m5 := mload(0xa0)
  7809 |     |             m6 := mload(0xc0)
  7810 |     |             // Selector of `log(bool,string,uint256,bool)`.
  7811 |     |             mstore(0x00, 0x6b0e5d53)
  7812 |     |             mstore(0x20, p0)
  7813 |     |             mstore(0x40, 0x80)
  7814 |     |             mstore(0x60, p2)
  7815 |     |             mstore(0x80, p3)
  7816 |     |             writeString(0xa0, p1)
  7817 |     |         }
  7818 |     |         _sendLogPayload(0x1c, 0xc4);
  7819 |     |         /// @solidity memory-safe-assembly
  7820 |     |         assembly {
  7821 |     |             mstore(0x00, m0)
  7822 |     |             mstore(0x20, m1)
  7823 |     |             mstore(0x40, m2)
  7824 |     |             mstore(0x60, m3)
  7825 |     |             mstore(0x80, m4)
  7826 |     |             mstore(0xa0, m5)
  7827 |     |             mstore(0xc0, m6)
  7828 |     |         }
  7829 |     |     }
  7830 |     | 
  7831 |     |     function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  7832 |     |         bytes32 m0;
  7833 |     |         bytes32 m1;
  7834 |     |         bytes32 m2;
  7835 |     |         bytes32 m3;
  7836 |     |         bytes32 m4;
  7837 |     |         bytes32 m5;
  7838 |     |         bytes32 m6;
  7839 |     |         /// @solidity memory-safe-assembly
  7840 |     |         assembly {
  7841 |     |             function writeString(pos, w) {
  7842 |     |                 let length := 0
  7843 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7844 |     |                 mstore(pos, length)
  7845 |     |                 let shift := sub(256, shl(3, length))
  7846 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7847 |     |             }
  7848 |     |             m0 := mload(0x00)
  7849 |     |             m1 := mload(0x20)
  7850 |     |             m2 := mload(0x40)
  7851 |     |             m3 := mload(0x60)
  7852 |     |             m4 := mload(0x80)
  7853 |     |             m5 := mload(0xa0)
  7854 |     |             m6 := mload(0xc0)
  7855 |     |             // Selector of `log(bool,string,uint256,uint256)`.
  7856 |     |             mstore(0x00, 0x28863fcb)
  7857 |     |             mstore(0x20, p0)
  7858 |     |             mstore(0x40, 0x80)
  7859 |     |             mstore(0x60, p2)
  7860 |     |             mstore(0x80, p3)
  7861 |     |             writeString(0xa0, p1)
  7862 |     |         }
  7863 |     |         _sendLogPayload(0x1c, 0xc4);
  7864 |     |         /// @solidity memory-safe-assembly
  7865 |     |         assembly {
  7866 |     |             mstore(0x00, m0)
  7867 |     |             mstore(0x20, m1)
  7868 |     |             mstore(0x40, m2)
  7869 |     |             mstore(0x60, m3)
  7870 |     |             mstore(0x80, m4)
  7871 |     |             mstore(0xa0, m5)
  7872 |     |             mstore(0xc0, m6)
  7873 |     |         }
  7874 |     |     }
  7875 |     | 
  7876 |     |     function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  7877 |     |         bytes32 m0;
  7878 |     |         bytes32 m1;
  7879 |     |         bytes32 m2;
  7880 |     |         bytes32 m3;
  7881 |     |         bytes32 m4;
  7882 |     |         bytes32 m5;
  7883 |     |         bytes32 m6;
  7884 |     |         bytes32 m7;
  7885 |     |         bytes32 m8;
  7886 |     |         /// @solidity memory-safe-assembly
  7887 |     |         assembly {
  7888 |     |             function writeString(pos, w) {
  7889 |     |                 let length := 0
  7890 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7891 |     |                 mstore(pos, length)
  7892 |     |                 let shift := sub(256, shl(3, length))
  7893 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7894 |     |             }
  7895 |     |             m0 := mload(0x00)
  7896 |     |             m1 := mload(0x20)
  7897 |     |             m2 := mload(0x40)
  7898 |     |             m3 := mload(0x60)
  7899 |     |             m4 := mload(0x80)
  7900 |     |             m5 := mload(0xa0)
  7901 |     |             m6 := mload(0xc0)
  7902 |     |             m7 := mload(0xe0)
  7903 |     |             m8 := mload(0x100)
  7904 |     |             // Selector of `log(bool,string,uint256,string)`.
  7905 |     |             mstore(0x00, 0x1ad96de6)
  7906 |     |             mstore(0x20, p0)
  7907 |     |             mstore(0x40, 0x80)
  7908 |     |             mstore(0x60, p2)
  7909 |     |             mstore(0x80, 0xc0)
  7910 |     |             writeString(0xa0, p1)
  7911 |     |             writeString(0xe0, p3)
  7912 |     |         }
  7913 |     |         _sendLogPayload(0x1c, 0x104);
  7914 |     |         /// @solidity memory-safe-assembly
  7915 |     |         assembly {
  7916 |     |             mstore(0x00, m0)
  7917 |     |             mstore(0x20, m1)
  7918 |     |             mstore(0x40, m2)
  7919 |     |             mstore(0x60, m3)
  7920 |     |             mstore(0x80, m4)
  7921 |     |             mstore(0xa0, m5)
  7922 |     |             mstore(0xc0, m6)
  7923 |     |             mstore(0xe0, m7)
  7924 |     |             mstore(0x100, m8)
  7925 |     |         }
  7926 |     |     }
  7927 |     | 
  7928 |     |     function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  7929 |     |         bytes32 m0;
  7930 |     |         bytes32 m1;
  7931 |     |         bytes32 m2;
  7932 |     |         bytes32 m3;
  7933 |     |         bytes32 m4;
  7934 |     |         bytes32 m5;
  7935 |     |         bytes32 m6;
  7936 |     |         bytes32 m7;
  7937 |     |         bytes32 m8;
  7938 |     |         /// @solidity memory-safe-assembly
  7939 |     |         assembly {
  7940 |     |             function writeString(pos, w) {
  7941 |     |                 let length := 0
  7942 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7943 |     |                 mstore(pos, length)
  7944 |     |                 let shift := sub(256, shl(3, length))
  7945 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7946 |     |             }
  7947 |     |             m0 := mload(0x00)
  7948 |     |             m1 := mload(0x20)
  7949 |     |             m2 := mload(0x40)
  7950 |     |             m3 := mload(0x60)
  7951 |     |             m4 := mload(0x80)
  7952 |     |             m5 := mload(0xa0)
  7953 |     |             m6 := mload(0xc0)
  7954 |     |             m7 := mload(0xe0)
  7955 |     |             m8 := mload(0x100)
  7956 |     |             // Selector of `log(bool,string,string,address)`.
  7957 |     |             mstore(0x00, 0x97d394d8)
  7958 |     |             mstore(0x20, p0)
  7959 |     |             mstore(0x40, 0x80)
  7960 |     |             mstore(0x60, 0xc0)
  7961 |     |             mstore(0x80, p3)
  7962 |     |             writeString(0xa0, p1)
  7963 |     |             writeString(0xe0, p2)
  7964 |     |         }
  7965 |     |         _sendLogPayload(0x1c, 0x104);
  7966 |     |         /// @solidity memory-safe-assembly
  7967 |     |         assembly {
  7968 |     |             mstore(0x00, m0)
  7969 |     |             mstore(0x20, m1)
  7970 |     |             mstore(0x40, m2)
  7971 |     |             mstore(0x60, m3)
  7972 |     |             mstore(0x80, m4)
  7973 |     |             mstore(0xa0, m5)
  7974 |     |             mstore(0xc0, m6)
  7975 |     |             mstore(0xe0, m7)
  7976 |     |             mstore(0x100, m8)
  7977 |     |         }
  7978 |     |     }
  7979 |     | 
  7980 |     |     function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
  7981 |     |         bytes32 m0;
  7982 |     |         bytes32 m1;
  7983 |     |         bytes32 m2;
  7984 |     |         bytes32 m3;
  7985 |     |         bytes32 m4;
  7986 |     |         bytes32 m5;
  7987 |     |         bytes32 m6;
  7988 |     |         bytes32 m7;
  7989 |     |         bytes32 m8;
  7990 |     |         /// @solidity memory-safe-assembly
  7991 |     |         assembly {
  7992 |     |             function writeString(pos, w) {
  7993 |     |                 let length := 0
  7994 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7995 |     |                 mstore(pos, length)
  7996 |     |                 let shift := sub(256, shl(3, length))
  7997 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7998 |     |             }
  7999 |     |             m0 := mload(0x00)
  8000 |     |             m1 := mload(0x20)
  8001 |     |             m2 := mload(0x40)
  8002 |     |             m3 := mload(0x60)
  8003 |     |             m4 := mload(0x80)
  8004 |     |             m5 := mload(0xa0)
  8005 |     |             m6 := mload(0xc0)
  8006 |     |             m7 := mload(0xe0)
  8007 |     |             m8 := mload(0x100)
  8008 |     |             // Selector of `log(bool,string,string,bool)`.
  8009 |     |             mstore(0x00, 0x1e4b87e5)
  8010 |     |             mstore(0x20, p0)
  8011 |     |             mstore(0x40, 0x80)
  8012 |     |             mstore(0x60, 0xc0)
  8013 |     |             mstore(0x80, p3)
  8014 |     |             writeString(0xa0, p1)
  8015 |     |             writeString(0xe0, p2)
  8016 |     |         }
  8017 |     |         _sendLogPayload(0x1c, 0x104);
  8018 |     |         /// @solidity memory-safe-assembly
  8019 |     |         assembly {
  8020 |     |             mstore(0x00, m0)
  8021 |     |             mstore(0x20, m1)
  8022 |     |             mstore(0x40, m2)
  8023 |     |             mstore(0x60, m3)
  8024 |     |             mstore(0x80, m4)
  8025 |     |             mstore(0xa0, m5)
  8026 |     |             mstore(0xc0, m6)
  8027 |     |             mstore(0xe0, m7)
  8028 |     |             mstore(0x100, m8)
  8029 |     |         }
  8030 |     |     }
  8031 |     | 
  8032 |     |     function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
  8033 |     |         bytes32 m0;
  8034 |     |         bytes32 m1;
  8035 |     |         bytes32 m2;
  8036 |     |         bytes32 m3;
  8037 |     |         bytes32 m4;
  8038 |     |         bytes32 m5;
  8039 |     |         bytes32 m6;
  8040 |     |         bytes32 m7;
  8041 |     |         bytes32 m8;
  8042 |     |         /// @solidity memory-safe-assembly
  8043 |     |         assembly {
  8044 |     |             function writeString(pos, w) {
  8045 |     |                 let length := 0
  8046 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8047 |     |                 mstore(pos, length)
  8048 |     |                 let shift := sub(256, shl(3, length))
  8049 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8050 |     |             }
  8051 |     |             m0 := mload(0x00)
  8052 |     |             m1 := mload(0x20)
  8053 |     |             m2 := mload(0x40)
  8054 |     |             m3 := mload(0x60)
  8055 |     |             m4 := mload(0x80)
  8056 |     |             m5 := mload(0xa0)
  8057 |     |             m6 := mload(0xc0)
  8058 |     |             m7 := mload(0xe0)
  8059 |     |             m8 := mload(0x100)
  8060 |     |             // Selector of `log(bool,string,string,uint256)`.
  8061 |     |             mstore(0x00, 0x7be0c3eb)
  8062 |     |             mstore(0x20, p0)
  8063 |     |             mstore(0x40, 0x80)
  8064 |     |             mstore(0x60, 0xc0)
  8065 |     |             mstore(0x80, p3)
  8066 |     |             writeString(0xa0, p1)
  8067 |     |             writeString(0xe0, p2)
  8068 |     |         }
  8069 |     |         _sendLogPayload(0x1c, 0x104);
  8070 |     |         /// @solidity memory-safe-assembly
  8071 |     |         assembly {
  8072 |     |             mstore(0x00, m0)
  8073 |     |             mstore(0x20, m1)
  8074 |     |             mstore(0x40, m2)
  8075 |     |             mstore(0x60, m3)
  8076 |     |             mstore(0x80, m4)
  8077 |     |             mstore(0xa0, m5)
  8078 |     |             mstore(0xc0, m6)
  8079 |     |             mstore(0xe0, m7)
  8080 |     |             mstore(0x100, m8)
  8081 |     |         }
  8082 |     |     }
  8083 |     | 
  8084 |     |     function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
  8085 |     |         bytes32 m0;
  8086 |     |         bytes32 m1;
  8087 |     |         bytes32 m2;
  8088 |     |         bytes32 m3;
  8089 |     |         bytes32 m4;
  8090 |     |         bytes32 m5;
  8091 |     |         bytes32 m6;
  8092 |     |         bytes32 m7;
  8093 |     |         bytes32 m8;
  8094 |     |         bytes32 m9;
  8095 |     |         bytes32 m10;
  8096 |     |         /// @solidity memory-safe-assembly
  8097 |     |         assembly {
  8098 |     |             function writeString(pos, w) {
  8099 |     |                 let length := 0
  8100 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8101 |     |                 mstore(pos, length)
  8102 |     |                 let shift := sub(256, shl(3, length))
  8103 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8104 |     |             }
  8105 |     |             m0 := mload(0x00)
  8106 |     |             m1 := mload(0x20)
  8107 |     |             m2 := mload(0x40)
  8108 |     |             m3 := mload(0x60)
  8109 |     |             m4 := mload(0x80)
  8110 |     |             m5 := mload(0xa0)
  8111 |     |             m6 := mload(0xc0)
  8112 |     |             m7 := mload(0xe0)
  8113 |     |             m8 := mload(0x100)
  8114 |     |             m9 := mload(0x120)
  8115 |     |             m10 := mload(0x140)
  8116 |     |             // Selector of `log(bool,string,string,string)`.
  8117 |     |             mstore(0x00, 0x1762e32a)
  8118 |     |             mstore(0x20, p0)
  8119 |     |             mstore(0x40, 0x80)
  8120 |     |             mstore(0x60, 0xc0)
  8121 |     |             mstore(0x80, 0x100)
  8122 |     |             writeString(0xa0, p1)
  8123 |     |             writeString(0xe0, p2)
  8124 |     |             writeString(0x120, p3)
  8125 |     |         }
  8126 |     |         _sendLogPayload(0x1c, 0x144);
  8127 |     |         /// @solidity memory-safe-assembly
  8128 |     |         assembly {
  8129 |     |             mstore(0x00, m0)
  8130 |     |             mstore(0x20, m1)
  8131 |     |             mstore(0x40, m2)
  8132 |     |             mstore(0x60, m3)
  8133 |     |             mstore(0x80, m4)
  8134 |     |             mstore(0xa0, m5)
  8135 |     |             mstore(0xc0, m6)
  8136 |     |             mstore(0xe0, m7)
  8137 |     |             mstore(0x100, m8)
  8138 |     |             mstore(0x120, m9)
  8139 |     |             mstore(0x140, m10)
  8140 |     |         }
  8141 |     |     }
  8142 |     | 
  8143 |     |     function log(uint256 p0, address p1, address p2, address p3) internal pure {
  8144 |     |         bytes32 m0;
  8145 |     |         bytes32 m1;
  8146 |     |         bytes32 m2;
  8147 |     |         bytes32 m3;
  8148 |     |         bytes32 m4;
  8149 |     |         /// @solidity memory-safe-assembly
  8150 |     |         assembly {
  8151 |     |             m0 := mload(0x00)
  8152 |     |             m1 := mload(0x20)
  8153 |     |             m2 := mload(0x40)
  8154 |     |             m3 := mload(0x60)
  8155 |     |             m4 := mload(0x80)
  8156 |     |             // Selector of `log(uint256,address,address,address)`.
  8157 |     |             mstore(0x00, 0x2488b414)
  8158 |     |             mstore(0x20, p0)
  8159 |     |             mstore(0x40, p1)
  8160 |     |             mstore(0x60, p2)
  8161 |     |             mstore(0x80, p3)
  8162 |     |         }
  8163 |     |         _sendLogPayload(0x1c, 0x84);
  8164 |     |         /// @solidity memory-safe-assembly
  8165 |     |         assembly {
  8166 |     |             mstore(0x00, m0)
  8167 |     |             mstore(0x20, m1)
  8168 |     |             mstore(0x40, m2)
  8169 |     |             mstore(0x60, m3)
  8170 |     |             mstore(0x80, m4)
  8171 |     |         }
  8172 |     |     }
  8173 |     | 
  8174 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal pure {
  8175 |     |         bytes32 m0;
  8176 |     |         bytes32 m1;
  8177 |     |         bytes32 m2;
  8178 |     |         bytes32 m3;
  8179 |     |         bytes32 m4;
  8180 |     |         /// @solidity memory-safe-assembly
  8181 |     |         assembly {
  8182 |     |             m0 := mload(0x00)
  8183 |     |             m1 := mload(0x20)
  8184 |     |             m2 := mload(0x40)
  8185 |     |             m3 := mload(0x60)
  8186 |     |             m4 := mload(0x80)
  8187 |     |             // Selector of `log(uint256,address,address,bool)`.
  8188 |     |             mstore(0x00, 0x091ffaf5)
  8189 |     |             mstore(0x20, p0)
  8190 |     |             mstore(0x40, p1)
  8191 |     |             mstore(0x60, p2)
  8192 |     |             mstore(0x80, p3)
  8193 |     |         }
  8194 |     |         _sendLogPayload(0x1c, 0x84);
  8195 |     |         /// @solidity memory-safe-assembly
  8196 |     |         assembly {
  8197 |     |             mstore(0x00, m0)
  8198 |     |             mstore(0x20, m1)
  8199 |     |             mstore(0x40, m2)
  8200 |     |             mstore(0x60, m3)
  8201 |     |             mstore(0x80, m4)
  8202 |     |         }
  8203 |     |     }
  8204 |     | 
  8205 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {
  8206 |     |         bytes32 m0;
  8207 |     |         bytes32 m1;
  8208 |     |         bytes32 m2;
  8209 |     |         bytes32 m3;
  8210 |     |         bytes32 m4;
  8211 |     |         /// @solidity memory-safe-assembly
  8212 |     |         assembly {
  8213 |     |             m0 := mload(0x00)
  8214 |     |             m1 := mload(0x20)
  8215 |     |             m2 := mload(0x40)
  8216 |     |             m3 := mload(0x60)
  8217 |     |             m4 := mload(0x80)
  8218 |     |             // Selector of `log(uint256,address,address,uint256)`.
  8219 |     |             mstore(0x00, 0x736efbb6)
  8220 |     |             mstore(0x20, p0)
  8221 |     |             mstore(0x40, p1)
  8222 |     |             mstore(0x60, p2)
  8223 |     |             mstore(0x80, p3)
  8224 |     |         }
  8225 |     |         _sendLogPayload(0x1c, 0x84);
  8226 |     |         /// @solidity memory-safe-assembly
  8227 |     |         assembly {
  8228 |     |             mstore(0x00, m0)
  8229 |     |             mstore(0x20, m1)
  8230 |     |             mstore(0x40, m2)
  8231 |     |             mstore(0x60, m3)
  8232 |     |             mstore(0x80, m4)
  8233 |     |         }
  8234 |     |     }
  8235 |     | 
  8236 |     |     function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {
  8237 |     |         bytes32 m0;
  8238 |     |         bytes32 m1;
  8239 |     |         bytes32 m2;
  8240 |     |         bytes32 m3;
  8241 |     |         bytes32 m4;
  8242 |     |         bytes32 m5;
  8243 |     |         bytes32 m6;
  8244 |     |         /// @solidity memory-safe-assembly
  8245 |     |         assembly {
  8246 |     |             function writeString(pos, w) {
  8247 |     |                 let length := 0
  8248 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8249 |     |                 mstore(pos, length)
  8250 |     |                 let shift := sub(256, shl(3, length))
  8251 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8252 |     |             }
  8253 |     |             m0 := mload(0x00)
  8254 |     |             m1 := mload(0x20)
  8255 |     |             m2 := mload(0x40)
  8256 |     |             m3 := mload(0x60)
  8257 |     |             m4 := mload(0x80)
  8258 |     |             m5 := mload(0xa0)
  8259 |     |             m6 := mload(0xc0)
  8260 |     |             // Selector of `log(uint256,address,address,string)`.
  8261 |     |             mstore(0x00, 0x031c6f73)
  8262 |     |             mstore(0x20, p0)
  8263 |     |             mstore(0x40, p1)
  8264 |     |             mstore(0x60, p2)
  8265 |     |             mstore(0x80, 0x80)
  8266 |     |             writeString(0xa0, p3)
  8267 |     |         }
  8268 |     |         _sendLogPayload(0x1c, 0xc4);
  8269 |     |         /// @solidity memory-safe-assembly
  8270 |     |         assembly {
  8271 |     |             mstore(0x00, m0)
  8272 |     |             mstore(0x20, m1)
  8273 |     |             mstore(0x40, m2)
  8274 |     |             mstore(0x60, m3)
  8275 |     |             mstore(0x80, m4)
  8276 |     |             mstore(0xa0, m5)
  8277 |     |             mstore(0xc0, m6)
  8278 |     |         }
  8279 |     |     }
  8280 |     | 
  8281 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal pure {
  8282 |     |         bytes32 m0;
  8283 |     |         bytes32 m1;
  8284 |     |         bytes32 m2;
  8285 |     |         bytes32 m3;
  8286 |     |         bytes32 m4;
  8287 |     |         /// @solidity memory-safe-assembly
  8288 |     |         assembly {
  8289 |     |             m0 := mload(0x00)
  8290 |     |             m1 := mload(0x20)
  8291 |     |             m2 := mload(0x40)
  8292 |     |             m3 := mload(0x60)
  8293 |     |             m4 := mload(0x80)
  8294 |     |             // Selector of `log(uint256,address,bool,address)`.
  8295 |     |             mstore(0x00, 0xef72c513)
  8296 |     |             mstore(0x20, p0)
  8297 |     |             mstore(0x40, p1)
  8298 |     |             mstore(0x60, p2)
  8299 |     |             mstore(0x80, p3)
  8300 |     |         }
  8301 |     |         _sendLogPayload(0x1c, 0x84);
  8302 |     |         /// @solidity memory-safe-assembly
  8303 |     |         assembly {
  8304 |     |             mstore(0x00, m0)
  8305 |     |             mstore(0x20, m1)
  8306 |     |             mstore(0x40, m2)
  8307 |     |             mstore(0x60, m3)
  8308 |     |             mstore(0x80, m4)
  8309 |     |         }
  8310 |     |     }
  8311 |     | 
  8312 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal pure {
  8313 |     |         bytes32 m0;
  8314 |     |         bytes32 m1;
  8315 |     |         bytes32 m2;
  8316 |     |         bytes32 m3;
  8317 |     |         bytes32 m4;
  8318 |     |         /// @solidity memory-safe-assembly
  8319 |     |         assembly {
  8320 |     |             m0 := mload(0x00)
  8321 |     |             m1 := mload(0x20)
  8322 |     |             m2 := mload(0x40)
  8323 |     |             m3 := mload(0x60)
  8324 |     |             m4 := mload(0x80)
  8325 |     |             // Selector of `log(uint256,address,bool,bool)`.
  8326 |     |             mstore(0x00, 0xe351140f)
  8327 |     |             mstore(0x20, p0)
  8328 |     |             mstore(0x40, p1)
  8329 |     |             mstore(0x60, p2)
  8330 |     |             mstore(0x80, p3)
  8331 |     |         }
  8332 |     |         _sendLogPayload(0x1c, 0x84);
  8333 |     |         /// @solidity memory-safe-assembly
  8334 |     |         assembly {
  8335 |     |             mstore(0x00, m0)
  8336 |     |             mstore(0x20, m1)
  8337 |     |             mstore(0x40, m2)
  8338 |     |             mstore(0x60, m3)
  8339 |     |             mstore(0x80, m4)
  8340 |     |         }
  8341 |     |     }
  8342 |     | 
  8343 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {
  8344 |     |         bytes32 m0;
  8345 |     |         bytes32 m1;
  8346 |     |         bytes32 m2;
  8347 |     |         bytes32 m3;
  8348 |     |         bytes32 m4;
  8349 |     |         /// @solidity memory-safe-assembly
  8350 |     |         assembly {
  8351 |     |             m0 := mload(0x00)
  8352 |     |             m1 := mload(0x20)
  8353 |     |             m2 := mload(0x40)
  8354 |     |             m3 := mload(0x60)
  8355 |     |             m4 := mload(0x80)
  8356 |     |             // Selector of `log(uint256,address,bool,uint256)`.
  8357 |     |             mstore(0x00, 0x5abd992a)
  8358 |     |             mstore(0x20, p0)
  8359 |     |             mstore(0x40, p1)
  8360 |     |             mstore(0x60, p2)
  8361 |     |             mstore(0x80, p3)
  8362 |     |         }
  8363 |     |         _sendLogPayload(0x1c, 0x84);
  8364 |     |         /// @solidity memory-safe-assembly
  8365 |     |         assembly {
  8366 |     |             mstore(0x00, m0)
  8367 |     |             mstore(0x20, m1)
  8368 |     |             mstore(0x40, m2)
  8369 |     |             mstore(0x60, m3)
  8370 |     |             mstore(0x80, m4)
  8371 |     |         }
  8372 |     |     }
  8373 |     | 
  8374 |     |     function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {
  8375 |     |         bytes32 m0;
  8376 |     |         bytes32 m1;
  8377 |     |         bytes32 m2;
  8378 |     |         bytes32 m3;
  8379 |     |         bytes32 m4;
  8380 |     |         bytes32 m5;
  8381 |     |         bytes32 m6;
  8382 |     |         /// @solidity memory-safe-assembly
  8383 |     |         assembly {
  8384 |     |             function writeString(pos, w) {
  8385 |     |                 let length := 0
  8386 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8387 |     |                 mstore(pos, length)
  8388 |     |                 let shift := sub(256, shl(3, length))
  8389 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8390 |     |             }
  8391 |     |             m0 := mload(0x00)
  8392 |     |             m1 := mload(0x20)
  8393 |     |             m2 := mload(0x40)
  8394 |     |             m3 := mload(0x60)
  8395 |     |             m4 := mload(0x80)
  8396 |     |             m5 := mload(0xa0)
  8397 |     |             m6 := mload(0xc0)
  8398 |     |             // Selector of `log(uint256,address,bool,string)`.
  8399 |     |             mstore(0x00, 0x90fb06aa)
  8400 |     |             mstore(0x20, p0)
  8401 |     |             mstore(0x40, p1)
  8402 |     |             mstore(0x60, p2)
  8403 |     |             mstore(0x80, 0x80)
  8404 |     |             writeString(0xa0, p3)
  8405 |     |         }
  8406 |     |         _sendLogPayload(0x1c, 0xc4);
  8407 |     |         /// @solidity memory-safe-assembly
  8408 |     |         assembly {
  8409 |     |             mstore(0x00, m0)
  8410 |     |             mstore(0x20, m1)
  8411 |     |             mstore(0x40, m2)
  8412 |     |             mstore(0x60, m3)
  8413 |     |             mstore(0x80, m4)
  8414 |     |             mstore(0xa0, m5)
  8415 |     |             mstore(0xc0, m6)
  8416 |     |         }
  8417 |     |     }
  8418 |     | 
  8419 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {
  8420 |     |         bytes32 m0;
  8421 |     |         bytes32 m1;
  8422 |     |         bytes32 m2;
  8423 |     |         bytes32 m3;
  8424 |     |         bytes32 m4;
  8425 |     |         /// @solidity memory-safe-assembly
  8426 |     |         assembly {
  8427 |     |             m0 := mload(0x00)
  8428 |     |             m1 := mload(0x20)
  8429 |     |             m2 := mload(0x40)
  8430 |     |             m3 := mload(0x60)
  8431 |     |             m4 := mload(0x80)
  8432 |     |             // Selector of `log(uint256,address,uint256,address)`.
  8433 |     |             mstore(0x00, 0x15c127b5)
  8434 |     |             mstore(0x20, p0)
  8435 |     |             mstore(0x40, p1)
  8436 |     |             mstore(0x60, p2)
  8437 |     |             mstore(0x80, p3)
  8438 |     |         }
  8439 |     |         _sendLogPayload(0x1c, 0x84);
  8440 |     |         /// @solidity memory-safe-assembly
  8441 |     |         assembly {
  8442 |     |             mstore(0x00, m0)
  8443 |     |             mstore(0x20, m1)
  8444 |     |             mstore(0x40, m2)
  8445 |     |             mstore(0x60, m3)
  8446 |     |             mstore(0x80, m4)
  8447 |     |         }
  8448 |     |     }
  8449 |     | 
  8450 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {
  8451 |     |         bytes32 m0;
  8452 |     |         bytes32 m1;
  8453 |     |         bytes32 m2;
  8454 |     |         bytes32 m3;
  8455 |     |         bytes32 m4;
  8456 |     |         /// @solidity memory-safe-assembly
  8457 |     |         assembly {
  8458 |     |             m0 := mload(0x00)
  8459 |     |             m1 := mload(0x20)
  8460 |     |             m2 := mload(0x40)
  8461 |     |             m3 := mload(0x60)
  8462 |     |             m4 := mload(0x80)
  8463 |     |             // Selector of `log(uint256,address,uint256,bool)`.
  8464 |     |             mstore(0x00, 0x5f743a7c)
  8465 |     |             mstore(0x20, p0)
  8466 |     |             mstore(0x40, p1)
  8467 |     |             mstore(0x60, p2)
  8468 |     |             mstore(0x80, p3)
  8469 |     |         }
  8470 |     |         _sendLogPayload(0x1c, 0x84);
  8471 |     |         /// @solidity memory-safe-assembly
  8472 |     |         assembly {
  8473 |     |             mstore(0x00, m0)
  8474 |     |             mstore(0x20, m1)
  8475 |     |             mstore(0x40, m2)
  8476 |     |             mstore(0x60, m3)
  8477 |     |             mstore(0x80, m4)
  8478 |     |         }
  8479 |     |     }
  8480 |     | 
  8481 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {
  8482 |     |         bytes32 m0;
  8483 |     |         bytes32 m1;
  8484 |     |         bytes32 m2;
  8485 |     |         bytes32 m3;
  8486 |     |         bytes32 m4;
  8487 |     |         /// @solidity memory-safe-assembly
  8488 |     |         assembly {
  8489 |     |             m0 := mload(0x00)
  8490 |     |             m1 := mload(0x20)
  8491 |     |             m2 := mload(0x40)
  8492 |     |             m3 := mload(0x60)
  8493 |     |             m4 := mload(0x80)
  8494 |     |             // Selector of `log(uint256,address,uint256,uint256)`.
  8495 |     |             mstore(0x00, 0x0c9cd9c1)
  8496 |     |             mstore(0x20, p0)
  8497 |     |             mstore(0x40, p1)
  8498 |     |             mstore(0x60, p2)
  8499 |     |             mstore(0x80, p3)
  8500 |     |         }
  8501 |     |         _sendLogPayload(0x1c, 0x84);
  8502 |     |         /// @solidity memory-safe-assembly
  8503 |     |         assembly {
  8504 |     |             mstore(0x00, m0)
  8505 |     |             mstore(0x20, m1)
  8506 |     |             mstore(0x40, m2)
  8507 |     |             mstore(0x60, m3)
  8508 |     |             mstore(0x80, m4)
  8509 |     |         }
  8510 |     |     }
  8511 |     | 
  8512 |     |     function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {
  8513 |     |         bytes32 m0;
  8514 |     |         bytes32 m1;
  8515 |     |         bytes32 m2;
  8516 |     |         bytes32 m3;
  8517 |     |         bytes32 m4;
  8518 |     |         bytes32 m5;
  8519 |     |         bytes32 m6;
  8520 |     |         /// @solidity memory-safe-assembly
  8521 |     |         assembly {
  8522 |     |             function writeString(pos, w) {
  8523 |     |                 let length := 0
  8524 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8525 |     |                 mstore(pos, length)
  8526 |     |                 let shift := sub(256, shl(3, length))
  8527 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8528 |     |             }
  8529 |     |             m0 := mload(0x00)
  8530 |     |             m1 := mload(0x20)
  8531 |     |             m2 := mload(0x40)
  8532 |     |             m3 := mload(0x60)
  8533 |     |             m4 := mload(0x80)
  8534 |     |             m5 := mload(0xa0)
  8535 |     |             m6 := mload(0xc0)
  8536 |     |             // Selector of `log(uint256,address,uint256,string)`.
  8537 |     |             mstore(0x00, 0xddb06521)
  8538 |     |             mstore(0x20, p0)
  8539 |     |             mstore(0x40, p1)
  8540 |     |             mstore(0x60, p2)
  8541 |     |             mstore(0x80, 0x80)
  8542 |     |             writeString(0xa0, p3)
  8543 |     |         }
  8544 |     |         _sendLogPayload(0x1c, 0xc4);
  8545 |     |         /// @solidity memory-safe-assembly
  8546 |     |         assembly {
  8547 |     |             mstore(0x00, m0)
  8548 |     |             mstore(0x20, m1)
  8549 |     |             mstore(0x40, m2)
  8550 |     |             mstore(0x60, m3)
  8551 |     |             mstore(0x80, m4)
  8552 |     |             mstore(0xa0, m5)
  8553 |     |             mstore(0xc0, m6)
  8554 |     |         }
  8555 |     |     }
  8556 |     | 
  8557 |     |     function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {
  8558 |     |         bytes32 m0;
  8559 |     |         bytes32 m1;
  8560 |     |         bytes32 m2;
  8561 |     |         bytes32 m3;
  8562 |     |         bytes32 m4;
  8563 |     |         bytes32 m5;
  8564 |     |         bytes32 m6;
  8565 |     |         /// @solidity memory-safe-assembly
  8566 |     |         assembly {
  8567 |     |             function writeString(pos, w) {
  8568 |     |                 let length := 0
  8569 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8570 |     |                 mstore(pos, length)
  8571 |     |                 let shift := sub(256, shl(3, length))
  8572 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8573 |     |             }
  8574 |     |             m0 := mload(0x00)
  8575 |     |             m1 := mload(0x20)
  8576 |     |             m2 := mload(0x40)
  8577 |     |             m3 := mload(0x60)
  8578 |     |             m4 := mload(0x80)
  8579 |     |             m5 := mload(0xa0)
  8580 |     |             m6 := mload(0xc0)
  8581 |     |             // Selector of `log(uint256,address,string,address)`.
  8582 |     |             mstore(0x00, 0x9cba8fff)
  8583 |     |             mstore(0x20, p0)
  8584 |     |             mstore(0x40, p1)
  8585 |     |             mstore(0x60, 0x80)
  8586 |     |             mstore(0x80, p3)
  8587 |     |             writeString(0xa0, p2)
  8588 |     |         }
  8589 |     |         _sendLogPayload(0x1c, 0xc4);
  8590 |     |         /// @solidity memory-safe-assembly
  8591 |     |         assembly {
  8592 |     |             mstore(0x00, m0)
  8593 |     |             mstore(0x20, m1)
  8594 |     |             mstore(0x40, m2)
  8595 |     |             mstore(0x60, m3)
  8596 |     |             mstore(0x80, m4)
  8597 |     |             mstore(0xa0, m5)
  8598 |     |             mstore(0xc0, m6)
  8599 |     |         }
  8600 |     |     }
  8601 |     | 
  8602 |     |     function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {
  8603 |     |         bytes32 m0;
  8604 |     |         bytes32 m1;
  8605 |     |         bytes32 m2;
  8606 |     |         bytes32 m3;
  8607 |     |         bytes32 m4;
  8608 |     |         bytes32 m5;
  8609 |     |         bytes32 m6;
  8610 |     |         /// @solidity memory-safe-assembly
  8611 |     |         assembly {
  8612 |     |             function writeString(pos, w) {
  8613 |     |                 let length := 0
  8614 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8615 |     |                 mstore(pos, length)
  8616 |     |                 let shift := sub(256, shl(3, length))
  8617 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8618 |     |             }
  8619 |     |             m0 := mload(0x00)
  8620 |     |             m1 := mload(0x20)
  8621 |     |             m2 := mload(0x40)
  8622 |     |             m3 := mload(0x60)
  8623 |     |             m4 := mload(0x80)
  8624 |     |             m5 := mload(0xa0)
  8625 |     |             m6 := mload(0xc0)
  8626 |     |             // Selector of `log(uint256,address,string,bool)`.
  8627 |     |             mstore(0x00, 0xcc32ab07)
  8628 |     |             mstore(0x20, p0)
  8629 |     |             mstore(0x40, p1)
  8630 |     |             mstore(0x60, 0x80)
  8631 |     |             mstore(0x80, p3)
  8632 |     |             writeString(0xa0, p2)
  8633 |     |         }
  8634 |     |         _sendLogPayload(0x1c, 0xc4);
  8635 |     |         /// @solidity memory-safe-assembly
  8636 |     |         assembly {
  8637 |     |             mstore(0x00, m0)
  8638 |     |             mstore(0x20, m1)
  8639 |     |             mstore(0x40, m2)
  8640 |     |             mstore(0x60, m3)
  8641 |     |             mstore(0x80, m4)
  8642 |     |             mstore(0xa0, m5)
  8643 |     |             mstore(0xc0, m6)
  8644 |     |         }
  8645 |     |     }
  8646 |     | 
  8647 |     |     function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {
  8648 |     |         bytes32 m0;
  8649 |     |         bytes32 m1;
  8650 |     |         bytes32 m2;
  8651 |     |         bytes32 m3;
  8652 |     |         bytes32 m4;
  8653 |     |         bytes32 m5;
  8654 |     |         bytes32 m6;
  8655 |     |         /// @solidity memory-safe-assembly
  8656 |     |         assembly {
  8657 |     |             function writeString(pos, w) {
  8658 |     |                 let length := 0
  8659 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8660 |     |                 mstore(pos, length)
  8661 |     |                 let shift := sub(256, shl(3, length))
  8662 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8663 |     |             }
  8664 |     |             m0 := mload(0x00)
  8665 |     |             m1 := mload(0x20)
  8666 |     |             m2 := mload(0x40)
  8667 |     |             m3 := mload(0x60)
  8668 |     |             m4 := mload(0x80)
  8669 |     |             m5 := mload(0xa0)
  8670 |     |             m6 := mload(0xc0)
  8671 |     |             // Selector of `log(uint256,address,string,uint256)`.
  8672 |     |             mstore(0x00, 0x46826b5d)
  8673 |     |             mstore(0x20, p0)
  8674 |     |             mstore(0x40, p1)
  8675 |     |             mstore(0x60, 0x80)
  8676 |     |             mstore(0x80, p3)
  8677 |     |             writeString(0xa0, p2)
  8678 |     |         }
  8679 |     |         _sendLogPayload(0x1c, 0xc4);
  8680 |     |         /// @solidity memory-safe-assembly
  8681 |     |         assembly {
  8682 |     |             mstore(0x00, m0)
  8683 |     |             mstore(0x20, m1)
  8684 |     |             mstore(0x40, m2)
  8685 |     |             mstore(0x60, m3)
  8686 |     |             mstore(0x80, m4)
  8687 |     |             mstore(0xa0, m5)
  8688 |     |             mstore(0xc0, m6)
  8689 |     |         }
  8690 |     |     }
  8691 |     | 
  8692 |     |     function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  8693 |     |         bytes32 m0;
  8694 |     |         bytes32 m1;
  8695 |     |         bytes32 m2;
  8696 |     |         bytes32 m3;
  8697 |     |         bytes32 m4;
  8698 |     |         bytes32 m5;
  8699 |     |         bytes32 m6;
  8700 |     |         bytes32 m7;
  8701 |     |         bytes32 m8;
  8702 |     |         /// @solidity memory-safe-assembly
  8703 |     |         assembly {
  8704 |     |             function writeString(pos, w) {
  8705 |     |                 let length := 0
  8706 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8707 |     |                 mstore(pos, length)
  8708 |     |                 let shift := sub(256, shl(3, length))
  8709 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8710 |     |             }
  8711 |     |             m0 := mload(0x00)
  8712 |     |             m1 := mload(0x20)
  8713 |     |             m2 := mload(0x40)
  8714 |     |             m3 := mload(0x60)
  8715 |     |             m4 := mload(0x80)
  8716 |     |             m5 := mload(0xa0)
  8717 |     |             m6 := mload(0xc0)
  8718 |     |             m7 := mload(0xe0)
  8719 |     |             m8 := mload(0x100)
  8720 |     |             // Selector of `log(uint256,address,string,string)`.
  8721 |     |             mstore(0x00, 0x3e128ca3)
  8722 |     |             mstore(0x20, p0)
  8723 |     |             mstore(0x40, p1)
  8724 |     |             mstore(0x60, 0x80)
  8725 |     |             mstore(0x80, 0xc0)
  8726 |     |             writeString(0xa0, p2)
  8727 |     |             writeString(0xe0, p3)
  8728 |     |         }
  8729 |     |         _sendLogPayload(0x1c, 0x104);
  8730 |     |         /// @solidity memory-safe-assembly
  8731 |     |         assembly {
  8732 |     |             mstore(0x00, m0)
  8733 |     |             mstore(0x20, m1)
  8734 |     |             mstore(0x40, m2)
  8735 |     |             mstore(0x60, m3)
  8736 |     |             mstore(0x80, m4)
  8737 |     |             mstore(0xa0, m5)
  8738 |     |             mstore(0xc0, m6)
  8739 |     |             mstore(0xe0, m7)
  8740 |     |             mstore(0x100, m8)
  8741 |     |         }
  8742 |     |     }
  8743 |     | 
  8744 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal pure {
  8745 |     |         bytes32 m0;
  8746 |     |         bytes32 m1;
  8747 |     |         bytes32 m2;
  8748 |     |         bytes32 m3;
  8749 |     |         bytes32 m4;
  8750 |     |         /// @solidity memory-safe-assembly
  8751 |     |         assembly {
  8752 |     |             m0 := mload(0x00)
  8753 |     |             m1 := mload(0x20)
  8754 |     |             m2 := mload(0x40)
  8755 |     |             m3 := mload(0x60)
  8756 |     |             m4 := mload(0x80)
  8757 |     |             // Selector of `log(uint256,bool,address,address)`.
  8758 |     |             mstore(0x00, 0xa1ef4cbb)
  8759 |     |             mstore(0x20, p0)
  8760 |     |             mstore(0x40, p1)
  8761 |     |             mstore(0x60, p2)
  8762 |     |             mstore(0x80, p3)
  8763 |     |         }
  8764 |     |         _sendLogPayload(0x1c, 0x84);
  8765 |     |         /// @solidity memory-safe-assembly
  8766 |     |         assembly {
  8767 |     |             mstore(0x00, m0)
  8768 |     |             mstore(0x20, m1)
  8769 |     |             mstore(0x40, m2)
  8770 |     |             mstore(0x60, m3)
  8771 |     |             mstore(0x80, m4)
  8772 |     |         }
  8773 |     |     }
  8774 |     | 
  8775 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal pure {
  8776 |     |         bytes32 m0;
  8777 |     |         bytes32 m1;
  8778 |     |         bytes32 m2;
  8779 |     |         bytes32 m3;
  8780 |     |         bytes32 m4;
  8781 |     |         /// @solidity memory-safe-assembly
  8782 |     |         assembly {
  8783 |     |             m0 := mload(0x00)
  8784 |     |             m1 := mload(0x20)
  8785 |     |             m2 := mload(0x40)
  8786 |     |             m3 := mload(0x60)
  8787 |     |             m4 := mload(0x80)
  8788 |     |             // Selector of `log(uint256,bool,address,bool)`.
  8789 |     |             mstore(0x00, 0x454d54a5)
  8790 |     |             mstore(0x20, p0)
  8791 |     |             mstore(0x40, p1)
  8792 |     |             mstore(0x60, p2)
  8793 |     |             mstore(0x80, p3)
  8794 |     |         }
  8795 |     |         _sendLogPayload(0x1c, 0x84);
  8796 |     |         /// @solidity memory-safe-assembly
  8797 |     |         assembly {
  8798 |     |             mstore(0x00, m0)
  8799 |     |             mstore(0x20, m1)
  8800 |     |             mstore(0x40, m2)
  8801 |     |             mstore(0x60, m3)
  8802 |     |             mstore(0x80, m4)
  8803 |     |         }
  8804 |     |     }
  8805 |     | 
  8806 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {
  8807 |     |         bytes32 m0;
  8808 |     |         bytes32 m1;
  8809 |     |         bytes32 m2;
  8810 |     |         bytes32 m3;
  8811 |     |         bytes32 m4;
  8812 |     |         /// @solidity memory-safe-assembly
  8813 |     |         assembly {
  8814 |     |             m0 := mload(0x00)
  8815 |     |             m1 := mload(0x20)
  8816 |     |             m2 := mload(0x40)
  8817 |     |             m3 := mload(0x60)
  8818 |     |             m4 := mload(0x80)
  8819 |     |             // Selector of `log(uint256,bool,address,uint256)`.
  8820 |     |             mstore(0x00, 0x078287f5)
  8821 |     |             mstore(0x20, p0)
  8822 |     |             mstore(0x40, p1)
  8823 |     |             mstore(0x60, p2)
  8824 |     |             mstore(0x80, p3)
  8825 |     |         }
  8826 |     |         _sendLogPayload(0x1c, 0x84);
  8827 |     |         /// @solidity memory-safe-assembly
  8828 |     |         assembly {
  8829 |     |             mstore(0x00, m0)
  8830 |     |             mstore(0x20, m1)
  8831 |     |             mstore(0x40, m2)
  8832 |     |             mstore(0x60, m3)
  8833 |     |             mstore(0x80, m4)
  8834 |     |         }
  8835 |     |     }
  8836 |     | 
  8837 |     |     function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {
  8838 |     |         bytes32 m0;
  8839 |     |         bytes32 m1;
  8840 |     |         bytes32 m2;
  8841 |     |         bytes32 m3;
  8842 |     |         bytes32 m4;
  8843 |     |         bytes32 m5;
  8844 |     |         bytes32 m6;
  8845 |     |         /// @solidity memory-safe-assembly
  8846 |     |         assembly {
  8847 |     |             function writeString(pos, w) {
  8848 |     |                 let length := 0
  8849 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8850 |     |                 mstore(pos, length)
  8851 |     |                 let shift := sub(256, shl(3, length))
  8852 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8853 |     |             }
  8854 |     |             m0 := mload(0x00)
  8855 |     |             m1 := mload(0x20)
  8856 |     |             m2 := mload(0x40)
  8857 |     |             m3 := mload(0x60)
  8858 |     |             m4 := mload(0x80)
  8859 |     |             m5 := mload(0xa0)
  8860 |     |             m6 := mload(0xc0)
  8861 |     |             // Selector of `log(uint256,bool,address,string)`.
  8862 |     |             mstore(0x00, 0xade052c7)
  8863 |     |             mstore(0x20, p0)
  8864 |     |             mstore(0x40, p1)
  8865 |     |             mstore(0x60, p2)
  8866 |     |             mstore(0x80, 0x80)
  8867 |     |             writeString(0xa0, p3)
  8868 |     |         }
  8869 |     |         _sendLogPayload(0x1c, 0xc4);
  8870 |     |         /// @solidity memory-safe-assembly
  8871 |     |         assembly {
  8872 |     |             mstore(0x00, m0)
  8873 |     |             mstore(0x20, m1)
  8874 |     |             mstore(0x40, m2)
  8875 |     |             mstore(0x60, m3)
  8876 |     |             mstore(0x80, m4)
  8877 |     |             mstore(0xa0, m5)
  8878 |     |             mstore(0xc0, m6)
  8879 |     |         }
  8880 |     |     }
  8881 |     | 
  8882 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal pure {
  8883 |     |         bytes32 m0;
  8884 |     |         bytes32 m1;
  8885 |     |         bytes32 m2;
  8886 |     |         bytes32 m3;
  8887 |     |         bytes32 m4;
  8888 |     |         /// @solidity memory-safe-assembly
  8889 |     |         assembly {
  8890 |     |             m0 := mload(0x00)
  8891 |     |             m1 := mload(0x20)
  8892 |     |             m2 := mload(0x40)
  8893 |     |             m3 := mload(0x60)
  8894 |     |             m4 := mload(0x80)
  8895 |     |             // Selector of `log(uint256,bool,bool,address)`.
  8896 |     |             mstore(0x00, 0x69640b59)
  8897 |     |             mstore(0x20, p0)
  8898 |     |             mstore(0x40, p1)
  8899 |     |             mstore(0x60, p2)
  8900 |     |             mstore(0x80, p3)
  8901 |     |         }
  8902 |     |         _sendLogPayload(0x1c, 0x84);
  8903 |     |         /// @solidity memory-safe-assembly
  8904 |     |         assembly {
  8905 |     |             mstore(0x00, m0)
  8906 |     |             mstore(0x20, m1)
  8907 |     |             mstore(0x40, m2)
  8908 |     |             mstore(0x60, m3)
  8909 |     |             mstore(0x80, m4)
  8910 |     |         }
  8911 |     |     }
  8912 |     | 
  8913 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {
  8914 |     |         bytes32 m0;
  8915 |     |         bytes32 m1;
  8916 |     |         bytes32 m2;
  8917 |     |         bytes32 m3;
  8918 |     |         bytes32 m4;
  8919 |     |         /// @solidity memory-safe-assembly
  8920 |     |         assembly {
  8921 |     |             m0 := mload(0x00)
  8922 |     |             m1 := mload(0x20)
  8923 |     |             m2 := mload(0x40)
  8924 |     |             m3 := mload(0x60)
  8925 |     |             m4 := mload(0x80)
  8926 |     |             // Selector of `log(uint256,bool,bool,bool)`.
  8927 |     |             mstore(0x00, 0xb6f577a1)
  8928 |     |             mstore(0x20, p0)
  8929 |     |             mstore(0x40, p1)
  8930 |     |             mstore(0x60, p2)
  8931 |     |             mstore(0x80, p3)
  8932 |     |         }
  8933 |     |         _sendLogPayload(0x1c, 0x84);
  8934 |     |         /// @solidity memory-safe-assembly
  8935 |     |         assembly {
  8936 |     |             mstore(0x00, m0)
  8937 |     |             mstore(0x20, m1)
  8938 |     |             mstore(0x40, m2)
  8939 |     |             mstore(0x60, m3)
  8940 |     |             mstore(0x80, m4)
  8941 |     |         }
  8942 |     |     }
  8943 |     | 
  8944 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {
  8945 |     |         bytes32 m0;
  8946 |     |         bytes32 m1;
  8947 |     |         bytes32 m2;
  8948 |     |         bytes32 m3;
  8949 |     |         bytes32 m4;
  8950 |     |         /// @solidity memory-safe-assembly
  8951 |     |         assembly {
  8952 |     |             m0 := mload(0x00)
  8953 |     |             m1 := mload(0x20)
  8954 |     |             m2 := mload(0x40)
  8955 |     |             m3 := mload(0x60)
  8956 |     |             m4 := mload(0x80)
  8957 |     |             // Selector of `log(uint256,bool,bool,uint256)`.
  8958 |     |             mstore(0x00, 0x7464ce23)
  8959 |     |             mstore(0x20, p0)
  8960 |     |             mstore(0x40, p1)
  8961 |     |             mstore(0x60, p2)
  8962 |     |             mstore(0x80, p3)
  8963 |     |         }
  8964 |     |         _sendLogPayload(0x1c, 0x84);
  8965 |     |         /// @solidity memory-safe-assembly
  8966 |     |         assembly {
  8967 |     |             mstore(0x00, m0)
  8968 |     |             mstore(0x20, m1)
  8969 |     |             mstore(0x40, m2)
  8970 |     |             mstore(0x60, m3)
  8971 |     |             mstore(0x80, m4)
  8972 |     |         }
  8973 |     |     }
  8974 |     | 
  8975 |     |     function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {
  8976 |     |         bytes32 m0;
  8977 |     |         bytes32 m1;
  8978 |     |         bytes32 m2;
  8979 |     |         bytes32 m3;
  8980 |     |         bytes32 m4;
  8981 |     |         bytes32 m5;
  8982 |     |         bytes32 m6;
  8983 |     |         /// @solidity memory-safe-assembly
  8984 |     |         assembly {
  8985 |     |             function writeString(pos, w) {
  8986 |     |                 let length := 0
  8987 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8988 |     |                 mstore(pos, length)
  8989 |     |                 let shift := sub(256, shl(3, length))
  8990 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8991 |     |             }
  8992 |     |             m0 := mload(0x00)
  8993 |     |             m1 := mload(0x20)
  8994 |     |             m2 := mload(0x40)
  8995 |     |             m3 := mload(0x60)
  8996 |     |             m4 := mload(0x80)
  8997 |     |             m5 := mload(0xa0)
  8998 |     |             m6 := mload(0xc0)
  8999 |     |             // Selector of `log(uint256,bool,bool,string)`.
  9000 |     |             mstore(0x00, 0xdddb9561)
  9001 |     |             mstore(0x20, p0)
  9002 |     |             mstore(0x40, p1)
  9003 |     |             mstore(0x60, p2)
  9004 |     |             mstore(0x80, 0x80)
  9005 |     |             writeString(0xa0, p3)
  9006 |     |         }
  9007 |     |         _sendLogPayload(0x1c, 0xc4);
  9008 |     |         /// @solidity memory-safe-assembly
  9009 |     |         assembly {
  9010 |     |             mstore(0x00, m0)
  9011 |     |             mstore(0x20, m1)
  9012 |     |             mstore(0x40, m2)
  9013 |     |             mstore(0x60, m3)
  9014 |     |             mstore(0x80, m4)
  9015 |     |             mstore(0xa0, m5)
  9016 |     |             mstore(0xc0, m6)
  9017 |     |         }
  9018 |     |     }
  9019 |     | 
  9020 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {
  9021 |     |         bytes32 m0;
  9022 |     |         bytes32 m1;
  9023 |     |         bytes32 m2;
  9024 |     |         bytes32 m3;
  9025 |     |         bytes32 m4;
  9026 |     |         /// @solidity memory-safe-assembly
  9027 |     |         assembly {
  9028 |     |             m0 := mload(0x00)
  9029 |     |             m1 := mload(0x20)
  9030 |     |             m2 := mload(0x40)
  9031 |     |             m3 := mload(0x60)
  9032 |     |             m4 := mload(0x80)
  9033 |     |             // Selector of `log(uint256,bool,uint256,address)`.
  9034 |     |             mstore(0x00, 0x88cb6041)
  9035 |     |             mstore(0x20, p0)
  9036 |     |             mstore(0x40, p1)
  9037 |     |             mstore(0x60, p2)
  9038 |     |             mstore(0x80, p3)
  9039 |     |         }
  9040 |     |         _sendLogPayload(0x1c, 0x84);
  9041 |     |         /// @solidity memory-safe-assembly
  9042 |     |         assembly {
  9043 |     |             mstore(0x00, m0)
  9044 |     |             mstore(0x20, m1)
  9045 |     |             mstore(0x40, m2)
  9046 |     |             mstore(0x60, m3)
  9047 |     |             mstore(0x80, m4)
  9048 |     |         }
  9049 |     |     }
  9050 |     | 
  9051 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {
  9052 |     |         bytes32 m0;
  9053 |     |         bytes32 m1;
  9054 |     |         bytes32 m2;
  9055 |     |         bytes32 m3;
  9056 |     |         bytes32 m4;
  9057 |     |         /// @solidity memory-safe-assembly
  9058 |     |         assembly {
  9059 |     |             m0 := mload(0x00)
  9060 |     |             m1 := mload(0x20)
  9061 |     |             m2 := mload(0x40)
  9062 |     |             m3 := mload(0x60)
  9063 |     |             m4 := mload(0x80)
  9064 |     |             // Selector of `log(uint256,bool,uint256,bool)`.
  9065 |     |             mstore(0x00, 0x91a02e2a)
  9066 |     |             mstore(0x20, p0)
  9067 |     |             mstore(0x40, p1)
  9068 |     |             mstore(0x60, p2)
  9069 |     |             mstore(0x80, p3)
  9070 |     |         }
  9071 |     |         _sendLogPayload(0x1c, 0x84);
  9072 |     |         /// @solidity memory-safe-assembly
  9073 |     |         assembly {
  9074 |     |             mstore(0x00, m0)
  9075 |     |             mstore(0x20, m1)
  9076 |     |             mstore(0x40, m2)
  9077 |     |             mstore(0x60, m3)
  9078 |     |             mstore(0x80, m4)
  9079 |     |         }
  9080 |     |     }
  9081 |     | 
  9082 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {
  9083 |     |         bytes32 m0;
  9084 |     |         bytes32 m1;
  9085 |     |         bytes32 m2;
  9086 |     |         bytes32 m3;
  9087 |     |         bytes32 m4;
  9088 |     |         /// @solidity memory-safe-assembly
  9089 |     |         assembly {
  9090 |     |             m0 := mload(0x00)
  9091 |     |             m1 := mload(0x20)
  9092 |     |             m2 := mload(0x40)
  9093 |     |             m3 := mload(0x60)
  9094 |     |             m4 := mload(0x80)
  9095 |     |             // Selector of `log(uint256,bool,uint256,uint256)`.
  9096 |     |             mstore(0x00, 0xc6acc7a8)
  9097 |     |             mstore(0x20, p0)
  9098 |     |             mstore(0x40, p1)
  9099 |     |             mstore(0x60, p2)
  9100 |     |             mstore(0x80, p3)
  9101 |     |         }
  9102 |     |         _sendLogPayload(0x1c, 0x84);
  9103 |     |         /// @solidity memory-safe-assembly
  9104 |     |         assembly {
  9105 |     |             mstore(0x00, m0)
  9106 |     |             mstore(0x20, m1)
  9107 |     |             mstore(0x40, m2)
  9108 |     |             mstore(0x60, m3)
  9109 |     |             mstore(0x80, m4)
  9110 |     |         }
  9111 |     |     }
  9112 |     | 
  9113 |     |     function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  9114 |     |         bytes32 m0;
  9115 |     |         bytes32 m1;
  9116 |     |         bytes32 m2;
  9117 |     |         bytes32 m3;
  9118 |     |         bytes32 m4;
  9119 |     |         bytes32 m5;
  9120 |     |         bytes32 m6;
  9121 |     |         /// @solidity memory-safe-assembly
  9122 |     |         assembly {
  9123 |     |             function writeString(pos, w) {
  9124 |     |                 let length := 0
  9125 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9126 |     |                 mstore(pos, length)
  9127 |     |                 let shift := sub(256, shl(3, length))
  9128 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9129 |     |             }
  9130 |     |             m0 := mload(0x00)
  9131 |     |             m1 := mload(0x20)
  9132 |     |             m2 := mload(0x40)
  9133 |     |             m3 := mload(0x60)
  9134 |     |             m4 := mload(0x80)
  9135 |     |             m5 := mload(0xa0)
  9136 |     |             m6 := mload(0xc0)
  9137 |     |             // Selector of `log(uint256,bool,uint256,string)`.
  9138 |     |             mstore(0x00, 0xde03e774)
  9139 |     |             mstore(0x20, p0)
  9140 |     |             mstore(0x40, p1)
  9141 |     |             mstore(0x60, p2)
  9142 |     |             mstore(0x80, 0x80)
  9143 |     |             writeString(0xa0, p3)
  9144 |     |         }
  9145 |     |         _sendLogPayload(0x1c, 0xc4);
  9146 |     |         /// @solidity memory-safe-assembly
  9147 |     |         assembly {
  9148 |     |             mstore(0x00, m0)
  9149 |     |             mstore(0x20, m1)
  9150 |     |             mstore(0x40, m2)
  9151 |     |             mstore(0x60, m3)
  9152 |     |             mstore(0x80, m4)
  9153 |     |             mstore(0xa0, m5)
  9154 |     |             mstore(0xc0, m6)
  9155 |     |         }
  9156 |     |     }
  9157 |     | 
  9158 |     |     function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {
  9159 |     |         bytes32 m0;
  9160 |     |         bytes32 m1;
  9161 |     |         bytes32 m2;
  9162 |     |         bytes32 m3;
  9163 |     |         bytes32 m4;
  9164 |     |         bytes32 m5;
  9165 |     |         bytes32 m6;
  9166 |     |         /// @solidity memory-safe-assembly
  9167 |     |         assembly {
  9168 |     |             function writeString(pos, w) {
  9169 |     |                 let length := 0
  9170 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9171 |     |                 mstore(pos, length)
  9172 |     |                 let shift := sub(256, shl(3, length))
  9173 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9174 |     |             }
  9175 |     |             m0 := mload(0x00)
  9176 |     |             m1 := mload(0x20)
  9177 |     |             m2 := mload(0x40)
  9178 |     |             m3 := mload(0x60)
  9179 |     |             m4 := mload(0x80)
  9180 |     |             m5 := mload(0xa0)
  9181 |     |             m6 := mload(0xc0)
  9182 |     |             // Selector of `log(uint256,bool,string,address)`.
  9183 |     |             mstore(0x00, 0xef529018)
  9184 |     |             mstore(0x20, p0)
  9185 |     |             mstore(0x40, p1)
  9186 |     |             mstore(0x60, 0x80)
  9187 |     |             mstore(0x80, p3)
  9188 |     |             writeString(0xa0, p2)
  9189 |     |         }
  9190 |     |         _sendLogPayload(0x1c, 0xc4);
  9191 |     |         /// @solidity memory-safe-assembly
  9192 |     |         assembly {
  9193 |     |             mstore(0x00, m0)
  9194 |     |             mstore(0x20, m1)
  9195 |     |             mstore(0x40, m2)
  9196 |     |             mstore(0x60, m3)
  9197 |     |             mstore(0x80, m4)
  9198 |     |             mstore(0xa0, m5)
  9199 |     |             mstore(0xc0, m6)
  9200 |     |         }
  9201 |     |     }
  9202 |     | 
  9203 |     |     function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {
  9204 |     |         bytes32 m0;
  9205 |     |         bytes32 m1;
  9206 |     |         bytes32 m2;
  9207 |     |         bytes32 m3;
  9208 |     |         bytes32 m4;
  9209 |     |         bytes32 m5;
  9210 |     |         bytes32 m6;
  9211 |     |         /// @solidity memory-safe-assembly
  9212 |     |         assembly {
  9213 |     |             function writeString(pos, w) {
  9214 |     |                 let length := 0
  9215 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9216 |     |                 mstore(pos, length)
  9217 |     |                 let shift := sub(256, shl(3, length))
  9218 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9219 |     |             }
  9220 |     |             m0 := mload(0x00)
  9221 |     |             m1 := mload(0x20)
  9222 |     |             m2 := mload(0x40)
  9223 |     |             m3 := mload(0x60)
  9224 |     |             m4 := mload(0x80)
  9225 |     |             m5 := mload(0xa0)
  9226 |     |             m6 := mload(0xc0)
  9227 |     |             // Selector of `log(uint256,bool,string,bool)`.
  9228 |     |             mstore(0x00, 0xeb928d7f)
  9229 |     |             mstore(0x20, p0)
  9230 |     |             mstore(0x40, p1)
  9231 |     |             mstore(0x60, 0x80)
  9232 |     |             mstore(0x80, p3)
  9233 |     |             writeString(0xa0, p2)
  9234 |     |         }
  9235 |     |         _sendLogPayload(0x1c, 0xc4);
  9236 |     |         /// @solidity memory-safe-assembly
  9237 |     |         assembly {
  9238 |     |             mstore(0x00, m0)
  9239 |     |             mstore(0x20, m1)
  9240 |     |             mstore(0x40, m2)
  9241 |     |             mstore(0x60, m3)
  9242 |     |             mstore(0x80, m4)
  9243 |     |             mstore(0xa0, m5)
  9244 |     |             mstore(0xc0, m6)
  9245 |     |         }
  9246 |     |     }
  9247 |     | 
  9248 |     |     function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  9249 |     |         bytes32 m0;
  9250 |     |         bytes32 m1;
  9251 |     |         bytes32 m2;
  9252 |     |         bytes32 m3;
  9253 |     |         bytes32 m4;
  9254 |     |         bytes32 m5;
  9255 |     |         bytes32 m6;
  9256 |     |         /// @solidity memory-safe-assembly
  9257 |     |         assembly {
  9258 |     |             function writeString(pos, w) {
  9259 |     |                 let length := 0
  9260 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9261 |     |                 mstore(pos, length)
  9262 |     |                 let shift := sub(256, shl(3, length))
  9263 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9264 |     |             }
  9265 |     |             m0 := mload(0x00)
  9266 |     |             m1 := mload(0x20)
  9267 |     |             m2 := mload(0x40)
  9268 |     |             m3 := mload(0x60)
  9269 |     |             m4 := mload(0x80)
  9270 |     |             m5 := mload(0xa0)
  9271 |     |             m6 := mload(0xc0)
  9272 |     |             // Selector of `log(uint256,bool,string,uint256)`.
  9273 |     |             mstore(0x00, 0x2c1d0746)
  9274 |     |             mstore(0x20, p0)
  9275 |     |             mstore(0x40, p1)
  9276 |     |             mstore(0x60, 0x80)
  9277 |     |             mstore(0x80, p3)
  9278 |     |             writeString(0xa0, p2)
  9279 |     |         }
  9280 |     |         _sendLogPayload(0x1c, 0xc4);
  9281 |     |         /// @solidity memory-safe-assembly
  9282 |     |         assembly {
  9283 |     |             mstore(0x00, m0)
  9284 |     |             mstore(0x20, m1)
  9285 |     |             mstore(0x40, m2)
  9286 |     |             mstore(0x60, m3)
  9287 |     |             mstore(0x80, m4)
  9288 |     |             mstore(0xa0, m5)
  9289 |     |             mstore(0xc0, m6)
  9290 |     |         }
  9291 |     |     }
  9292 |     | 
  9293 |     |     function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  9294 |     |         bytes32 m0;
  9295 |     |         bytes32 m1;
  9296 |     |         bytes32 m2;
  9297 |     |         bytes32 m3;
  9298 |     |         bytes32 m4;
  9299 |     |         bytes32 m5;
  9300 |     |         bytes32 m6;
  9301 |     |         bytes32 m7;
  9302 |     |         bytes32 m8;
  9303 |     |         /// @solidity memory-safe-assembly
  9304 |     |         assembly {
  9305 |     |             function writeString(pos, w) {
  9306 |     |                 let length := 0
  9307 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9308 |     |                 mstore(pos, length)
  9309 |     |                 let shift := sub(256, shl(3, length))
  9310 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9311 |     |             }
  9312 |     |             m0 := mload(0x00)
  9313 |     |             m1 := mload(0x20)
  9314 |     |             m2 := mload(0x40)
  9315 |     |             m3 := mload(0x60)
  9316 |     |             m4 := mload(0x80)
  9317 |     |             m5 := mload(0xa0)
  9318 |     |             m6 := mload(0xc0)
  9319 |     |             m7 := mload(0xe0)
  9320 |     |             m8 := mload(0x100)
  9321 |     |             // Selector of `log(uint256,bool,string,string)`.
  9322 |     |             mstore(0x00, 0x68c8b8bd)
  9323 |     |             mstore(0x20, p0)
  9324 |     |             mstore(0x40, p1)
  9325 |     |             mstore(0x60, 0x80)
  9326 |     |             mstore(0x80, 0xc0)
  9327 |     |             writeString(0xa0, p2)
  9328 |     |             writeString(0xe0, p3)
  9329 |     |         }
  9330 |     |         _sendLogPayload(0x1c, 0x104);
  9331 |     |         /// @solidity memory-safe-assembly
  9332 |     |         assembly {
  9333 |     |             mstore(0x00, m0)
  9334 |     |             mstore(0x20, m1)
  9335 |     |             mstore(0x40, m2)
  9336 |     |             mstore(0x60, m3)
  9337 |     |             mstore(0x80, m4)
  9338 |     |             mstore(0xa0, m5)
  9339 |     |             mstore(0xc0, m6)
  9340 |     |             mstore(0xe0, m7)
  9341 |     |             mstore(0x100, m8)
  9342 |     |         }
  9343 |     |     }
  9344 |     | 
  9345 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {
  9346 |     |         bytes32 m0;
  9347 |     |         bytes32 m1;
  9348 |     |         bytes32 m2;
  9349 |     |         bytes32 m3;
  9350 |     |         bytes32 m4;
  9351 |     |         /// @solidity memory-safe-assembly
  9352 |     |         assembly {
  9353 |     |             m0 := mload(0x00)
  9354 |     |             m1 := mload(0x20)
  9355 |     |             m2 := mload(0x40)
  9356 |     |             m3 := mload(0x60)
  9357 |     |             m4 := mload(0x80)
  9358 |     |             // Selector of `log(uint256,uint256,address,address)`.
  9359 |     |             mstore(0x00, 0x56a5d1b1)
  9360 |     |             mstore(0x20, p0)
  9361 |     |             mstore(0x40, p1)
  9362 |     |             mstore(0x60, p2)
  9363 |     |             mstore(0x80, p3)
  9364 |     |         }
  9365 |     |         _sendLogPayload(0x1c, 0x84);
  9366 |     |         /// @solidity memory-safe-assembly
  9367 |     |         assembly {
  9368 |     |             mstore(0x00, m0)
  9369 |     |             mstore(0x20, m1)
  9370 |     |             mstore(0x40, m2)
  9371 |     |             mstore(0x60, m3)
  9372 |     |             mstore(0x80, m4)
  9373 |     |         }
  9374 |     |     }
  9375 |     | 
  9376 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {
  9377 |     |         bytes32 m0;
  9378 |     |         bytes32 m1;
  9379 |     |         bytes32 m2;
  9380 |     |         bytes32 m3;
  9381 |     |         bytes32 m4;
  9382 |     |         /// @solidity memory-safe-assembly
  9383 |     |         assembly {
  9384 |     |             m0 := mload(0x00)
  9385 |     |             m1 := mload(0x20)
  9386 |     |             m2 := mload(0x40)
  9387 |     |             m3 := mload(0x60)
  9388 |     |             m4 := mload(0x80)
  9389 |     |             // Selector of `log(uint256,uint256,address,bool)`.
  9390 |     |             mstore(0x00, 0x15cac476)
  9391 |     |             mstore(0x20, p0)
  9392 |     |             mstore(0x40, p1)
  9393 |     |             mstore(0x60, p2)
  9394 |     |             mstore(0x80, p3)
  9395 |     |         }
  9396 |     |         _sendLogPayload(0x1c, 0x84);
  9397 |     |         /// @solidity memory-safe-assembly
  9398 |     |         assembly {
  9399 |     |             mstore(0x00, m0)
  9400 |     |             mstore(0x20, m1)
  9401 |     |             mstore(0x40, m2)
  9402 |     |             mstore(0x60, m3)
  9403 |     |             mstore(0x80, m4)
  9404 |     |         }
  9405 |     |     }
  9406 |     | 
  9407 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {
  9408 |     |         bytes32 m0;
  9409 |     |         bytes32 m1;
  9410 |     |         bytes32 m2;
  9411 |     |         bytes32 m3;
  9412 |     |         bytes32 m4;
  9413 |     |         /// @solidity memory-safe-assembly
  9414 |     |         assembly {
  9415 |     |             m0 := mload(0x00)
  9416 |     |             m1 := mload(0x20)
  9417 |     |             m2 := mload(0x40)
  9418 |     |             m3 := mload(0x60)
  9419 |     |             m4 := mload(0x80)
  9420 |     |             // Selector of `log(uint256,uint256,address,uint256)`.
  9421 |     |             mstore(0x00, 0x88f6e4b2)
  9422 |     |             mstore(0x20, p0)
  9423 |     |             mstore(0x40, p1)
  9424 |     |             mstore(0x60, p2)
  9425 |     |             mstore(0x80, p3)
  9426 |     |         }
  9427 |     |         _sendLogPayload(0x1c, 0x84);
  9428 |     |         /// @solidity memory-safe-assembly
  9429 |     |         assembly {
  9430 |     |             mstore(0x00, m0)
  9431 |     |             mstore(0x20, m1)
  9432 |     |             mstore(0x40, m2)
  9433 |     |             mstore(0x60, m3)
  9434 |     |             mstore(0x80, m4)
  9435 |     |         }
  9436 |     |     }
  9437 |     | 
  9438 |     |     function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {
  9439 |     |         bytes32 m0;
  9440 |     |         bytes32 m1;
  9441 |     |         bytes32 m2;
  9442 |     |         bytes32 m3;
  9443 |     |         bytes32 m4;
  9444 |     |         bytes32 m5;
  9445 |     |         bytes32 m6;
  9446 |     |         /// @solidity memory-safe-assembly
  9447 |     |         assembly {
  9448 |     |             function writeString(pos, w) {
  9449 |     |                 let length := 0
  9450 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9451 |     |                 mstore(pos, length)
  9452 |     |                 let shift := sub(256, shl(3, length))
  9453 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9454 |     |             }
  9455 |     |             m0 := mload(0x00)
  9456 |     |             m1 := mload(0x20)
  9457 |     |             m2 := mload(0x40)
  9458 |     |             m3 := mload(0x60)
  9459 |     |             m4 := mload(0x80)
  9460 |     |             m5 := mload(0xa0)
  9461 |     |             m6 := mload(0xc0)
  9462 |     |             // Selector of `log(uint256,uint256,address,string)`.
  9463 |     |             mstore(0x00, 0x6cde40b8)
  9464 |     |             mstore(0x20, p0)
  9465 |     |             mstore(0x40, p1)
  9466 |     |             mstore(0x60, p2)
  9467 |     |             mstore(0x80, 0x80)
  9468 |     |             writeString(0xa0, p3)
  9469 |     |         }
  9470 |     |         _sendLogPayload(0x1c, 0xc4);
  9471 |     |         /// @solidity memory-safe-assembly
  9472 |     |         assembly {
  9473 |     |             mstore(0x00, m0)
  9474 |     |             mstore(0x20, m1)
  9475 |     |             mstore(0x40, m2)
  9476 |     |             mstore(0x60, m3)
  9477 |     |             mstore(0x80, m4)
  9478 |     |             mstore(0xa0, m5)
  9479 |     |             mstore(0xc0, m6)
  9480 |     |         }
  9481 |     |     }
  9482 |     | 
  9483 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {
  9484 |     |         bytes32 m0;
  9485 |     |         bytes32 m1;
  9486 |     |         bytes32 m2;
  9487 |     |         bytes32 m3;
  9488 |     |         bytes32 m4;
  9489 |     |         /// @solidity memory-safe-assembly
  9490 |     |         assembly {
  9491 |     |             m0 := mload(0x00)
  9492 |     |             m1 := mload(0x20)
  9493 |     |             m2 := mload(0x40)
  9494 |     |             m3 := mload(0x60)
  9495 |     |             m4 := mload(0x80)
  9496 |     |             // Selector of `log(uint256,uint256,bool,address)`.
  9497 |     |             mstore(0x00, 0x9a816a83)
  9498 |     |             mstore(0x20, p0)
  9499 |     |             mstore(0x40, p1)
  9500 |     |             mstore(0x60, p2)
  9501 |     |             mstore(0x80, p3)
  9502 |     |         }
  9503 |     |         _sendLogPayload(0x1c, 0x84);
  9504 |     |         /// @solidity memory-safe-assembly
  9505 |     |         assembly {
  9506 |     |             mstore(0x00, m0)
  9507 |     |             mstore(0x20, m1)
  9508 |     |             mstore(0x40, m2)
  9509 |     |             mstore(0x60, m3)
  9510 |     |             mstore(0x80, m4)
  9511 |     |         }
  9512 |     |     }
  9513 |     | 
  9514 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {
  9515 |     |         bytes32 m0;
  9516 |     |         bytes32 m1;
  9517 |     |         bytes32 m2;
  9518 |     |         bytes32 m3;
  9519 |     |         bytes32 m4;
  9520 |     |         /// @solidity memory-safe-assembly
  9521 |     |         assembly {
  9522 |     |             m0 := mload(0x00)
  9523 |     |             m1 := mload(0x20)
  9524 |     |             m2 := mload(0x40)
  9525 |     |             m3 := mload(0x60)
  9526 |     |             m4 := mload(0x80)
  9527 |     |             // Selector of `log(uint256,uint256,bool,bool)`.
  9528 |     |             mstore(0x00, 0xab085ae6)
  9529 |     |             mstore(0x20, p0)
  9530 |     |             mstore(0x40, p1)
  9531 |     |             mstore(0x60, p2)
  9532 |     |             mstore(0x80, p3)
  9533 |     |         }
  9534 |     |         _sendLogPayload(0x1c, 0x84);
  9535 |     |         /// @solidity memory-safe-assembly
  9536 |     |         assembly {
  9537 |     |             mstore(0x00, m0)
  9538 |     |             mstore(0x20, m1)
  9539 |     |             mstore(0x40, m2)
  9540 |     |             mstore(0x60, m3)
  9541 |     |             mstore(0x80, m4)
  9542 |     |         }
  9543 |     |     }
  9544 |     | 
  9545 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {
  9546 |     |         bytes32 m0;
  9547 |     |         bytes32 m1;
  9548 |     |         bytes32 m2;
  9549 |     |         bytes32 m3;
  9550 |     |         bytes32 m4;
  9551 |     |         /// @solidity memory-safe-assembly
  9552 |     |         assembly {
  9553 |     |             m0 := mload(0x00)
  9554 |     |             m1 := mload(0x20)
  9555 |     |             m2 := mload(0x40)
  9556 |     |             m3 := mload(0x60)
  9557 |     |             m4 := mload(0x80)
  9558 |     |             // Selector of `log(uint256,uint256,bool,uint256)`.
  9559 |     |             mstore(0x00, 0xeb7f6fd2)
  9560 |     |             mstore(0x20, p0)
  9561 |     |             mstore(0x40, p1)
  9562 |     |             mstore(0x60, p2)
  9563 |     |             mstore(0x80, p3)
  9564 |     |         }
  9565 |     |         _sendLogPayload(0x1c, 0x84);
  9566 |     |         /// @solidity memory-safe-assembly
  9567 |     |         assembly {
  9568 |     |             mstore(0x00, m0)
  9569 |     |             mstore(0x20, m1)
  9570 |     |             mstore(0x40, m2)
  9571 |     |             mstore(0x60, m3)
  9572 |     |             mstore(0x80, m4)
  9573 |     |         }
  9574 |     |     }
  9575 |     | 
  9576 |     |     function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  9577 |     |         bytes32 m0;
  9578 |     |         bytes32 m1;
  9579 |     |         bytes32 m2;
  9580 |     |         bytes32 m3;
  9581 |     |         bytes32 m4;
  9582 |     |         bytes32 m5;
  9583 |     |         bytes32 m6;
  9584 |     |         /// @solidity memory-safe-assembly
  9585 |     |         assembly {
  9586 |     |             function writeString(pos, w) {
  9587 |     |                 let length := 0
  9588 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9589 |     |                 mstore(pos, length)
  9590 |     |                 let shift := sub(256, shl(3, length))
  9591 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9592 |     |             }
  9593 |     |             m0 := mload(0x00)
  9594 |     |             m1 := mload(0x20)
  9595 |     |             m2 := mload(0x40)
  9596 |     |             m3 := mload(0x60)
  9597 |     |             m4 := mload(0x80)
  9598 |     |             m5 := mload(0xa0)
  9599 |     |             m6 := mload(0xc0)
  9600 |     |             // Selector of `log(uint256,uint256,bool,string)`.
  9601 |     |             mstore(0x00, 0xa5b4fc99)
  9602 |     |             mstore(0x20, p0)
  9603 |     |             mstore(0x40, p1)
  9604 |     |             mstore(0x60, p2)
  9605 |     |             mstore(0x80, 0x80)
  9606 |     |             writeString(0xa0, p3)
  9607 |     |         }
  9608 |     |         _sendLogPayload(0x1c, 0xc4);
  9609 |     |         /// @solidity memory-safe-assembly
  9610 |     |         assembly {
  9611 |     |             mstore(0x00, m0)
  9612 |     |             mstore(0x20, m1)
  9613 |     |             mstore(0x40, m2)
  9614 |     |             mstore(0x60, m3)
  9615 |     |             mstore(0x80, m4)
  9616 |     |             mstore(0xa0, m5)
  9617 |     |             mstore(0xc0, m6)
  9618 |     |         }
  9619 |     |     }
  9620 |     | 
  9621 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {
  9622 |     |         bytes32 m0;
  9623 |     |         bytes32 m1;
  9624 |     |         bytes32 m2;
  9625 |     |         bytes32 m3;
  9626 |     |         bytes32 m4;
  9627 |     |         /// @solidity memory-safe-assembly
  9628 |     |         assembly {
  9629 |     |             m0 := mload(0x00)
  9630 |     |             m1 := mload(0x20)
  9631 |     |             m2 := mload(0x40)
  9632 |     |             m3 := mload(0x60)
  9633 |     |             m4 := mload(0x80)
  9634 |     |             // Selector of `log(uint256,uint256,uint256,address)`.
  9635 |     |             mstore(0x00, 0xfa8185af)
  9636 |     |             mstore(0x20, p0)
  9637 |     |             mstore(0x40, p1)
  9638 |     |             mstore(0x60, p2)
  9639 |     |             mstore(0x80, p3)
  9640 |     |         }
  9641 |     |         _sendLogPayload(0x1c, 0x84);
  9642 |     |         /// @solidity memory-safe-assembly
  9643 |     |         assembly {
  9644 |     |             mstore(0x00, m0)
  9645 |     |             mstore(0x20, m1)
  9646 |     |             mstore(0x40, m2)
  9647 |     |             mstore(0x60, m3)
  9648 |     |             mstore(0x80, m4)
  9649 |     |         }
  9650 |     |     }
  9651 |     | 
  9652 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {
  9653 |     |         bytes32 m0;
  9654 |     |         bytes32 m1;
  9655 |     |         bytes32 m2;
  9656 |     |         bytes32 m3;
  9657 |     |         bytes32 m4;
  9658 |     |         /// @solidity memory-safe-assembly
  9659 |     |         assembly {
  9660 |     |             m0 := mload(0x00)
  9661 |     |             m1 := mload(0x20)
  9662 |     |             m2 := mload(0x40)
  9663 |     |             m3 := mload(0x60)
  9664 |     |             m4 := mload(0x80)
  9665 |     |             // Selector of `log(uint256,uint256,uint256,bool)`.
  9666 |     |             mstore(0x00, 0xc598d185)
  9667 |     |             mstore(0x20, p0)
  9668 |     |             mstore(0x40, p1)
  9669 |     |             mstore(0x60, p2)
  9670 |     |             mstore(0x80, p3)
  9671 |     |         }
  9672 |     |         _sendLogPayload(0x1c, 0x84);
  9673 |     |         /// @solidity memory-safe-assembly
  9674 |     |         assembly {
  9675 |     |             mstore(0x00, m0)
  9676 |     |             mstore(0x20, m1)
  9677 |     |             mstore(0x40, m2)
  9678 |     |             mstore(0x60, m3)
  9679 |     |             mstore(0x80, m4)
  9680 |     |         }
  9681 |     |     }
  9682 |     | 
  9683 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  9684 |     |         bytes32 m0;
  9685 |     |         bytes32 m1;
  9686 |     |         bytes32 m2;
  9687 |     |         bytes32 m3;
  9688 |     |         bytes32 m4;
  9689 |     |         /// @solidity memory-safe-assembly
  9690 |     |         assembly {
  9691 |     |             m0 := mload(0x00)
  9692 |     |             m1 := mload(0x20)
  9693 |     |             m2 := mload(0x40)
  9694 |     |             m3 := mload(0x60)
  9695 |     |             m4 := mload(0x80)
  9696 |     |             // Selector of `log(uint256,uint256,uint256,uint256)`.
  9697 |     |             mstore(0x00, 0x193fb800)
  9698 |     |             mstore(0x20, p0)
  9699 |     |             mstore(0x40, p1)
  9700 |     |             mstore(0x60, p2)
  9701 |     |             mstore(0x80, p3)
  9702 |     |         }
  9703 |     |         _sendLogPayload(0x1c, 0x84);
  9704 |     |         /// @solidity memory-safe-assembly
  9705 |     |         assembly {
  9706 |     |             mstore(0x00, m0)
  9707 |     |             mstore(0x20, m1)
  9708 |     |             mstore(0x40, m2)
  9709 |     |             mstore(0x60, m3)
  9710 |     |             mstore(0x80, m4)
  9711 |     |         }
  9712 |     |     }
  9713 |     | 
  9714 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  9715 |     |         bytes32 m0;
  9716 |     |         bytes32 m1;
  9717 |     |         bytes32 m2;
  9718 |     |         bytes32 m3;
  9719 |     |         bytes32 m4;
  9720 |     |         bytes32 m5;
  9721 |     |         bytes32 m6;
  9722 |     |         /// @solidity memory-safe-assembly
  9723 |     |         assembly {
  9724 |     |             function writeString(pos, w) {
  9725 |     |                 let length := 0
  9726 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9727 |     |                 mstore(pos, length)
  9728 |     |                 let shift := sub(256, shl(3, length))
  9729 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9730 |     |             }
  9731 |     |             m0 := mload(0x00)
  9732 |     |             m1 := mload(0x20)
  9733 |     |             m2 := mload(0x40)
  9734 |     |             m3 := mload(0x60)
  9735 |     |             m4 := mload(0x80)
  9736 |     |             m5 := mload(0xa0)
  9737 |     |             m6 := mload(0xc0)
  9738 |     |             // Selector of `log(uint256,uint256,uint256,string)`.
  9739 |     |             mstore(0x00, 0x59cfcbe3)
  9740 |     |             mstore(0x20, p0)
  9741 |     |             mstore(0x40, p1)
  9742 |     |             mstore(0x60, p2)
  9743 |     |             mstore(0x80, 0x80)
  9744 |     |             writeString(0xa0, p3)
  9745 |     |         }
  9746 |     |         _sendLogPayload(0x1c, 0xc4);
  9747 |     |         /// @solidity memory-safe-assembly
  9748 |     |         assembly {
  9749 |     |             mstore(0x00, m0)
  9750 |     |             mstore(0x20, m1)
  9751 |     |             mstore(0x40, m2)
  9752 |     |             mstore(0x60, m3)
  9753 |     |             mstore(0x80, m4)
  9754 |     |             mstore(0xa0, m5)
  9755 |     |             mstore(0xc0, m6)
  9756 |     |         }
  9757 |     |     }
  9758 |     | 
  9759 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {
  9760 |     |         bytes32 m0;
  9761 |     |         bytes32 m1;
  9762 |     |         bytes32 m2;
  9763 |     |         bytes32 m3;
  9764 |     |         bytes32 m4;
  9765 |     |         bytes32 m5;
  9766 |     |         bytes32 m6;
  9767 |     |         /// @solidity memory-safe-assembly
  9768 |     |         assembly {
  9769 |     |             function writeString(pos, w) {
  9770 |     |                 let length := 0
  9771 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9772 |     |                 mstore(pos, length)
  9773 |     |                 let shift := sub(256, shl(3, length))
  9774 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9775 |     |             }
  9776 |     |             m0 := mload(0x00)
  9777 |     |             m1 := mload(0x20)
  9778 |     |             m2 := mload(0x40)
  9779 |     |             m3 := mload(0x60)
  9780 |     |             m4 := mload(0x80)
  9781 |     |             m5 := mload(0xa0)
  9782 |     |             m6 := mload(0xc0)
  9783 |     |             // Selector of `log(uint256,uint256,string,address)`.
  9784 |     |             mstore(0x00, 0x42d21db7)
  9785 |     |             mstore(0x20, p0)
  9786 |     |             mstore(0x40, p1)
  9787 |     |             mstore(0x60, 0x80)
  9788 |     |             mstore(0x80, p3)
  9789 |     |             writeString(0xa0, p2)
  9790 |     |         }
  9791 |     |         _sendLogPayload(0x1c, 0xc4);
  9792 |     |         /// @solidity memory-safe-assembly
  9793 |     |         assembly {
  9794 |     |             mstore(0x00, m0)
  9795 |     |             mstore(0x20, m1)
  9796 |     |             mstore(0x40, m2)
  9797 |     |             mstore(0x60, m3)
  9798 |     |             mstore(0x80, m4)
  9799 |     |             mstore(0xa0, m5)
  9800 |     |             mstore(0xc0, m6)
  9801 |     |         }
  9802 |     |     }
  9803 |     | 
  9804 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  9805 |     |         bytes32 m0;
  9806 |     |         bytes32 m1;
  9807 |     |         bytes32 m2;
  9808 |     |         bytes32 m3;
  9809 |     |         bytes32 m4;
  9810 |     |         bytes32 m5;
  9811 |     |         bytes32 m6;
  9812 |     |         /// @solidity memory-safe-assembly
  9813 |     |         assembly {
  9814 |     |             function writeString(pos, w) {
  9815 |     |                 let length := 0
  9816 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9817 |     |                 mstore(pos, length)
  9818 |     |                 let shift := sub(256, shl(3, length))
  9819 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9820 |     |             }
  9821 |     |             m0 := mload(0x00)
  9822 |     |             m1 := mload(0x20)
  9823 |     |             m2 := mload(0x40)
  9824 |     |             m3 := mload(0x60)
  9825 |     |             m4 := mload(0x80)
  9826 |     |             m5 := mload(0xa0)
  9827 |     |             m6 := mload(0xc0)
  9828 |     |             // Selector of `log(uint256,uint256,string,bool)`.
  9829 |     |             mstore(0x00, 0x7af6ab25)
  9830 |     |             mstore(0x20, p0)
  9831 |     |             mstore(0x40, p1)
  9832 |     |             mstore(0x60, 0x80)
  9833 |     |             mstore(0x80, p3)
  9834 |     |             writeString(0xa0, p2)
  9835 |     |         }
  9836 |     |         _sendLogPayload(0x1c, 0xc4);
  9837 |     |         /// @solidity memory-safe-assembly
  9838 |     |         assembly {
  9839 |     |             mstore(0x00, m0)
  9840 |     |             mstore(0x20, m1)
  9841 |     |             mstore(0x40, m2)
  9842 |     |             mstore(0x60, m3)
  9843 |     |             mstore(0x80, m4)
  9844 |     |             mstore(0xa0, m5)
  9845 |     |             mstore(0xc0, m6)
  9846 |     |         }
  9847 |     |     }
  9848 |     | 
  9849 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  9850 |     |         bytes32 m0;
  9851 |     |         bytes32 m1;
  9852 |     |         bytes32 m2;
  9853 |     |         bytes32 m3;
  9854 |     |         bytes32 m4;
  9855 |     |         bytes32 m5;
  9856 |     |         bytes32 m6;
  9857 |     |         /// @solidity memory-safe-assembly
  9858 |     |         assembly {
  9859 |     |             function writeString(pos, w) {
  9860 |     |                 let length := 0
  9861 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9862 |     |                 mstore(pos, length)
  9863 |     |                 let shift := sub(256, shl(3, length))
  9864 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9865 |     |             }
  9866 |     |             m0 := mload(0x00)
  9867 |     |             m1 := mload(0x20)
  9868 |     |             m2 := mload(0x40)
  9869 |     |             m3 := mload(0x60)
  9870 |     |             m4 := mload(0x80)
  9871 |     |             m5 := mload(0xa0)
  9872 |     |             m6 := mload(0xc0)
  9873 |     |             // Selector of `log(uint256,uint256,string,uint256)`.
  9874 |     |             mstore(0x00, 0x5da297eb)
  9875 |     |             mstore(0x20, p0)
  9876 |     |             mstore(0x40, p1)
  9877 |     |             mstore(0x60, 0x80)
  9878 |     |             mstore(0x80, p3)
  9879 |     |             writeString(0xa0, p2)
  9880 |     |         }
  9881 |     |         _sendLogPayload(0x1c, 0xc4);
  9882 |     |         /// @solidity memory-safe-assembly
  9883 |     |         assembly {
  9884 |     |             mstore(0x00, m0)
  9885 |     |             mstore(0x20, m1)
  9886 |     |             mstore(0x40, m2)
  9887 |     |             mstore(0x60, m3)
  9888 |     |             mstore(0x80, m4)
  9889 |     |             mstore(0xa0, m5)
  9890 |     |             mstore(0xc0, m6)
  9891 |     |         }
  9892 |     |     }
  9893 |     | 
  9894 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  9895 |     |         bytes32 m0;
  9896 |     |         bytes32 m1;
  9897 |     |         bytes32 m2;
  9898 |     |         bytes32 m3;
  9899 |     |         bytes32 m4;
  9900 |     |         bytes32 m5;
  9901 |     |         bytes32 m6;
  9902 |     |         bytes32 m7;
  9903 |     |         bytes32 m8;
  9904 |     |         /// @solidity memory-safe-assembly
  9905 |     |         assembly {
  9906 |     |             function writeString(pos, w) {
  9907 |     |                 let length := 0
  9908 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9909 |     |                 mstore(pos, length)
  9910 |     |                 let shift := sub(256, shl(3, length))
  9911 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9912 |     |             }
  9913 |     |             m0 := mload(0x00)
  9914 |     |             m1 := mload(0x20)
  9915 |     |             m2 := mload(0x40)
  9916 |     |             m3 := mload(0x60)
  9917 |     |             m4 := mload(0x80)
  9918 |     |             m5 := mload(0xa0)
  9919 |     |             m6 := mload(0xc0)
  9920 |     |             m7 := mload(0xe0)
  9921 |     |             m8 := mload(0x100)
  9922 |     |             // Selector of `log(uint256,uint256,string,string)`.
  9923 |     |             mstore(0x00, 0x27d8afd2)
  9924 |     |             mstore(0x20, p0)
  9925 |     |             mstore(0x40, p1)
  9926 |     |             mstore(0x60, 0x80)
  9927 |     |             mstore(0x80, 0xc0)
  9928 |     |             writeString(0xa0, p2)
  9929 |     |             writeString(0xe0, p3)
  9930 |     |         }
  9931 |     |         _sendLogPayload(0x1c, 0x104);
  9932 |     |         /// @solidity memory-safe-assembly
  9933 |     |         assembly {
  9934 |     |             mstore(0x00, m0)
  9935 |     |             mstore(0x20, m1)
  9936 |     |             mstore(0x40, m2)
  9937 |     |             mstore(0x60, m3)
  9938 |     |             mstore(0x80, m4)
  9939 |     |             mstore(0xa0, m5)
  9940 |     |             mstore(0xc0, m6)
  9941 |     |             mstore(0xe0, m7)
  9942 |     |             mstore(0x100, m8)
  9943 |     |         }
  9944 |     |     }
  9945 |     | 
  9946 |     |     function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {
  9947 |     |         bytes32 m0;
  9948 |     |         bytes32 m1;
  9949 |     |         bytes32 m2;
  9950 |     |         bytes32 m3;
  9951 |     |         bytes32 m4;
  9952 |     |         bytes32 m5;
  9953 |     |         bytes32 m6;
  9954 |     |         /// @solidity memory-safe-assembly
  9955 |     |         assembly {
  9956 |     |             function writeString(pos, w) {
  9957 |     |                 let length := 0
  9958 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9959 |     |                 mstore(pos, length)
  9960 |     |                 let shift := sub(256, shl(3, length))
  9961 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9962 |     |             }
  9963 |     |             m0 := mload(0x00)
  9964 |     |             m1 := mload(0x20)
  9965 |     |             m2 := mload(0x40)
  9966 |     |             m3 := mload(0x60)
  9967 |     |             m4 := mload(0x80)
  9968 |     |             m5 := mload(0xa0)
  9969 |     |             m6 := mload(0xc0)
  9970 |     |             // Selector of `log(uint256,string,address,address)`.
  9971 |     |             mstore(0x00, 0x6168ed61)
  9972 |     |             mstore(0x20, p0)
  9973 |     |             mstore(0x40, 0x80)
  9974 |     |             mstore(0x60, p2)
  9975 |     |             mstore(0x80, p3)
  9976 |     |             writeString(0xa0, p1)
  9977 |     |         }
  9978 |     |         _sendLogPayload(0x1c, 0xc4);
  9979 |     |         /// @solidity memory-safe-assembly
  9980 |     |         assembly {
  9981 |     |             mstore(0x00, m0)
  9982 |     |             mstore(0x20, m1)
  9983 |     |             mstore(0x40, m2)
  9984 |     |             mstore(0x60, m3)
  9985 |     |             mstore(0x80, m4)
  9986 |     |             mstore(0xa0, m5)
  9987 |     |             mstore(0xc0, m6)
  9988 |     |         }
  9989 |     |     }
  9990 |     | 
  9991 |     |     function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {
  9992 |     |         bytes32 m0;
  9993 |     |         bytes32 m1;
  9994 |     |         bytes32 m2;
  9995 |     |         bytes32 m3;
  9996 |     |         bytes32 m4;
  9997 |     |         bytes32 m5;
  9998 |     |         bytes32 m6;
  9999 |     |         /// @solidity memory-safe-assembly
 10000 |     |         assembly {
 10001 |     |             function writeString(pos, w) {
 10002 |     |                 let length := 0
 10003 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10004 |     |                 mstore(pos, length)
 10005 |     |                 let shift := sub(256, shl(3, length))
 10006 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10007 |     |             }
 10008 |     |             m0 := mload(0x00)
 10009 |     |             m1 := mload(0x20)
 10010 |     |             m2 := mload(0x40)
 10011 |     |             m3 := mload(0x60)
 10012 |     |             m4 := mload(0x80)
 10013 |     |             m5 := mload(0xa0)
 10014 |     |             m6 := mload(0xc0)
 10015 |     |             // Selector of `log(uint256,string,address,bool)`.
 10016 |     |             mstore(0x00, 0x90c30a56)
 10017 |     |             mstore(0x20, p0)
 10018 |     |             mstore(0x40, 0x80)
 10019 |     |             mstore(0x60, p2)
 10020 |     |             mstore(0x80, p3)
 10021 |     |             writeString(0xa0, p1)
 10022 |     |         }
 10023 |     |         _sendLogPayload(0x1c, 0xc4);
 10024 |     |         /// @solidity memory-safe-assembly
 10025 |     |         assembly {
 10026 |     |             mstore(0x00, m0)
 10027 |     |             mstore(0x20, m1)
 10028 |     |             mstore(0x40, m2)
 10029 |     |             mstore(0x60, m3)
 10030 |     |             mstore(0x80, m4)
 10031 |     |             mstore(0xa0, m5)
 10032 |     |             mstore(0xc0, m6)
 10033 |     |         }
 10034 |     |     }
 10035 |     | 
 10036 |     |     function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {
 10037 |     |         bytes32 m0;
 10038 |     |         bytes32 m1;
 10039 |     |         bytes32 m2;
 10040 |     |         bytes32 m3;
 10041 |     |         bytes32 m4;
 10042 |     |         bytes32 m5;
 10043 |     |         bytes32 m6;
 10044 |     |         /// @solidity memory-safe-assembly
 10045 |     |         assembly {
 10046 |     |             function writeString(pos, w) {
 10047 |     |                 let length := 0
 10048 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10049 |     |                 mstore(pos, length)
 10050 |     |                 let shift := sub(256, shl(3, length))
 10051 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10052 |     |             }
 10053 |     |             m0 := mload(0x00)
 10054 |     |             m1 := mload(0x20)
 10055 |     |             m2 := mload(0x40)
 10056 |     |             m3 := mload(0x60)
 10057 |     |             m4 := mload(0x80)
 10058 |     |             m5 := mload(0xa0)
 10059 |     |             m6 := mload(0xc0)
 10060 |     |             // Selector of `log(uint256,string,address,uint256)`.
 10061 |     |             mstore(0x00, 0xe8d3018d)
 10062 |     |             mstore(0x20, p0)
 10063 |     |             mstore(0x40, 0x80)
 10064 |     |             mstore(0x60, p2)
 10065 |     |             mstore(0x80, p3)
 10066 |     |             writeString(0xa0, p1)
 10067 |     |         }
 10068 |     |         _sendLogPayload(0x1c, 0xc4);
 10069 |     |         /// @solidity memory-safe-assembly
 10070 |     |         assembly {
 10071 |     |             mstore(0x00, m0)
 10072 |     |             mstore(0x20, m1)
 10073 |     |             mstore(0x40, m2)
 10074 |     |             mstore(0x60, m3)
 10075 |     |             mstore(0x80, m4)
 10076 |     |             mstore(0xa0, m5)
 10077 |     |             mstore(0xc0, m6)
 10078 |     |         }
 10079 |     |     }
 10080 |     | 
 10081 |     |     function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {
 10082 |     |         bytes32 m0;
 10083 |     |         bytes32 m1;
 10084 |     |         bytes32 m2;
 10085 |     |         bytes32 m3;
 10086 |     |         bytes32 m4;
 10087 |     |         bytes32 m5;
 10088 |     |         bytes32 m6;
 10089 |     |         bytes32 m7;
 10090 |     |         bytes32 m8;
 10091 |     |         /// @solidity memory-safe-assembly
 10092 |     |         assembly {
 10093 |     |             function writeString(pos, w) {
 10094 |     |                 let length := 0
 10095 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10096 |     |                 mstore(pos, length)
 10097 |     |                 let shift := sub(256, shl(3, length))
 10098 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10099 |     |             }
 10100 |     |             m0 := mload(0x00)
 10101 |     |             m1 := mload(0x20)
 10102 |     |             m2 := mload(0x40)
 10103 |     |             m3 := mload(0x60)
 10104 |     |             m4 := mload(0x80)
 10105 |     |             m5 := mload(0xa0)
 10106 |     |             m6 := mload(0xc0)
 10107 |     |             m7 := mload(0xe0)
 10108 |     |             m8 := mload(0x100)
 10109 |     |             // Selector of `log(uint256,string,address,string)`.
 10110 |     |             mstore(0x00, 0x9c3adfa1)
 10111 |     |             mstore(0x20, p0)
 10112 |     |             mstore(0x40, 0x80)
 10113 |     |             mstore(0x60, p2)
 10114 |     |             mstore(0x80, 0xc0)
 10115 |     |             writeString(0xa0, p1)
 10116 |     |             writeString(0xe0, p3)
 10117 |     |         }
 10118 |     |         _sendLogPayload(0x1c, 0x104);
 10119 |     |         /// @solidity memory-safe-assembly
 10120 |     |         assembly {
 10121 |     |             mstore(0x00, m0)
 10122 |     |             mstore(0x20, m1)
 10123 |     |             mstore(0x40, m2)
 10124 |     |             mstore(0x60, m3)
 10125 |     |             mstore(0x80, m4)
 10126 |     |             mstore(0xa0, m5)
 10127 |     |             mstore(0xc0, m6)
 10128 |     |             mstore(0xe0, m7)
 10129 |     |             mstore(0x100, m8)
 10130 |     |         }
 10131 |     |     }
 10132 |     | 
 10133 |     |     function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {
 10134 |     |         bytes32 m0;
 10135 |     |         bytes32 m1;
 10136 |     |         bytes32 m2;
 10137 |     |         bytes32 m3;
 10138 |     |         bytes32 m4;
 10139 |     |         bytes32 m5;
 10140 |     |         bytes32 m6;
 10141 |     |         /// @solidity memory-safe-assembly
 10142 |     |         assembly {
 10143 |     |             function writeString(pos, w) {
 10144 |     |                 let length := 0
 10145 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10146 |     |                 mstore(pos, length)
 10147 |     |                 let shift := sub(256, shl(3, length))
 10148 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10149 |     |             }
 10150 |     |             m0 := mload(0x00)
 10151 |     |             m1 := mload(0x20)
 10152 |     |             m2 := mload(0x40)
 10153 |     |             m3 := mload(0x60)
 10154 |     |             m4 := mload(0x80)
 10155 |     |             m5 := mload(0xa0)
 10156 |     |             m6 := mload(0xc0)
 10157 |     |             // Selector of `log(uint256,string,bool,address)`.
 10158 |     |             mstore(0x00, 0xae2ec581)
 10159 |     |             mstore(0x20, p0)
 10160 |     |             mstore(0x40, 0x80)
 10161 |     |             mstore(0x60, p2)
 10162 |     |             mstore(0x80, p3)
 10163 |     |             writeString(0xa0, p1)
 10164 |     |         }
 10165 |     |         _sendLogPayload(0x1c, 0xc4);
 10166 |     |         /// @solidity memory-safe-assembly
 10167 |     |         assembly {
 10168 |     |             mstore(0x00, m0)
 10169 |     |             mstore(0x20, m1)
 10170 |     |             mstore(0x40, m2)
 10171 |     |             mstore(0x60, m3)
 10172 |     |             mstore(0x80, m4)
 10173 |     |             mstore(0xa0, m5)
 10174 |     |             mstore(0xc0, m6)
 10175 |     |         }
 10176 |     |     }
 10177 |     | 
 10178 |     |     function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {
 10179 |     |         bytes32 m0;
 10180 |     |         bytes32 m1;
 10181 |     |         bytes32 m2;
 10182 |     |         bytes32 m3;
 10183 |     |         bytes32 m4;
 10184 |     |         bytes32 m5;
 10185 |     |         bytes32 m6;
 10186 |     |         /// @solidity memory-safe-assembly
 10187 |     |         assembly {
 10188 |     |             function writeString(pos, w) {
 10189 |     |                 let length := 0
 10190 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10191 |     |                 mstore(pos, length)
 10192 |     |                 let shift := sub(256, shl(3, length))
 10193 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10194 |     |             }
 10195 |     |             m0 := mload(0x00)
 10196 |     |             m1 := mload(0x20)
 10197 |     |             m2 := mload(0x40)
 10198 |     |             m3 := mload(0x60)
 10199 |     |             m4 := mload(0x80)
 10200 |     |             m5 := mload(0xa0)
 10201 |     |             m6 := mload(0xc0)
 10202 |     |             // Selector of `log(uint256,string,bool,bool)`.
 10203 |     |             mstore(0x00, 0xba535d9c)
 10204 |     |             mstore(0x20, p0)
 10205 |     |             mstore(0x40, 0x80)
 10206 |     |             mstore(0x60, p2)
 10207 |     |             mstore(0x80, p3)
 10208 |     |             writeString(0xa0, p1)
 10209 |     |         }
 10210 |     |         _sendLogPayload(0x1c, 0xc4);
 10211 |     |         /// @solidity memory-safe-assembly
 10212 |     |         assembly {
 10213 |     |             mstore(0x00, m0)
 10214 |     |             mstore(0x20, m1)
 10215 |     |             mstore(0x40, m2)
 10216 |     |             mstore(0x60, m3)
 10217 |     |             mstore(0x80, m4)
 10218 |     |             mstore(0xa0, m5)
 10219 |     |             mstore(0xc0, m6)
 10220 |     |         }
 10221 |     |     }
 10222 |     | 
 10223 |     |     function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {
 10224 |     |         bytes32 m0;
 10225 |     |         bytes32 m1;
 10226 |     |         bytes32 m2;
 10227 |     |         bytes32 m3;
 10228 |     |         bytes32 m4;
 10229 |     |         bytes32 m5;
 10230 |     |         bytes32 m6;
 10231 |     |         /// @solidity memory-safe-assembly
 10232 |     |         assembly {
 10233 |     |             function writeString(pos, w) {
 10234 |     |                 let length := 0
 10235 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10236 |     |                 mstore(pos, length)
 10237 |     |                 let shift := sub(256, shl(3, length))
 10238 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10239 |     |             }
 10240 |     |             m0 := mload(0x00)
 10241 |     |             m1 := mload(0x20)
 10242 |     |             m2 := mload(0x40)
 10243 |     |             m3 := mload(0x60)
 10244 |     |             m4 := mload(0x80)
 10245 |     |             m5 := mload(0xa0)
 10246 |     |             m6 := mload(0xc0)
 10247 |     |             // Selector of `log(uint256,string,bool,uint256)`.
 10248 |     |             mstore(0x00, 0xcf009880)
 10249 |     |             mstore(0x20, p0)
 10250 |     |             mstore(0x40, 0x80)
 10251 |     |             mstore(0x60, p2)
 10252 |     |             mstore(0x80, p3)
 10253 |     |             writeString(0xa0, p1)
 10254 |     |         }
 10255 |     |         _sendLogPayload(0x1c, 0xc4);
 10256 |     |         /// @solidity memory-safe-assembly
 10257 |     |         assembly {
 10258 |     |             mstore(0x00, m0)
 10259 |     |             mstore(0x20, m1)
 10260 |     |             mstore(0x40, m2)
 10261 |     |             mstore(0x60, m3)
 10262 |     |             mstore(0x80, m4)
 10263 |     |             mstore(0xa0, m5)
 10264 |     |             mstore(0xc0, m6)
 10265 |     |         }
 10266 |     |     }
 10267 |     | 
 10268 |     |     function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
 10269 |     |         bytes32 m0;
 10270 |     |         bytes32 m1;
 10271 |     |         bytes32 m2;
 10272 |     |         bytes32 m3;
 10273 |     |         bytes32 m4;
 10274 |     |         bytes32 m5;
 10275 |     |         bytes32 m6;
 10276 |     |         bytes32 m7;
 10277 |     |         bytes32 m8;
 10278 |     |         /// @solidity memory-safe-assembly
 10279 |     |         assembly {
 10280 |     |             function writeString(pos, w) {
 10281 |     |                 let length := 0
 10282 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10283 |     |                 mstore(pos, length)
 10284 |     |                 let shift := sub(256, shl(3, length))
 10285 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10286 |     |             }
 10287 |     |             m0 := mload(0x00)
 10288 |     |             m1 := mload(0x20)
 10289 |     |             m2 := mload(0x40)
 10290 |     |             m3 := mload(0x60)
 10291 |     |             m4 := mload(0x80)
 10292 |     |             m5 := mload(0xa0)
 10293 |     |             m6 := mload(0xc0)
 10294 |     |             m7 := mload(0xe0)
 10295 |     |             m8 := mload(0x100)
 10296 |     |             // Selector of `log(uint256,string,bool,string)`.
 10297 |     |             mstore(0x00, 0xd2d423cd)
 10298 |     |             mstore(0x20, p0)
 10299 |     |             mstore(0x40, 0x80)
 10300 |     |             mstore(0x60, p2)
 10301 |     |             mstore(0x80, 0xc0)
 10302 |     |             writeString(0xa0, p1)
 10303 |     |             writeString(0xe0, p3)
 10304 |     |         }
 10305 |     |         _sendLogPayload(0x1c, 0x104);
 10306 |     |         /// @solidity memory-safe-assembly
 10307 |     |         assembly {
 10308 |     |             mstore(0x00, m0)
 10309 |     |             mstore(0x20, m1)
 10310 |     |             mstore(0x40, m2)
 10311 |     |             mstore(0x60, m3)
 10312 |     |             mstore(0x80, m4)
 10313 |     |             mstore(0xa0, m5)
 10314 |     |             mstore(0xc0, m6)
 10315 |     |             mstore(0xe0, m7)
 10316 |     |             mstore(0x100, m8)
 10317 |     |         }
 10318 |     |     }
 10319 |     | 
 10320 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {
 10321 |     |         bytes32 m0;
 10322 |     |         bytes32 m1;
 10323 |     |         bytes32 m2;
 10324 |     |         bytes32 m3;
 10325 |     |         bytes32 m4;
 10326 |     |         bytes32 m5;
 10327 |     |         bytes32 m6;
 10328 |     |         /// @solidity memory-safe-assembly
 10329 |     |         assembly {
 10330 |     |             function writeString(pos, w) {
 10331 |     |                 let length := 0
 10332 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10333 |     |                 mstore(pos, length)
 10334 |     |                 let shift := sub(256, shl(3, length))
 10335 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10336 |     |             }
 10337 |     |             m0 := mload(0x00)
 10338 |     |             m1 := mload(0x20)
 10339 |     |             m2 := mload(0x40)
 10340 |     |             m3 := mload(0x60)
 10341 |     |             m4 := mload(0x80)
 10342 |     |             m5 := mload(0xa0)
 10343 |     |             m6 := mload(0xc0)
 10344 |     |             // Selector of `log(uint256,string,uint256,address)`.
 10345 |     |             mstore(0x00, 0x3b2279b4)
 10346 |     |             mstore(0x20, p0)
 10347 |     |             mstore(0x40, 0x80)
 10348 |     |             mstore(0x60, p2)
 10349 |     |             mstore(0x80, p3)
 10350 |     |             writeString(0xa0, p1)
 10351 |     |         }
 10352 |     |         _sendLogPayload(0x1c, 0xc4);
 10353 |     |         /// @solidity memory-safe-assembly
 10354 |     |         assembly {
 10355 |     |             mstore(0x00, m0)
 10356 |     |             mstore(0x20, m1)
 10357 |     |             mstore(0x40, m2)
 10358 |     |             mstore(0x60, m3)
 10359 |     |             mstore(0x80, m4)
 10360 |     |             mstore(0xa0, m5)
 10361 |     |             mstore(0xc0, m6)
 10362 |     |         }
 10363 |     |     }
 10364 |     | 
 10365 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {
 10366 |     |         bytes32 m0;
 10367 |     |         bytes32 m1;
 10368 |     |         bytes32 m2;
 10369 |     |         bytes32 m3;
 10370 |     |         bytes32 m4;
 10371 |     |         bytes32 m5;
 10372 |     |         bytes32 m6;
 10373 |     |         /// @solidity memory-safe-assembly
 10374 |     |         assembly {
 10375 |     |             function writeString(pos, w) {
 10376 |     |                 let length := 0
 10377 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10378 |     |                 mstore(pos, length)
 10379 |     |                 let shift := sub(256, shl(3, length))
 10380 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10381 |     |             }
 10382 |     |             m0 := mload(0x00)
 10383 |     |             m1 := mload(0x20)
 10384 |     |             m2 := mload(0x40)
 10385 |     |             m3 := mload(0x60)
 10386 |     |             m4 := mload(0x80)
 10387 |     |             m5 := mload(0xa0)
 10388 |     |             m6 := mload(0xc0)
 10389 |     |             // Selector of `log(uint256,string,uint256,bool)`.
 10390 |     |             mstore(0x00, 0x691a8f74)
 10391 |     |             mstore(0x20, p0)
 10392 |     |             mstore(0x40, 0x80)
 10393 |     |             mstore(0x60, p2)
 10394 |     |             mstore(0x80, p3)
 10395 |     |             writeString(0xa0, p1)
 10396 |     |         }
 10397 |     |         _sendLogPayload(0x1c, 0xc4);
 10398 |     |         /// @solidity memory-safe-assembly
 10399 |     |         assembly {
 10400 |     |             mstore(0x00, m0)
 10401 |     |             mstore(0x20, m1)
 10402 |     |             mstore(0x40, m2)
 10403 |     |             mstore(0x60, m3)
 10404 |     |             mstore(0x80, m4)
 10405 |     |             mstore(0xa0, m5)
 10406 |     |             mstore(0xc0, m6)
 10407 |     |         }
 10408 |     |     }
 10409 |     | 
 10410 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
 10411 |     |         bytes32 m0;
 10412 |     |         bytes32 m1;
 10413 |     |         bytes32 m2;
 10414 |     |         bytes32 m3;
 10415 |     |         bytes32 m4;
 10416 |     |         bytes32 m5;
 10417 |     |         bytes32 m6;
 10418 |     |         /// @solidity memory-safe-assembly
 10419 |     |         assembly {
 10420 |     |             function writeString(pos, w) {
 10421 |     |                 let length := 0
 10422 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10423 |     |                 mstore(pos, length)
 10424 |     |                 let shift := sub(256, shl(3, length))
 10425 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10426 |     |             }
 10427 |     |             m0 := mload(0x00)
 10428 |     |             m1 := mload(0x20)
 10429 |     |             m2 := mload(0x40)
 10430 |     |             m3 := mload(0x60)
 10431 |     |             m4 := mload(0x80)
 10432 |     |             m5 := mload(0xa0)
 10433 |     |             m6 := mload(0xc0)
 10434 |     |             // Selector of `log(uint256,string,uint256,uint256)`.
 10435 |     |             mstore(0x00, 0x82c25b74)
 10436 |     |             mstore(0x20, p0)
 10437 |     |             mstore(0x40, 0x80)
 10438 |     |             mstore(0x60, p2)
 10439 |     |             mstore(0x80, p3)
 10440 |     |             writeString(0xa0, p1)
 10441 |     |         }
 10442 |     |         _sendLogPayload(0x1c, 0xc4);
 10443 |     |         /// @solidity memory-safe-assembly
 10444 |     |         assembly {
 10445 |     |             mstore(0x00, m0)
 10446 |     |             mstore(0x20, m1)
 10447 |     |             mstore(0x40, m2)
 10448 |     |             mstore(0x60, m3)
 10449 |     |             mstore(0x80, m4)
 10450 |     |             mstore(0xa0, m5)
 10451 |     |             mstore(0xc0, m6)
 10452 |     |         }
 10453 |     |     }
 10454 |     | 
 10455 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
 10456 |     |         bytes32 m0;
 10457 |     |         bytes32 m1;
 10458 |     |         bytes32 m2;
 10459 |     |         bytes32 m3;
 10460 |     |         bytes32 m4;
 10461 |     |         bytes32 m5;
 10462 |     |         bytes32 m6;
 10463 |     |         bytes32 m7;
 10464 |     |         bytes32 m8;
 10465 |     |         /// @solidity memory-safe-assembly
 10466 |     |         assembly {
 10467 |     |             function writeString(pos, w) {
 10468 |     |                 let length := 0
 10469 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10470 |     |                 mstore(pos, length)
 10471 |     |                 let shift := sub(256, shl(3, length))
 10472 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10473 |     |             }
 10474 |     |             m0 := mload(0x00)
 10475 |     |             m1 := mload(0x20)
 10476 |     |             m2 := mload(0x40)
 10477 |     |             m3 := mload(0x60)
 10478 |     |             m4 := mload(0x80)
 10479 |     |             m5 := mload(0xa0)
 10480 |     |             m6 := mload(0xc0)
 10481 |     |             m7 := mload(0xe0)
 10482 |     |             m8 := mload(0x100)
 10483 |     |             // Selector of `log(uint256,string,uint256,string)`.
 10484 |     |             mstore(0x00, 0xb7b914ca)
 10485 |     |             mstore(0x20, p0)
 10486 |     |             mstore(0x40, 0x80)
 10487 |     |             mstore(0x60, p2)
 10488 |     |             mstore(0x80, 0xc0)
 10489 |     |             writeString(0xa0, p1)
 10490 |     |             writeString(0xe0, p3)
 10491 |     |         }
 10492 |     |         _sendLogPayload(0x1c, 0x104);
 10493 |     |         /// @solidity memory-safe-assembly
 10494 |     |         assembly {
 10495 |     |             mstore(0x00, m0)
 10496 |     |             mstore(0x20, m1)
 10497 |     |             mstore(0x40, m2)
 10498 |     |             mstore(0x60, m3)
 10499 |     |             mstore(0x80, m4)
 10500 |     |             mstore(0xa0, m5)
 10501 |     |             mstore(0xc0, m6)
 10502 |     |             mstore(0xe0, m7)
 10503 |     |             mstore(0x100, m8)
 10504 |     |         }
 10505 |     |     }
 10506 |     | 
 10507 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {
 10508 |     |         bytes32 m0;
 10509 |     |         bytes32 m1;
 10510 |     |         bytes32 m2;
 10511 |     |         bytes32 m3;
 10512 |     |         bytes32 m4;
 10513 |     |         bytes32 m5;
 10514 |     |         bytes32 m6;
 10515 |     |         bytes32 m7;
 10516 |     |         bytes32 m8;
 10517 |     |         /// @solidity memory-safe-assembly
 10518 |     |         assembly {
 10519 |     |             function writeString(pos, w) {
 10520 |     |                 let length := 0
 10521 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10522 |     |                 mstore(pos, length)
 10523 |     |                 let shift := sub(256, shl(3, length))
 10524 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10525 |     |             }
 10526 |     |             m0 := mload(0x00)
 10527 |     |             m1 := mload(0x20)
 10528 |     |             m2 := mload(0x40)
 10529 |     |             m3 := mload(0x60)
 10530 |     |             m4 := mload(0x80)
 10531 |     |             m5 := mload(0xa0)
 10532 |     |             m6 := mload(0xc0)
 10533 |     |             m7 := mload(0xe0)
 10534 |     |             m8 := mload(0x100)
 10535 |     |             // Selector of `log(uint256,string,string,address)`.
 10536 |     |             mstore(0x00, 0xd583c602)
 10537 |     |             mstore(0x20, p0)
 10538 |     |             mstore(0x40, 0x80)
 10539 |     |             mstore(0x60, 0xc0)
 10540 |     |             mstore(0x80, p3)
 10541 |     |             writeString(0xa0, p1)
 10542 |     |             writeString(0xe0, p2)
 10543 |     |         }
 10544 |     |         _sendLogPayload(0x1c, 0x104);
 10545 |     |         /// @solidity memory-safe-assembly
 10546 |     |         assembly {
 10547 |     |             mstore(0x00, m0)
 10548 |     |             mstore(0x20, m1)
 10549 |     |             mstore(0x40, m2)
 10550 |     |             mstore(0x60, m3)
 10551 |     |             mstore(0x80, m4)
 10552 |     |             mstore(0xa0, m5)
 10553 |     |             mstore(0xc0, m6)
 10554 |     |             mstore(0xe0, m7)
 10555 |     |             mstore(0x100, m8)
 10556 |     |         }
 10557 |     |     }
 10558 |     | 
 10559 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
 10560 |     |         bytes32 m0;
 10561 |     |         bytes32 m1;
 10562 |     |         bytes32 m2;
 10563 |     |         bytes32 m3;
 10564 |     |         bytes32 m4;
 10565 |     |         bytes32 m5;
 10566 |     |         bytes32 m6;
 10567 |     |         bytes32 m7;
 10568 |     |         bytes32 m8;
 10569 |     |         /// @solidity memory-safe-assembly
 10570 |     |         assembly {
 10571 |     |             function writeString(pos, w) {
 10572 |     |                 let length := 0
 10573 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10574 |     |                 mstore(pos, length)
 10575 |     |                 let shift := sub(256, shl(3, length))
 10576 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10577 |     |             }
 10578 |     |             m0 := mload(0x00)
 10579 |     |             m1 := mload(0x20)
 10580 |     |             m2 := mload(0x40)
 10581 |     |             m3 := mload(0x60)
 10582 |     |             m4 := mload(0x80)
 10583 |     |             m5 := mload(0xa0)
 10584 |     |             m6 := mload(0xc0)
 10585 |     |             m7 := mload(0xe0)
 10586 |     |             m8 := mload(0x100)
 10587 |     |             // Selector of `log(uint256,string,string,bool)`.
 10588 |     |             mstore(0x00, 0xb3a6b6bd)
 10589 |     |             mstore(0x20, p0)
 10590 |     |             mstore(0x40, 0x80)
 10591 |     |             mstore(0x60, 0xc0)
 10592 |     |             mstore(0x80, p3)
 10593 |     |             writeString(0xa0, p1)
 10594 |     |             writeString(0xe0, p2)
 10595 |     |         }
 10596 |     |         _sendLogPayload(0x1c, 0x104);
 10597 |     |         /// @solidity memory-safe-assembly
 10598 |     |         assembly {
 10599 |     |             mstore(0x00, m0)
 10600 |     |             mstore(0x20, m1)
 10601 |     |             mstore(0x40, m2)
 10602 |     |             mstore(0x60, m3)
 10603 |     |             mstore(0x80, m4)
 10604 |     |             mstore(0xa0, m5)
 10605 |     |             mstore(0xc0, m6)
 10606 |     |             mstore(0xe0, m7)
 10607 |     |             mstore(0x100, m8)
 10608 |     |         }
 10609 |     |     }
 10610 |     | 
 10611 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
 10612 |     |         bytes32 m0;
 10613 |     |         bytes32 m1;
 10614 |     |         bytes32 m2;
 10615 |     |         bytes32 m3;
 10616 |     |         bytes32 m4;
 10617 |     |         bytes32 m5;
 10618 |     |         bytes32 m6;
 10619 |     |         bytes32 m7;
 10620 |     |         bytes32 m8;
 10621 |     |         /// @solidity memory-safe-assembly
 10622 |     |         assembly {
 10623 |     |             function writeString(pos, w) {
 10624 |     |                 let length := 0
 10625 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10626 |     |                 mstore(pos, length)
 10627 |     |                 let shift := sub(256, shl(3, length))
 10628 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10629 |     |             }
 10630 |     |             m0 := mload(0x00)
 10631 |     |             m1 := mload(0x20)
 10632 |     |             m2 := mload(0x40)
 10633 |     |             m3 := mload(0x60)
 10634 |     |             m4 := mload(0x80)
 10635 |     |             m5 := mload(0xa0)
 10636 |     |             m6 := mload(0xc0)
 10637 |     |             m7 := mload(0xe0)
 10638 |     |             m8 := mload(0x100)
 10639 |     |             // Selector of `log(uint256,string,string,uint256)`.
 10640 |     |             mstore(0x00, 0xb028c9bd)
 10641 |     |             mstore(0x20, p0)
 10642 |     |             mstore(0x40, 0x80)
 10643 |     |             mstore(0x60, 0xc0)
 10644 |     |             mstore(0x80, p3)
 10645 |     |             writeString(0xa0, p1)
 10646 |     |             writeString(0xe0, p2)
 10647 |     |         }
 10648 |     |         _sendLogPayload(0x1c, 0x104);
 10649 |     |         /// @solidity memory-safe-assembly
 10650 |     |         assembly {
 10651 |     |             mstore(0x00, m0)
 10652 |     |             mstore(0x20, m1)
 10653 |     |             mstore(0x40, m2)
 10654 |     |             mstore(0x60, m3)
 10655 |     |             mstore(0x80, m4)
 10656 |     |             mstore(0xa0, m5)
 10657 |     |             mstore(0xc0, m6)
 10658 |     |             mstore(0xe0, m7)
 10659 |     |             mstore(0x100, m8)
 10660 |     |         }
 10661 |     |     }
 10662 |     | 
 10663 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
 10664 |     |         bytes32 m0;
 10665 |     |         bytes32 m1;
 10666 |     |         bytes32 m2;
 10667 |     |         bytes32 m3;
 10668 |     |         bytes32 m4;
 10669 |     |         bytes32 m5;
 10670 |     |         bytes32 m6;
 10671 |     |         bytes32 m7;
 10672 |     |         bytes32 m8;
 10673 |     |         bytes32 m9;
 10674 |     |         bytes32 m10;
 10675 |     |         /// @solidity memory-safe-assembly
 10676 |     |         assembly {
 10677 |     |             function writeString(pos, w) {
 10678 |     |                 let length := 0
 10679 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10680 |     |                 mstore(pos, length)
 10681 |     |                 let shift := sub(256, shl(3, length))
 10682 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10683 |     |             }
 10684 |     |             m0 := mload(0x00)
 10685 |     |             m1 := mload(0x20)
 10686 |     |             m2 := mload(0x40)
 10687 |     |             m3 := mload(0x60)
 10688 |     |             m4 := mload(0x80)
 10689 |     |             m5 := mload(0xa0)
 10690 |     |             m6 := mload(0xc0)
 10691 |     |             m7 := mload(0xe0)
 10692 |     |             m8 := mload(0x100)
 10693 |     |             m9 := mload(0x120)
 10694 |     |             m10 := mload(0x140)
 10695 |     |             // Selector of `log(uint256,string,string,string)`.
 10696 |     |             mstore(0x00, 0x21ad0683)
 10697 |     |             mstore(0x20, p0)
 10698 |     |             mstore(0x40, 0x80)
 10699 |     |             mstore(0x60, 0xc0)
 10700 |     |             mstore(0x80, 0x100)
 10701 |     |             writeString(0xa0, p1)
 10702 |     |             writeString(0xe0, p2)
 10703 |     |             writeString(0x120, p3)
 10704 |     |         }
 10705 |     |         _sendLogPayload(0x1c, 0x144);
 10706 |     |         /// @solidity memory-safe-assembly
 10707 |     |         assembly {
 10708 |     |             mstore(0x00, m0)
 10709 |     |             mstore(0x20, m1)
 10710 |     |             mstore(0x40, m2)
 10711 |     |             mstore(0x60, m3)
 10712 |     |             mstore(0x80, m4)
 10713 |     |             mstore(0xa0, m5)
 10714 |     |             mstore(0xc0, m6)
 10715 |     |             mstore(0xe0, m7)
 10716 |     |             mstore(0x100, m8)
 10717 |     |             mstore(0x120, m9)
 10718 |     |             mstore(0x140, m10)
 10719 |     |         }
 10720 |     |     }
 10721 |     | 
 10722 |     |     function log(bytes32 p0, address p1, address p2, address p3) internal pure {
 10723 |     |         bytes32 m0;
 10724 |     |         bytes32 m1;
 10725 |     |         bytes32 m2;
 10726 |     |         bytes32 m3;
 10727 |     |         bytes32 m4;
 10728 |     |         bytes32 m5;
 10729 |     |         bytes32 m6;
 10730 |     |         /// @solidity memory-safe-assembly
 10731 |     |         assembly {
 10732 |     |             function writeString(pos, w) {
 10733 |     |                 let length := 0
 10734 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10735 |     |                 mstore(pos, length)
 10736 |     |                 let shift := sub(256, shl(3, length))
 10737 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10738 |     |             }
 10739 |     |             m0 := mload(0x00)
 10740 |     |             m1 := mload(0x20)
 10741 |     |             m2 := mload(0x40)
 10742 |     |             m3 := mload(0x60)
 10743 |     |             m4 := mload(0x80)
 10744 |     |             m5 := mload(0xa0)
 10745 |     |             m6 := mload(0xc0)
 10746 |     |             // Selector of `log(string,address,address,address)`.
 10747 |     |             mstore(0x00, 0xed8f28f6)
 10748 |     |             mstore(0x20, 0x80)
 10749 |     |             mstore(0x40, p1)
 10750 |     |             mstore(0x60, p2)
 10751 |     |             mstore(0x80, p3)
 10752 |     |             writeString(0xa0, p0)
 10753 |     |         }
 10754 |     |         _sendLogPayload(0x1c, 0xc4);
 10755 |     |         /// @solidity memory-safe-assembly
 10756 |     |         assembly {
 10757 |     |             mstore(0x00, m0)
 10758 |     |             mstore(0x20, m1)
 10759 |     |             mstore(0x40, m2)
 10760 |     |             mstore(0x60, m3)
 10761 |     |             mstore(0x80, m4)
 10762 |     |             mstore(0xa0, m5)
 10763 |     |             mstore(0xc0, m6)
 10764 |     |         }
 10765 |     |     }
 10766 |     | 
 10767 |     |     function log(bytes32 p0, address p1, address p2, bool p3) internal pure {
 10768 |     |         bytes32 m0;
 10769 |     |         bytes32 m1;
 10770 |     |         bytes32 m2;
 10771 |     |         bytes32 m3;
 10772 |     |         bytes32 m4;
 10773 |     |         bytes32 m5;
 10774 |     |         bytes32 m6;
 10775 |     |         /// @solidity memory-safe-assembly
 10776 |     |         assembly {
 10777 |     |             function writeString(pos, w) {
 10778 |     |                 let length := 0
 10779 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10780 |     |                 mstore(pos, length)
 10781 |     |                 let shift := sub(256, shl(3, length))
 10782 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10783 |     |             }
 10784 |     |             m0 := mload(0x00)
 10785 |     |             m1 := mload(0x20)
 10786 |     |             m2 := mload(0x40)
 10787 |     |             m3 := mload(0x60)
 10788 |     |             m4 := mload(0x80)
 10789 |     |             m5 := mload(0xa0)
 10790 |     |             m6 := mload(0xc0)
 10791 |     |             // Selector of `log(string,address,address,bool)`.
 10792 |     |             mstore(0x00, 0xb59dbd60)
 10793 |     |             mstore(0x20, 0x80)
 10794 |     |             mstore(0x40, p1)
 10795 |     |             mstore(0x60, p2)
 10796 |     |             mstore(0x80, p3)
 10797 |     |             writeString(0xa0, p0)
 10798 |     |         }
 10799 |     |         _sendLogPayload(0x1c, 0xc4);
 10800 |     |         /// @solidity memory-safe-assembly
 10801 |     |         assembly {
 10802 |     |             mstore(0x00, m0)
 10803 |     |             mstore(0x20, m1)
 10804 |     |             mstore(0x40, m2)
 10805 |     |             mstore(0x60, m3)
 10806 |     |             mstore(0x80, m4)
 10807 |     |             mstore(0xa0, m5)
 10808 |     |             mstore(0xc0, m6)
 10809 |     |         }
 10810 |     |     }
 10811 |     | 
 10812 |     |     function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {
 10813 |     |         bytes32 m0;
 10814 |     |         bytes32 m1;
 10815 |     |         bytes32 m2;
 10816 |     |         bytes32 m3;
 10817 |     |         bytes32 m4;
 10818 |     |         bytes32 m5;
 10819 |     |         bytes32 m6;
 10820 |     |         /// @solidity memory-safe-assembly
 10821 |     |         assembly {
 10822 |     |             function writeString(pos, w) {
 10823 |     |                 let length := 0
 10824 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10825 |     |                 mstore(pos, length)
 10826 |     |                 let shift := sub(256, shl(3, length))
 10827 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10828 |     |             }
 10829 |     |             m0 := mload(0x00)
 10830 |     |             m1 := mload(0x20)
 10831 |     |             m2 := mload(0x40)
 10832 |     |             m3 := mload(0x60)
 10833 |     |             m4 := mload(0x80)
 10834 |     |             m5 := mload(0xa0)
 10835 |     |             m6 := mload(0xc0)
 10836 |     |             // Selector of `log(string,address,address,uint256)`.
 10837 |     |             mstore(0x00, 0x8ef3f399)
 10838 |     |             mstore(0x20, 0x80)
 10839 |     |             mstore(0x40, p1)
 10840 |     |             mstore(0x60, p2)
 10841 |     |             mstore(0x80, p3)
 10842 |     |             writeString(0xa0, p0)
 10843 |     |         }
 10844 |     |         _sendLogPayload(0x1c, 0xc4);
 10845 |     |         /// @solidity memory-safe-assembly
 10846 |     |         assembly {
 10847 |     |             mstore(0x00, m0)
 10848 |     |             mstore(0x20, m1)
 10849 |     |             mstore(0x40, m2)
 10850 |     |             mstore(0x60, m3)
 10851 |     |             mstore(0x80, m4)
 10852 |     |             mstore(0xa0, m5)
 10853 |     |             mstore(0xc0, m6)
 10854 |     |         }
 10855 |     |     }
 10856 |     | 
 10857 |     |     function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {
 10858 |     |         bytes32 m0;
 10859 |     |         bytes32 m1;
 10860 |     |         bytes32 m2;
 10861 |     |         bytes32 m3;
 10862 |     |         bytes32 m4;
 10863 |     |         bytes32 m5;
 10864 |     |         bytes32 m6;
 10865 |     |         bytes32 m7;
 10866 |     |         bytes32 m8;
 10867 |     |         /// @solidity memory-safe-assembly
 10868 |     |         assembly {
 10869 |     |             function writeString(pos, w) {
 10870 |     |                 let length := 0
 10871 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10872 |     |                 mstore(pos, length)
 10873 |     |                 let shift := sub(256, shl(3, length))
 10874 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10875 |     |             }
 10876 |     |             m0 := mload(0x00)
 10877 |     |             m1 := mload(0x20)
 10878 |     |             m2 := mload(0x40)
 10879 |     |             m3 := mload(0x60)
 10880 |     |             m4 := mload(0x80)
 10881 |     |             m5 := mload(0xa0)
 10882 |     |             m6 := mload(0xc0)
 10883 |     |             m7 := mload(0xe0)
 10884 |     |             m8 := mload(0x100)
 10885 |     |             // Selector of `log(string,address,address,string)`.
 10886 |     |             mstore(0x00, 0x800a1c67)
 10887 |     |             mstore(0x20, 0x80)
 10888 |     |             mstore(0x40, p1)
 10889 |     |             mstore(0x60, p2)
 10890 |     |             mstore(0x80, 0xc0)
 10891 |     |             writeString(0xa0, p0)
 10892 |     |             writeString(0xe0, p3)
 10893 |     |         }
 10894 |     |         _sendLogPayload(0x1c, 0x104);
 10895 |     |         /// @solidity memory-safe-assembly
 10896 |     |         assembly {
 10897 |     |             mstore(0x00, m0)
 10898 |     |             mstore(0x20, m1)
 10899 |     |             mstore(0x40, m2)
 10900 |     |             mstore(0x60, m3)
 10901 |     |             mstore(0x80, m4)
 10902 |     |             mstore(0xa0, m5)
 10903 |     |             mstore(0xc0, m6)
 10904 |     |             mstore(0xe0, m7)
 10905 |     |             mstore(0x100, m8)
 10906 |     |         }
 10907 |     |     }
 10908 |     | 
 10909 |     |     function log(bytes32 p0, address p1, bool p2, address p3) internal pure {
 10910 |     |         bytes32 m0;
 10911 |     |         bytes32 m1;
 10912 |     |         bytes32 m2;
 10913 |     |         bytes32 m3;
 10914 |     |         bytes32 m4;
 10915 |     |         bytes32 m5;
 10916 |     |         bytes32 m6;
 10917 |     |         /// @solidity memory-safe-assembly
 10918 |     |         assembly {
 10919 |     |             function writeString(pos, w) {
 10920 |     |                 let length := 0
 10921 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10922 |     |                 mstore(pos, length)
 10923 |     |                 let shift := sub(256, shl(3, length))
 10924 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10925 |     |             }
 10926 |     |             m0 := mload(0x00)
 10927 |     |             m1 := mload(0x20)
 10928 |     |             m2 := mload(0x40)
 10929 |     |             m3 := mload(0x60)
 10930 |     |             m4 := mload(0x80)
 10931 |     |             m5 := mload(0xa0)
 10932 |     |             m6 := mload(0xc0)
 10933 |     |             // Selector of `log(string,address,bool,address)`.
 10934 |     |             mstore(0x00, 0x223603bd)
 10935 |     |             mstore(0x20, 0x80)
 10936 |     |             mstore(0x40, p1)
 10937 |     |             mstore(0x60, p2)
 10938 |     |             mstore(0x80, p3)
 10939 |     |             writeString(0xa0, p0)
 10940 |     |         }
 10941 |     |         _sendLogPayload(0x1c, 0xc4);
 10942 |     |         /// @solidity memory-safe-assembly
 10943 |     |         assembly {
 10944 |     |             mstore(0x00, m0)
 10945 |     |             mstore(0x20, m1)
 10946 |     |             mstore(0x40, m2)
 10947 |     |             mstore(0x60, m3)
 10948 |     |             mstore(0x80, m4)
 10949 |     |             mstore(0xa0, m5)
 10950 |     |             mstore(0xc0, m6)
 10951 |     |         }
 10952 |     |     }
 10953 |     | 
 10954 |     |     function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {
 10955 |     |         bytes32 m0;
 10956 |     |         bytes32 m1;
 10957 |     |         bytes32 m2;
 10958 |     |         bytes32 m3;
 10959 |     |         bytes32 m4;
 10960 |     |         bytes32 m5;
 10961 |     |         bytes32 m6;
 10962 |     |         /// @solidity memory-safe-assembly
 10963 |     |         assembly {
 10964 |     |             function writeString(pos, w) {
 10965 |     |                 let length := 0
 10966 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10967 |     |                 mstore(pos, length)
 10968 |     |                 let shift := sub(256, shl(3, length))
 10969 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10970 |     |             }
 10971 |     |             m0 := mload(0x00)
 10972 |     |             m1 := mload(0x20)
 10973 |     |             m2 := mload(0x40)
 10974 |     |             m3 := mload(0x60)
 10975 |     |             m4 := mload(0x80)
 10976 |     |             m5 := mload(0xa0)
 10977 |     |             m6 := mload(0xc0)
 10978 |     |             // Selector of `log(string,address,bool,bool)`.
 10979 |     |             mstore(0x00, 0x79884c2b)
 10980 |     |             mstore(0x20, 0x80)
 10981 |     |             mstore(0x40, p1)
 10982 |     |             mstore(0x60, p2)
 10983 |     |             mstore(0x80, p3)
 10984 |     |             writeString(0xa0, p0)
 10985 |     |         }
 10986 |     |         _sendLogPayload(0x1c, 0xc4);
 10987 |     |         /// @solidity memory-safe-assembly
 10988 |     |         assembly {
 10989 |     |             mstore(0x00, m0)
 10990 |     |             mstore(0x20, m1)
 10991 |     |             mstore(0x40, m2)
 10992 |     |             mstore(0x60, m3)
 10993 |     |             mstore(0x80, m4)
 10994 |     |             mstore(0xa0, m5)
 10995 |     |             mstore(0xc0, m6)
 10996 |     |         }
 10997 |     |     }
 10998 |     | 
 10999 |     |     function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {
 11000 |     |         bytes32 m0;
 11001 |     |         bytes32 m1;
 11002 |     |         bytes32 m2;
 11003 |     |         bytes32 m3;
 11004 |     |         bytes32 m4;
 11005 |     |         bytes32 m5;
 11006 |     |         bytes32 m6;
 11007 |     |         /// @solidity memory-safe-assembly
 11008 |     |         assembly {
 11009 |     |             function writeString(pos, w) {
 11010 |     |                 let length := 0
 11011 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11012 |     |                 mstore(pos, length)
 11013 |     |                 let shift := sub(256, shl(3, length))
 11014 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11015 |     |             }
 11016 |     |             m0 := mload(0x00)
 11017 |     |             m1 := mload(0x20)
 11018 |     |             m2 := mload(0x40)
 11019 |     |             m3 := mload(0x60)
 11020 |     |             m4 := mload(0x80)
 11021 |     |             m5 := mload(0xa0)
 11022 |     |             m6 := mload(0xc0)
 11023 |     |             // Selector of `log(string,address,bool,uint256)`.
 11024 |     |             mstore(0x00, 0x3e9f866a)
 11025 |     |             mstore(0x20, 0x80)
 11026 |     |             mstore(0x40, p1)
 11027 |     |             mstore(0x60, p2)
 11028 |     |             mstore(0x80, p3)
 11029 |     |             writeString(0xa0, p0)
 11030 |     |         }
 11031 |     |         _sendLogPayload(0x1c, 0xc4);
 11032 |     |         /// @solidity memory-safe-assembly
 11033 |     |         assembly {
 11034 |     |             mstore(0x00, m0)
 11035 |     |             mstore(0x20, m1)
 11036 |     |             mstore(0x40, m2)
 11037 |     |             mstore(0x60, m3)
 11038 |     |             mstore(0x80, m4)
 11039 |     |             mstore(0xa0, m5)
 11040 |     |             mstore(0xc0, m6)
 11041 |     |         }
 11042 |     |     }
 11043 |     | 
 11044 |     |     function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {
 11045 |     |         bytes32 m0;
 11046 |     |         bytes32 m1;
 11047 |     |         bytes32 m2;
 11048 |     |         bytes32 m3;
 11049 |     |         bytes32 m4;
 11050 |     |         bytes32 m5;
 11051 |     |         bytes32 m6;
 11052 |     |         bytes32 m7;
 11053 |     |         bytes32 m8;
 11054 |     |         /// @solidity memory-safe-assembly
 11055 |     |         assembly {
 11056 |     |             function writeString(pos, w) {
 11057 |     |                 let length := 0
 11058 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11059 |     |                 mstore(pos, length)
 11060 |     |                 let shift := sub(256, shl(3, length))
 11061 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11062 |     |             }
 11063 |     |             m0 := mload(0x00)
 11064 |     |             m1 := mload(0x20)
 11065 |     |             m2 := mload(0x40)
 11066 |     |             m3 := mload(0x60)
 11067 |     |             m4 := mload(0x80)
 11068 |     |             m5 := mload(0xa0)
 11069 |     |             m6 := mload(0xc0)
 11070 |     |             m7 := mload(0xe0)
 11071 |     |             m8 := mload(0x100)
 11072 |     |             // Selector of `log(string,address,bool,string)`.
 11073 |     |             mstore(0x00, 0x0454c079)
 11074 |     |             mstore(0x20, 0x80)
 11075 |     |             mstore(0x40, p1)
 11076 |     |             mstore(0x60, p2)
 11077 |     |             mstore(0x80, 0xc0)
 11078 |     |             writeString(0xa0, p0)
 11079 |     |             writeString(0xe0, p3)
 11080 |     |         }
 11081 |     |         _sendLogPayload(0x1c, 0x104);
 11082 |     |         /// @solidity memory-safe-assembly
 11083 |     |         assembly {
 11084 |     |             mstore(0x00, m0)
 11085 |     |             mstore(0x20, m1)
 11086 |     |             mstore(0x40, m2)
 11087 |     |             mstore(0x60, m3)
 11088 |     |             mstore(0x80, m4)
 11089 |     |             mstore(0xa0, m5)
 11090 |     |             mstore(0xc0, m6)
 11091 |     |             mstore(0xe0, m7)
 11092 |     |             mstore(0x100, m8)
 11093 |     |         }
 11094 |     |     }
 11095 |     | 
 11096 |     |     function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {
 11097 |     |         bytes32 m0;
 11098 |     |         bytes32 m1;
 11099 |     |         bytes32 m2;
 11100 |     |         bytes32 m3;
 11101 |     |         bytes32 m4;
 11102 |     |         bytes32 m5;
 11103 |     |         bytes32 m6;
 11104 |     |         /// @solidity memory-safe-assembly
 11105 |     |         assembly {
 11106 |     |             function writeString(pos, w) {
 11107 |     |                 let length := 0
 11108 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11109 |     |                 mstore(pos, length)
 11110 |     |                 let shift := sub(256, shl(3, length))
 11111 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11112 |     |             }
 11113 |     |             m0 := mload(0x00)
 11114 |     |             m1 := mload(0x20)
 11115 |     |             m2 := mload(0x40)
 11116 |     |             m3 := mload(0x60)
 11117 |     |             m4 := mload(0x80)
 11118 |     |             m5 := mload(0xa0)
 11119 |     |             m6 := mload(0xc0)
 11120 |     |             // Selector of `log(string,address,uint256,address)`.
 11121 |     |             mstore(0x00, 0x63fb8bc5)
 11122 |     |             mstore(0x20, 0x80)
 11123 |     |             mstore(0x40, p1)
 11124 |     |             mstore(0x60, p2)
 11125 |     |             mstore(0x80, p3)
 11126 |     |             writeString(0xa0, p0)
 11127 |     |         }
 11128 |     |         _sendLogPayload(0x1c, 0xc4);
 11129 |     |         /// @solidity memory-safe-assembly
 11130 |     |         assembly {
 11131 |     |             mstore(0x00, m0)
 11132 |     |             mstore(0x20, m1)
 11133 |     |             mstore(0x40, m2)
 11134 |     |             mstore(0x60, m3)
 11135 |     |             mstore(0x80, m4)
 11136 |     |             mstore(0xa0, m5)
 11137 |     |             mstore(0xc0, m6)
 11138 |     |         }
 11139 |     |     }
 11140 |     | 
 11141 |     |     function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {
 11142 |     |         bytes32 m0;
 11143 |     |         bytes32 m1;
 11144 |     |         bytes32 m2;
 11145 |     |         bytes32 m3;
 11146 |     |         bytes32 m4;
 11147 |     |         bytes32 m5;
 11148 |     |         bytes32 m6;
 11149 |     |         /// @solidity memory-safe-assembly
 11150 |     |         assembly {
 11151 |     |             function writeString(pos, w) {
 11152 |     |                 let length := 0
 11153 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11154 |     |                 mstore(pos, length)
 11155 |     |                 let shift := sub(256, shl(3, length))
 11156 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11157 |     |             }
 11158 |     |             m0 := mload(0x00)
 11159 |     |             m1 := mload(0x20)
 11160 |     |             m2 := mload(0x40)
 11161 |     |             m3 := mload(0x60)
 11162 |     |             m4 := mload(0x80)
 11163 |     |             m5 := mload(0xa0)
 11164 |     |             m6 := mload(0xc0)
 11165 |     |             // Selector of `log(string,address,uint256,bool)`.
 11166 |     |             mstore(0x00, 0xfc4845f0)
 11167 |     |             mstore(0x20, 0x80)
 11168 |     |             mstore(0x40, p1)
 11169 |     |             mstore(0x60, p2)
 11170 |     |             mstore(0x80, p3)
 11171 |     |             writeString(0xa0, p0)
 11172 |     |         }
 11173 |     |         _sendLogPayload(0x1c, 0xc4);
 11174 |     |         /// @solidity memory-safe-assembly
 11175 |     |         assembly {
 11176 |     |             mstore(0x00, m0)
 11177 |     |             mstore(0x20, m1)
 11178 |     |             mstore(0x40, m2)
 11179 |     |             mstore(0x60, m3)
 11180 |     |             mstore(0x80, m4)
 11181 |     |             mstore(0xa0, m5)
 11182 |     |             mstore(0xc0, m6)
 11183 |     |         }
 11184 |     |     }
 11185 |     | 
 11186 |     |     function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {
 11187 |     |         bytes32 m0;
 11188 |     |         bytes32 m1;
 11189 |     |         bytes32 m2;
 11190 |     |         bytes32 m3;
 11191 |     |         bytes32 m4;
 11192 |     |         bytes32 m5;
 11193 |     |         bytes32 m6;
 11194 |     |         /// @solidity memory-safe-assembly
 11195 |     |         assembly {
 11196 |     |             function writeString(pos, w) {
 11197 |     |                 let length := 0
 11198 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11199 |     |                 mstore(pos, length)
 11200 |     |                 let shift := sub(256, shl(3, length))
 11201 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11202 |     |             }
 11203 |     |             m0 := mload(0x00)
 11204 |     |             m1 := mload(0x20)
 11205 |     |             m2 := mload(0x40)
 11206 |     |             m3 := mload(0x60)
 11207 |     |             m4 := mload(0x80)
 11208 |     |             m5 := mload(0xa0)
 11209 |     |             m6 := mload(0xc0)
 11210 |     |             // Selector of `log(string,address,uint256,uint256)`.
 11211 |     |             mstore(0x00, 0xf8f51b1e)
 11212 |     |             mstore(0x20, 0x80)
 11213 |     |             mstore(0x40, p1)
 11214 |     |             mstore(0x60, p2)
 11215 |     |             mstore(0x80, p3)
 11216 |     |             writeString(0xa0, p0)
 11217 |     |         }
 11218 |     |         _sendLogPayload(0x1c, 0xc4);
 11219 |     |         /// @solidity memory-safe-assembly
 11220 |     |         assembly {
 11221 |     |             mstore(0x00, m0)
 11222 |     |             mstore(0x20, m1)
 11223 |     |             mstore(0x40, m2)
 11224 |     |             mstore(0x60, m3)
 11225 |     |             mstore(0x80, m4)
 11226 |     |             mstore(0xa0, m5)
 11227 |     |             mstore(0xc0, m6)
 11228 |     |         }
 11229 |     |     }
 11230 |     | 
 11231 |     |     function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {
 11232 |     |         bytes32 m0;
 11233 |     |         bytes32 m1;
 11234 |     |         bytes32 m2;
 11235 |     |         bytes32 m3;
 11236 |     |         bytes32 m4;
 11237 |     |         bytes32 m5;
 11238 |     |         bytes32 m6;
 11239 |     |         bytes32 m7;
 11240 |     |         bytes32 m8;
 11241 |     |         /// @solidity memory-safe-assembly
 11242 |     |         assembly {
 11243 |     |             function writeString(pos, w) {
 11244 |     |                 let length := 0
 11245 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11246 |     |                 mstore(pos, length)
 11247 |     |                 let shift := sub(256, shl(3, length))
 11248 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11249 |     |             }
 11250 |     |             m0 := mload(0x00)
 11251 |     |             m1 := mload(0x20)
 11252 |     |             m2 := mload(0x40)
 11253 |     |             m3 := mload(0x60)
 11254 |     |             m4 := mload(0x80)
 11255 |     |             m5 := mload(0xa0)
 11256 |     |             m6 := mload(0xc0)
 11257 |     |             m7 := mload(0xe0)
 11258 |     |             m8 := mload(0x100)
 11259 |     |             // Selector of `log(string,address,uint256,string)`.
 11260 |     |             mstore(0x00, 0x5a477632)
 11261 |     |             mstore(0x20, 0x80)
 11262 |     |             mstore(0x40, p1)
 11263 |     |             mstore(0x60, p2)
 11264 |     |             mstore(0x80, 0xc0)
 11265 |     |             writeString(0xa0, p0)
 11266 |     |             writeString(0xe0, p3)
 11267 |     |         }
 11268 |     |         _sendLogPayload(0x1c, 0x104);
 11269 |     |         /// @solidity memory-safe-assembly
 11270 |     |         assembly {
 11271 |     |             mstore(0x00, m0)
 11272 |     |             mstore(0x20, m1)
 11273 |     |             mstore(0x40, m2)
 11274 |     |             mstore(0x60, m3)
 11275 |     |             mstore(0x80, m4)
 11276 |     |             mstore(0xa0, m5)
 11277 |     |             mstore(0xc0, m6)
 11278 |     |             mstore(0xe0, m7)
 11279 |     |             mstore(0x100, m8)
 11280 |     |         }
 11281 |     |     }
 11282 |     | 
 11283 |     |     function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {
 11284 |     |         bytes32 m0;
 11285 |     |         bytes32 m1;
 11286 |     |         bytes32 m2;
 11287 |     |         bytes32 m3;
 11288 |     |         bytes32 m4;
 11289 |     |         bytes32 m5;
 11290 |     |         bytes32 m6;
 11291 |     |         bytes32 m7;
 11292 |     |         bytes32 m8;
 11293 |     |         /// @solidity memory-safe-assembly
 11294 |     |         assembly {
 11295 |     |             function writeString(pos, w) {
 11296 |     |                 let length := 0
 11297 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11298 |     |                 mstore(pos, length)
 11299 |     |                 let shift := sub(256, shl(3, length))
 11300 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11301 |     |             }
 11302 |     |             m0 := mload(0x00)
 11303 |     |             m1 := mload(0x20)
 11304 |     |             m2 := mload(0x40)
 11305 |     |             m3 := mload(0x60)
 11306 |     |             m4 := mload(0x80)
 11307 |     |             m5 := mload(0xa0)
 11308 |     |             m6 := mload(0xc0)
 11309 |     |             m7 := mload(0xe0)
 11310 |     |             m8 := mload(0x100)
 11311 |     |             // Selector of `log(string,address,string,address)`.
 11312 |     |             mstore(0x00, 0xaabc9a31)
 11313 |     |             mstore(0x20, 0x80)
 11314 |     |             mstore(0x40, p1)
 11315 |     |             mstore(0x60, 0xc0)
 11316 |     |             mstore(0x80, p3)
 11317 |     |             writeString(0xa0, p0)
 11318 |     |             writeString(0xe0, p2)
 11319 |     |         }
 11320 |     |         _sendLogPayload(0x1c, 0x104);
 11321 |     |         /// @solidity memory-safe-assembly
 11322 |     |         assembly {
 11323 |     |             mstore(0x00, m0)
 11324 |     |             mstore(0x20, m1)
 11325 |     |             mstore(0x40, m2)
 11326 |     |             mstore(0x60, m3)
 11327 |     |             mstore(0x80, m4)
 11328 |     |             mstore(0xa0, m5)
 11329 |     |             mstore(0xc0, m6)
 11330 |     |             mstore(0xe0, m7)
 11331 |     |             mstore(0x100, m8)
 11332 |     |         }
 11333 |     |     }
 11334 |     | 
 11335 |     |     function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {
 11336 |     |         bytes32 m0;
 11337 |     |         bytes32 m1;
 11338 |     |         bytes32 m2;
 11339 |     |         bytes32 m3;
 11340 |     |         bytes32 m4;
 11341 |     |         bytes32 m5;
 11342 |     |         bytes32 m6;
 11343 |     |         bytes32 m7;
 11344 |     |         bytes32 m8;
 11345 |     |         /// @solidity memory-safe-assembly
 11346 |     |         assembly {
 11347 |     |             function writeString(pos, w) {
 11348 |     |                 let length := 0
 11349 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11350 |     |                 mstore(pos, length)
 11351 |     |                 let shift := sub(256, shl(3, length))
 11352 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11353 |     |             }
 11354 |     |             m0 := mload(0x00)
 11355 |     |             m1 := mload(0x20)
 11356 |     |             m2 := mload(0x40)
 11357 |     |             m3 := mload(0x60)
 11358 |     |             m4 := mload(0x80)
 11359 |     |             m5 := mload(0xa0)
 11360 |     |             m6 := mload(0xc0)
 11361 |     |             m7 := mload(0xe0)
 11362 |     |             m8 := mload(0x100)
 11363 |     |             // Selector of `log(string,address,string,bool)`.
 11364 |     |             mstore(0x00, 0x5f15d28c)
 11365 |     |             mstore(0x20, 0x80)
 11366 |     |             mstore(0x40, p1)
 11367 |     |             mstore(0x60, 0xc0)
 11368 |     |             mstore(0x80, p3)
 11369 |     |             writeString(0xa0, p0)
 11370 |     |             writeString(0xe0, p2)
 11371 |     |         }
 11372 |     |         _sendLogPayload(0x1c, 0x104);
 11373 |     |         /// @solidity memory-safe-assembly
 11374 |     |         assembly {
 11375 |     |             mstore(0x00, m0)
 11376 |     |             mstore(0x20, m1)
 11377 |     |             mstore(0x40, m2)
 11378 |     |             mstore(0x60, m3)
 11379 |     |             mstore(0x80, m4)
 11380 |     |             mstore(0xa0, m5)
 11381 |     |             mstore(0xc0, m6)
 11382 |     |             mstore(0xe0, m7)
 11383 |     |             mstore(0x100, m8)
 11384 |     |         }
 11385 |     |     }
 11386 |     | 
 11387 |     |     function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {
 11388 |     |         bytes32 m0;
 11389 |     |         bytes32 m1;
 11390 |     |         bytes32 m2;
 11391 |     |         bytes32 m3;
 11392 |     |         bytes32 m4;
 11393 |     |         bytes32 m5;
 11394 |     |         bytes32 m6;
 11395 |     |         bytes32 m7;
 11396 |     |         bytes32 m8;
 11397 |     |         /// @solidity memory-safe-assembly
 11398 |     |         assembly {
 11399 |     |             function writeString(pos, w) {
 11400 |     |                 let length := 0
 11401 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11402 |     |                 mstore(pos, length)
 11403 |     |                 let shift := sub(256, shl(3, length))
 11404 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11405 |     |             }
 11406 |     |             m0 := mload(0x00)
 11407 |     |             m1 := mload(0x20)
 11408 |     |             m2 := mload(0x40)
 11409 |     |             m3 := mload(0x60)
 11410 |     |             m4 := mload(0x80)
 11411 |     |             m5 := mload(0xa0)
 11412 |     |             m6 := mload(0xc0)
 11413 |     |             m7 := mload(0xe0)
 11414 |     |             m8 := mload(0x100)
 11415 |     |             // Selector of `log(string,address,string,uint256)`.
 11416 |     |             mstore(0x00, 0x91d1112e)
 11417 |     |             mstore(0x20, 0x80)
 11418 |     |             mstore(0x40, p1)
 11419 |     |             mstore(0x60, 0xc0)
 11420 |     |             mstore(0x80, p3)
 11421 |     |             writeString(0xa0, p0)
 11422 |     |             writeString(0xe0, p2)
 11423 |     |         }
 11424 |     |         _sendLogPayload(0x1c, 0x104);
 11425 |     |         /// @solidity memory-safe-assembly
 11426 |     |         assembly {
 11427 |     |             mstore(0x00, m0)
 11428 |     |             mstore(0x20, m1)
 11429 |     |             mstore(0x40, m2)
 11430 |     |             mstore(0x60, m3)
 11431 |     |             mstore(0x80, m4)
 11432 |     |             mstore(0xa0, m5)
 11433 |     |             mstore(0xc0, m6)
 11434 |     |             mstore(0xe0, m7)
 11435 |     |             mstore(0x100, m8)
 11436 |     |         }
 11437 |     |     }
 11438 |     | 
 11439 |     |     function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {
 11440 |     |         bytes32 m0;
 11441 |     |         bytes32 m1;
 11442 |     |         bytes32 m2;
 11443 |     |         bytes32 m3;
 11444 |     |         bytes32 m4;
 11445 |     |         bytes32 m5;
 11446 |     |         bytes32 m6;
 11447 |     |         bytes32 m7;
 11448 |     |         bytes32 m8;
 11449 |     |         bytes32 m9;
 11450 |     |         bytes32 m10;
 11451 |     |         /// @solidity memory-safe-assembly
 11452 |     |         assembly {
 11453 |     |             function writeString(pos, w) {
 11454 |     |                 let length := 0
 11455 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11456 |     |                 mstore(pos, length)
 11457 |     |                 let shift := sub(256, shl(3, length))
 11458 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11459 |     |             }
 11460 |     |             m0 := mload(0x00)
 11461 |     |             m1 := mload(0x20)
 11462 |     |             m2 := mload(0x40)
 11463 |     |             m3 := mload(0x60)
 11464 |     |             m4 := mload(0x80)
 11465 |     |             m5 := mload(0xa0)
 11466 |     |             m6 := mload(0xc0)
 11467 |     |             m7 := mload(0xe0)
 11468 |     |             m8 := mload(0x100)
 11469 |     |             m9 := mload(0x120)
 11470 |     |             m10 := mload(0x140)
 11471 |     |             // Selector of `log(string,address,string,string)`.
 11472 |     |             mstore(0x00, 0x245986f2)
 11473 |     |             mstore(0x20, 0x80)
 11474 |     |             mstore(0x40, p1)
 11475 |     |             mstore(0x60, 0xc0)
 11476 |     |             mstore(0x80, 0x100)
 11477 |     |             writeString(0xa0, p0)
 11478 |     |             writeString(0xe0, p2)
 11479 |     |             writeString(0x120, p3)
 11480 |     |         }
 11481 |     |         _sendLogPayload(0x1c, 0x144);
 11482 |     |         /// @solidity memory-safe-assembly
 11483 |     |         assembly {
 11484 |     |             mstore(0x00, m0)
 11485 |     |             mstore(0x20, m1)
 11486 |     |             mstore(0x40, m2)
 11487 |     |             mstore(0x60, m3)
 11488 |     |             mstore(0x80, m4)
 11489 |     |             mstore(0xa0, m5)
 11490 |     |             mstore(0xc0, m6)
 11491 |     |             mstore(0xe0, m7)
 11492 |     |             mstore(0x100, m8)
 11493 |     |             mstore(0x120, m9)
 11494 |     |             mstore(0x140, m10)
 11495 |     |         }
 11496 |     |     }
 11497 |     | 
 11498 |     |     function log(bytes32 p0, bool p1, address p2, address p3) internal pure {
 11499 |     |         bytes32 m0;
 11500 |     |         bytes32 m1;
 11501 |     |         bytes32 m2;
 11502 |     |         bytes32 m3;
 11503 |     |         bytes32 m4;
 11504 |     |         bytes32 m5;
 11505 |     |         bytes32 m6;
 11506 |     |         /// @solidity memory-safe-assembly
 11507 |     |         assembly {
 11508 |     |             function writeString(pos, w) {
 11509 |     |                 let length := 0
 11510 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11511 |     |                 mstore(pos, length)
 11512 |     |                 let shift := sub(256, shl(3, length))
 11513 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11514 |     |             }
 11515 |     |             m0 := mload(0x00)
 11516 |     |             m1 := mload(0x20)
 11517 |     |             m2 := mload(0x40)
 11518 |     |             m3 := mload(0x60)
 11519 |     |             m4 := mload(0x80)
 11520 |     |             m5 := mload(0xa0)
 11521 |     |             m6 := mload(0xc0)
 11522 |     |             // Selector of `log(string,bool,address,address)`.
 11523 |     |             mstore(0x00, 0x33e9dd1d)
 11524 |     |             mstore(0x20, 0x80)
 11525 |     |             mstore(0x40, p1)
 11526 |     |             mstore(0x60, p2)
 11527 |     |             mstore(0x80, p3)
 11528 |     |             writeString(0xa0, p0)
 11529 |     |         }
 11530 |     |         _sendLogPayload(0x1c, 0xc4);
 11531 |     |         /// @solidity memory-safe-assembly
 11532 |     |         assembly {
 11533 |     |             mstore(0x00, m0)
 11534 |     |             mstore(0x20, m1)
 11535 |     |             mstore(0x40, m2)
 11536 |     |             mstore(0x60, m3)
 11537 |     |             mstore(0x80, m4)
 11538 |     |             mstore(0xa0, m5)
 11539 |     |             mstore(0xc0, m6)
 11540 |     |         }
 11541 |     |     }
 11542 |     | 
 11543 |     |     function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {
 11544 |     |         bytes32 m0;
 11545 |     |         bytes32 m1;
 11546 |     |         bytes32 m2;
 11547 |     |         bytes32 m3;
 11548 |     |         bytes32 m4;
 11549 |     |         bytes32 m5;
 11550 |     |         bytes32 m6;
 11551 |     |         /// @solidity memory-safe-assembly
 11552 |     |         assembly {
 11553 |     |             function writeString(pos, w) {
 11554 |     |                 let length := 0
 11555 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11556 |     |                 mstore(pos, length)
 11557 |     |                 let shift := sub(256, shl(3, length))
 11558 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11559 |     |             }
 11560 |     |             m0 := mload(0x00)
 11561 |     |             m1 := mload(0x20)
 11562 |     |             m2 := mload(0x40)
 11563 |     |             m3 := mload(0x60)
 11564 |     |             m4 := mload(0x80)
 11565 |     |             m5 := mload(0xa0)
 11566 |     |             m6 := mload(0xc0)
 11567 |     |             // Selector of `log(string,bool,address,bool)`.
 11568 |     |             mstore(0x00, 0x958c28c6)
 11569 |     |             mstore(0x20, 0x80)
 11570 |     |             mstore(0x40, p1)
 11571 |     |             mstore(0x60, p2)
 11572 |     |             mstore(0x80, p3)
 11573 |     |             writeString(0xa0, p0)
 11574 |     |         }
 11575 |     |         _sendLogPayload(0x1c, 0xc4);
 11576 |     |         /// @solidity memory-safe-assembly
 11577 |     |         assembly {
 11578 |     |             mstore(0x00, m0)
 11579 |     |             mstore(0x20, m1)
 11580 |     |             mstore(0x40, m2)
 11581 |     |             mstore(0x60, m3)
 11582 |     |             mstore(0x80, m4)
 11583 |     |             mstore(0xa0, m5)
 11584 |     |             mstore(0xc0, m6)
 11585 |     |         }
 11586 |     |     }
 11587 |     | 
 11588 |     |     function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {
 11589 |     |         bytes32 m0;
 11590 |     |         bytes32 m1;
 11591 |     |         bytes32 m2;
 11592 |     |         bytes32 m3;
 11593 |     |         bytes32 m4;
 11594 |     |         bytes32 m5;
 11595 |     |         bytes32 m6;
 11596 |     |         /// @solidity memory-safe-assembly
 11597 |     |         assembly {
 11598 |     |             function writeString(pos, w) {
 11599 |     |                 let length := 0
 11600 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11601 |     |                 mstore(pos, length)
 11602 |     |                 let shift := sub(256, shl(3, length))
 11603 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11604 |     |             }
 11605 |     |             m0 := mload(0x00)
 11606 |     |             m1 := mload(0x20)
 11607 |     |             m2 := mload(0x40)
 11608 |     |             m3 := mload(0x60)
 11609 |     |             m4 := mload(0x80)
 11610 |     |             m5 := mload(0xa0)
 11611 |     |             m6 := mload(0xc0)
 11612 |     |             // Selector of `log(string,bool,address,uint256)`.
 11613 |     |             mstore(0x00, 0x5d08bb05)
 11614 |     |             mstore(0x20, 0x80)
 11615 |     |             mstore(0x40, p1)
 11616 |     |             mstore(0x60, p2)
 11617 |     |             mstore(0x80, p3)
 11618 |     |             writeString(0xa0, p0)
 11619 |     |         }
 11620 |     |         _sendLogPayload(0x1c, 0xc4);
 11621 |     |         /// @solidity memory-safe-assembly
 11622 |     |         assembly {
 11623 |     |             mstore(0x00, m0)
 11624 |     |             mstore(0x20, m1)
 11625 |     |             mstore(0x40, m2)
 11626 |     |             mstore(0x60, m3)
 11627 |     |             mstore(0x80, m4)
 11628 |     |             mstore(0xa0, m5)
 11629 |     |             mstore(0xc0, m6)
 11630 |     |         }
 11631 |     |     }
 11632 |     | 
 11633 |     |     function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {
 11634 |     |         bytes32 m0;
 11635 |     |         bytes32 m1;
 11636 |     |         bytes32 m2;
 11637 |     |         bytes32 m3;
 11638 |     |         bytes32 m4;
 11639 |     |         bytes32 m5;
 11640 |     |         bytes32 m6;
 11641 |     |         bytes32 m7;
 11642 |     |         bytes32 m8;
 11643 |     |         /// @solidity memory-safe-assembly
 11644 |     |         assembly {
 11645 |     |             function writeString(pos, w) {
 11646 |     |                 let length := 0
 11647 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11648 |     |                 mstore(pos, length)
 11649 |     |                 let shift := sub(256, shl(3, length))
 11650 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11651 |     |             }
 11652 |     |             m0 := mload(0x00)
 11653 |     |             m1 := mload(0x20)
 11654 |     |             m2 := mload(0x40)
 11655 |     |             m3 := mload(0x60)
 11656 |     |             m4 := mload(0x80)
 11657 |     |             m5 := mload(0xa0)
 11658 |     |             m6 := mload(0xc0)
 11659 |     |             m7 := mload(0xe0)
 11660 |     |             m8 := mload(0x100)
 11661 |     |             // Selector of `log(string,bool,address,string)`.
 11662 |     |             mstore(0x00, 0x2d8e33a4)
 11663 |     |             mstore(0x20, 0x80)
 11664 |     |             mstore(0x40, p1)
 11665 |     |             mstore(0x60, p2)
 11666 |     |             mstore(0x80, 0xc0)
 11667 |     |             writeString(0xa0, p0)
 11668 |     |             writeString(0xe0, p3)
 11669 |     |         }
 11670 |     |         _sendLogPayload(0x1c, 0x104);
 11671 |     |         /// @solidity memory-safe-assembly
 11672 |     |         assembly {
 11673 |     |             mstore(0x00, m0)
 11674 |     |             mstore(0x20, m1)
 11675 |     |             mstore(0x40, m2)
 11676 |     |             mstore(0x60, m3)
 11677 |     |             mstore(0x80, m4)
 11678 |     |             mstore(0xa0, m5)
 11679 |     |             mstore(0xc0, m6)
 11680 |     |             mstore(0xe0, m7)
 11681 |     |             mstore(0x100, m8)
 11682 |     |         }
 11683 |     |     }
 11684 |     | 
 11685 |     |     function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {
 11686 |     |         bytes32 m0;
 11687 |     |         bytes32 m1;
 11688 |     |         bytes32 m2;
 11689 |     |         bytes32 m3;
 11690 |     |         bytes32 m4;
 11691 |     |         bytes32 m5;
 11692 |     |         bytes32 m6;
 11693 |     |         /// @solidity memory-safe-assembly
 11694 |     |         assembly {
 11695 |     |             function writeString(pos, w) {
 11696 |     |                 let length := 0
 11697 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11698 |     |                 mstore(pos, length)
 11699 |     |                 let shift := sub(256, shl(3, length))
 11700 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11701 |     |             }
 11702 |     |             m0 := mload(0x00)
 11703 |     |             m1 := mload(0x20)
 11704 |     |             m2 := mload(0x40)
 11705 |     |             m3 := mload(0x60)
 11706 |     |             m4 := mload(0x80)
 11707 |     |             m5 := mload(0xa0)
 11708 |     |             m6 := mload(0xc0)
 11709 |     |             // Selector of `log(string,bool,bool,address)`.
 11710 |     |             mstore(0x00, 0x7190a529)
 11711 |     |             mstore(0x20, 0x80)
 11712 |     |             mstore(0x40, p1)
 11713 |     |             mstore(0x60, p2)
 11714 |     |             mstore(0x80, p3)
 11715 |     |             writeString(0xa0, p0)
 11716 |     |         }
 11717 |     |         _sendLogPayload(0x1c, 0xc4);
 11718 |     |         /// @solidity memory-safe-assembly
 11719 |     |         assembly {
 11720 |     |             mstore(0x00, m0)
 11721 |     |             mstore(0x20, m1)
 11722 |     |             mstore(0x40, m2)
 11723 |     |             mstore(0x60, m3)
 11724 |     |             mstore(0x80, m4)
 11725 |     |             mstore(0xa0, m5)
 11726 |     |             mstore(0xc0, m6)
 11727 |     |         }
 11728 |     |     }
 11729 |     | 
 11730 |     |     function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {
 11731 |     |         bytes32 m0;
 11732 |     |         bytes32 m1;
 11733 |     |         bytes32 m2;
 11734 |     |         bytes32 m3;
 11735 |     |         bytes32 m4;
 11736 |     |         bytes32 m5;
 11737 |     |         bytes32 m6;
 11738 |     |         /// @solidity memory-safe-assembly
 11739 |     |         assembly {
 11740 |     |             function writeString(pos, w) {
 11741 |     |                 let length := 0
 11742 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11743 |     |                 mstore(pos, length)
 11744 |     |                 let shift := sub(256, shl(3, length))
 11745 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11746 |     |             }
 11747 |     |             m0 := mload(0x00)
 11748 |     |             m1 := mload(0x20)
 11749 |     |             m2 := mload(0x40)
 11750 |     |             m3 := mload(0x60)
 11751 |     |             m4 := mload(0x80)
 11752 |     |             m5 := mload(0xa0)
 11753 |     |             m6 := mload(0xc0)
 11754 |     |             // Selector of `log(string,bool,bool,bool)`.
 11755 |     |             mstore(0x00, 0x895af8c5)
 11756 |     |             mstore(0x20, 0x80)
 11757 |     |             mstore(0x40, p1)
 11758 |     |             mstore(0x60, p2)
 11759 |     |             mstore(0x80, p3)
 11760 |     |             writeString(0xa0, p0)
 11761 |     |         }
 11762 |     |         _sendLogPayload(0x1c, 0xc4);
 11763 |     |         /// @solidity memory-safe-assembly
 11764 |     |         assembly {
 11765 |     |             mstore(0x00, m0)
 11766 |     |             mstore(0x20, m1)
 11767 |     |             mstore(0x40, m2)
 11768 |     |             mstore(0x60, m3)
 11769 |     |             mstore(0x80, m4)
 11770 |     |             mstore(0xa0, m5)
 11771 |     |             mstore(0xc0, m6)
 11772 |     |         }
 11773 |     |     }
 11774 |     | 
 11775 |     |     function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {
 11776 |     |         bytes32 m0;
 11777 |     |         bytes32 m1;
 11778 |     |         bytes32 m2;
 11779 |     |         bytes32 m3;
 11780 |     |         bytes32 m4;
 11781 |     |         bytes32 m5;
 11782 |     |         bytes32 m6;
 11783 |     |         /// @solidity memory-safe-assembly
 11784 |     |         assembly {
 11785 |     |             function writeString(pos, w) {
 11786 |     |                 let length := 0
 11787 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11788 |     |                 mstore(pos, length)
 11789 |     |                 let shift := sub(256, shl(3, length))
 11790 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11791 |     |             }
 11792 |     |             m0 := mload(0x00)
 11793 |     |             m1 := mload(0x20)
 11794 |     |             m2 := mload(0x40)
 11795 |     |             m3 := mload(0x60)
 11796 |     |             m4 := mload(0x80)
 11797 |     |             m5 := mload(0xa0)
 11798 |     |             m6 := mload(0xc0)
 11799 |     |             // Selector of `log(string,bool,bool,uint256)`.
 11800 |     |             mstore(0x00, 0x8e3f78a9)
 11801 |     |             mstore(0x20, 0x80)
 11802 |     |             mstore(0x40, p1)
 11803 |     |             mstore(0x60, p2)
 11804 |     |             mstore(0x80, p3)
 11805 |     |             writeString(0xa0, p0)
 11806 |     |         }
 11807 |     |         _sendLogPayload(0x1c, 0xc4);
 11808 |     |         /// @solidity memory-safe-assembly
 11809 |     |         assembly {
 11810 |     |             mstore(0x00, m0)
 11811 |     |             mstore(0x20, m1)
 11812 |     |             mstore(0x40, m2)
 11813 |     |             mstore(0x60, m3)
 11814 |     |             mstore(0x80, m4)
 11815 |     |             mstore(0xa0, m5)
 11816 |     |             mstore(0xc0, m6)
 11817 |     |         }
 11818 |     |     }
 11819 |     | 
 11820 |     |     function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {
 11821 |     |         bytes32 m0;
 11822 |     |         bytes32 m1;
 11823 |     |         bytes32 m2;
 11824 |     |         bytes32 m3;
 11825 |     |         bytes32 m4;
 11826 |     |         bytes32 m5;
 11827 |     |         bytes32 m6;
 11828 |     |         bytes32 m7;
 11829 |     |         bytes32 m8;
 11830 |     |         /// @solidity memory-safe-assembly
 11831 |     |         assembly {
 11832 |     |             function writeString(pos, w) {
 11833 |     |                 let length := 0
 11834 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11835 |     |                 mstore(pos, length)
 11836 |     |                 let shift := sub(256, shl(3, length))
 11837 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11838 |     |             }
 11839 |     |             m0 := mload(0x00)
 11840 |     |             m1 := mload(0x20)
 11841 |     |             m2 := mload(0x40)
 11842 |     |             m3 := mload(0x60)
 11843 |     |             m4 := mload(0x80)
 11844 |     |             m5 := mload(0xa0)
 11845 |     |             m6 := mload(0xc0)
 11846 |     |             m7 := mload(0xe0)
 11847 |     |             m8 := mload(0x100)
 11848 |     |             // Selector of `log(string,bool,bool,string)`.
 11849 |     |             mstore(0x00, 0x9d22d5dd)
 11850 |     |             mstore(0x20, 0x80)
 11851 |     |             mstore(0x40, p1)
 11852 |     |             mstore(0x60, p2)
 11853 |     |             mstore(0x80, 0xc0)
 11854 |     |             writeString(0xa0, p0)
 11855 |     |             writeString(0xe0, p3)
 11856 |     |         }
 11857 |     |         _sendLogPayload(0x1c, 0x104);
 11858 |     |         /// @solidity memory-safe-assembly
 11859 |     |         assembly {
 11860 |     |             mstore(0x00, m0)
 11861 |     |             mstore(0x20, m1)
 11862 |     |             mstore(0x40, m2)
 11863 |     |             mstore(0x60, m3)
 11864 |     |             mstore(0x80, m4)
 11865 |     |             mstore(0xa0, m5)
 11866 |     |             mstore(0xc0, m6)
 11867 |     |             mstore(0xe0, m7)
 11868 |     |             mstore(0x100, m8)
 11869 |     |         }
 11870 |     |     }
 11871 |     | 
 11872 |     |     function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {
 11873 |     |         bytes32 m0;
 11874 |     |         bytes32 m1;
 11875 |     |         bytes32 m2;
 11876 |     |         bytes32 m3;
 11877 |     |         bytes32 m4;
 11878 |     |         bytes32 m5;
 11879 |     |         bytes32 m6;
 11880 |     |         /// @solidity memory-safe-assembly
 11881 |     |         assembly {
 11882 |     |             function writeString(pos, w) {
 11883 |     |                 let length := 0
 11884 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11885 |     |                 mstore(pos, length)
 11886 |     |                 let shift := sub(256, shl(3, length))
 11887 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11888 |     |             }
 11889 |     |             m0 := mload(0x00)
 11890 |     |             m1 := mload(0x20)
 11891 |     |             m2 := mload(0x40)
 11892 |     |             m3 := mload(0x60)
 11893 |     |             m4 := mload(0x80)
 11894 |     |             m5 := mload(0xa0)
 11895 |     |             m6 := mload(0xc0)
 11896 |     |             // Selector of `log(string,bool,uint256,address)`.
 11897 |     |             mstore(0x00, 0x935e09bf)
 11898 |     |             mstore(0x20, 0x80)
 11899 |     |             mstore(0x40, p1)
 11900 |     |             mstore(0x60, p2)
 11901 |     |             mstore(0x80, p3)
 11902 |     |             writeString(0xa0, p0)
 11903 |     |         }
 11904 |     |         _sendLogPayload(0x1c, 0xc4);
 11905 |     |         /// @solidity memory-safe-assembly
 11906 |     |         assembly {
 11907 |     |             mstore(0x00, m0)
 11908 |     |             mstore(0x20, m1)
 11909 |     |             mstore(0x40, m2)
 11910 |     |             mstore(0x60, m3)
 11911 |     |             mstore(0x80, m4)
 11912 |     |             mstore(0xa0, m5)
 11913 |     |             mstore(0xc0, m6)
 11914 |     |         }
 11915 |     |     }
 11916 |     | 
 11917 |     |     function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {
 11918 |     |         bytes32 m0;
 11919 |     |         bytes32 m1;
 11920 |     |         bytes32 m2;
 11921 |     |         bytes32 m3;
 11922 |     |         bytes32 m4;
 11923 |     |         bytes32 m5;
 11924 |     |         bytes32 m6;
 11925 |     |         /// @solidity memory-safe-assembly
 11926 |     |         assembly {
 11927 |     |             function writeString(pos, w) {
 11928 |     |                 let length := 0
 11929 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11930 |     |                 mstore(pos, length)
 11931 |     |                 let shift := sub(256, shl(3, length))
 11932 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11933 |     |             }
 11934 |     |             m0 := mload(0x00)
 11935 |     |             m1 := mload(0x20)
 11936 |     |             m2 := mload(0x40)
 11937 |     |             m3 := mload(0x60)
 11938 |     |             m4 := mload(0x80)
 11939 |     |             m5 := mload(0xa0)
 11940 |     |             m6 := mload(0xc0)
 11941 |     |             // Selector of `log(string,bool,uint256,bool)`.
 11942 |     |             mstore(0x00, 0x8af7cf8a)
 11943 |     |             mstore(0x20, 0x80)
 11944 |     |             mstore(0x40, p1)
 11945 |     |             mstore(0x60, p2)
 11946 |     |             mstore(0x80, p3)
 11947 |     |             writeString(0xa0, p0)
 11948 |     |         }
 11949 |     |         _sendLogPayload(0x1c, 0xc4);
 11950 |     |         /// @solidity memory-safe-assembly
 11951 |     |         assembly {
 11952 |     |             mstore(0x00, m0)
 11953 |     |             mstore(0x20, m1)
 11954 |     |             mstore(0x40, m2)
 11955 |     |             mstore(0x60, m3)
 11956 |     |             mstore(0x80, m4)
 11957 |     |             mstore(0xa0, m5)
 11958 |     |             mstore(0xc0, m6)
 11959 |     |         }
 11960 |     |     }
 11961 |     | 
 11962 |     |     function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {
 11963 |     |         bytes32 m0;
 11964 |     |         bytes32 m1;
 11965 |     |         bytes32 m2;
 11966 |     |         bytes32 m3;
 11967 |     |         bytes32 m4;
 11968 |     |         bytes32 m5;
 11969 |     |         bytes32 m6;
 11970 |     |         /// @solidity memory-safe-assembly
 11971 |     |         assembly {
 11972 |     |             function writeString(pos, w) {
 11973 |     |                 let length := 0
 11974 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11975 |     |                 mstore(pos, length)
 11976 |     |                 let shift := sub(256, shl(3, length))
 11977 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11978 |     |             }
 11979 |     |             m0 := mload(0x00)
 11980 |     |             m1 := mload(0x20)
 11981 |     |             m2 := mload(0x40)
 11982 |     |             m3 := mload(0x60)
 11983 |     |             m4 := mload(0x80)
 11984 |     |             m5 := mload(0xa0)
 11985 |     |             m6 := mload(0xc0)
 11986 |     |             // Selector of `log(string,bool,uint256,uint256)`.
 11987 |     |             mstore(0x00, 0x64b5bb67)
 11988 |     |             mstore(0x20, 0x80)
 11989 |     |             mstore(0x40, p1)
 11990 |     |             mstore(0x60, p2)
 11991 |     |             mstore(0x80, p3)
 11992 |     |             writeString(0xa0, p0)
 11993 |     |         }
 11994 |     |         _sendLogPayload(0x1c, 0xc4);
 11995 |     |         /// @solidity memory-safe-assembly
 11996 |     |         assembly {
 11997 |     |             mstore(0x00, m0)
 11998 |     |             mstore(0x20, m1)
 11999 |     |             mstore(0x40, m2)
 12000 |     |             mstore(0x60, m3)
 12001 |     |             mstore(0x80, m4)
 12002 |     |             mstore(0xa0, m5)
 12003 |     |             mstore(0xc0, m6)
 12004 |     |         }
 12005 |     |     }
 12006 |     | 
 12007 |     |     function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {
 12008 |     |         bytes32 m0;
 12009 |     |         bytes32 m1;
 12010 |     |         bytes32 m2;
 12011 |     |         bytes32 m3;
 12012 |     |         bytes32 m4;
 12013 |     |         bytes32 m5;
 12014 |     |         bytes32 m6;
 12015 |     |         bytes32 m7;
 12016 |     |         bytes32 m8;
 12017 |     |         /// @solidity memory-safe-assembly
 12018 |     |         assembly {
 12019 |     |             function writeString(pos, w) {
 12020 |     |                 let length := 0
 12021 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12022 |     |                 mstore(pos, length)
 12023 |     |                 let shift := sub(256, shl(3, length))
 12024 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12025 |     |             }
 12026 |     |             m0 := mload(0x00)
 12027 |     |             m1 := mload(0x20)
 12028 |     |             m2 := mload(0x40)
 12029 |     |             m3 := mload(0x60)
 12030 |     |             m4 := mload(0x80)
 12031 |     |             m5 := mload(0xa0)
 12032 |     |             m6 := mload(0xc0)
 12033 |     |             m7 := mload(0xe0)
 12034 |     |             m8 := mload(0x100)
 12035 |     |             // Selector of `log(string,bool,uint256,string)`.
 12036 |     |             mstore(0x00, 0x742d6ee7)
 12037 |     |             mstore(0x20, 0x80)
 12038 |     |             mstore(0x40, p1)
 12039 |     |             mstore(0x60, p2)
 12040 |     |             mstore(0x80, 0xc0)
 12041 |     |             writeString(0xa0, p0)
 12042 |     |             writeString(0xe0, p3)
 12043 |     |         }
 12044 |     |         _sendLogPayload(0x1c, 0x104);
 12045 |     |         /// @solidity memory-safe-assembly
 12046 |     |         assembly {
 12047 |     |             mstore(0x00, m0)
 12048 |     |             mstore(0x20, m1)
 12049 |     |             mstore(0x40, m2)
 12050 |     |             mstore(0x60, m3)
 12051 |     |             mstore(0x80, m4)
 12052 |     |             mstore(0xa0, m5)
 12053 |     |             mstore(0xc0, m6)
 12054 |     |             mstore(0xe0, m7)
 12055 |     |             mstore(0x100, m8)
 12056 |     |         }
 12057 |     |     }
 12058 |     | 
 12059 |     |     function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {
 12060 |     |         bytes32 m0;
 12061 |     |         bytes32 m1;
 12062 |     |         bytes32 m2;
 12063 |     |         bytes32 m3;
 12064 |     |         bytes32 m4;
 12065 |     |         bytes32 m5;
 12066 |     |         bytes32 m6;
 12067 |     |         bytes32 m7;
 12068 |     |         bytes32 m8;
 12069 |     |         /// @solidity memory-safe-assembly
 12070 |     |         assembly {
 12071 |     |             function writeString(pos, w) {
 12072 |     |                 let length := 0
 12073 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12074 |     |                 mstore(pos, length)
 12075 |     |                 let shift := sub(256, shl(3, length))
 12076 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12077 |     |             }
 12078 |     |             m0 := mload(0x00)
 12079 |     |             m1 := mload(0x20)
 12080 |     |             m2 := mload(0x40)
 12081 |     |             m3 := mload(0x60)
 12082 |     |             m4 := mload(0x80)
 12083 |     |             m5 := mload(0xa0)
 12084 |     |             m6 := mload(0xc0)
 12085 |     |             m7 := mload(0xe0)
 12086 |     |             m8 := mload(0x100)
 12087 |     |             // Selector of `log(string,bool,string,address)`.
 12088 |     |             mstore(0x00, 0xe0625b29)
 12089 |     |             mstore(0x20, 0x80)
 12090 |     |             mstore(0x40, p1)
 12091 |     |             mstore(0x60, 0xc0)
 12092 |     |             mstore(0x80, p3)
 12093 |     |             writeString(0xa0, p0)
 12094 |     |             writeString(0xe0, p2)
 12095 |     |         }
 12096 |     |         _sendLogPayload(0x1c, 0x104);
 12097 |     |         /// @solidity memory-safe-assembly
 12098 |     |         assembly {
 12099 |     |             mstore(0x00, m0)
 12100 |     |             mstore(0x20, m1)
 12101 |     |             mstore(0x40, m2)
 12102 |     |             mstore(0x60, m3)
 12103 |     |             mstore(0x80, m4)
 12104 |     |             mstore(0xa0, m5)
 12105 |     |             mstore(0xc0, m6)
 12106 |     |             mstore(0xe0, m7)
 12107 |     |             mstore(0x100, m8)
 12108 |     |         }
 12109 |     |     }
 12110 |     | 
 12111 |     |     function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {
 12112 |     |         bytes32 m0;
 12113 |     |         bytes32 m1;
 12114 |     |         bytes32 m2;
 12115 |     |         bytes32 m3;
 12116 |     |         bytes32 m4;
 12117 |     |         bytes32 m5;
 12118 |     |         bytes32 m6;
 12119 |     |         bytes32 m7;
 12120 |     |         bytes32 m8;
 12121 |     |         /// @solidity memory-safe-assembly
 12122 |     |         assembly {
 12123 |     |             function writeString(pos, w) {
 12124 |     |                 let length := 0
 12125 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12126 |     |                 mstore(pos, length)
 12127 |     |                 let shift := sub(256, shl(3, length))
 12128 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12129 |     |             }
 12130 |     |             m0 := mload(0x00)
 12131 |     |             m1 := mload(0x20)
 12132 |     |             m2 := mload(0x40)
 12133 |     |             m3 := mload(0x60)
 12134 |     |             m4 := mload(0x80)
 12135 |     |             m5 := mload(0xa0)
 12136 |     |             m6 := mload(0xc0)
 12137 |     |             m7 := mload(0xe0)
 12138 |     |             m8 := mload(0x100)
 12139 |     |             // Selector of `log(string,bool,string,bool)`.
 12140 |     |             mstore(0x00, 0x3f8a701d)
 12141 |     |             mstore(0x20, 0x80)
 12142 |     |             mstore(0x40, p1)
 12143 |     |             mstore(0x60, 0xc0)
 12144 |     |             mstore(0x80, p3)
 12145 |     |             writeString(0xa0, p0)
 12146 |     |             writeString(0xe0, p2)
 12147 |     |         }
 12148 |     |         _sendLogPayload(0x1c, 0x104);
 12149 |     |         /// @solidity memory-safe-assembly
 12150 |     |         assembly {
 12151 |     |             mstore(0x00, m0)
 12152 |     |             mstore(0x20, m1)
 12153 |     |             mstore(0x40, m2)
 12154 |     |             mstore(0x60, m3)
 12155 |     |             mstore(0x80, m4)
 12156 |     |             mstore(0xa0, m5)
 12157 |     |             mstore(0xc0, m6)
 12158 |     |             mstore(0xe0, m7)
 12159 |     |             mstore(0x100, m8)
 12160 |     |         }
 12161 |     |     }
 12162 |     | 
 12163 |     |     function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {
 12164 |     |         bytes32 m0;
 12165 |     |         bytes32 m1;
 12166 |     |         bytes32 m2;
 12167 |     |         bytes32 m3;
 12168 |     |         bytes32 m4;
 12169 |     |         bytes32 m5;
 12170 |     |         bytes32 m6;
 12171 |     |         bytes32 m7;
 12172 |     |         bytes32 m8;
 12173 |     |         /// @solidity memory-safe-assembly
 12174 |     |         assembly {
 12175 |     |             function writeString(pos, w) {
 12176 |     |                 let length := 0
 12177 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12178 |     |                 mstore(pos, length)
 12179 |     |                 let shift := sub(256, shl(3, length))
 12180 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12181 |     |             }
 12182 |     |             m0 := mload(0x00)
 12183 |     |             m1 := mload(0x20)
 12184 |     |             m2 := mload(0x40)
 12185 |     |             m3 := mload(0x60)
 12186 |     |             m4 := mload(0x80)
 12187 |     |             m5 := mload(0xa0)
 12188 |     |             m6 := mload(0xc0)
 12189 |     |             m7 := mload(0xe0)
 12190 |     |             m8 := mload(0x100)
 12191 |     |             // Selector of `log(string,bool,string,uint256)`.
 12192 |     |             mstore(0x00, 0x24f91465)
 12193 |     |             mstore(0x20, 0x80)
 12194 |     |             mstore(0x40, p1)
 12195 |     |             mstore(0x60, 0xc0)
 12196 |     |             mstore(0x80, p3)
 12197 |     |             writeString(0xa0, p0)
 12198 |     |             writeString(0xe0, p2)
 12199 |     |         }
 12200 |     |         _sendLogPayload(0x1c, 0x104);
 12201 |     |         /// @solidity memory-safe-assembly
 12202 |     |         assembly {
 12203 |     |             mstore(0x00, m0)
 12204 |     |             mstore(0x20, m1)
 12205 |     |             mstore(0x40, m2)
 12206 |     |             mstore(0x60, m3)
 12207 |     |             mstore(0x80, m4)
 12208 |     |             mstore(0xa0, m5)
 12209 |     |             mstore(0xc0, m6)
 12210 |     |             mstore(0xe0, m7)
 12211 |     |             mstore(0x100, m8)
 12212 |     |         }
 12213 |     |     }
 12214 |     | 
 12215 |     |     function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
 12216 |     |         bytes32 m0;
 12217 |     |         bytes32 m1;
 12218 |     |         bytes32 m2;
 12219 |     |         bytes32 m3;
 12220 |     |         bytes32 m4;
 12221 |     |         bytes32 m5;
 12222 |     |         bytes32 m6;
 12223 |     |         bytes32 m7;
 12224 |     |         bytes32 m8;
 12225 |     |         bytes32 m9;
 12226 |     |         bytes32 m10;
 12227 |     |         /// @solidity memory-safe-assembly
 12228 |     |         assembly {
 12229 |     |             function writeString(pos, w) {
 12230 |     |                 let length := 0
 12231 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12232 |     |                 mstore(pos, length)
 12233 |     |                 let shift := sub(256, shl(3, length))
 12234 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12235 |     |             }
 12236 |     |             m0 := mload(0x00)
 12237 |     |             m1 := mload(0x20)
 12238 |     |             m2 := mload(0x40)
 12239 |     |             m3 := mload(0x60)
 12240 |     |             m4 := mload(0x80)
 12241 |     |             m5 := mload(0xa0)
 12242 |     |             m6 := mload(0xc0)
 12243 |     |             m7 := mload(0xe0)
 12244 |     |             m8 := mload(0x100)
 12245 |     |             m9 := mload(0x120)
 12246 |     |             m10 := mload(0x140)
 12247 |     |             // Selector of `log(string,bool,string,string)`.
 12248 |     |             mstore(0x00, 0xa826caeb)
 12249 |     |             mstore(0x20, 0x80)
 12250 |     |             mstore(0x40, p1)
 12251 |     |             mstore(0x60, 0xc0)
 12252 |     |             mstore(0x80, 0x100)
 12253 |     |             writeString(0xa0, p0)
 12254 |     |             writeString(0xe0, p2)
 12255 |     |             writeString(0x120, p3)
 12256 |     |         }
 12257 |     |         _sendLogPayload(0x1c, 0x144);
 12258 |     |         /// @solidity memory-safe-assembly
 12259 |     |         assembly {
 12260 |     |             mstore(0x00, m0)
 12261 |     |             mstore(0x20, m1)
 12262 |     |             mstore(0x40, m2)
 12263 |     |             mstore(0x60, m3)
 12264 |     |             mstore(0x80, m4)
 12265 |     |             mstore(0xa0, m5)
 12266 |     |             mstore(0xc0, m6)
 12267 |     |             mstore(0xe0, m7)
 12268 |     |             mstore(0x100, m8)
 12269 |     |             mstore(0x120, m9)
 12270 |     |             mstore(0x140, m10)
 12271 |     |         }
 12272 |     |     }
 12273 |     | 
 12274 |     |     function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {
 12275 |     |         bytes32 m0;
 12276 |     |         bytes32 m1;
 12277 |     |         bytes32 m2;
 12278 |     |         bytes32 m3;
 12279 |     |         bytes32 m4;
 12280 |     |         bytes32 m5;
 12281 |     |         bytes32 m6;
 12282 |     |         /// @solidity memory-safe-assembly
 12283 |     |         assembly {
 12284 |     |             function writeString(pos, w) {
 12285 |     |                 let length := 0
 12286 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12287 |     |                 mstore(pos, length)
 12288 |     |                 let shift := sub(256, shl(3, length))
 12289 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12290 |     |             }
 12291 |     |             m0 := mload(0x00)
 12292 |     |             m1 := mload(0x20)
 12293 |     |             m2 := mload(0x40)
 12294 |     |             m3 := mload(0x60)
 12295 |     |             m4 := mload(0x80)
 12296 |     |             m5 := mload(0xa0)
 12297 |     |             m6 := mload(0xc0)
 12298 |     |             // Selector of `log(string,uint256,address,address)`.
 12299 |     |             mstore(0x00, 0x5ea2b7ae)
 12300 |     |             mstore(0x20, 0x80)
 12301 |     |             mstore(0x40, p1)
 12302 |     |             mstore(0x60, p2)
 12303 |     |             mstore(0x80, p3)
 12304 |     |             writeString(0xa0, p0)
 12305 |     |         }
 12306 |     |         _sendLogPayload(0x1c, 0xc4);
 12307 |     |         /// @solidity memory-safe-assembly
 12308 |     |         assembly {
 12309 |     |             mstore(0x00, m0)
 12310 |     |             mstore(0x20, m1)
 12311 |     |             mstore(0x40, m2)
 12312 |     |             mstore(0x60, m3)
 12313 |     |             mstore(0x80, m4)
 12314 |     |             mstore(0xa0, m5)
 12315 |     |             mstore(0xc0, m6)
 12316 |     |         }
 12317 |     |     }
 12318 |     | 
 12319 |     |     function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {
 12320 |     |         bytes32 m0;
 12321 |     |         bytes32 m1;
 12322 |     |         bytes32 m2;
 12323 |     |         bytes32 m3;
 12324 |     |         bytes32 m4;
 12325 |     |         bytes32 m5;
 12326 |     |         bytes32 m6;
 12327 |     |         /// @solidity memory-safe-assembly
 12328 |     |         assembly {
 12329 |     |             function writeString(pos, w) {
 12330 |     |                 let length := 0
 12331 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12332 |     |                 mstore(pos, length)
 12333 |     |                 let shift := sub(256, shl(3, length))
 12334 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12335 |     |             }
 12336 |     |             m0 := mload(0x00)
 12337 |     |             m1 := mload(0x20)
 12338 |     |             m2 := mload(0x40)
 12339 |     |             m3 := mload(0x60)
 12340 |     |             m4 := mload(0x80)
 12341 |     |             m5 := mload(0xa0)
 12342 |     |             m6 := mload(0xc0)
 12343 |     |             // Selector of `log(string,uint256,address,bool)`.
 12344 |     |             mstore(0x00, 0x82112a42)
 12345 |     |             mstore(0x20, 0x80)
 12346 |     |             mstore(0x40, p1)
 12347 |     |             mstore(0x60, p2)
 12348 |     |             mstore(0x80, p3)
 12349 |     |             writeString(0xa0, p0)
 12350 |     |         }
 12351 |     |         _sendLogPayload(0x1c, 0xc4);
 12352 |     |         /// @solidity memory-safe-assembly
 12353 |     |         assembly {
 12354 |     |             mstore(0x00, m0)
 12355 |     |             mstore(0x20, m1)
 12356 |     |             mstore(0x40, m2)
 12357 |     |             mstore(0x60, m3)
 12358 |     |             mstore(0x80, m4)
 12359 |     |             mstore(0xa0, m5)
 12360 |     |             mstore(0xc0, m6)
 12361 |     |         }
 12362 |     |     }
 12363 |     | 
 12364 |     |     function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {
 12365 |     |         bytes32 m0;
 12366 |     |         bytes32 m1;
 12367 |     |         bytes32 m2;
 12368 |     |         bytes32 m3;
 12369 |     |         bytes32 m4;
 12370 |     |         bytes32 m5;
 12371 |     |         bytes32 m6;
 12372 |     |         /// @solidity memory-safe-assembly
 12373 |     |         assembly {
 12374 |     |             function writeString(pos, w) {
 12375 |     |                 let length := 0
 12376 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12377 |     |                 mstore(pos, length)
 12378 |     |                 let shift := sub(256, shl(3, length))
 12379 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12380 |     |             }
 12381 |     |             m0 := mload(0x00)
 12382 |     |             m1 := mload(0x20)
 12383 |     |             m2 := mload(0x40)
 12384 |     |             m3 := mload(0x60)
 12385 |     |             m4 := mload(0x80)
 12386 |     |             m5 := mload(0xa0)
 12387 |     |             m6 := mload(0xc0)
 12388 |     |             // Selector of `log(string,uint256,address,uint256)`.
 12389 |     |             mstore(0x00, 0x4f04fdc6)
 12390 |     |             mstore(0x20, 0x80)
 12391 |     |             mstore(0x40, p1)
 12392 |     |             mstore(0x60, p2)
 12393 |     |             mstore(0x80, p3)
 12394 |     |             writeString(0xa0, p0)
 12395 |     |         }
 12396 |     |         _sendLogPayload(0x1c, 0xc4);
 12397 |     |         /// @solidity memory-safe-assembly
 12398 |     |         assembly {
 12399 |     |             mstore(0x00, m0)
 12400 |     |             mstore(0x20, m1)
 12401 |     |             mstore(0x40, m2)
 12402 |     |             mstore(0x60, m3)
 12403 |     |             mstore(0x80, m4)
 12404 |     |             mstore(0xa0, m5)
 12405 |     |             mstore(0xc0, m6)
 12406 |     |         }
 12407 |     |     }
 12408 |     | 
 12409 |     |     function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {
 12410 |     |         bytes32 m0;
 12411 |     |         bytes32 m1;
 12412 |     |         bytes32 m2;
 12413 |     |         bytes32 m3;
 12414 |     |         bytes32 m4;
 12415 |     |         bytes32 m5;
 12416 |     |         bytes32 m6;
 12417 |     |         bytes32 m7;
 12418 |     |         bytes32 m8;
 12419 |     |         /// @solidity memory-safe-assembly
 12420 |     |         assembly {
 12421 |     |             function writeString(pos, w) {
 12422 |     |                 let length := 0
 12423 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12424 |     |                 mstore(pos, length)
 12425 |     |                 let shift := sub(256, shl(3, length))
 12426 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12427 |     |             }
 12428 |     |             m0 := mload(0x00)
 12429 |     |             m1 := mload(0x20)
 12430 |     |             m2 := mload(0x40)
 12431 |     |             m3 := mload(0x60)
 12432 |     |             m4 := mload(0x80)
 12433 |     |             m5 := mload(0xa0)
 12434 |     |             m6 := mload(0xc0)
 12435 |     |             m7 := mload(0xe0)
 12436 |     |             m8 := mload(0x100)
 12437 |     |             // Selector of `log(string,uint256,address,string)`.
 12438 |     |             mstore(0x00, 0x9ffb2f93)
 12439 |     |             mstore(0x20, 0x80)
 12440 |     |             mstore(0x40, p1)
 12441 |     |             mstore(0x60, p2)
 12442 |     |             mstore(0x80, 0xc0)
 12443 |     |             writeString(0xa0, p0)
 12444 |     |             writeString(0xe0, p3)
 12445 |     |         }
 12446 |     |         _sendLogPayload(0x1c, 0x104);
 12447 |     |         /// @solidity memory-safe-assembly
 12448 |     |         assembly {
 12449 |     |             mstore(0x00, m0)
 12450 |     |             mstore(0x20, m1)
 12451 |     |             mstore(0x40, m2)
 12452 |     |             mstore(0x60, m3)
 12453 |     |             mstore(0x80, m4)
 12454 |     |             mstore(0xa0, m5)
 12455 |     |             mstore(0xc0, m6)
 12456 |     |             mstore(0xe0, m7)
 12457 |     |             mstore(0x100, m8)
 12458 |     |         }
 12459 |     |     }
 12460 |     | 
 12461 |     |     function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {
 12462 |     |         bytes32 m0;
 12463 |     |         bytes32 m1;
 12464 |     |         bytes32 m2;
 12465 |     |         bytes32 m3;
 12466 |     |         bytes32 m4;
 12467 |     |         bytes32 m5;
 12468 |     |         bytes32 m6;
 12469 |     |         /// @solidity memory-safe-assembly
 12470 |     |         assembly {
 12471 |     |             function writeString(pos, w) {
 12472 |     |                 let length := 0
 12473 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12474 |     |                 mstore(pos, length)
 12475 |     |                 let shift := sub(256, shl(3, length))
 12476 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12477 |     |             }
 12478 |     |             m0 := mload(0x00)
 12479 |     |             m1 := mload(0x20)
 12480 |     |             m2 := mload(0x40)
 12481 |     |             m3 := mload(0x60)
 12482 |     |             m4 := mload(0x80)
 12483 |     |             m5 := mload(0xa0)
 12484 |     |             m6 := mload(0xc0)
 12485 |     |             // Selector of `log(string,uint256,bool,address)`.
 12486 |     |             mstore(0x00, 0xe0e95b98)
 12487 |     |             mstore(0x20, 0x80)
 12488 |     |             mstore(0x40, p1)
 12489 |     |             mstore(0x60, p2)
 12490 |     |             mstore(0x80, p3)
 12491 |     |             writeString(0xa0, p0)
 12492 |     |         }
 12493 |     |         _sendLogPayload(0x1c, 0xc4);
 12494 |     |         /// @solidity memory-safe-assembly
 12495 |     |         assembly {
 12496 |     |             mstore(0x00, m0)
 12497 |     |             mstore(0x20, m1)
 12498 |     |             mstore(0x40, m2)
 12499 |     |             mstore(0x60, m3)
 12500 |     |             mstore(0x80, m4)
 12501 |     |             mstore(0xa0, m5)
 12502 |     |             mstore(0xc0, m6)
 12503 |     |         }
 12504 |     |     }
 12505 |     | 
 12506 |     |     function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {
 12507 |     |         bytes32 m0;
 12508 |     |         bytes32 m1;
 12509 |     |         bytes32 m2;
 12510 |     |         bytes32 m3;
 12511 |     |         bytes32 m4;
 12512 |     |         bytes32 m5;
 12513 |     |         bytes32 m6;
 12514 |     |         /// @solidity memory-safe-assembly
 12515 |     |         assembly {
 12516 |     |             function writeString(pos, w) {
 12517 |     |                 let length := 0
 12518 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12519 |     |                 mstore(pos, length)
 12520 |     |                 let shift := sub(256, shl(3, length))
 12521 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12522 |     |             }
 12523 |     |             m0 := mload(0x00)
 12524 |     |             m1 := mload(0x20)
 12525 |     |             m2 := mload(0x40)
 12526 |     |             m3 := mload(0x60)
 12527 |     |             m4 := mload(0x80)
 12528 |     |             m5 := mload(0xa0)
 12529 |     |             m6 := mload(0xc0)
 12530 |     |             // Selector of `log(string,uint256,bool,bool)`.
 12531 |     |             mstore(0x00, 0x354c36d6)
 12532 |     |             mstore(0x20, 0x80)
 12533 |     |             mstore(0x40, p1)
 12534 |     |             mstore(0x60, p2)
 12535 |     |             mstore(0x80, p3)
 12536 |     |             writeString(0xa0, p0)
 12537 |     |         }
 12538 |     |         _sendLogPayload(0x1c, 0xc4);
 12539 |     |         /// @solidity memory-safe-assembly
 12540 |     |         assembly {
 12541 |     |             mstore(0x00, m0)
 12542 |     |             mstore(0x20, m1)
 12543 |     |             mstore(0x40, m2)
 12544 |     |             mstore(0x60, m3)
 12545 |     |             mstore(0x80, m4)
 12546 |     |             mstore(0xa0, m5)
 12547 |     |             mstore(0xc0, m6)
 12548 |     |         }
 12549 |     |     }
 12550 |     | 
 12551 |     |     function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {
 12552 |     |         bytes32 m0;
 12553 |     |         bytes32 m1;
 12554 |     |         bytes32 m2;
 12555 |     |         bytes32 m3;
 12556 |     |         bytes32 m4;
 12557 |     |         bytes32 m5;
 12558 |     |         bytes32 m6;
 12559 |     |         /// @solidity memory-safe-assembly
 12560 |     |         assembly {
 12561 |     |             function writeString(pos, w) {
 12562 |     |                 let length := 0
 12563 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12564 |     |                 mstore(pos, length)
 12565 |     |                 let shift := sub(256, shl(3, length))
 12566 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12567 |     |             }
 12568 |     |             m0 := mload(0x00)
 12569 |     |             m1 := mload(0x20)
 12570 |     |             m2 := mload(0x40)
 12571 |     |             m3 := mload(0x60)
 12572 |     |             m4 := mload(0x80)
 12573 |     |             m5 := mload(0xa0)
 12574 |     |             m6 := mload(0xc0)
 12575 |     |             // Selector of `log(string,uint256,bool,uint256)`.
 12576 |     |             mstore(0x00, 0xe41b6f6f)
 12577 |     |             mstore(0x20, 0x80)
 12578 |     |             mstore(0x40, p1)
 12579 |     |             mstore(0x60, p2)
 12580 |     |             mstore(0x80, p3)
 12581 |     |             writeString(0xa0, p0)
 12582 |     |         }
 12583 |     |         _sendLogPayload(0x1c, 0xc4);
 12584 |     |         /// @solidity memory-safe-assembly
 12585 |     |         assembly {
 12586 |     |             mstore(0x00, m0)
 12587 |     |             mstore(0x20, m1)
 12588 |     |             mstore(0x40, m2)
 12589 |     |             mstore(0x60, m3)
 12590 |     |             mstore(0x80, m4)
 12591 |     |             mstore(0xa0, m5)
 12592 |     |             mstore(0xc0, m6)
 12593 |     |         }
 12594 |     |     }
 12595 |     | 
 12596 |     |     function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {
 12597 |     |         bytes32 m0;
 12598 |     |         bytes32 m1;
 12599 |     |         bytes32 m2;
 12600 |     |         bytes32 m3;
 12601 |     |         bytes32 m4;
 12602 |     |         bytes32 m5;
 12603 |     |         bytes32 m6;
 12604 |     |         bytes32 m7;
 12605 |     |         bytes32 m8;
 12606 |     |         /// @solidity memory-safe-assembly
 12607 |     |         assembly {
 12608 |     |             function writeString(pos, w) {
 12609 |     |                 let length := 0
 12610 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12611 |     |                 mstore(pos, length)
 12612 |     |                 let shift := sub(256, shl(3, length))
 12613 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12614 |     |             }
 12615 |     |             m0 := mload(0x00)
 12616 |     |             m1 := mload(0x20)
 12617 |     |             m2 := mload(0x40)
 12618 |     |             m3 := mload(0x60)
 12619 |     |             m4 := mload(0x80)
 12620 |     |             m5 := mload(0xa0)
 12621 |     |             m6 := mload(0xc0)
 12622 |     |             m7 := mload(0xe0)
 12623 |     |             m8 := mload(0x100)
 12624 |     |             // Selector of `log(string,uint256,bool,string)`.
 12625 |     |             mstore(0x00, 0xabf73a98)
 12626 |     |             mstore(0x20, 0x80)
 12627 |     |             mstore(0x40, p1)
 12628 |     |             mstore(0x60, p2)
 12629 |     |             mstore(0x80, 0xc0)
 12630 |     |             writeString(0xa0, p0)
 12631 |     |             writeString(0xe0, p3)
 12632 |     |         }
 12633 |     |         _sendLogPayload(0x1c, 0x104);
 12634 |     |         /// @solidity memory-safe-assembly
 12635 |     |         assembly {
 12636 |     |             mstore(0x00, m0)
 12637 |     |             mstore(0x20, m1)
 12638 |     |             mstore(0x40, m2)
 12639 |     |             mstore(0x60, m3)
 12640 |     |             mstore(0x80, m4)
 12641 |     |             mstore(0xa0, m5)
 12642 |     |             mstore(0xc0, m6)
 12643 |     |             mstore(0xe0, m7)
 12644 |     |             mstore(0x100, m8)
 12645 |     |         }
 12646 |     |     }
 12647 |     | 
 12648 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {
 12649 |     |         bytes32 m0;
 12650 |     |         bytes32 m1;
 12651 |     |         bytes32 m2;
 12652 |     |         bytes32 m3;
 12653 |     |         bytes32 m4;
 12654 |     |         bytes32 m5;
 12655 |     |         bytes32 m6;
 12656 |     |         /// @solidity memory-safe-assembly
 12657 |     |         assembly {
 12658 |     |             function writeString(pos, w) {
 12659 |     |                 let length := 0
 12660 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12661 |     |                 mstore(pos, length)
 12662 |     |                 let shift := sub(256, shl(3, length))
 12663 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12664 |     |             }
 12665 |     |             m0 := mload(0x00)
 12666 |     |             m1 := mload(0x20)
 12667 |     |             m2 := mload(0x40)
 12668 |     |             m3 := mload(0x60)
 12669 |     |             m4 := mload(0x80)
 12670 |     |             m5 := mload(0xa0)
 12671 |     |             m6 := mload(0xc0)
 12672 |     |             // Selector of `log(string,uint256,uint256,address)`.
 12673 |     |             mstore(0x00, 0xe21de278)
 12674 |     |             mstore(0x20, 0x80)
 12675 |     |             mstore(0x40, p1)
 12676 |     |             mstore(0x60, p2)
 12677 |     |             mstore(0x80, p3)
 12678 |     |             writeString(0xa0, p0)
 12679 |     |         }
 12680 |     |         _sendLogPayload(0x1c, 0xc4);
 12681 |     |         /// @solidity memory-safe-assembly
 12682 |     |         assembly {
 12683 |     |             mstore(0x00, m0)
 12684 |     |             mstore(0x20, m1)
 12685 |     |             mstore(0x40, m2)
 12686 |     |             mstore(0x60, m3)
 12687 |     |             mstore(0x80, m4)
 12688 |     |             mstore(0xa0, m5)
 12689 |     |             mstore(0xc0, m6)
 12690 |     |         }
 12691 |     |     }
 12692 |     | 
 12693 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {
 12694 |     |         bytes32 m0;
 12695 |     |         bytes32 m1;
 12696 |     |         bytes32 m2;
 12697 |     |         bytes32 m3;
 12698 |     |         bytes32 m4;
 12699 |     |         bytes32 m5;
 12700 |     |         bytes32 m6;
 12701 |     |         /// @solidity memory-safe-assembly
 12702 |     |         assembly {
 12703 |     |             function writeString(pos, w) {
 12704 |     |                 let length := 0
 12705 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12706 |     |                 mstore(pos, length)
 12707 |     |                 let shift := sub(256, shl(3, length))
 12708 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12709 |     |             }
 12710 |     |             m0 := mload(0x00)
 12711 |     |             m1 := mload(0x20)
 12712 |     |             m2 := mload(0x40)
 12713 |     |             m3 := mload(0x60)
 12714 |     |             m4 := mload(0x80)
 12715 |     |             m5 := mload(0xa0)
 12716 |     |             m6 := mload(0xc0)
 12717 |     |             // Selector of `log(string,uint256,uint256,bool)`.
 12718 |     |             mstore(0x00, 0x7626db92)
 12719 |     |             mstore(0x20, 0x80)
 12720 |     |             mstore(0x40, p1)
 12721 |     |             mstore(0x60, p2)
 12722 |     |             mstore(0x80, p3)
 12723 |     |             writeString(0xa0, p0)
 12724 |     |         }
 12725 |     |         _sendLogPayload(0x1c, 0xc4);
 12726 |     |         /// @solidity memory-safe-assembly
 12727 |     |         assembly {
 12728 |     |             mstore(0x00, m0)
 12729 |     |             mstore(0x20, m1)
 12730 |     |             mstore(0x40, m2)
 12731 |     |             mstore(0x60, m3)
 12732 |     |             mstore(0x80, m4)
 12733 |     |             mstore(0xa0, m5)
 12734 |     |             mstore(0xc0, m6)
 12735 |     |         }
 12736 |     |     }
 12737 |     | 
 12738 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 12739 |     |         bytes32 m0;
 12740 |     |         bytes32 m1;
 12741 |     |         bytes32 m2;
 12742 |     |         bytes32 m3;
 12743 |     |         bytes32 m4;
 12744 |     |         bytes32 m5;
 12745 |     |         bytes32 m6;
 12746 |     |         /// @solidity memory-safe-assembly
 12747 |     |         assembly {
 12748 |     |             function writeString(pos, w) {
 12749 |     |                 let length := 0
 12750 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12751 |     |                 mstore(pos, length)
 12752 |     |                 let shift := sub(256, shl(3, length))
 12753 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12754 |     |             }
 12755 |     |             m0 := mload(0x00)
 12756 |     |             m1 := mload(0x20)
 12757 |     |             m2 := mload(0x40)
 12758 |     |             m3 := mload(0x60)
 12759 |     |             m4 := mload(0x80)
 12760 |     |             m5 := mload(0xa0)
 12761 |     |             m6 := mload(0xc0)
 12762 |     |             // Selector of `log(string,uint256,uint256,uint256)`.
 12763 |     |             mstore(0x00, 0xa7a87853)
 12764 |     |             mstore(0x20, 0x80)
 12765 |     |             mstore(0x40, p1)
 12766 |     |             mstore(0x60, p2)
 12767 |     |             mstore(0x80, p3)
 12768 |     |             writeString(0xa0, p0)
 12769 |     |         }
 12770 |     |         _sendLogPayload(0x1c, 0xc4);
 12771 |     |         /// @solidity memory-safe-assembly
 12772 |     |         assembly {
 12773 |     |             mstore(0x00, m0)
 12774 |     |             mstore(0x20, m1)
 12775 |     |             mstore(0x40, m2)
 12776 |     |             mstore(0x60, m3)
 12777 |     |             mstore(0x80, m4)
 12778 |     |             mstore(0xa0, m5)
 12779 |     |             mstore(0xc0, m6)
 12780 |     |         }
 12781 |     |     }
 12782 |     | 
 12783 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
 12784 |     |         bytes32 m0;
 12785 |     |         bytes32 m1;
 12786 |     |         bytes32 m2;
 12787 |     |         bytes32 m3;
 12788 |     |         bytes32 m4;
 12789 |     |         bytes32 m5;
 12790 |     |         bytes32 m6;
 12791 |     |         bytes32 m7;
 12792 |     |         bytes32 m8;
 12793 |     |         /// @solidity memory-safe-assembly
 12794 |     |         assembly {
 12795 |     |             function writeString(pos, w) {
 12796 |     |                 let length := 0
 12797 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12798 |     |                 mstore(pos, length)
 12799 |     |                 let shift := sub(256, shl(3, length))
 12800 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12801 |     |             }
 12802 |     |             m0 := mload(0x00)
 12803 |     |             m1 := mload(0x20)
 12804 |     |             m2 := mload(0x40)
 12805 |     |             m3 := mload(0x60)
 12806 |     |             m4 := mload(0x80)
 12807 |     |             m5 := mload(0xa0)
 12808 |     |             m6 := mload(0xc0)
 12809 |     |             m7 := mload(0xe0)
 12810 |     |             m8 := mload(0x100)
 12811 |     |             // Selector of `log(string,uint256,uint256,string)`.
 12812 |     |             mstore(0x00, 0x854b3496)
 12813 |     |             mstore(0x20, 0x80)
 12814 |     |             mstore(0x40, p1)
 12815 |     |             mstore(0x60, p2)
 12816 |     |             mstore(0x80, 0xc0)
 12817 |     |             writeString(0xa0, p0)
 12818 |     |             writeString(0xe0, p3)
 12819 |     |         }
 12820 |     |         _sendLogPayload(0x1c, 0x104);
 12821 |     |         /// @solidity memory-safe-assembly
 12822 |     |         assembly {
 12823 |     |             mstore(0x00, m0)
 12824 |     |             mstore(0x20, m1)
 12825 |     |             mstore(0x40, m2)
 12826 |     |             mstore(0x60, m3)
 12827 |     |             mstore(0x80, m4)
 12828 |     |             mstore(0xa0, m5)
 12829 |     |             mstore(0xc0, m6)
 12830 |     |             mstore(0xe0, m7)
 12831 |     |             mstore(0x100, m8)
 12832 |     |         }
 12833 |     |     }
 12834 |     | 
 12835 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {
 12836 |     |         bytes32 m0;
 12837 |     |         bytes32 m1;
 12838 |     |         bytes32 m2;
 12839 |     |         bytes32 m3;
 12840 |     |         bytes32 m4;
 12841 |     |         bytes32 m5;
 12842 |     |         bytes32 m6;
 12843 |     |         bytes32 m7;
 12844 |     |         bytes32 m8;
 12845 |     |         /// @solidity memory-safe-assembly
 12846 |     |         assembly {
 12847 |     |             function writeString(pos, w) {
 12848 |     |                 let length := 0
 12849 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12850 |     |                 mstore(pos, length)
 12851 |     |                 let shift := sub(256, shl(3, length))
 12852 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12853 |     |             }
 12854 |     |             m0 := mload(0x00)
 12855 |     |             m1 := mload(0x20)
 12856 |     |             m2 := mload(0x40)
 12857 |     |             m3 := mload(0x60)
 12858 |     |             m4 := mload(0x80)
 12859 |     |             m5 := mload(0xa0)
 12860 |     |             m6 := mload(0xc0)
 12861 |     |             m7 := mload(0xe0)
 12862 |     |             m8 := mload(0x100)
 12863 |     |             // Selector of `log(string,uint256,string,address)`.
 12864 |     |             mstore(0x00, 0x7c4632a4)
 12865 |     |             mstore(0x20, 0x80)
 12866 |     |             mstore(0x40, p1)
 12867 |     |             mstore(0x60, 0xc0)
 12868 |     |             mstore(0x80, p3)
 12869 |     |             writeString(0xa0, p0)
 12870 |     |             writeString(0xe0, p2)
 12871 |     |         }
 12872 |     |         _sendLogPayload(0x1c, 0x104);
 12873 |     |         /// @solidity memory-safe-assembly
 12874 |     |         assembly {
 12875 |     |             mstore(0x00, m0)
 12876 |     |             mstore(0x20, m1)
 12877 |     |             mstore(0x40, m2)
 12878 |     |             mstore(0x60, m3)
 12879 |     |             mstore(0x80, m4)
 12880 |     |             mstore(0xa0, m5)
 12881 |     |             mstore(0xc0, m6)
 12882 |     |             mstore(0xe0, m7)
 12883 |     |             mstore(0x100, m8)
 12884 |     |         }
 12885 |     |     }
 12886 |     | 
 12887 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {
 12888 |     |         bytes32 m0;
 12889 |     |         bytes32 m1;
 12890 |     |         bytes32 m2;
 12891 |     |         bytes32 m3;
 12892 |     |         bytes32 m4;
 12893 |     |         bytes32 m5;
 12894 |     |         bytes32 m6;
 12895 |     |         bytes32 m7;
 12896 |     |         bytes32 m8;
 12897 |     |         /// @solidity memory-safe-assembly
 12898 |     |         assembly {
 12899 |     |             function writeString(pos, w) {
 12900 |     |                 let length := 0
 12901 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12902 |     |                 mstore(pos, length)
 12903 |     |                 let shift := sub(256, shl(3, length))
 12904 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12905 |     |             }
 12906 |     |             m0 := mload(0x00)
 12907 |     |             m1 := mload(0x20)
 12908 |     |             m2 := mload(0x40)
 12909 |     |             m3 := mload(0x60)
 12910 |     |             m4 := mload(0x80)
 12911 |     |             m5 := mload(0xa0)
 12912 |     |             m6 := mload(0xc0)
 12913 |     |             m7 := mload(0xe0)
 12914 |     |             m8 := mload(0x100)
 12915 |     |             // Selector of `log(string,uint256,string,bool)`.
 12916 |     |             mstore(0x00, 0x7d24491d)
 12917 |     |             mstore(0x20, 0x80)
 12918 |     |             mstore(0x40, p1)
 12919 |     |             mstore(0x60, 0xc0)
 12920 |     |             mstore(0x80, p3)
 12921 |     |             writeString(0xa0, p0)
 12922 |     |             writeString(0xe0, p2)
 12923 |     |         }
 12924 |     |         _sendLogPayload(0x1c, 0x104);
 12925 |     |         /// @solidity memory-safe-assembly
 12926 |     |         assembly {
 12927 |     |             mstore(0x00, m0)
 12928 |     |             mstore(0x20, m1)
 12929 |     |             mstore(0x40, m2)
 12930 |     |             mstore(0x60, m3)
 12931 |     |             mstore(0x80, m4)
 12932 |     |             mstore(0xa0, m5)
 12933 |     |             mstore(0xc0, m6)
 12934 |     |             mstore(0xe0, m7)
 12935 |     |             mstore(0x100, m8)
 12936 |     |         }
 12937 |     |     }
 12938 |     | 
 12939 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
 12940 |     |         bytes32 m0;
 12941 |     |         bytes32 m1;
 12942 |     |         bytes32 m2;
 12943 |     |         bytes32 m3;
 12944 |     |         bytes32 m4;
 12945 |     |         bytes32 m5;
 12946 |     |         bytes32 m6;
 12947 |     |         bytes32 m7;
 12948 |     |         bytes32 m8;
 12949 |     |         /// @solidity memory-safe-assembly
 12950 |     |         assembly {
 12951 |     |             function writeString(pos, w) {
 12952 |     |                 let length := 0
 12953 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12954 |     |                 mstore(pos, length)
 12955 |     |                 let shift := sub(256, shl(3, length))
 12956 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12957 |     |             }
 12958 |     |             m0 := mload(0x00)
 12959 |     |             m1 := mload(0x20)
 12960 |     |             m2 := mload(0x40)
 12961 |     |             m3 := mload(0x60)
 12962 |     |             m4 := mload(0x80)
 12963 |     |             m5 := mload(0xa0)
 12964 |     |             m6 := mload(0xc0)
 12965 |     |             m7 := mload(0xe0)
 12966 |     |             m8 := mload(0x100)
 12967 |     |             // Selector of `log(string,uint256,string,uint256)`.
 12968 |     |             mstore(0x00, 0xc67ea9d1)
 12969 |     |             mstore(0x20, 0x80)
 12970 |     |             mstore(0x40, p1)
 12971 |     |             mstore(0x60, 0xc0)
 12972 |     |             mstore(0x80, p3)
 12973 |     |             writeString(0xa0, p0)
 12974 |     |             writeString(0xe0, p2)
 12975 |     |         }
 12976 |     |         _sendLogPayload(0x1c, 0x104);
 12977 |     |         /// @solidity memory-safe-assembly
 12978 |     |         assembly {
 12979 |     |             mstore(0x00, m0)
 12980 |     |             mstore(0x20, m1)
 12981 |     |             mstore(0x40, m2)
 12982 |     |             mstore(0x60, m3)
 12983 |     |             mstore(0x80, m4)
 12984 |     |             mstore(0xa0, m5)
 12985 |     |             mstore(0xc0, m6)
 12986 |     |             mstore(0xe0, m7)
 12987 |     |             mstore(0x100, m8)
 12988 |     |         }
 12989 |     |     }
 12990 |     | 
 12991 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
 12992 |     |         bytes32 m0;
 12993 |     |         bytes32 m1;
 12994 |     |         bytes32 m2;
 12995 |     |         bytes32 m3;
 12996 |     |         bytes32 m4;
 12997 |     |         bytes32 m5;
 12998 |     |         bytes32 m6;
 12999 |     |         bytes32 m7;
 13000 |     |         bytes32 m8;
 13001 |     |         bytes32 m9;
 13002 |     |         bytes32 m10;
 13003 |     |         /// @solidity memory-safe-assembly
 13004 |     |         assembly {
 13005 |     |             function writeString(pos, w) {
 13006 |     |                 let length := 0
 13007 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13008 |     |                 mstore(pos, length)
 13009 |     |                 let shift := sub(256, shl(3, length))
 13010 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13011 |     |             }
 13012 |     |             m0 := mload(0x00)
 13013 |     |             m1 := mload(0x20)
 13014 |     |             m2 := mload(0x40)
 13015 |     |             m3 := mload(0x60)
 13016 |     |             m4 := mload(0x80)
 13017 |     |             m5 := mload(0xa0)
 13018 |     |             m6 := mload(0xc0)
 13019 |     |             m7 := mload(0xe0)
 13020 |     |             m8 := mload(0x100)
 13021 |     |             m9 := mload(0x120)
 13022 |     |             m10 := mload(0x140)
 13023 |     |             // Selector of `log(string,uint256,string,string)`.
 13024 |     |             mstore(0x00, 0x5ab84e1f)
 13025 |     |             mstore(0x20, 0x80)
 13026 |     |             mstore(0x40, p1)
 13027 |     |             mstore(0x60, 0xc0)
 13028 |     |             mstore(0x80, 0x100)
 13029 |     |             writeString(0xa0, p0)
 13030 |     |             writeString(0xe0, p2)
 13031 |     |             writeString(0x120, p3)
 13032 |     |         }
 13033 |     |         _sendLogPayload(0x1c, 0x144);
 13034 |     |         /// @solidity memory-safe-assembly
 13035 |     |         assembly {
 13036 |     |             mstore(0x00, m0)
 13037 |     |             mstore(0x20, m1)
 13038 |     |             mstore(0x40, m2)
 13039 |     |             mstore(0x60, m3)
 13040 |     |             mstore(0x80, m4)
 13041 |     |             mstore(0xa0, m5)
 13042 |     |             mstore(0xc0, m6)
 13043 |     |             mstore(0xe0, m7)
 13044 |     |             mstore(0x100, m8)
 13045 |     |             mstore(0x120, m9)
 13046 |     |             mstore(0x140, m10)
 13047 |     |         }
 13048 |     |     }
 13049 |     | 
 13050 |     |     function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {
 13051 |     |         bytes32 m0;
 13052 |     |         bytes32 m1;
 13053 |     |         bytes32 m2;
 13054 |     |         bytes32 m3;
 13055 |     |         bytes32 m4;
 13056 |     |         bytes32 m5;
 13057 |     |         bytes32 m6;
 13058 |     |         bytes32 m7;
 13059 |     |         bytes32 m8;
 13060 |     |         /// @solidity memory-safe-assembly
 13061 |     |         assembly {
 13062 |     |             function writeString(pos, w) {
 13063 |     |                 let length := 0
 13064 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13065 |     |                 mstore(pos, length)
 13066 |     |                 let shift := sub(256, shl(3, length))
 13067 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13068 |     |             }
 13069 |     |             m0 := mload(0x00)
 13070 |     |             m1 := mload(0x20)
 13071 |     |             m2 := mload(0x40)
 13072 |     |             m3 := mload(0x60)
 13073 |     |             m4 := mload(0x80)
 13074 |     |             m5 := mload(0xa0)
 13075 |     |             m6 := mload(0xc0)
 13076 |     |             m7 := mload(0xe0)
 13077 |     |             m8 := mload(0x100)
 13078 |     |             // Selector of `log(string,string,address,address)`.
 13079 |     |             mstore(0x00, 0x439c7bef)
 13080 |     |             mstore(0x20, 0x80)
 13081 |     |             mstore(0x40, 0xc0)
 13082 |     |             mstore(0x60, p2)
 13083 |     |             mstore(0x80, p3)
 13084 |     |             writeString(0xa0, p0)
 13085 |     |             writeString(0xe0, p1)
 13086 |     |         }
 13087 |     |         _sendLogPayload(0x1c, 0x104);
 13088 |     |         /// @solidity memory-safe-assembly
 13089 |     |         assembly {
 13090 |     |             mstore(0x00, m0)
 13091 |     |             mstore(0x20, m1)
 13092 |     |             mstore(0x40, m2)
 13093 |     |             mstore(0x60, m3)
 13094 |     |             mstore(0x80, m4)
 13095 |     |             mstore(0xa0, m5)
 13096 |     |             mstore(0xc0, m6)
 13097 |     |             mstore(0xe0, m7)
 13098 |     |             mstore(0x100, m8)
 13099 |     |         }
 13100 |     |     }
 13101 |     | 
 13102 |     |     function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {
 13103 |     |         bytes32 m0;
 13104 |     |         bytes32 m1;
 13105 |     |         bytes32 m2;
 13106 |     |         bytes32 m3;
 13107 |     |         bytes32 m4;
 13108 |     |         bytes32 m5;
 13109 |     |         bytes32 m6;
 13110 |     |         bytes32 m7;
 13111 |     |         bytes32 m8;
 13112 |     |         /// @solidity memory-safe-assembly
 13113 |     |         assembly {
 13114 |     |             function writeString(pos, w) {
 13115 |     |                 let length := 0
 13116 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13117 |     |                 mstore(pos, length)
 13118 |     |                 let shift := sub(256, shl(3, length))
 13119 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13120 |     |             }
 13121 |     |             m0 := mload(0x00)
 13122 |     |             m1 := mload(0x20)
 13123 |     |             m2 := mload(0x40)
 13124 |     |             m3 := mload(0x60)
 13125 |     |             m4 := mload(0x80)
 13126 |     |             m5 := mload(0xa0)
 13127 |     |             m6 := mload(0xc0)
 13128 |     |             m7 := mload(0xe0)
 13129 |     |             m8 := mload(0x100)
 13130 |     |             // Selector of `log(string,string,address,bool)`.
 13131 |     |             mstore(0x00, 0x5ccd4e37)
 13132 |     |             mstore(0x20, 0x80)
 13133 |     |             mstore(0x40, 0xc0)
 13134 |     |             mstore(0x60, p2)
 13135 |     |             mstore(0x80, p3)
 13136 |     |             writeString(0xa0, p0)
 13137 |     |             writeString(0xe0, p1)
 13138 |     |         }
 13139 |     |         _sendLogPayload(0x1c, 0x104);
 13140 |     |         /// @solidity memory-safe-assembly
 13141 |     |         assembly {
 13142 |     |             mstore(0x00, m0)
 13143 |     |             mstore(0x20, m1)
 13144 |     |             mstore(0x40, m2)
 13145 |     |             mstore(0x60, m3)
 13146 |     |             mstore(0x80, m4)
 13147 |     |             mstore(0xa0, m5)
 13148 |     |             mstore(0xc0, m6)
 13149 |     |             mstore(0xe0, m7)
 13150 |     |             mstore(0x100, m8)
 13151 |     |         }
 13152 |     |     }
 13153 |     | 
 13154 |     |     function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {
 13155 |     |         bytes32 m0;
 13156 |     |         bytes32 m1;
 13157 |     |         bytes32 m2;
 13158 |     |         bytes32 m3;
 13159 |     |         bytes32 m4;
 13160 |     |         bytes32 m5;
 13161 |     |         bytes32 m6;
 13162 |     |         bytes32 m7;
 13163 |     |         bytes32 m8;
 13164 |     |         /// @solidity memory-safe-assembly
 13165 |     |         assembly {
 13166 |     |             function writeString(pos, w) {
 13167 |     |                 let length := 0
 13168 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13169 |     |                 mstore(pos, length)
 13170 |     |                 let shift := sub(256, shl(3, length))
 13171 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13172 |     |             }
 13173 |     |             m0 := mload(0x00)
 13174 |     |             m1 := mload(0x20)
 13175 |     |             m2 := mload(0x40)
 13176 |     |             m3 := mload(0x60)
 13177 |     |             m4 := mload(0x80)
 13178 |     |             m5 := mload(0xa0)
 13179 |     |             m6 := mload(0xc0)
 13180 |     |             m7 := mload(0xe0)
 13181 |     |             m8 := mload(0x100)
 13182 |     |             // Selector of `log(string,string,address,uint256)`.
 13183 |     |             mstore(0x00, 0x7cc3c607)
 13184 |     |             mstore(0x20, 0x80)
 13185 |     |             mstore(0x40, 0xc0)
 13186 |     |             mstore(0x60, p2)
 13187 |     |             mstore(0x80, p3)
 13188 |     |             writeString(0xa0, p0)
 13189 |     |             writeString(0xe0, p1)
 13190 |     |         }
 13191 |     |         _sendLogPayload(0x1c, 0x104);
 13192 |     |         /// @solidity memory-safe-assembly
 13193 |     |         assembly {
 13194 |     |             mstore(0x00, m0)
 13195 |     |             mstore(0x20, m1)
 13196 |     |             mstore(0x40, m2)
 13197 |     |             mstore(0x60, m3)
 13198 |     |             mstore(0x80, m4)
 13199 |     |             mstore(0xa0, m5)
 13200 |     |             mstore(0xc0, m6)
 13201 |     |             mstore(0xe0, m7)
 13202 |     |             mstore(0x100, m8)
 13203 |     |         }
 13204 |     |     }
 13205 |     | 
 13206 |     |     function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {
 13207 |     |         bytes32 m0;
 13208 |     |         bytes32 m1;
 13209 |     |         bytes32 m2;
 13210 |     |         bytes32 m3;
 13211 |     |         bytes32 m4;
 13212 |     |         bytes32 m5;
 13213 |     |         bytes32 m6;
 13214 |     |         bytes32 m7;
 13215 |     |         bytes32 m8;
 13216 |     |         bytes32 m9;
 13217 |     |         bytes32 m10;
 13218 |     |         /// @solidity memory-safe-assembly
 13219 |     |         assembly {
 13220 |     |             function writeString(pos, w) {
 13221 |     |                 let length := 0
 13222 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13223 |     |                 mstore(pos, length)
 13224 |     |                 let shift := sub(256, shl(3, length))
 13225 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13226 |     |             }
 13227 |     |             m0 := mload(0x00)
 13228 |     |             m1 := mload(0x20)
 13229 |     |             m2 := mload(0x40)
 13230 |     |             m3 := mload(0x60)
 13231 |     |             m4 := mload(0x80)
 13232 |     |             m5 := mload(0xa0)
 13233 |     |             m6 := mload(0xc0)
 13234 |     |             m7 := mload(0xe0)
 13235 |     |             m8 := mload(0x100)
 13236 |     |             m9 := mload(0x120)
 13237 |     |             m10 := mload(0x140)
 13238 |     |             // Selector of `log(string,string,address,string)`.
 13239 |     |             mstore(0x00, 0xeb1bff80)
 13240 |     |             mstore(0x20, 0x80)
 13241 |     |             mstore(0x40, 0xc0)
 13242 |     |             mstore(0x60, p2)
 13243 |     |             mstore(0x80, 0x100)
 13244 |     |             writeString(0xa0, p0)
 13245 |     |             writeString(0xe0, p1)
 13246 |     |             writeString(0x120, p3)
 13247 |     |         }
 13248 |     |         _sendLogPayload(0x1c, 0x144);
 13249 |     |         /// @solidity memory-safe-assembly
 13250 |     |         assembly {
 13251 |     |             mstore(0x00, m0)
 13252 |     |             mstore(0x20, m1)
 13253 |     |             mstore(0x40, m2)
 13254 |     |             mstore(0x60, m3)
 13255 |     |             mstore(0x80, m4)
 13256 |     |             mstore(0xa0, m5)
 13257 |     |             mstore(0xc0, m6)
 13258 |     |             mstore(0xe0, m7)
 13259 |     |             mstore(0x100, m8)
 13260 |     |             mstore(0x120, m9)
 13261 |     |             mstore(0x140, m10)
 13262 |     |         }
 13263 |     |     }
 13264 |     | 
 13265 |     |     function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {
 13266 |     |         bytes32 m0;
 13267 |     |         bytes32 m1;
 13268 |     |         bytes32 m2;
 13269 |     |         bytes32 m3;
 13270 |     |         bytes32 m4;
 13271 |     |         bytes32 m5;
 13272 |     |         bytes32 m6;
 13273 |     |         bytes32 m7;
 13274 |     |         bytes32 m8;
 13275 |     |         /// @solidity memory-safe-assembly
 13276 |     |         assembly {
 13277 |     |             function writeString(pos, w) {
 13278 |     |                 let length := 0
 13279 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13280 |     |                 mstore(pos, length)
 13281 |     |                 let shift := sub(256, shl(3, length))
 13282 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13283 |     |             }
 13284 |     |             m0 := mload(0x00)
 13285 |     |             m1 := mload(0x20)
 13286 |     |             m2 := mload(0x40)
 13287 |     |             m3 := mload(0x60)
 13288 |     |             m4 := mload(0x80)
 13289 |     |             m5 := mload(0xa0)
 13290 |     |             m6 := mload(0xc0)
 13291 |     |             m7 := mload(0xe0)
 13292 |     |             m8 := mload(0x100)
 13293 |     |             // Selector of `log(string,string,bool,address)`.
 13294 |     |             mstore(0x00, 0xc371c7db)
 13295 |     |             mstore(0x20, 0x80)
 13296 |     |             mstore(0x40, 0xc0)
 13297 |     |             mstore(0x60, p2)
 13298 |     |             mstore(0x80, p3)
 13299 |     |             writeString(0xa0, p0)
 13300 |     |             writeString(0xe0, p1)
 13301 |     |         }
 13302 |     |         _sendLogPayload(0x1c, 0x104);
 13303 |     |         /// @solidity memory-safe-assembly
 13304 |     |         assembly {
 13305 |     |             mstore(0x00, m0)
 13306 |     |             mstore(0x20, m1)
 13307 |     |             mstore(0x40, m2)
 13308 |     |             mstore(0x60, m3)
 13309 |     |             mstore(0x80, m4)
 13310 |     |             mstore(0xa0, m5)
 13311 |     |             mstore(0xc0, m6)
 13312 |     |             mstore(0xe0, m7)
 13313 |     |             mstore(0x100, m8)
 13314 |     |         }
 13315 |     |     }
 13316 |     | 
 13317 |     |     function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {
 13318 |     |         bytes32 m0;
 13319 |     |         bytes32 m1;
 13320 |     |         bytes32 m2;
 13321 |     |         bytes32 m3;
 13322 |     |         bytes32 m4;
 13323 |     |         bytes32 m5;
 13324 |     |         bytes32 m6;
 13325 |     |         bytes32 m7;
 13326 |     |         bytes32 m8;
 13327 |     |         /// @solidity memory-safe-assembly
 13328 |     |         assembly {
 13329 |     |             function writeString(pos, w) {
 13330 |     |                 let length := 0
 13331 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13332 |     |                 mstore(pos, length)
 13333 |     |                 let shift := sub(256, shl(3, length))
 13334 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13335 |     |             }
 13336 |     |             m0 := mload(0x00)
 13337 |     |             m1 := mload(0x20)
 13338 |     |             m2 := mload(0x40)
 13339 |     |             m3 := mload(0x60)
 13340 |     |             m4 := mload(0x80)
 13341 |     |             m5 := mload(0xa0)
 13342 |     |             m6 := mload(0xc0)
 13343 |     |             m7 := mload(0xe0)
 13344 |     |             m8 := mload(0x100)
 13345 |     |             // Selector of `log(string,string,bool,bool)`.
 13346 |     |             mstore(0x00, 0x40785869)
 13347 |     |             mstore(0x20, 0x80)
 13348 |     |             mstore(0x40, 0xc0)
 13349 |     |             mstore(0x60, p2)
 13350 |     |             mstore(0x80, p3)
 13351 |     |             writeString(0xa0, p0)
 13352 |     |             writeString(0xe0, p1)
 13353 |     |         }
 13354 |     |         _sendLogPayload(0x1c, 0x104);
 13355 |     |         /// @solidity memory-safe-assembly
 13356 |     |         assembly {
 13357 |     |             mstore(0x00, m0)
 13358 |     |             mstore(0x20, m1)
 13359 |     |             mstore(0x40, m2)
 13360 |     |             mstore(0x60, m3)
 13361 |     |             mstore(0x80, m4)
 13362 |     |             mstore(0xa0, m5)
 13363 |     |             mstore(0xc0, m6)
 13364 |     |             mstore(0xe0, m7)
 13365 |     |             mstore(0x100, m8)
 13366 |     |         }
 13367 |     |     }
 13368 |     | 
 13369 |     |     function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {
 13370 |     |         bytes32 m0;
 13371 |     |         bytes32 m1;
 13372 |     |         bytes32 m2;
 13373 |     |         bytes32 m3;
 13374 |     |         bytes32 m4;
 13375 |     |         bytes32 m5;
 13376 |     |         bytes32 m6;
 13377 |     |         bytes32 m7;
 13378 |     |         bytes32 m8;
 13379 |     |         /// @solidity memory-safe-assembly
 13380 |     |         assembly {
 13381 |     |             function writeString(pos, w) {
 13382 |     |                 let length := 0
 13383 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13384 |     |                 mstore(pos, length)
 13385 |     |                 let shift := sub(256, shl(3, length))
 13386 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13387 |     |             }
 13388 |     |             m0 := mload(0x00)
 13389 |     |             m1 := mload(0x20)
 13390 |     |             m2 := mload(0x40)
 13391 |     |             m3 := mload(0x60)
 13392 |     |             m4 := mload(0x80)
 13393 |     |             m5 := mload(0xa0)
 13394 |     |             m6 := mload(0xc0)
 13395 |     |             m7 := mload(0xe0)
 13396 |     |             m8 := mload(0x100)
 13397 |     |             // Selector of `log(string,string,bool,uint256)`.
 13398 |     |             mstore(0x00, 0xd6aefad2)
 13399 |     |             mstore(0x20, 0x80)
 13400 |     |             mstore(0x40, 0xc0)
 13401 |     |             mstore(0x60, p2)
 13402 |     |             mstore(0x80, p3)
 13403 |     |             writeString(0xa0, p0)
 13404 |     |             writeString(0xe0, p1)
 13405 |     |         }
 13406 |     |         _sendLogPayload(0x1c, 0x104);
 13407 |     |         /// @solidity memory-safe-assembly
 13408 |     |         assembly {
 13409 |     |             mstore(0x00, m0)
 13410 |     |             mstore(0x20, m1)
 13411 |     |             mstore(0x40, m2)
 13412 |     |             mstore(0x60, m3)
 13413 |     |             mstore(0x80, m4)
 13414 |     |             mstore(0xa0, m5)
 13415 |     |             mstore(0xc0, m6)
 13416 |     |             mstore(0xe0, m7)
 13417 |     |             mstore(0x100, m8)
 13418 |     |         }
 13419 |     |     }
 13420 |     | 
 13421 |     |     function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
 13422 |     |         bytes32 m0;
 13423 |     |         bytes32 m1;
 13424 |     |         bytes32 m2;
 13425 |     |         bytes32 m3;
 13426 |     |         bytes32 m4;
 13427 |     |         bytes32 m5;
 13428 |     |         bytes32 m6;
 13429 |     |         bytes32 m7;
 13430 |     |         bytes32 m8;
 13431 |     |         bytes32 m9;
 13432 |     |         bytes32 m10;
 13433 |     |         /// @solidity memory-safe-assembly
 13434 |     |         assembly {
 13435 |     |             function writeString(pos, w) {
 13436 |     |                 let length := 0
 13437 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13438 |     |                 mstore(pos, length)
 13439 |     |                 let shift := sub(256, shl(3, length))
 13440 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13441 |     |             }
 13442 |     |             m0 := mload(0x00)
 13443 |     |             m1 := mload(0x20)
 13444 |     |             m2 := mload(0x40)
 13445 |     |             m3 := mload(0x60)
 13446 |     |             m4 := mload(0x80)
 13447 |     |             m5 := mload(0xa0)
 13448 |     |             m6 := mload(0xc0)
 13449 |     |             m7 := mload(0xe0)
 13450 |     |             m8 := mload(0x100)
 13451 |     |             m9 := mload(0x120)
 13452 |     |             m10 := mload(0x140)
 13453 |     |             // Selector of `log(string,string,bool,string)`.
 13454 |     |             mstore(0x00, 0x5e84b0ea)
 13455 |     |             mstore(0x20, 0x80)
 13456 |     |             mstore(0x40, 0xc0)
 13457 |     |             mstore(0x60, p2)
 13458 |     |             mstore(0x80, 0x100)
 13459 |     |             writeString(0xa0, p0)
 13460 |     |             writeString(0xe0, p1)
 13461 |     |             writeString(0x120, p3)
 13462 |     |         }
 13463 |     |         _sendLogPayload(0x1c, 0x144);
 13464 |     |         /// @solidity memory-safe-assembly
 13465 |     |         assembly {
 13466 |     |             mstore(0x00, m0)
 13467 |     |             mstore(0x20, m1)
 13468 |     |             mstore(0x40, m2)
 13469 |     |             mstore(0x60, m3)
 13470 |     |             mstore(0x80, m4)
 13471 |     |             mstore(0xa0, m5)
 13472 |     |             mstore(0xc0, m6)
 13473 |     |             mstore(0xe0, m7)
 13474 |     |             mstore(0x100, m8)
 13475 |     |             mstore(0x120, m9)
 13476 |     |             mstore(0x140, m10)
 13477 |     |         }
 13478 |     |     }
 13479 |     | 
 13480 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {
 13481 |     |         bytes32 m0;
 13482 |     |         bytes32 m1;
 13483 |     |         bytes32 m2;
 13484 |     |         bytes32 m3;
 13485 |     |         bytes32 m4;
 13486 |     |         bytes32 m5;
 13487 |     |         bytes32 m6;
 13488 |     |         bytes32 m7;
 13489 |     |         bytes32 m8;
 13490 |     |         /// @solidity memory-safe-assembly
 13491 |     |         assembly {
 13492 |     |             function writeString(pos, w) {
 13493 |     |                 let length := 0
 13494 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13495 |     |                 mstore(pos, length)
 13496 |     |                 let shift := sub(256, shl(3, length))
 13497 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13498 |     |             }
 13499 |     |             m0 := mload(0x00)
 13500 |     |             m1 := mload(0x20)
 13501 |     |             m2 := mload(0x40)
 13502 |     |             m3 := mload(0x60)
 13503 |     |             m4 := mload(0x80)
 13504 |     |             m5 := mload(0xa0)
 13505 |     |             m6 := mload(0xc0)
 13506 |     |             m7 := mload(0xe0)
 13507 |     |             m8 := mload(0x100)
 13508 |     |             // Selector of `log(string,string,uint256,address)`.
 13509 |     |             mstore(0x00, 0x1023f7b2)
 13510 |     |             mstore(0x20, 0x80)
 13511 |     |             mstore(0x40, 0xc0)
 13512 |     |             mstore(0x60, p2)
 13513 |     |             mstore(0x80, p3)
 13514 |     |             writeString(0xa0, p0)
 13515 |     |             writeString(0xe0, p1)
 13516 |     |         }
 13517 |     |         _sendLogPayload(0x1c, 0x104);
 13518 |     |         /// @solidity memory-safe-assembly
 13519 |     |         assembly {
 13520 |     |             mstore(0x00, m0)
 13521 |     |             mstore(0x20, m1)
 13522 |     |             mstore(0x40, m2)
 13523 |     |             mstore(0x60, m3)
 13524 |     |             mstore(0x80, m4)
 13525 |     |             mstore(0xa0, m5)
 13526 |     |             mstore(0xc0, m6)
 13527 |     |             mstore(0xe0, m7)
 13528 |     |             mstore(0x100, m8)
 13529 |     |         }
 13530 |     |     }
 13531 |     | 
 13532 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {
 13533 |     |         bytes32 m0;
 13534 |     |         bytes32 m1;
 13535 |     |         bytes32 m2;
 13536 |     |         bytes32 m3;
 13537 |     |         bytes32 m4;
 13538 |     |         bytes32 m5;
 13539 |     |         bytes32 m6;
 13540 |     |         bytes32 m7;
 13541 |     |         bytes32 m8;
 13542 |     |         /// @solidity memory-safe-assembly
 13543 |     |         assembly {
 13544 |     |             function writeString(pos, w) {
 13545 |     |                 let length := 0
 13546 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13547 |     |                 mstore(pos, length)
 13548 |     |                 let shift := sub(256, shl(3, length))
 13549 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13550 |     |             }
 13551 |     |             m0 := mload(0x00)
 13552 |     |             m1 := mload(0x20)
 13553 |     |             m2 := mload(0x40)
 13554 |     |             m3 := mload(0x60)
 13555 |     |             m4 := mload(0x80)
 13556 |     |             m5 := mload(0xa0)
 13557 |     |             m6 := mload(0xc0)
 13558 |     |             m7 := mload(0xe0)
 13559 |     |             m8 := mload(0x100)
 13560 |     |             // Selector of `log(string,string,uint256,bool)`.
 13561 |     |             mstore(0x00, 0xc3a8a654)
 13562 |     |             mstore(0x20, 0x80)
 13563 |     |             mstore(0x40, 0xc0)
 13564 |     |             mstore(0x60, p2)
 13565 |     |             mstore(0x80, p3)
 13566 |     |             writeString(0xa0, p0)
 13567 |     |             writeString(0xe0, p1)
 13568 |     |         }
 13569 |     |         _sendLogPayload(0x1c, 0x104);
 13570 |     |         /// @solidity memory-safe-assembly
 13571 |     |         assembly {
 13572 |     |             mstore(0x00, m0)
 13573 |     |             mstore(0x20, m1)
 13574 |     |             mstore(0x40, m2)
 13575 |     |             mstore(0x60, m3)
 13576 |     |             mstore(0x80, m4)
 13577 |     |             mstore(0xa0, m5)
 13578 |     |             mstore(0xc0, m6)
 13579 |     |             mstore(0xe0, m7)
 13580 |     |             mstore(0x100, m8)
 13581 |     |         }
 13582 |     |     }
 13583 |     | 
 13584 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
 13585 |     |         bytes32 m0;
 13586 |     |         bytes32 m1;
 13587 |     |         bytes32 m2;
 13588 |     |         bytes32 m3;
 13589 |     |         bytes32 m4;
 13590 |     |         bytes32 m5;
 13591 |     |         bytes32 m6;
 13592 |     |         bytes32 m7;
 13593 |     |         bytes32 m8;
 13594 |     |         /// @solidity memory-safe-assembly
 13595 |     |         assembly {
 13596 |     |             function writeString(pos, w) {
 13597 |     |                 let length := 0
 13598 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13599 |     |                 mstore(pos, length)
 13600 |     |                 let shift := sub(256, shl(3, length))
 13601 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13602 |     |             }
 13603 |     |             m0 := mload(0x00)
 13604 |     |             m1 := mload(0x20)
 13605 |     |             m2 := mload(0x40)
 13606 |     |             m3 := mload(0x60)
 13607 |     |             m4 := mload(0x80)
 13608 |     |             m5 := mload(0xa0)
 13609 |     |             m6 := mload(0xc0)
 13610 |     |             m7 := mload(0xe0)
 13611 |     |             m8 := mload(0x100)
 13612 |     |             // Selector of `log(string,string,uint256,uint256)`.
 13613 |     |             mstore(0x00, 0xf45d7d2c)
 13614 |     |             mstore(0x20, 0x80)
 13615 |     |             mstore(0x40, 0xc0)
 13616 |     |             mstore(0x60, p2)
 13617 |     |             mstore(0x80, p3)
 13618 |     |             writeString(0xa0, p0)
 13619 |     |             writeString(0xe0, p1)
 13620 |     |         }
 13621 |     |         _sendLogPayload(0x1c, 0x104);
 13622 |     |         /// @solidity memory-safe-assembly
 13623 |     |         assembly {
 13624 |     |             mstore(0x00, m0)
 13625 |     |             mstore(0x20, m1)
 13626 |     |             mstore(0x40, m2)
 13627 |     |             mstore(0x60, m3)
 13628 |     |             mstore(0x80, m4)
 13629 |     |             mstore(0xa0, m5)
 13630 |     |             mstore(0xc0, m6)
 13631 |     |             mstore(0xe0, m7)
 13632 |     |             mstore(0x100, m8)
 13633 |     |         }
 13634 |     |     }
 13635 |     | 
 13636 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
 13637 |     |         bytes32 m0;
 13638 |     |         bytes32 m1;
 13639 |     |         bytes32 m2;
 13640 |     |         bytes32 m3;
 13641 |     |         bytes32 m4;
 13642 |     |         bytes32 m5;
 13643 |     |         bytes32 m6;
 13644 |     |         bytes32 m7;
 13645 |     |         bytes32 m8;
 13646 |     |         bytes32 m9;
 13647 |     |         bytes32 m10;
 13648 |     |         /// @solidity memory-safe-assembly
 13649 |     |         assembly {
 13650 |     |             function writeString(pos, w) {
 13651 |     |                 let length := 0
 13652 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13653 |     |                 mstore(pos, length)
 13654 |     |                 let shift := sub(256, shl(3, length))
 13655 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13656 |     |             }
 13657 |     |             m0 := mload(0x00)
 13658 |     |             m1 := mload(0x20)
 13659 |     |             m2 := mload(0x40)
 13660 |     |             m3 := mload(0x60)
 13661 |     |             m4 := mload(0x80)
 13662 |     |             m5 := mload(0xa0)
 13663 |     |             m6 := mload(0xc0)
 13664 |     |             m7 := mload(0xe0)
 13665 |     |             m8 := mload(0x100)
 13666 |     |             m9 := mload(0x120)
 13667 |     |             m10 := mload(0x140)
 13668 |     |             // Selector of `log(string,string,uint256,string)`.
 13669 |     |             mstore(0x00, 0x5d1a971a)
 13670 |     |             mstore(0x20, 0x80)
 13671 |     |             mstore(0x40, 0xc0)
 13672 |     |             mstore(0x60, p2)
 13673 |     |             mstore(0x80, 0x100)
 13674 |     |             writeString(0xa0, p0)
 13675 |     |             writeString(0xe0, p1)
 13676 |     |             writeString(0x120, p3)
 13677 |     |         }
 13678 |     |         _sendLogPayload(0x1c, 0x144);
 13679 |     |         /// @solidity memory-safe-assembly
 13680 |     |         assembly {
 13681 |     |             mstore(0x00, m0)
 13682 |     |             mstore(0x20, m1)
 13683 |     |             mstore(0x40, m2)
 13684 |     |             mstore(0x60, m3)
 13685 |     |             mstore(0x80, m4)
 13686 |     |             mstore(0xa0, m5)
 13687 |     |             mstore(0xc0, m6)
 13688 |     |             mstore(0xe0, m7)
 13689 |     |             mstore(0x100, m8)
 13690 |     |             mstore(0x120, m9)
 13691 |     |             mstore(0x140, m10)
 13692 |     |         }
 13693 |     |     }
 13694 |     | 
 13695 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {
 13696 |     |         bytes32 m0;
 13697 |     |         bytes32 m1;
 13698 |     |         bytes32 m2;
 13699 |     |         bytes32 m3;
 13700 |     |         bytes32 m4;
 13701 |     |         bytes32 m5;
 13702 |     |         bytes32 m6;
 13703 |     |         bytes32 m7;
 13704 |     |         bytes32 m8;
 13705 |     |         bytes32 m9;
 13706 |     |         bytes32 m10;
 13707 |     |         /// @solidity memory-safe-assembly
 13708 |     |         assembly {
 13709 |     |             function writeString(pos, w) {
 13710 |     |                 let length := 0
 13711 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13712 |     |                 mstore(pos, length)
 13713 |     |                 let shift := sub(256, shl(3, length))
 13714 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13715 |     |             }
 13716 |     |             m0 := mload(0x00)
 13717 |     |             m1 := mload(0x20)
 13718 |     |             m2 := mload(0x40)
 13719 |     |             m3 := mload(0x60)
 13720 |     |             m4 := mload(0x80)
 13721 |     |             m5 := mload(0xa0)
 13722 |     |             m6 := mload(0xc0)
 13723 |     |             m7 := mload(0xe0)
 13724 |     |             m8 := mload(0x100)
 13725 |     |             m9 := mload(0x120)
 13726 |     |             m10 := mload(0x140)
 13727 |     |             // Selector of `log(string,string,string,address)`.
 13728 |     |             mstore(0x00, 0x6d572f44)
 13729 |     |             mstore(0x20, 0x80)
 13730 |     |             mstore(0x40, 0xc0)
 13731 |     |             mstore(0x60, 0x100)
 13732 |     |             mstore(0x80, p3)
 13733 |     |             writeString(0xa0, p0)
 13734 |     |             writeString(0xe0, p1)
 13735 |     |             writeString(0x120, p2)
 13736 |     |         }
 13737 |     |         _sendLogPayload(0x1c, 0x144);
 13738 |     |         /// @solidity memory-safe-assembly
 13739 |     |         assembly {
 13740 |     |             mstore(0x00, m0)
 13741 |     |             mstore(0x20, m1)
 13742 |     |             mstore(0x40, m2)
 13743 |     |             mstore(0x60, m3)
 13744 |     |             mstore(0x80, m4)
 13745 |     |             mstore(0xa0, m5)
 13746 |     |             mstore(0xc0, m6)
 13747 |     |             mstore(0xe0, m7)
 13748 |     |             mstore(0x100, m8)
 13749 |     |             mstore(0x120, m9)
 13750 |     |             mstore(0x140, m10)
 13751 |     |         }
 13752 |     |     }
 13753 |     | 
 13754 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
 13755 |     |         bytes32 m0;
 13756 |     |         bytes32 m1;
 13757 |     |         bytes32 m2;
 13758 |     |         bytes32 m3;
 13759 |     |         bytes32 m4;
 13760 |     |         bytes32 m5;
 13761 |     |         bytes32 m6;
 13762 |     |         bytes32 m7;
 13763 |     |         bytes32 m8;
 13764 |     |         bytes32 m9;
 13765 |     |         bytes32 m10;
 13766 |     |         /// @solidity memory-safe-assembly
 13767 |     |         assembly {
 13768 |     |             function writeString(pos, w) {
 13769 |     |                 let length := 0
 13770 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13771 |     |                 mstore(pos, length)
 13772 |     |                 let shift := sub(256, shl(3, length))
 13773 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13774 |     |             }
 13775 |     |             m0 := mload(0x00)
 13776 |     |             m1 := mload(0x20)
 13777 |     |             m2 := mload(0x40)
 13778 |     |             m3 := mload(0x60)
 13779 |     |             m4 := mload(0x80)
 13780 |     |             m5 := mload(0xa0)
 13781 |     |             m6 := mload(0xc0)
 13782 |     |             m7 := mload(0xe0)
 13783 |     |             m8 := mload(0x100)
 13784 |     |             m9 := mload(0x120)
 13785 |     |             m10 := mload(0x140)
 13786 |     |             // Selector of `log(string,string,string,bool)`.
 13787 |     |             mstore(0x00, 0x2c1754ed)
 13788 |     |             mstore(0x20, 0x80)
 13789 |     |             mstore(0x40, 0xc0)
 13790 |     |             mstore(0x60, 0x100)
 13791 |     |             mstore(0x80, p3)
 13792 |     |             writeString(0xa0, p0)
 13793 |     |             writeString(0xe0, p1)
 13794 |     |             writeString(0x120, p2)
 13795 |     |         }
 13796 |     |         _sendLogPayload(0x1c, 0x144);
 13797 |     |         /// @solidity memory-safe-assembly
 13798 |     |         assembly {
 13799 |     |             mstore(0x00, m0)
 13800 |     |             mstore(0x20, m1)
 13801 |     |             mstore(0x40, m2)
 13802 |     |             mstore(0x60, m3)
 13803 |     |             mstore(0x80, m4)
 13804 |     |             mstore(0xa0, m5)
 13805 |     |             mstore(0xc0, m6)
 13806 |     |             mstore(0xe0, m7)
 13807 |     |             mstore(0x100, m8)
 13808 |     |             mstore(0x120, m9)
 13809 |     |             mstore(0x140, m10)
 13810 |     |         }
 13811 |     |     }
 13812 |     | 
 13813 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
 13814 |     |         bytes32 m0;
 13815 |     |         bytes32 m1;
 13816 |     |         bytes32 m2;
 13817 |     |         bytes32 m3;
 13818 |     |         bytes32 m4;
 13819 |     |         bytes32 m5;
 13820 |     |         bytes32 m6;
 13821 |     |         bytes32 m7;
 13822 |     |         bytes32 m8;
 13823 |     |         bytes32 m9;
 13824 |     |         bytes32 m10;
 13825 |     |         /// @solidity memory-safe-assembly
 13826 |     |         assembly {
 13827 |     |             function writeString(pos, w) {
 13828 |     |                 let length := 0
 13829 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13830 |     |                 mstore(pos, length)
 13831 |     |                 let shift := sub(256, shl(3, length))
 13832 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13833 |     |             }
 13834 |     |             m0 := mload(0x00)
 13835 |     |             m1 := mload(0x20)
 13836 |     |             m2 := mload(0x40)
 13837 |     |             m3 := mload(0x60)
 13838 |     |             m4 := mload(0x80)
 13839 |     |             m5 := mload(0xa0)
 13840 |     |             m6 := mload(0xc0)
 13841 |     |             m7 := mload(0xe0)
 13842 |     |             m8 := mload(0x100)
 13843 |     |             m9 := mload(0x120)
 13844 |     |             m10 := mload(0x140)
 13845 |     |             // Selector of `log(string,string,string,uint256)`.
 13846 |     |             mstore(0x00, 0x8eafb02b)
 13847 |     |             mstore(0x20, 0x80)
 13848 |     |             mstore(0x40, 0xc0)
 13849 |     |             mstore(0x60, 0x100)
 13850 |     |             mstore(0x80, p3)
 13851 |     |             writeString(0xa0, p0)
 13852 |     |             writeString(0xe0, p1)
 13853 |     |             writeString(0x120, p2)
 13854 |     |         }
 13855 |     |         _sendLogPayload(0x1c, 0x144);
 13856 |     |         /// @solidity memory-safe-assembly
 13857 |     |         assembly {
 13858 |     |             mstore(0x00, m0)
 13859 |     |             mstore(0x20, m1)
 13860 |     |             mstore(0x40, m2)
 13861 |     |             mstore(0x60, m3)
 13862 |     |             mstore(0x80, m4)
 13863 |     |             mstore(0xa0, m5)
 13864 |     |             mstore(0xc0, m6)
 13865 |     |             mstore(0xe0, m7)
 13866 |     |             mstore(0x100, m8)
 13867 |     |             mstore(0x120, m9)
 13868 |     |             mstore(0x140, m10)
 13869 |     |         }
 13870 |     |     }
 13871 |     | 
 13872 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
 13873 |     |         bytes32 m0;
 13874 |     |         bytes32 m1;
 13875 |     |         bytes32 m2;
 13876 |     |         bytes32 m3;
 13877 |     |         bytes32 m4;
 13878 |     |         bytes32 m5;
 13879 |     |         bytes32 m6;
 13880 |     |         bytes32 m7;
 13881 |     |         bytes32 m8;
 13882 |     |         bytes32 m9;
 13883 |     |         bytes32 m10;
 13884 |     |         bytes32 m11;
 13885 |     |         bytes32 m12;
 13886 |     |         /// @solidity memory-safe-assembly
 13887 |     |         assembly {
 13888 |     |             function writeString(pos, w) {
 13889 |     |                 let length := 0
 13890 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13891 |     |                 mstore(pos, length)
 13892 |     |                 let shift := sub(256, shl(3, length))
 13893 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13894 |     |             }
 13895 |     |             m0 := mload(0x00)
 13896 |     |             m1 := mload(0x20)
 13897 |     |             m2 := mload(0x40)
 13898 |     |             m3 := mload(0x60)
 13899 |     |             m4 := mload(0x80)
 13900 |     |             m5 := mload(0xa0)
 13901 |     |             m6 := mload(0xc0)
 13902 |     |             m7 := mload(0xe0)
 13903 |     |             m8 := mload(0x100)
 13904 |     |             m9 := mload(0x120)
 13905 |     |             m10 := mload(0x140)
 13906 |     |             m11 := mload(0x160)
 13907 |     |             m12 := mload(0x180)
 13908 |     |             // Selector of `log(string,string,string,string)`.
 13909 |     |             mstore(0x00, 0xde68f20a)
 13910 |     |             mstore(0x20, 0x80)
 13911 |     |             mstore(0x40, 0xc0)
 13912 |     |             mstore(0x60, 0x100)
 13913 |     |             mstore(0x80, 0x140)
 13914 |     |             writeString(0xa0, p0)
 13915 |     |             writeString(0xe0, p1)
 13916 |     |             writeString(0x120, p2)
 13917 |     |             writeString(0x160, p3)
 13918 |     |         }
 13919 |     |         _sendLogPayload(0x1c, 0x184);
 13920 |     |         /// @solidity memory-safe-assembly
 13921 |     |         assembly {
 13922 |     |             mstore(0x00, m0)
 13923 |     |             mstore(0x20, m1)
 13924 |     |             mstore(0x40, m2)
 13925 |     |             mstore(0x60, m3)
 13926 |     |             mstore(0x80, m4)
 13927 |     |             mstore(0xa0, m5)
 13928 |     |             mstore(0xc0, m6)
 13929 |     |             mstore(0xe0, m7)
 13930 |     |             mstore(0x100, m8)
 13931 |     |             mstore(0x120, m9)
 13932 |     |             mstore(0x140, m10)
 13933 |     |             mstore(0x160, m11)
 13934 |     |             mstore(0x180, m12)
 13935 |     |         }
 13936 |     |     }
 13937 |     | }
 13938 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/fuzzlib/src/FuzzBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {Fuzzlib} from "./Fuzzlib.sol";
  5 |     | import {PlatformCrytic} from "./platform/PlatformCrytic.sol";
  6 |     | 
  7 |     | abstract contract FuzzBase {
  8 | *   |     Fuzzlib internal fl = new Fuzzlib();
  9 |     | 
 10 |     |     constructor() {
 11 | *   |         fl.setPlatform(address(new PlatformCrytic()));
 12 |     |     }
 13 |     | }
 14 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/fuzzlib/src/FuzzLibString.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | /// @notice Efficient library for creating string representations of integers.
   5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
   6 |     | /// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)
   7 |     | /// @author Modified from Crytic Properties (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   8 |     | library FuzzLibString {
   9 |     |     bytes16 internal constant HEX_DIGITS = "0123456789abcdef";
  10 |     | 
  11 | *   |     function toString(int256 value) internal pure returns (string memory str) {
  12 | *   |         uint256 absValue = value >= 0 ? uint256(value) : uint256(-value);
  13 | *   |         str = toString(absValue);
  14 |     | 
  15 | *   |         if (value < 0) {
  16 |     |             str = string(abi.encodePacked("-", str));
  17 |     |         }
  18 |     |     }
  19 |     | 
  20 | *   |     function toString(uint256 value) internal pure returns (string memory str) {
  21 |     |         /// @solidity memory-safe-assembly
  22 | *   |         assembly {
  23 |     |             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes
  24 |     |             // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the
  25 |     |             // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.
  26 | *   |             let newFreeMemoryPointer := add(mload(0x40), 160)
  27 |     | 
  28 |     |             // Update the free memory pointer to avoid overriding our string.
  29 | *   |             mstore(0x40, newFreeMemoryPointer)
  30 |     | 
  31 |     |             // Assign str to the end of the zone of newly allocated memory.
  32 | *   |             str := sub(newFreeMemoryPointer, 32)
  33 |     | 
  34 |     |             // Clean the last word of memory it may not be overwritten.
  35 | *   |             mstore(str, 0)
  36 |     | 
  37 |     |             // Cache the end of the memory to calculate the length later.
  38 | *   |             let end := str
  39 |     | 
  40 |     |             // We write the string from rightmost digit to leftmost digit.
  41 |     |             // The following is essentially a do-while loop that also handles the zero case.
  42 |     |             // prettier-ignore
  43 | *   |             for { let temp := value } 1 {} {
  44 |     |                 // Move the pointer 1 byte to the left.
  45 | *   |                 str := sub(str, 1)
  46 |     | 
  47 |     |                 // Write the character to the pointer.
  48 |     |                 // The ASCII index of the '0' character is 48.
  49 | *   |                 mstore8(str, add(48, mod(temp, 10)))
  50 |     | 
  51 |     |                 // Keep dividing temp until zero.
  52 | *   |                 temp := div(temp, 10)
  53 |     | 
  54 |     |                  // prettier-ignore
  55 | *   |                 if iszero(temp) { break }
  56 |     |             }
  57 |     | 
  58 |     |             // Compute and cache the final total length of the string.
  59 | *   |             let length := sub(end, str)
  60 |     | 
  61 |     |             // Move the pointer 32 bytes leftwards to make room for the length.
  62 | *   |             str := sub(str, 32)
  63 |     | 
  64 |     |             // Store the string's length at the start of memory allocated for our string.
  65 | *   |             mstore(str, length)
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     function toString(address value) internal pure returns (string memory str) {
  70 |     |         bytes memory s = new bytes(40);
  71 |     |         for (uint256 i = 0; i < 20; i++) {
  72 |     |             bytes1 b = bytes1(
  73 |     |                 uint8(uint256(uint160(value)) / (2**(8 * (19 - i))))
  74 |     |             );
  75 |     |             bytes1 hi = bytes1(uint8(b) / 16);
  76 |     |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
  77 |     |             s[2 * i] = char(hi);
  78 |     |             s[2 * i + 1] = char(lo);
  79 |     |         }
  80 |     |         return string(s);
  81 |     |     }
  82 |     | 
  83 |     |     function char(bytes1 b) internal pure returns (bytes1 c) {
  84 |     |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
  85 |     |         else return bytes1(uint8(b) + 0x57);
  86 |     |     }
  87 |     | 
  88 |     |     // based on OZ's toHexString
  89 |     |     // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol
  90 | *   |     function toHexString(bytes memory value)
  91 |     |         internal
  92 |     |         pure
  93 | *   |         returns (string memory)
  94 |     |     {
  95 | *   |         bytes memory buffer = new bytes(2 * value.length + 2);
  96 | *   |         buffer[0] = "0";
  97 | *   |         buffer[1] = "x";
  98 | *   |         for (uint256 i = 0; i < value.length; i++) {
  99 | *   |             uint8 valueByte = uint8(value[i]);
 100 | *   |             buffer[2 * i + 2] = HEX_DIGITS[valueByte >> 4];
 101 | *   |             buffer[2 * i + 3] = HEX_DIGITS[valueByte & 0xf];
 102 |     |         }
 103 | *   |         return string(buffer);
 104 |     |     }
 105 |     | 
 106 |     |     // https://ethereum.stackexchange.com/a/83577
 107 |     |     function getRevertMsg(bytes memory returnData)
 108 |     |         internal
 109 |     |         pure
 110 |     |         returns (string memory)
 111 |     |     {
 112 |     |         // Check that the data has the right size: 4 bytes for signature + 32 bytes for panic code
 113 |     |         if (returnData.length == 4 + 32) {
 114 |     |             // Check that the data starts with the Panic signature
 115 |     |             bytes4 panicSignature = bytes4(keccak256(bytes("Panic(uint256)")));
 116 |     |             for (uint256 i = 0; i < 4; i++) {
 117 |     |                 if (returnData[i] != panicSignature[i])
 118 |     |                     return "Undefined signature";
 119 |     |             }
 120 |     | 
 121 |     |             uint256 panicCode;
 122 |     |             for (uint256 i = 4; i < 36; i++) {
 123 |     |                 panicCode = panicCode << 8;
 124 |     |                 panicCode |= uint8(returnData[i]);
 125 |     |             }
 126 |     | 
 127 |     |             // Now convert the panic code into its string representation
 128 |     |             if (panicCode == 17) {
 129 |     |                 return "Panic(17)";
 130 |     |             }
 131 |     | 
 132 |     |             // Add other panic codes as needed or return a generic "Unknown panic"
 133 |     |             return "Undefined panic code";
 134 |     |         }
 135 |     | 
 136 |     |         // If the returnData length is less than 68, then the transaction failed silently (without a revert message)
 137 |     |         if (returnData.length < 68) return "Transaction reverted silently";
 138 |     | 
 139 |     |         assembly {
 140 |     |             // Slice the sighash.
 141 |     |             returnData := add(returnData, 0x04)
 142 |     |         }
 143 |     |         return abi.decode(returnData, (string)); // All that remains is the revert string
 144 |     |     }
 145 |     | 
 146 |     |     function isRevertReasonEqual(bytes memory returnData, string memory reason)
 147 |     |         internal
 148 |     |         pure
 149 |     |         returns (bool)
 150 |     |     {
 151 |     |         return (keccak256(abi.encodePacked(getRevertMsg(returnData))) ==
 152 |     |             keccak256(abi.encodePacked(reason)));
 153 |     |     }
 154 |     | }
 155 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/fuzzlib/src/Fuzzlib.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {HelperBase} from "./helpers/HelperBase.sol";
  5 |     | import {HelperAssert} from "./helpers/HelperAssert.sol";
  6 |     | import {HelperClamp} from "./helpers/HelperClamp.sol";
  7 |     | import {HelperLog} from "./helpers/HelperLog.sol";
  8 |     | import {HelperMath} from "./helpers/HelperMath.sol";
  9 |     | import {HelperRandom} from "./helpers/HelperRandom.sol";
 10 |     | 
 11 | *   | contract Fuzzlib is
 12 |     |     HelperBase,
 13 |     |     HelperAssert,
 14 |     |     HelperClamp,
 15 |     |     HelperLog,
 16 |     |     HelperMath,
 17 |     |     HelperRandom
 18 |     | {}
 19 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/fuzzlib/src/helpers/HelperAssert.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./HelperBase.sol";
   5 |     | 
   6 |     | import "../FuzzLibString.sol";
   7 |     | 
   8 |     | /// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   9 |     | abstract contract HelperAssert is HelperBase {
  10 |     |     event AssertFail(string);
  11 |     |     event AssertEqFail(string);
  12 |     |     event AssertNeqFail(string);
  13 |     |     event AssertGteFail(string);
  14 |     |     event AssertGtFail(string);
  15 |     |     event AssertLteFail(string);
  16 |     |     event AssertLtFail(string);
  17 |     | 
  18 | *   |     function t(bool b, string memory reason) public {
  19 | *   |         if (!b) {
  20 | *   |             emit AssertFail(reason);
  21 | *   |             platform.assertFail();
  22 |     |         }
  23 |     |     }
  24 |     | 
  25 |     |     /// @notice asserts that a is equal to b. Violations are logged using reason.
  26 | *   |     function eq(
  27 |     |         uint256 a,
  28 |     |         uint256 b,
  29 |     |         string memory reason
  30 |     |     ) public {
  31 | *   |         if (a != b) {
  32 |     |             string memory aStr = FuzzLibString.toString(a);
  33 |     |             string memory bStr = FuzzLibString.toString(b);
  34 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  35 |     |             emit AssertEqFail(assertMsg);
  36 |     |             platform.assertFail();
  37 |     |         }
  38 |     |     }
  39 |     | 
  40 |     |     /// @notice int256 version of eq
  41 |     |     function eq(
  42 |     |         int256 a,
  43 |     |         int256 b,
  44 |     |         string memory reason
  45 |     |     ) public {
  46 |     |         if (a != b) {
  47 |     |             string memory aStr = FuzzLibString.toString(a);
  48 |     |             string memory bStr = FuzzLibString.toString(b);
  49 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  50 |     |            emit AssertEqFail(assertMsg);
  51 |     |             platform.assertFail();
  52 |     |         }
  53 |     |     }
  54 |     | 
  55 |     |     /// @notice bool version of eq
  56 |     |     function eq(
  57 |     |         bool a,
  58 |     |         bool b,
  59 |     |         string memory reason
  60 |     |     ) public {
  61 |     |         if (a != b) {
  62 |     |             string memory aStr = a ? "true" : "false";
  63 |     |             string memory bStr = b ? "true" : "false";
  64 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  65 |     |             emit AssertEqFail(assertMsg);
  66 |     |             platform.assertFail();
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 |     |     /// @notice address version of eq
  71 |     |     function eq(
  72 |     |         address a,
  73 |     |         address b,
  74 |     |         string memory reason
  75 |     |     ) public {
  76 |     |         if (a != b) {
  77 |     |             string memory aStr = FuzzLibString.toString(a);
  78 |     |             string memory bStr = FuzzLibString.toString(b);
  79 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  80 |     |             emit AssertEqFail(assertMsg);
  81 |     |             platform.assertFail();
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     /// @notice bytes4 version of eq
  86 |     |     function eq(
  87 |     |         bytes4 a,
  88 |     |         bytes4 b,
  89 |     |         string memory reason
  90 |     |     ) public {
  91 |     |         if (a != b) {
  92 |     |             bytes memory aBytes = abi.encodePacked(a);
  93 |     |             bytes memory bBytes = abi.encodePacked(b);
  94 |     |             string memory aStr = FuzzLibString.toHexString(aBytes);
  95 |     |             string memory bStr = FuzzLibString.toHexString(bBytes);
  96 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  97 |     |             emit AssertEqFail(assertMsg);
  98 |     |             platform.assertFail();
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     /// @notice asserts that a is not equal to b. Violations are logged using reason.
 103 |     |     function neq(
 104 |     |         uint256 a,
 105 |     |         uint256 b,
 106 |     |         string memory reason
 107 |     |     ) public {
 108 |     |         if (a == b) {
 109 |     |             string memory aStr = FuzzLibString.toString(a);
 110 |     |             string memory bStr = FuzzLibString.toString(b);
 111 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "==", reason);
 112 |     |             emit AssertNeqFail(assertMsg);
 113 |     |             platform.assertFail();
 114 |     |         }
 115 |     |     }
 116 |     | 
 117 |     |     /// @notice int256 version of neq
 118 |     |     function neq(
 119 |     |         int256 a,
 120 |     |         int256 b,
 121 |     |         string memory reason
 122 |     |     ) public {
 123 |     |         if (a == b) {
 124 |     |             string memory aStr = FuzzLibString.toString(a);
 125 |     |             string memory bStr = FuzzLibString.toString(b);
 126 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "==", reason);
 127 |     |             emit AssertNeqFail(assertMsg);
 128 |     |             platform.assertFail();
 129 |     |         }
 130 |     |     }
 131 |     | 
 132 |     |     /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.
 133 | *   |     function gte(
 134 |     |         uint256 a,
 135 |     |         uint256 b,
 136 |     |         string memory reason
 137 |     |     ) public {
 138 | *   |         if (!(a >= b)) {
 139 |     |             string memory aStr = FuzzLibString.toString(a);
 140 |     |             string memory bStr = FuzzLibString.toString(b);
 141 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<", reason);
 142 |     |             emit AssertGteFail(assertMsg);
 143 |     |             platform.assertFail();
 144 |     |         }
 145 |     |     }
 146 |     | 
 147 |     |     /// @notice int256 version of gte
 148 |     |     function gte(
 149 |     |         int256 a,
 150 |     |         int256 b,
 151 |     |         string memory reason
 152 |     |     ) public {
 153 |     |         if (!(a >= b)) {
 154 |     |             string memory aStr = FuzzLibString.toString(a);
 155 |     |             string memory bStr = FuzzLibString.toString(b);
 156 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<", reason);
 157 |     |             emit AssertGteFail(assertMsg);
 158 |     |             platform.assertFail();
 159 |     |         }
 160 |     |     }
 161 |     | 
 162 |     |     /// @notice asserts that a is greater than b. Violations are logged using reason.
 163 |     |     function gt(
 164 |     |         uint256 a,
 165 |     |         uint256 b,
 166 |     |         string memory reason
 167 |     |     ) public {
 168 |     |         if (!(a > b)) {
 169 |     |             string memory aStr = FuzzLibString.toString(a);
 170 |     |             string memory bStr = FuzzLibString.toString(b);
 171 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<=", reason);
 172 |     |             emit AssertGtFail(assertMsg);
 173 |     |             platform.assertFail();
 174 |     |         }
 175 |     |     }
 176 |     | 
 177 |     |     /// @notice int256 version of gt
 178 |     |     function gt(
 179 |     |         int256 a,
 180 |     |         int256 b,
 181 |     |         string memory reason
 182 |     |     ) public {
 183 |     |         if (!(a > b)) {
 184 |     |             string memory aStr = FuzzLibString.toString(a);
 185 |     |             string memory bStr = FuzzLibString.toString(b);
 186 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<=", reason);
 187 |     |             emit AssertGtFail(assertMsg);
 188 |     |             platform.assertFail();
 189 |     |         }
 190 |     |     }
 191 |     | 
 192 |     |     /// @notice asserts that a is less than or equal to b. Violations are logged using reason.
 193 |     |     function lte(
 194 |     |         uint256 a,
 195 |     |         uint256 b,
 196 |     |         string memory reason
 197 |     |     ) public {
 198 |     |         if (!(a <= b)) {
 199 |     |             string memory aStr = FuzzLibString.toString(a);
 200 |     |             string memory bStr = FuzzLibString.toString(b);
 201 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">", reason);
 202 |     |             emit AssertLteFail(assertMsg);
 203 |     |             platform.assertFail();
 204 |     |         }
 205 |     |     }
 206 |     | 
 207 |     |     /// @notice int256 version of lte
 208 |     |     function lte(
 209 |     |         int256 a,
 210 |     |         int256 b,
 211 |     |         string memory reason
 212 |     |     ) public {
 213 |     |         if (!(a <= b)) {
 214 |     |             string memory aStr = FuzzLibString.toString(a);
 215 |     |             string memory bStr = FuzzLibString.toString(b);
 216 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">", reason);
 217 |     |             emit AssertLteFail(assertMsg);
 218 |     |             platform.assertFail();
 219 |     |         }
 220 |     |     }
 221 |     | 
 222 |     |     /// @notice asserts that a is less than b. Violations are logged using reason.
 223 |     |     function lt(
 224 |     |         uint256 a,
 225 |     |         uint256 b,
 226 |     |         string memory reason
 227 |     |     ) public {
 228 |     |         if (!(a < b)) {
 229 |     |             string memory aStr = FuzzLibString.toString(a);
 230 |     |             string memory bStr = FuzzLibString.toString(b);
 231 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">=", reason);
 232 |     |             emit AssertLtFail(assertMsg);
 233 |     |             platform.assertFail();
 234 |     |         }
 235 |     |     }
 236 |     | 
 237 |     |     /// @notice int256 version of lt
 238 |     |     function lt(
 239 |     |         int256 a,
 240 |     |         int256 b,
 241 |     |         string memory reason
 242 |     |     ) public {
 243 |     |         if (!(a < b)) {
 244 |     |             string memory aStr = FuzzLibString.toString(a);
 245 |     |             string memory bStr = FuzzLibString.toString(b);
 246 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">=", reason);
 247 |     |             emit AssertLtFail(assertMsg);
 248 |     |             platform.assertFail();
 249 |     |         }
 250 |     |     }
 251 |     | 
 252 |     |     function assertRevertReasonNotEqual(
 253 |     |         bytes memory returnData,
 254 |     |         string memory reason
 255 |     |     ) public {
 256 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);
 257 |     |         t(!isEqual, reason);
 258 |     |     }
 259 |     | 
 260 |     |     function assertRevertReasonEqual(
 261 |     |         bytes memory returnData,
 262 |     |         string memory reason
 263 |     |     ) public {
 264 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);
 265 |     |         t(isEqual, reason);
 266 |     |     }
 267 |     | 
 268 |     |     function assertRevertReasonEqual(
 269 |     |         bytes memory returnData,
 270 |     |         string memory reason1,
 271 |     |         string memory reason2
 272 |     |     ) public {
 273 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 274 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2);
 275 |     |         string memory assertMsg = string(
 276 |     |             abi.encodePacked(reason1, " OR ", reason2)
 277 |     |         );
 278 |     |         t(isEqual, assertMsg);
 279 |     |     }
 280 |     | 
 281 |     |     function assertRevertReasonEqual(
 282 |     |         bytes memory returnData,
 283 |     |         string memory reason1,
 284 |     |         string memory reason2,
 285 |     |         string memory reason3
 286 |     |     ) public {
 287 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 288 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2) ||
 289 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason3);
 290 |     |         string memory assertMsg = string(
 291 |     |             abi.encodePacked(reason1, " OR ", reason2, " OR ", reason3)
 292 |     |         );
 293 |     |         t(isEqual, assertMsg);
 294 |     |     }
 295 |     | 
 296 |     |     function assertRevertReasonEqual(
 297 |     |         bytes memory returnData,
 298 |     |         string memory reason1,
 299 |     |         string memory reason2,
 300 |     |         string memory reason3,
 301 |     |         string memory reason4
 302 |     |     ) public {
 303 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 304 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2) ||
 305 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason3) ||
 306 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason4);
 307 |     |         string memory assertMsg = string(
 308 |     |             abi.encodePacked(
 309 |     |                 reason1,
 310 |     |                 " OR ",
 311 |     |                 reason2,
 312 |     |                 " OR ",
 313 |     |                 reason3,
 314 |     |                 " OR ",
 315 |     |                 reason4
 316 |     |             )
 317 |     |         );
 318 |     |         t(isEqual, assertMsg);
 319 |     |     }
 320 |     | 
 321 | *   |     function errAllow(
 322 |     |         bytes4 errorSelector,
 323 |     |         bytes4[] memory allowedErrors,
 324 |     |         string memory message
 325 | *   |     ) public {
 326 | *   |         bool allowed = false;
 327 | *   |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 328 | *   |             if (errorSelector == allowedErrors[i]) {
 329 | *   |                 allowed = true;
 330 | *   |                 break;
 331 |     |             }
 332 |     |         }
 333 | *   |         t(allowed, message);
 334 |     |     }
 335 |     | 
 336 |     |     function errsAllow(
 337 |     |         bytes4 errorSelector,
 338 |     |         bytes4[] memory allowedErrors,
 339 |     |         string[] memory messages
 340 |     |     ) public {
 341 |     |         bool allowed = false;
 342 |     |         uint256 passIndex = 0;
 343 |     |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 344 |     |             if (errorSelector == allowedErrors[i]) {
 345 |     |                 allowed = true;
 346 |     |                 passIndex = i;
 347 |     |                 break;
 348 |     |             }
 349 |     |         }
 350 |     |         t(allowed, messages[passIndex]);
 351 |     |     }
 352 |     | 
 353 |     |     function createAssertFailMessage(string memory aStr, string memory bStr, string memory operator, string memory reason)internal pure returns (string memory) {
 354 |     |         return string(abi.encodePacked("Invalid: ", aStr, operator, bStr, ", reason: ", reason));
 355 |     |     }
 356 |     | 
 357 |     | }
 358 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/fuzzlib/src/helpers/HelperBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {IPlatform} from "../platform/IPlatform.sol";
  5 |     | 
  6 |     | contract HelperBase {
  7 |     |     IPlatform public platform;
  8 |     | 
  9 | *   |     function setPlatform(address _platform) public {
 10 | *   |         platform = IPlatform(_platform);
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/fuzzlib/src/helpers/HelperClamp.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../FuzzLibString.sol";
   5 |     | import "./HelperAssert.sol";
   6 |     | 
   7 |     | /// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   8 |     | abstract contract HelperClamp is HelperAssert {
   9 |     |     event Clamped(string);
  10 |     | 
  11 |     |     /*
  12 |     |      **************************************************************************
  13 |     |      * Clamp functions with logging enabled
  14 |     |      **************************************************************************
  15 |     |      */
  16 |     | 
  17 |     |     /// @notice Clamps value to be between low and high, both inclusive
  18 | *   |     function clamp(
  19 |     |         uint256 value,
  20 |     |         uint256 low,
  21 |     |         uint256 high
  22 | *   |     ) public returns (uint256) {
  23 | *   |         return clamp(value, low, high, true);
  24 |     |     }
  25 |     | 
  26 |     |     /// @notice int256 version of clamp
  27 |     |     function clamp(
  28 |     |         int256 value,
  29 |     |         int256 low,
  30 |     |         int256 high
  31 |     |     ) public returns (int256) {
  32 |     |         return clamp(value, low, high, true);
  33 |     |     }
  34 |     | 
  35 |     |     /// @notice clamps a to be less than b
  36 |     |     function clampLt(uint256 a, uint256 b) public returns (uint256) {
  37 |     |         return clampLt(a, b);
  38 |     |     }
  39 |     | 
  40 |     |     /// @notice int256 version of clampLt
  41 |     |     function clampLt(int256 a, int256 b) public returns (int256) {
  42 |     |         return clampLt(a, b, true);
  43 |     |     }
  44 |     | 
  45 |     |     /// @notice clamps a to be less than or equal to b
  46 |     |     function clampLte(uint256 a, uint256 b) public returns (uint256) {
  47 |     |         return clampLte(a, b, true);
  48 |     |     }
  49 |     | 
  50 |     |     /// @notice int256 version of clampLte
  51 |     |     function clampLte(int256 a, int256 b) public returns (int256) {
  52 |     |         return clampLte(a, b, true);
  53 |     |     }
  54 |     | 
  55 |     |     /// @notice clamps a to be greater than b
  56 |     |     function clampGt(uint256 a, uint256 b) public returns (uint256) {
  57 |     |         return clampGt(a, b, true);
  58 |     |     }
  59 |     | 
  60 |     |     /// @notice int256 version of clampGt
  61 |     |     function clampGt(int256 a, int256 b) public returns (int256) {
  62 |     |         return clampGt(a, b, true);
  63 |     |     }
  64 |     | 
  65 |     |     /// @notice clamps a to be greater than or equal to b
  66 |     |     function clampGte(uint256 a, uint256 b) public returns (uint256) {
  67 |     |         return clampGte(a, b, true);
  68 |     |     }
  69 |     | 
  70 |     |     /// @notice int256 version of clampGte
  71 |     |     function clampGte(int256 a, int256 b) public returns (int256) {
  72 |     |         return clampGte(a, b, true);
  73 |     |     }
  74 |     | 
  75 |     |     /*
  76 |     |      **************************************************************************
  77 |     |      * Clamp functions with optional logging
  78 |     |      **************************************************************************
  79 |     |      */
  80 |     | 
  81 |     |     /// @notice Clamps value to be between low and high, both inclusive
  82 | *   |     function clamp(
  83 |     |         uint256 value,
  84 |     |         uint256 low,
  85 |     |         uint256 high,
  86 |     |         bool enableLogs
  87 | *   |     ) public returns (uint256) {
  88 | *   |         if (value < low || value > high) {
  89 | *   |             uint256 ans = low + (value % (high - low + 1));
  90 | *   |             if (enableLogs) {
  91 | *   |                 string memory valueStr = FuzzLibString.toString(value);
  92 | *   |                 string memory ansStr = FuzzLibString.toString(ans);
  93 | *   |                 bytes memory message = abi.encodePacked(
  94 |     |                     "Clamping value ",
  95 | *   |                     valueStr,
  96 |     |                     " to ",
  97 | *   |                     ansStr
  98 |     |                 );
  99 | *   |                 emit Clamped(string(message));
 100 |     |             }
 101 | *   |             return ans;
 102 |     |         }
 103 | *   |         return value;
 104 |     |     }
 105 |     | 
 106 |     |     /// @notice int256 version of clamp
 107 | *   |     function clamp(
 108 |     |         int256 value,
 109 |     |         int256 low,
 110 |     |         int256 high,
 111 |     |         bool enableLogs
 112 | *   |     ) public returns (int256) {
 113 | *   |         if (value < low || value > high) {
 114 | *   |             int256 range = high - low + 1;
 115 | *   |             int256 clamped = (value - low) % (range);
 116 | *   |             if (clamped < 0) clamped += range;
 117 | *   |             int256 ans = low + clamped;
 118 | *   |             if (enableLogs) {
 119 | *   |                 string memory valueStr = FuzzLibString.toString(value);
 120 | *   |                 string memory ansStr = FuzzLibString.toString(ans);
 121 | *   |                 bytes memory message = abi.encodePacked(
 122 |     |                     "Clamping value ",
 123 | *   |                     valueStr,
 124 |     |                     " to ",
 125 | *   |                     ansStr
 126 |     |                 );
 127 | *   |                 emit Clamped(string(message));
 128 |     |             }
 129 | *   |             return ans;
 130 |     |         }
 131 |     |         return value;
 132 |     |     }
 133 |     | 
 134 |     |     /// @notice clamps a to be less than b
 135 |     |     function clampLt(
 136 |     |         uint256 a,
 137 |     |         uint256 b,
 138 |     |         bool enableLogs
 139 |     |     ) public returns (uint256) {
 140 |     |         if (!(a < b)) {
 141 |     |             neq(
 142 |     |                 b,
 143 |     |                 0,
 144 |     |                 "clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions."
 145 |     |             );
 146 |     |             uint256 value = a % b;
 147 |     |             if (enableLogs) {
 148 |     |                 string memory aStr = FuzzLibString.toString(a);
 149 |     |                 string memory valueStr = FuzzLibString.toString(value);
 150 |     |                 bytes memory message = abi.encodePacked(
 151 |     |                     "Clamping value ",
 152 |     |                     aStr,
 153 |     |                     " to ",
 154 |     |                     valueStr
 155 |     |                 );
 156 |     |                 emit Clamped(string(message));
 157 |     |             }
 158 |     |             return value;
 159 |     |         }
 160 |     |         return a;
 161 |     |     }
 162 |     | 
 163 |     |     /// @notice int256 version of clampLt
 164 |     |     function clampLt(
 165 |     |         int256 a,
 166 |     |         int256 b,
 167 |     |         bool enableLogs
 168 |     |     ) public returns (int256) {
 169 |     |         if (!(a < b)) {
 170 |     |             int256 value = b - 1;
 171 |     |             if (enableLogs) {
 172 |     |                 string memory aStr = FuzzLibString.toString(a);
 173 |     |                 string memory valueStr = FuzzLibString.toString(value);
 174 |     |                 bytes memory message = abi.encodePacked(
 175 |     |                     "Clamping value ",
 176 |     |                     aStr,
 177 |     |                     " to ",
 178 |     |                     valueStr
 179 |     |                 );
 180 |     |                 emit Clamped(string(message));
 181 |     |             }
 182 |     |             return value;
 183 |     |         }
 184 |     |         return a;
 185 |     |     }
 186 |     | 
 187 |     |     /// @notice clamps a to be less than or equal to b
 188 |     |     function clampLte(
 189 |     |         uint256 a,
 190 |     |         uint256 b,
 191 |     |         bool enableLogs
 192 |     |     ) public returns (uint256) {
 193 |     |         if (!(a <= b)) {
 194 |     |             uint256 value = a % (b + 1);
 195 |     |             if (enableLogs) {
 196 |     |                 string memory aStr = FuzzLibString.toString(a);
 197 |     |                 string memory valueStr = FuzzLibString.toString(value);
 198 |     |                 bytes memory message = abi.encodePacked(
 199 |     |                     "Clamping value ",
 200 |     |                     aStr,
 201 |     |                     " to ",
 202 |     |                     valueStr
 203 |     |                 );
 204 |     |                 emit Clamped(string(message));
 205 |     |             }
 206 |     |             return value;
 207 |     |         }
 208 |     |         return a;
 209 |     |     }
 210 |     | 
 211 |     |     /// @notice int256 version of clampLte
 212 |     |     function clampLte(
 213 |     |         int256 a,
 214 |     |         int256 b,
 215 |     |         bool enableLogs
 216 |     |     ) public returns (int256) {
 217 |     |         if (!(a <= b)) {
 218 |     |             int256 value = b;
 219 |     |             if (enableLogs) {
 220 |     |                 string memory aStr = FuzzLibString.toString(a);
 221 |     |                 string memory valueStr = FuzzLibString.toString(value);
 222 |     |                 bytes memory message = abi.encodePacked(
 223 |     |                     "Clamping value ",
 224 |     |                     aStr,
 225 |     |                     " to ",
 226 |     |                     valueStr
 227 |     |                 );
 228 |     |                 emit Clamped(string(message));
 229 |     |             }
 230 |     |             return value;
 231 |     |         }
 232 |     |         return a;
 233 |     |     }
 234 |     | 
 235 |     |     /// @notice clamps a to be greater than b
 236 |     |     function clampGt(
 237 |     |         uint256 a,
 238 |     |         uint256 b,
 239 |     |         bool enableLogs
 240 |     |     ) public returns (uint256) {
 241 |     |         if (!(a > b)) {
 242 |     |             neq(
 243 |     |                 b,
 244 |     |                 type(uint256).max,
 245 |     |                 "clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions."
 246 |     |             );
 247 |     |             uint256 value = b + 1;
 248 |     |             if (enableLogs) {
 249 |     |                 string memory aStr = FuzzLibString.toString(a);
 250 |     |                 string memory valueStr = FuzzLibString.toString(value);
 251 |     |                 bytes memory message = abi.encodePacked(
 252 |     |                     "Clamping value ",
 253 |     |                     aStr,
 254 |     |                     " to ",
 255 |     |                     valueStr
 256 |     |                 );
 257 |     |                 emit Clamped(string(message));
 258 |     |             }
 259 |     |             return value;
 260 |     |         } else {
 261 |     |             return a;
 262 |     |         }
 263 |     |     }
 264 |     | 
 265 |     |     /// @notice int256 version of clampGt
 266 |     |     function clampGt(
 267 |     |         int256 a,
 268 |     |         int256 b,
 269 |     |         bool enableLogs
 270 |     |     ) public returns (int256) {
 271 |     |         if (!(a > b)) {
 272 |     |             int256 value = b + 1;
 273 |     |             if (enableLogs) {
 274 |     |                 string memory aStr = FuzzLibString.toString(a);
 275 |     |                 string memory valueStr = FuzzLibString.toString(value);
 276 |     |                 bytes memory message = abi.encodePacked(
 277 |     |                     "Clamping value ",
 278 |     |                     aStr,
 279 |     |                     " to ",
 280 |     |                     valueStr
 281 |     |                 );
 282 |     |                 emit Clamped(string(message));
 283 |     |             }
 284 |     |             return value;
 285 |     |         } else {
 286 |     |             return a;
 287 |     |         }
 288 |     |     }
 289 |     | 
 290 |     |     /// @notice clamps a to be greater than or equal to b
 291 |     |     function clampGte(
 292 |     |         uint256 a,
 293 |     |         uint256 b,
 294 |     |         bool enableLogs
 295 |     |     ) public returns (uint256) {
 296 |     |         if (!(a > b)) {
 297 |     |             uint256 value = b;
 298 |     |             if (enableLogs) {
 299 |     |                 string memory aStr = FuzzLibString.toString(a);
 300 |     |                 string memory valueStr = FuzzLibString.toString(value);
 301 |     |                 bytes memory message = abi.encodePacked(
 302 |     |                     "Clamping value ",
 303 |     |                     aStr,
 304 |     |                     " to ",
 305 |     |                     valueStr
 306 |     |                 );
 307 |     |                 emit Clamped(string(message));
 308 |     |             }
 309 |     |             return value;
 310 |     |         }
 311 |     |         return a;
 312 |     |     }
 313 |     | 
 314 |     |     /// @notice int256 version of clampGte
 315 |     |     function clampGte(
 316 |     |         int256 a,
 317 |     |         int256 b,
 318 |     |         bool enableLogs
 319 |     |     ) public returns (int256) {
 320 |     |         if (!(a > b)) {
 321 |     |             int256 value = b;
 322 |     |             if (enableLogs) {
 323 |     |                 string memory aStr = FuzzLibString.toString(a);
 324 |     |                 string memory valueStr = FuzzLibString.toString(value);
 325 |     |                 bytes memory message = abi.encodePacked(
 326 |     |                     "Clamping value ",
 327 |     |                     aStr,
 328 |     |                     " to ",
 329 |     |                     valueStr
 330 |     |                 );
 331 |     |                 emit Clamped(string(message));
 332 |     |             }
 333 |     |             return value;
 334 |     |         }
 335 |     |         return a;
 336 |     |     }
 337 |     | }
 338 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/fuzzlib/src/helpers/HelperLog.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {LibLog} from "../libraries/LibLog.sol";
  5 |     | 
  6 |     | abstract contract HelperLog {
  7 | *   |     function log(string memory message) public {
  8 | *   |         LibLog.log(message);
  9 |     |     }
 10 |     | 
 11 | *   |     function log(string memory message, string memory data) public {
 12 | *   |         LibLog.log(message, data);
 13 |     |     }
 14 |     | 
 15 |     |     function log(string memory message, bytes memory data) public {
 16 |     |         LibLog.log(message, data);
 17 |     |     }
 18 |     | 
 19 | *   |     function log(string memory message, uint256 data) public {
 20 | *   |         LibLog.log(message, data);
 21 |     |     }
 22 |     | 
 23 |     |     function log(string memory message, int256 data) public {
 24 |     |         LibLog.log(message, data);
 25 |     |     }
 26 |     | 
 27 |     |     function log(string memory message, address data) public {
 28 |     |         LibLog.log(message, data);
 29 |     |     }
 30 |     | 
 31 |     |     function log(string memory message, bool data) public {
 32 |     |         LibLog.log(message, data);
 33 |     |     }
 34 |     | 
 35 |     |     function log(string memory message, bytes32 data) public {
 36 |     |         LibLog.log(message, data);
 37 |     |     }
 38 |     | 
 39 |     |     function logFail() public {
 40 |     |         LibLog.logFail();
 41 |     |     }
 42 |     | 
 43 |     |     function logFail(string memory message) public {
 44 |     |         LibLog.logFail(message);
 45 |     |     }
 46 |     | 
 47 |     |     function logFail(string memory message, string memory data) public {
 48 |     |         LibLog.logFail(message, data);
 49 |     |     }
 50 |     | 
 51 |     |     function logFail(string memory message, bytes memory data) public {
 52 |     |         LibLog.logFail(message, data);
 53 |     |     }
 54 |     | 
 55 |     |     function logFail(string memory message, uint256 data) public {
 56 |     |         LibLog.logFail(message, data);
 57 |     |     }
 58 |     | 
 59 |     |     function logFail(string memory message, int256 data) public {
 60 |     |         LibLog.logFail(message, data);
 61 |     |     }
 62 |     | 
 63 |     |     function logFail(string memory message, address data) public {
 64 |     |         LibLog.logFail(message, data);
 65 |     |     }
 66 |     | 
 67 |     |     function logFail(string memory message, bool data) public {
 68 |     |         LibLog.logFail(message, data);
 69 |     |     }
 70 |     | 
 71 |     |     function logFail(string memory message, bytes32 data) public {
 72 |     |         LibLog.log(message, data);
 73 |     |     }
 74 |     | }
 75 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/fuzzlib/src/helpers/HelperMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | abstract contract HelperMath {
  5 |     |     function min(uint256 a, uint256 b) public pure returns (uint256) {
  6 |     |         return a < b ? a : b;
  7 |     |     }
  8 |     | 
  9 |     |     function max(uint256 a, uint256 b) public pure returns (uint256) {
 10 |     |         return a > b ? a : b;
 11 |     |     }
 12 |     | 
 13 |     |     // Forked from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.0.0/contracts/utils/math/SignedMath.sol
 14 |     |     function max(int256 a, int256 b) public pure returns (int256) {
 15 |     |         return a > b ? a : b;
 16 |     |     }
 17 |     | 
 18 |     |     // Forked with modifications from https://ethereum.stackexchange.com/a/84391
 19 |     |     function abs(int128 n) public pure returns (int128) {
 20 |     |         return n >= 0 ? n : -n;
 21 |     |     }
 22 |     | 
 23 |     |     function abs(int256 n) public pure returns (uint256) {
 24 |     |         return n >= 0 ? uint256(n) : uint256(-n);
 25 |     |     }
 26 |     | 
 27 |     |     function diff(int256 a, int256 b) public pure returns (uint256) {
 28 |     |         return a >= b ? uint256(a - b) : uint256(b - a);
 29 |     |     }
 30 |     | 
 31 |     |     function diff(uint256 a, uint256 b) public pure returns (uint256) {
 32 |     |         return a >= b ? a - b : b - a;
 33 |     |     }
 34 |     | }
 35 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/fuzzlib/src/helpers/HelperRandom.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | abstract contract HelperRandom {
  5 |     |     /// @notice Shuffle an array using Fisher-Yates algorithm
  6 |     |     /// @dev Based on https://gist.github.com/scammi/602387a22e04c77beb73c0ebc0f0bc18
  7 |     |     function shuffleArray(
  8 |     |         uint256[] memory shuffle,
  9 |     |         uint256 entropy
 10 |     |     ) public pure {
 11 |     |         for (uint256 i = shuffle.length - 1; i > 0; i--) {
 12 |     |             uint256 swapIndex = entropy % (shuffle.length - i);
 13 |     | 
 14 |     |             uint256 currentIndex = shuffle[i];
 15 |     |             uint256 indexToSwap = shuffle[swapIndex];
 16 |     | 
 17 |     |             shuffle[i] = indexToSwap;
 18 |     |             shuffle[swapIndex] = currentIndex;
 19 |     |         }
 20 |     |     }
 21 |     | }
 22 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/fuzzlib/src/libraries/LibLog.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | library LibLog {
  5 |     |     event Log(string message);
  6 |     |     event LogString(string message, string data);
  7 |     |     event LogBytes(string message, bytes data);
  8 |     |     event LogUint(string message, uint256 data);
  9 |     |     event LogInt(string message, int256 data);
 10 |     |     event LogAddress(string message, address data);
 11 |     |     event LogBool(string message, bool data);
 12 |     |     event LogBytes32(string message, bytes32 data);
 13 |     | 
 14 |     |     event AssertionFailed();
 15 |     |     event AssertionFailed(string message);
 16 |     |     event AssertionFailed(string message, string data);
 17 |     |     event AssertionFailed(string message, bytes data);
 18 |     |     event AssertionFailed(string message, uint256 data);
 19 |     |     event AssertionFailed(string message, int256 data);
 20 |     |     event AssertionFailed(string message, address data);
 21 |     |     event AssertionFailed(string message, bool data);
 22 |     | 
 23 | *   |     function log(string memory message) internal {
 24 | *   |         emit Log(message);
 25 |     |     }
 26 |     | 
 27 | *   |     function log(string memory message, string memory data) internal {
 28 | *   |         emit LogString(message, data);
 29 |     |     }
 30 |     | 
 31 |     |     function log(string memory message, bytes memory data) internal {
 32 |     |         emit LogBytes(message, data);
 33 |     |     }
 34 |     | 
 35 | *   |     function log(string memory message, uint256 data) internal {
 36 | *   |         emit LogUint(message, data);
 37 |     |     }
 38 |     | 
 39 |     |     function log(string memory message, int256 data) internal {
 40 |     |         emit LogInt(message, data);
 41 |     |     }
 42 |     | 
 43 |     |     function log(string memory message, address data) internal {
 44 |     |         emit LogAddress(message, data);
 45 |     |     }
 46 |     | 
 47 |     |     function log(string memory message, bool data) internal {
 48 |     |         emit LogBool(message, data);
 49 |     |     }
 50 |     | 
 51 |     |     function log(string memory message, bytes32 data) internal {
 52 |     |         emit LogBytes32(message, data);
 53 |     |     }
 54 |     | 
 55 |     |     function logFail() internal {
 56 |     |         emit AssertionFailed();
 57 |     |     }
 58 |     | 
 59 |     |     function logFail(string memory message) internal {
 60 |     |         emit AssertionFailed(message);
 61 |     |     }
 62 |     | 
 63 |     |     function logFail(string memory message, string memory data) internal {
 64 |     |         emit AssertionFailed(message, data);
 65 |     |     }
 66 |     | 
 67 |     |     function logFail(string memory message, bytes memory data) internal {
 68 |     |         emit AssertionFailed(message, data);
 69 |     |     }
 70 |     | 
 71 |     |     function logFail(string memory message, uint256 data) internal {
 72 |     |         emit AssertionFailed(message, data);
 73 |     |     }
 74 |     | 
 75 |     |     function logFail(string memory message, int256 data) internal {
 76 |     |         emit AssertionFailed(message, data);
 77 |     |     }
 78 |     | 
 79 |     |     function logFail(string memory message, address data) internal {
 80 |     |         emit AssertionFailed(message, data);
 81 |     |     }
 82 |     | 
 83 |     |     function logFail(string memory message, bool data) internal {
 84 |     |         emit AssertionFailed(message, data);
 85 |     |     }
 86 |     | 
 87 |     |     function logFail(string memory message, bytes32 data) internal {
 88 |     |         emit LogBytes32(message, data);
 89 |     |     }
 90 |     | }
 91 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/fuzzlib/src/platform/IPlatform.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | interface IPlatform {
 5 |     |     function assertFail() pure external;
 6 |     | }
 7 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/fuzzlib/src/platform/PlatformCrytic.sol
  1 |     | 
  2 |     | // SPDX-License-Identifier: MIT
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {IPlatform} from "./IPlatform.sol";
  6 |     | 
  7 | *   | contract PlatformCrytic is IPlatform {
  8 | *   |     function assertFail() pure public override{
  9 | *   |         assert(false);
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/openzeppelin-foundry-upgrades/src/Defender.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {Options, DefenderOptions} from "./Options.sol";
   5 |     | import {Core} from "./internal/Core.sol";
   6 |     | import {DefenderDeploy} from "./internal/DefenderDeploy.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Library for interacting with OpenZeppelin Defender from Forge scripts or tests.
  10 |     |  */
  11 |     | library Defender {
  12 |     |     /**
  13 |     |      * @dev Deploys a contract to the current network using OpenZeppelin Defender.
  14 |     |      *
  15 |     |      * WARNING: Do not use this function directly if you are deploying an upgradeable contract. This function does not validate whether the contract is upgrade safe.
  16 |     |      *
  17 |     |      * NOTE: If using an EOA or Safe to deploy, go to https://defender.openzeppelin.com/v2/#/deploy[Defender deploy] to submit the pending deployment while the script is running.
  18 |     |      * The script waits for the deployment to complete before it continues.
  19 |     |      *
  20 |     |      * @param contractName Name of the contract to deploy, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
  21 |     |      * @return Address of the deployed contract
  22 |     |      */
  23 |     |     function deployContract(string memory contractName) internal returns (address) {
  24 |     |         return deployContract(contractName, "");
  25 |     |     }
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Deploys a contract to the current network using OpenZeppelin Defender.
  29 |     |      *
  30 |     |      * WARNING: Do not use this function directly if you are deploying an upgradeable contract. This function does not validate whether the contract is upgrade safe.
  31 |     |      *
  32 |     |      * NOTE: If using an EOA or Safe to deploy, go to https://defender.openzeppelin.com/v2/#/deploy[Defender deploy] to submit the pending deployment while the script is running.
  33 |     |      * The script waits for the deployment to complete before it continues.
  34 |     |      *
  35 |     |      * @param contractName Name of the contract to deploy, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
  36 |     |      * @param defenderOpts Defender deployment options. Note that the `useDefenderDeploy` option is always treated as `true` when called from this function.
  37 |     |      * @return Address of the deployed contract
  38 |     |      */
  39 |     |     function deployContract(
  40 |     |         string memory contractName,
  41 |     |         DefenderOptions memory defenderOpts
  42 |     |     ) internal returns (address) {
  43 |     |         return deployContract(contractName, "", defenderOpts);
  44 |     |     }
  45 |     | 
  46 |     |     /**
  47 |     |      * @dev Deploys a contract with constructor arguments to the current network using OpenZeppelin Defender.
  48 |     |      *
  49 |     |      * WARNING: Do not use this function directly if you are deploying an upgradeable contract. This function does not validate whether the contract is upgrade safe.
  50 |     |      *
  51 |     |      * NOTE: If using an EOA or Safe to deploy, go to https://defender.openzeppelin.com/v2/#/deploy[Defender deploy] to submit the pending deployment while the script is running.
  52 |     |      * The script waits for the deployment to complete before it continues.
  53 |     |      *
  54 |     |      * @param contractName Name of the contract to deploy, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
  55 |     |      * @param constructorData Encoded constructor arguments
  56 |     |      * @return Address of the deployed contract
  57 |     |      */
  58 |     |     function deployContract(string memory contractName, bytes memory constructorData) internal returns (address) {
  59 |     |         DefenderOptions memory defenderOpts;
  60 |     |         return deployContract(contractName, constructorData, defenderOpts);
  61 |     |     }
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Deploys a contract with constructor arguments to the current network using OpenZeppelin Defender.
  65 |     |      *
  66 |     |      * WARNING: Do not use this function directly if you are deploying an upgradeable contract. This function does not validate whether the contract is upgrade safe.
  67 |     |      *
  68 |     |      * NOTE: If using an EOA or Safe to deploy, go to https://defender.openzeppelin.com/v2/#/deploy[Defender deploy] to submit the pending deployment while the script is running.
  69 |     |      * The script waits for the deployment to complete before it continues.
  70 |     |      *
  71 |     |      * @param contractName Name of the contract to deploy, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
  72 |     |      * @param constructorData Encoded constructor arguments
  73 |     |      * @param defenderOpts Defender deployment options. Note that the `useDefenderDeploy` option is always treated as `true` when called from this function.
  74 |     |      * @return Address of the deployed contract
  75 |     |      */
  76 |     |     function deployContract(
  77 |     |         string memory contractName,
  78 |     |         bytes memory constructorData,
  79 |     |         DefenderOptions memory defenderOpts
  80 |     |     ) internal returns (address) {
  81 |     |         return DefenderDeploy.deploy(contractName, constructorData, defenderOpts);
  82 |     |     }
  83 |     | 
  84 |     |     /**
  85 |     |      * @dev Proposes an upgrade to an upgradeable proxy using OpenZeppelin Defender.
  86 |     |      *
  87 |     |      * This function validates a new implementation contract in comparison with a reference contract, deploys the new implementation contract using Defender,
  88 |     |      * and proposes an upgrade to the new implementation contract using an upgrade approval process on Defender.
  89 |     |      *
  90 |     |      * Supported for UUPS or Transparent proxies. Not currently supported for beacon proxies or beacons.
  91 |     |      * For beacons, use `Upgrades.prepareUpgrade` along with a transaction proposal on Defender to upgrade the beacon to the deployed implementation.
  92 |     |      *
  93 |     |      * Requires that either the `referenceContract` option is set, or the contract has a `@custom:oz-upgrades-from <reference>` annotation.
  94 |     |      *
  95 |     |      * WARNING: Ensure that the reference contract is the same as the current implementation contract that the proxy is pointing to.
  96 |     |      * This function does not validate that the reference contract is the current implementation.
  97 |     |      *
  98 |     |      * NOTE: If using an EOA or Safe to deploy, go to https://defender.openzeppelin.com/v2/#/deploy[Defender deploy] to submit the pending deployment of the new implementation contract while the script is running.
  99 |     |      * The script waits for the deployment to complete before it continues.
 100 |     |      *
 101 |     |      * @param proxyAddress The proxy address
 102 |     |      * @param newImplementationContractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 103 |     |      * @param opts Common options. Note that the `defender.useDefenderDeploy` option is always treated as `true` when called from this function.
 104 |     |      * @return Struct containing the proposal ID and URL for the upgrade proposal
 105 |     |      */
 106 |     |     function proposeUpgrade(
 107 |     |         address proxyAddress,
 108 |     |         string memory newImplementationContractName,
 109 |     |         Options memory opts
 110 |     |     ) internal returns (ProposeUpgradeResponse memory) {
 111 |     |         opts.defender.useDefenderDeploy = true;
 112 |     |         address proxyAdminAddress = Core.getAdminAddress(proxyAddress);
 113 |     |         address newImplementationAddress = Core.prepareUpgrade(newImplementationContractName, opts);
 114 |     |         return
 115 |     |             DefenderDeploy.proposeUpgrade(
 116 |     |                 proxyAddress,
 117 |     |                 proxyAdminAddress,
 118 |     |                 newImplementationAddress,
 119 |     |                 newImplementationContractName,
 120 |     |                 opts
 121 |     |             );
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev Gets the default deploy approval process configured for your deployment environment on OpenZeppelin Defender.
 126 |     |      *
 127 |     |      * @return Struct with the default deploy approval process ID and the associated address, such as a Relayer, EOA, or multisig wallet address.
 128 |     |      */
 129 |     |     function getDeployApprovalProcess() internal returns (ApprovalProcessResponse memory) {
 130 |     |         return DefenderDeploy.getApprovalProcess("getDeployApprovalProcess");
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @dev Gets the default upgrade approval process configured for your deployment environment on OpenZeppelin Defender.
 135 |     |      * For example, this is useful for determining the default multisig wallet that you can use in your scripts to assign as the owner of your proxy.
 136 |     |      *
 137 |     |      * @return Struct with the default upgrade approval process ID and the associated address, such as a multisig or governor contract address.
 138 |     |      */
 139 |     |     function getUpgradeApprovalProcess() internal returns (ApprovalProcessResponse memory) {
 140 |     |         return DefenderDeploy.getApprovalProcess("getUpgradeApprovalProcess");
 141 |     |     }
 142 |     | }
 143 |     | 
 144 |     | struct ProposeUpgradeResponse {
 145 |     |     string proposalId;
 146 |     |     string url;
 147 |     | }
 148 |     | 
 149 |     | struct ApprovalProcessResponse {
 150 |     |     string approvalProcessId;
 151 |     |     address via;
 152 |     |     string viaType;
 153 |     | }
 154 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/openzeppelin-foundry-upgrades/src/Options.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | /**
   5 |     |  * Common options.
   6 |     |  */
   7 |     | struct Options {
   8 |     |     /*
   9 |     |      * The reference contract to use for storage layout comparisons.
  10 |     |      *
  11 |     |      * For supported formats, see https://docs.openzeppelin.com/upgrades-plugins/api-foundry-upgrades#contract_name_formats
  12 |     |      *
  13 |     |      * If not using the `referenceBuildInfoDir` option, this must be in Foundry artifact format.
  14 |     |      *
  15 |     |      * If using the `referenceBuildInfoDir` option, this must be in annotation format prefixed with the build info directory short name.
  16 |     |      * For example, if `referenceBuildInfoDir` is `previous-builds/build-info-v1` and the reference contract name is `ContractV1`,
  17 |     |      * then set this to `build-info-v1:ContractV1`
  18 |     |      *
  19 |     |      * If not set, attempts to use the `@custom:oz-upgrades-from <reference>` annotation from the contract.
  20 |     |      */
  21 |     |     string referenceContract;
  22 |     |     /*
  23 |     |      * Absolute or relative path to a build info directory from a previous version of the project to use for storage layout comparisons.
  24 |     |      * Relative paths must be relative to the Foundry project root.
  25 |     |      *
  26 |     |      * When using this option, refer to this directory using prefix `<dirName>:` before the contract name or fully qualified name
  27 |     |      * in the `referenceContract` option or `@custom:oz-upgrades-from` annotation, where `<dirName>` is the directory short name.
  28 |     |      * The directory short name must be unique when compared to the main build info directory.
  29 |     |      */
  30 |     |     string referenceBuildInfoDir;
  31 |     |     /*
  32 |     |      * Encoded constructor arguments for the implementation contract.
  33 |     |      * Note that these are different from initializer arguments, and will be used in the deployment of the implementation contract itself.
  34 |     |      * Can be used to initialize immutable variables.
  35 |     |      */
  36 |     |     bytes constructorData;
  37 |     |     /*
  38 |     |      * Exclude validations for contracts in source file paths that match any of the given glob patterns.
  39 |     |      * For example, patterns such as "contracts/helpers/*.sol". Does not apply to reference contracts.
  40 |     |      */
  41 |     |     string[] exclude;
  42 |     |     /*
  43 |     |      * Selectively disable one or more validation errors. Comma-separated list that must be compatible with the
  44 |     |      * --unsafeAllow option described in https://docs.openzeppelin.com/upgrades-plugins/api-core#usage
  45 |     |      */
  46 |     |     string unsafeAllow;
  47 |     |     /*
  48 |     |      * Configure storage layout check to allow variable renaming
  49 |     |      */
  50 |     |     bool unsafeAllowRenames;
  51 |     |     /*
  52 |     |      * Skips checking the `initialOwner` parameter of `Upgrades.deployTransparentProxy`.
  53 |     |      * When deploying a transparent proxy, the `initialOwner` must be the address of an EOA or a contract that can call functions on a ProxyAdmin. It must not be a ProxyAdmin contract itself.
  54 |     |      * Use this if you encounter an error due to this check and are sure that the `initialOwner` is not a ProxyAdmin contract.
  55 |     |      */
  56 |     |     bool unsafeSkipProxyAdminCheck;
  57 |     |     /*
  58 |     |      * Skips checking for storage layout compatibility errors. This is a dangerous option meant to be used as a last resort.
  59 |     |      */
  60 |     |     bool unsafeSkipStorageCheck;
  61 |     |     /*
  62 |     |      * Skips all upgrade safety checks. This is a dangerous option meant to be used as a last resort.
  63 |     |      */
  64 |     |     bool unsafeSkipAllChecks;
  65 |     |     /*
  66 |     |      * Options for OpenZeppelin Defender deployments.
  67 |     |      */
  68 |     |     DefenderOptions defender;
  69 |     | }
  70 |     | 
  71 |     | /**
  72 |     |  * Options for OpenZeppelin Defender deployments.
  73 |     |  */
  74 |     | struct DefenderOptions {
  75 |     |     /*
  76 |     |      * Deploys contracts using OpenZeppelin Defender instead of broadcasting deployments through Forge. Defaults to `false`. See DEFENDER.md.
  77 |     |      *
  78 |     |      * NOTE: If using an EOA or Safe to deploy, go to https://defender.openzeppelin.com/v2/#/deploy[Defender deploy] to submit the pending deployment(s) while the script is running.
  79 |     |      * The script waits for each deployment to complete before it continues.
  80 |     |      */
  81 |     |     bool useDefenderDeploy;
  82 |     |     /*
  83 |     |      * When using OpenZeppelin Defender deployments, whether to skip verifying source code on block explorers. Defaults to `false`.
  84 |     |      */
  85 |     |     bool skipVerifySourceCode;
  86 |     |     /*
  87 |     |      * When using OpenZeppelin Defender deployments, the ID of the relayer to use for the deployment. Defaults to the relayer configured for your deployment environment on Defender.
  88 |     |      */
  89 |     |     string relayerId;
  90 |     |     /*
  91 |     |      * Applies to OpenZeppelin Defender deployments only.
  92 |     |      * If this is not set, deployments will be performed using the CREATE opcode.
  93 |     |      * If this is set, deployments will be performed using the CREATE2 opcode with the provided salt.
  94 |     |      * Note that deployments using a Safe are done using CREATE2 and require a salt.
  95 |     |      *
  96 |     |      * WARNING: CREATE2 affects `msg.sender` behavior. See https://docs.openzeppelin.com/defender/v2/tutorial/deploy#deploy-caveat for more information.
  97 |     |      */
  98 |     |     bytes32 salt;
  99 |     |     /*
 100 |     |      * The ID of the upgrade approval process to use when proposing an upgrade.
 101 |     |      * Defaults to the upgrade approval process configured for your deployment environment on Defender.
 102 |     |      */
 103 |     |     string upgradeApprovalProcessId;
 104 |     |     /*
 105 |     |      * License type to display on block explorers for verified source code.
 106 |     |      * See https://etherscan.io/contract-license-types for supported values and use the string found in brackets, e.g. MIT.
 107 |     |      * If not set, infers the license type by using the SPDX license identifier from the contract's Solidity file.
 108 |     |      * Cannot be set if `skipLicenseType` or `skipVerifySourceCode` is `true`.
 109 |     |      */
 110 |     |     string licenseType;
 111 |     |     /*
 112 |     |      * If set to `true`, does not set the license type on block explorers for verified source code.
 113 |     |      * Use this if your contract's license type is not supported by block explorers.
 114 |     |      * Defaults to `false`.
 115 |     |      */
 116 |     |     bool skipLicenseType;
 117 |     |     /*
 118 |     |      * Transaction overrides for OpenZeppelin Defender deployments.
 119 |     |      */
 120 |     |     TxOverrides txOverrides;
 121 |     |     /*
 122 |     |      * When using OpenZeppelin Defender deployments, you can use this to identify, tag, or classify deployments.
 123 |     |      * See https://docs.openzeppelin.com/defender/module/deploy#metadata.
 124 |     |      * Must be a JSON string, for example: '{ "commitHash": "4ae3e0d", "tag": "v1.0.0", "anyOtherField": "anyValue" }'
 125 |     |      */
 126 |     |     string metadata;
 127 |     | }
 128 |     | 
 129 |     | /**
 130 |     |  * Transaction overrides for OpenZeppelin Defender deployments.
 131 |     |  */
 132 |     | struct TxOverrides {
 133 |     |     /*
 134 |     |      * Maximum amount of gas to allow the deployment transaction to use.
 135 |     |      */
 136 |     |     uint256 gasLimit;
 137 |     |     /*
 138 |     |      * Gas price for legacy transactions, in wei.
 139 |     |      */
 140 |     |     uint256 gasPrice;
 141 |     |     /*
 142 |     |      * Maximum total fee per gas, in wei.
 143 |     |      */
 144 |     |     uint256 maxFeePerGas;
 145 |     |     /*
 146 |     |      * Maximum priority fee per gas, in wei.
 147 |     |      */
 148 |     |     uint256 maxPriorityFeePerGas;
 149 |     | }
 150 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/openzeppelin-foundry-upgrades/src/Upgrades.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   5 |     | import {TransparentUpgradeableProxy} from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
   6 |     | import {UpgradeableBeacon} from "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol";
   7 |     | import {BeaconProxy} from "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol";
   8 |     | 
   9 |     | import {Vm} from "forge-std/Vm.sol";
  10 |     | import {Options} from "./Options.sol";
  11 |     | import {Core} from "./internal/Core.sol";
  12 |     | import {Utils} from "./internal/Utils.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @dev Library for deploying and managing upgradeable contracts from Forge scripts or tests.
  16 |     |  *
  17 |     |  * NOTE: Requires OpenZeppelin Contracts v5 or higher.
  18 |     |  */
  19 |     | library Upgrades {
  20 |     |     /**
  21 |     |      * @dev Deploys a UUPS proxy using the given contract as the implementation.
  22 |     |      *
  23 |     |      * @param contractName Name of the contract to use as the implementation, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
  24 |     |      * @param initializerData Encoded call data of the initializer function to call during creation of the proxy, or empty if no initialization is required
  25 |     |      * @param opts Common options
  26 |     |      * @return Proxy address
  27 |     |      */
  28 |     |     function deployUUPSProxy(
  29 |     |         string memory contractName,
  30 |     |         bytes memory initializerData,
  31 |     |         Options memory opts
  32 |     |     ) internal returns (address) {
  33 |     |         address impl = deployImplementation(contractName, opts);
  34 |     | 
  35 |     |         return Core.deploy("ERC1967Proxy.sol:ERC1967Proxy", abi.encode(impl, initializerData), opts);
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Deploys a UUPS proxy using the given contract as the implementation.
  40 |     |      *
  41 |     |      * @param contractName Name of the contract to use as the implementation, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
  42 |     |      * @param initializerData Encoded call data of the initializer function to call during creation of the proxy, or empty if no initialization is required
  43 |     |      * @return Proxy address
  44 |     |      */
  45 |     |     function deployUUPSProxy(string memory contractName, bytes memory initializerData) internal returns (address) {
  46 |     |         Options memory opts;
  47 |     |         return deployUUPSProxy(contractName, initializerData, opts);
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @dev Deploys a transparent proxy using the given contract as the implementation.
  52 |     |      *
  53 |     |      * @param contractName Name of the contract to use as the implementation, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
  54 |     |      * @param initialOwner Address to set as the owner of the ProxyAdmin contract which gets deployed by the proxy
  55 |     |      * @param initializerData Encoded call data of the initializer function to call during creation of the proxy, or empty if no initialization is required
  56 |     |      * @param opts Common options
  57 |     |      * @return Proxy address
  58 |     |      */
  59 |     |     function deployTransparentProxy(
  60 |     |         string memory contractName,
  61 |     |         address initialOwner,
  62 |     |         bytes memory initializerData,
  63 |     |         Options memory opts
  64 |     |     ) internal returns (address) {
  65 |     |         if (!opts.unsafeSkipAllChecks && !opts.unsafeSkipProxyAdminCheck && Core.inferProxyAdmin(initialOwner)) {
  66 |     |             revert(
  67 |     |                 string.concat(
  68 |     |                     "`initialOwner` must not be a ProxyAdmin contract. If the contract at address ",
  69 |     |                     Vm(Utils.CHEATCODE_ADDRESS).toString(initialOwner),
  70 |     |                     " is not a ProxyAdmin contract and you are sure that this contract is able to call functions on an actual ProxyAdmin, skip this check with the `unsafeSkipProxyAdminCheck` option."
  71 |     |                 )
  72 |     |             );
  73 |     |         }
  74 |     | 
  75 |     |         address impl = deployImplementation(contractName, opts);
  76 |     | 
  77 |     |         return
  78 |     |             Core.deploy(
  79 |     |                 "TransparentUpgradeableProxy.sol:TransparentUpgradeableProxy",
  80 |     |                 abi.encode(impl, initialOwner, initializerData),
  81 |     |                 opts
  82 |     |             );
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @dev Deploys a transparent proxy using the given contract as the implementation.
  87 |     |      *
  88 |     |      * @param contractName Name of the contract to use as the implementation, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
  89 |     |      * @param initialOwner Address to set as the owner of the ProxyAdmin contract which gets deployed by the proxy
  90 |     |      * @param initializerData Encoded call data of the initializer function to call during creation of the proxy, or empty if no initialization is required
  91 |     |      * @return Proxy address
  92 |     |      */
  93 |     |     function deployTransparentProxy(
  94 |     |         string memory contractName,
  95 |     |         address initialOwner,
  96 |     |         bytes memory initializerData
  97 |     |     ) internal returns (address) {
  98 |     |         Options memory opts;
  99 |     |         return deployTransparentProxy(contractName, initialOwner, initializerData, opts);
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Upgrades a proxy to a new implementation contract. Only supported for UUPS or transparent proxies.
 104 |     |      *
 105 |     |      * Requires that either the `referenceContract` option is set, or the new implementation contract has a `@custom:oz-upgrades-from <reference>` annotation.
 106 |     |      *
 107 |     |      * @param proxy Address of the proxy to upgrade
 108 |     |      * @param contractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 109 |     |      * @param data Encoded call data of an arbitrary function to call during the upgrade process, or empty if no function needs to be called during the upgrade
 110 |     |      * @param opts Common options
 111 |     |      */
 112 |     |     function upgradeProxy(address proxy, string memory contractName, bytes memory data, Options memory opts) internal {
 113 |     |         Core.upgradeProxy(proxy, contractName, data, opts);
 114 |     |     }
 115 |     | 
 116 |     |     /**
 117 |     |      * @dev Upgrades a proxy to a new implementation contract. Only supported for UUPS or transparent proxies.
 118 |     |      *
 119 |     |      * Requires that either the `referenceContract` option is set, or the new implementation contract has a `@custom:oz-upgrades-from <reference>` annotation.
 120 |     |      *
 121 |     |      * @param proxy Address of the proxy to upgrade
 122 |     |      * @param contractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 123 |     |      * @param data Encoded call data of an arbitrary function to call during the upgrade process, or empty if no function needs to be called during the upgrade
 124 |     |      */
 125 |     |     function upgradeProxy(address proxy, string memory contractName, bytes memory data) internal {
 126 |     |         Options memory opts;
 127 |     |         Core.upgradeProxy(proxy, contractName, data, opts);
 128 |     |     }
 129 |     | 
 130 |     |     /**
 131 |     |      * @notice For tests only. If broadcasting in scripts, use the `--sender <ADDRESS>` option with `forge script` instead.
 132 |     |      *
 133 |     |      * @dev Upgrades a proxy to a new implementation contract. Only supported for UUPS or transparent proxies.
 134 |     |      *
 135 |     |      * Requires that either the `referenceContract` option is set, or the new implementation contract has a `@custom:oz-upgrades-from <reference>` annotation.
 136 |     |      *
 137 |     |      * This function provides an additional `tryCaller` parameter to test an upgrade using a specific caller address.
 138 |     |      * Use this if you encounter `OwnableUnauthorizedAccount` errors in your tests.
 139 |     |      *
 140 |     |      * @param proxy Address of the proxy to upgrade
 141 |     |      * @param contractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 142 |     |      * @param data Encoded call data of an arbitrary function to call during the upgrade process, or empty if no function needs to be called during the upgrade
 143 |     |      * @param opts Common options
 144 |     |      * @param tryCaller Address to use as the caller of the upgrade function. This should be the address that owns the proxy or its ProxyAdmin.
 145 |     |      */
 146 |     |     function upgradeProxy(
 147 |     |         address proxy,
 148 |     |         string memory contractName,
 149 |     |         bytes memory data,
 150 |     |         Options memory opts,
 151 |     |         address tryCaller
 152 |     |     ) internal {
 153 |     |         Core.upgradeProxy(proxy, contractName, data, opts, tryCaller);
 154 |     |     }
 155 |     | 
 156 |     |     /**
 157 |     |      * @notice For tests only. If broadcasting in scripts, use the `--sender <ADDRESS>` option with `forge script` instead.
 158 |     |      *
 159 |     |      * @dev Upgrades a proxy to a new implementation contract. Only supported for UUPS or transparent proxies.
 160 |     |      *
 161 |     |      * Requires that either the `referenceContract` option is set, or the new implementation contract has a `@custom:oz-upgrades-from <reference>` annotation.
 162 |     |      *
 163 |     |      * This function provides an additional `tryCaller` parameter to test an upgrade using a specific caller address.
 164 |     |      * Use this if you encounter `OwnableUnauthorizedAccount` errors in your tests.
 165 |     |      *
 166 |     |      * @param proxy Address of the proxy to upgrade
 167 |     |      * @param contractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 168 |     |      * @param data Encoded call data of an arbitrary function to call during the upgrade process, or empty if no function needs to be called during the upgrade
 169 |     |      * @param tryCaller Address to use as the caller of the upgrade function. This should be the address that owns the proxy or its ProxyAdmin.
 170 |     |      */
 171 |     |     function upgradeProxy(address proxy, string memory contractName, bytes memory data, address tryCaller) internal {
 172 |     |         Options memory opts;
 173 |     |         Core.upgradeProxy(proxy, contractName, data, opts, tryCaller);
 174 |     |     }
 175 |     | 
 176 |     |     /**
 177 |     |      * @dev Deploys an upgradeable beacon using the given contract as the implementation.
 178 |     |      *
 179 |     |      * @param contractName Name of the contract to use as the implementation, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 180 |     |      * @param initialOwner Address to set as the owner of the UpgradeableBeacon contract which gets deployed
 181 |     |      * @param opts Common options
 182 |     |      * @return Beacon address
 183 |     |      */
 184 |     |     function deployBeacon(
 185 |     |         string memory contractName,
 186 |     |         address initialOwner,
 187 |     |         Options memory opts
 188 |     |     ) internal returns (address) {
 189 |     |         address impl = deployImplementation(contractName, opts);
 190 |     | 
 191 |     |         return Core.deploy("UpgradeableBeacon.sol:UpgradeableBeacon", abi.encode(impl, initialOwner), opts);
 192 |     |     }
 193 |     | 
 194 |     |     /**
 195 |     |      * @dev Deploys an upgradeable beacon using the given contract as the implementation.
 196 |     |      *
 197 |     |      * @param contractName Name of the contract to use as the implementation, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 198 |     |      * @param initialOwner Address to set as the owner of the UpgradeableBeacon contract which gets deployed
 199 |     |      * @return Beacon address
 200 |     |      */
 201 |     |     function deployBeacon(string memory contractName, address initialOwner) internal returns (address) {
 202 |     |         Options memory opts;
 203 |     |         return deployBeacon(contractName, initialOwner, opts);
 204 |     |     }
 205 |     | 
 206 |     |     /**
 207 |     |      * @dev Upgrades a beacon to a new implementation contract.
 208 |     |      *
 209 |     |      * Requires that either the `referenceContract` option is set, or the new implementation contract has a `@custom:oz-upgrades-from <reference>` annotation.
 210 |     |      *
 211 |     |      * @param beacon Address of the beacon to upgrade
 212 |     |      * @param contractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 213 |     |      * @param opts Common options
 214 |     |      */
 215 |     |     function upgradeBeacon(address beacon, string memory contractName, Options memory opts) internal {
 216 |     |         Core.upgradeBeacon(beacon, contractName, opts);
 217 |     |     }
 218 |     | 
 219 |     |     /**
 220 |     |      * @dev Upgrades a beacon to a new implementation contract.
 221 |     |      *
 222 |     |      * Requires that either the `referenceContract` option is set, or the new implementation contract has a `@custom:oz-upgrades-from <reference>` annotation.
 223 |     |      *
 224 |     |      * @param beacon Address of the beacon to upgrade
 225 |     |      * @param contractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 226 |     |      */
 227 |     |     function upgradeBeacon(address beacon, string memory contractName) internal {
 228 |     |         Options memory opts;
 229 |     |         Core.upgradeBeacon(beacon, contractName, opts);
 230 |     |     }
 231 |     | 
 232 |     |     /**
 233 |     |      * @notice For tests only. If broadcasting in scripts, use the `--sender <ADDRESS>` option with `forge script` instead.
 234 |     |      *
 235 |     |      * @dev Upgrades a beacon to a new implementation contract.
 236 |     |      *
 237 |     |      * Requires that either the `referenceContract` option is set, or the new implementation contract has a `@custom:oz-upgrades-from <reference>` annotation.
 238 |     |      *
 239 |     |      * This function provides an additional `tryCaller` parameter to test an upgrade using a specific caller address.
 240 |     |      * Use this if you encounter `OwnableUnauthorizedAccount` errors in your tests.
 241 |     |      *
 242 |     |      * @param beacon Address of the beacon to upgrade
 243 |     |      * @param contractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 244 |     |      * @param opts Common options
 245 |     |      * @param tryCaller Address to use as the caller of the upgrade function. This should be the address that owns the beacon.
 246 |     |      */
 247 |     |     function upgradeBeacon(
 248 |     |         address beacon,
 249 |     |         string memory contractName,
 250 |     |         Options memory opts,
 251 |     |         address tryCaller
 252 |     |     ) internal {
 253 |     |         Core.upgradeBeacon(beacon, contractName, opts, tryCaller);
 254 |     |     }
 255 |     | 
 256 |     |     /**
 257 |     |      * @notice For tests only. If broadcasting in scripts, use the `--sender <ADDRESS>` option with `forge script` instead.
 258 |     |      *
 259 |     |      * @dev Upgrades a beacon to a new implementation contract.
 260 |     |      *
 261 |     |      * Requires that either the `referenceContract` option is set, or the new implementation contract has a `@custom:oz-upgrades-from <reference>` annotation.
 262 |     |      *
 263 |     |      * This function provides an additional `tryCaller` parameter to test an upgrade using a specific caller address.
 264 |     |      * Use this if you encounter `OwnableUnauthorizedAccount` errors in your tests.
 265 |     |      *
 266 |     |      * @param beacon Address of the beacon to upgrade
 267 |     |      * @param contractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 268 |     |      * @param tryCaller Address to use as the caller of the upgrade function. This should be the address that owns the beacon.
 269 |     |      */
 270 |     |     function upgradeBeacon(address beacon, string memory contractName, address tryCaller) internal {
 271 |     |         Options memory opts;
 272 |     |         Core.upgradeBeacon(beacon, contractName, opts, tryCaller);
 273 |     |     }
 274 |     | 
 275 |     |     /**
 276 |     |      * @dev Deploys a beacon proxy using the given beacon and call data.
 277 |     |      *
 278 |     |      * @param beacon Address of the beacon to use
 279 |     |      * @param data Encoded call data of the initializer function to call during creation of the proxy, or empty if no initialization is required
 280 |     |      * @return Proxy address
 281 |     |      */
 282 |     |     function deployBeaconProxy(address beacon, bytes memory data) internal returns (address) {
 283 |     |         Options memory opts;
 284 |     |         return deployBeaconProxy(beacon, data, opts);
 285 |     |     }
 286 |     | 
 287 |     |     /**
 288 |     |      * @dev Deploys a beacon proxy using the given beacon and call data.
 289 |     |      *
 290 |     |      * @param beacon Address of the beacon to use
 291 |     |      * @param data Encoded call data of the initializer function to call during creation of the proxy, or empty if no initialization is required
 292 |     |      * @param opts Common options
 293 |     |      * @return Proxy address
 294 |     |      */
 295 |     |     function deployBeaconProxy(address beacon, bytes memory data, Options memory opts) internal returns (address) {
 296 |     |         return Core.deploy("BeaconProxy.sol:BeaconProxy", abi.encode(beacon, data), opts);
 297 |     |     }
 298 |     | 
 299 |     |     /**
 300 |     |      * @dev Validates an implementation contract, but does not deploy it.
 301 |     |      *
 302 |     |      * @param contractName Name of the contract to validate, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 303 |     |      * @param opts Common options
 304 |     |      */
 305 |     |     function validateImplementation(string memory contractName, Options memory opts) internal {
 306 |     |         Core.validateImplementation(contractName, opts);
 307 |     |     }
 308 |     | 
 309 |     |     /**
 310 |     |      * @dev Validates and deploys an implementation contract, and returns its address.
 311 |     |      *
 312 |     |      * @param contractName Name of the contract to deploy, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 313 |     |      * @param opts Common options
 314 |     |      * @return Address of the implementation contract
 315 |     |      */
 316 |     |     function deployImplementation(string memory contractName, Options memory opts) internal returns (address) {
 317 |     |         return Core.deployImplementation(contractName, opts);
 318 |     |     }
 319 |     | 
 320 |     |     /**
 321 |     |      * @dev Validates a new implementation contract in comparison with a reference contract, but does not deploy it.
 322 |     |      *
 323 |     |      * Requires that either the `referenceContract` option is set, or the contract has a `@custom:oz-upgrades-from <reference>` annotation.
 324 |     |      *
 325 |     |      * @param contractName Name of the contract to validate, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 326 |     |      * @param opts Common options
 327 |     |      */
 328 |     |     function validateUpgrade(string memory contractName, Options memory opts) internal {
 329 |     |         Core.validateUpgrade(contractName, opts);
 330 |     |     }
 331 |     | 
 332 |     |     /**
 333 |     |      * @dev Validates a new implementation contract in comparison with a reference contract, deploys the new implementation contract,
 334 |     |      * and returns its address.
 335 |     |      *
 336 |     |      * Requires that either the `referenceContract` option is set, or the contract has a `@custom:oz-upgrades-from <reference>` annotation.
 337 |     |      *
 338 |     |      * Use this method to prepare an upgrade to be run from an admin address you do not control directly or cannot use from your deployment environment.
 339 |     |      *
 340 |     |      * @param contractName Name of the contract to deploy, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 341 |     |      * @param opts Common options
 342 |     |      * @return Address of the new implementation contract
 343 |     |      */
 344 |     |     function prepareUpgrade(string memory contractName, Options memory opts) internal returns (address) {
 345 |     |         return Core.prepareUpgrade(contractName, opts);
 346 |     |     }
 347 |     | 
 348 |     |     /**
 349 |     |      * @dev Gets the admin address of a transparent proxy from its ERC1967 admin storage slot.
 350 |     |      *
 351 |     |      * @param proxy Address of a transparent proxy
 352 |     |      * @return Admin address
 353 |     |      */
 354 |     |     function getAdminAddress(address proxy) internal view returns (address) {
 355 |     |         return Core.getAdminAddress(proxy);
 356 |     |     }
 357 |     | 
 358 |     |     /**
 359 |     |      * @dev Gets the implementation address of a transparent or UUPS proxy from its ERC1967 implementation storage slot.
 360 |     |      *
 361 |     |      * @param proxy Address of a transparent or UUPS proxy
 362 |     |      * @return Implementation address
 363 |     |      */
 364 |     |     function getImplementationAddress(address proxy) internal view returns (address) {
 365 |     |         return Core.getImplementationAddress(proxy);
 366 |     |     }
 367 |     | 
 368 |     |     /**
 369 |     |      * @dev Gets the beacon address of a beacon proxy from its ERC1967 beacon storage slot.
 370 |     |      *
 371 |     |      * @param proxy Address of a beacon proxy
 372 |     |      * @return Beacon address
 373 |     |      */
 374 |     |     function getBeaconAddress(address proxy) internal view returns (address) {
 375 |     |         return Core.getBeaconAddress(proxy);
 376 |     |     }
 377 |     | }
 378 |     | 
 379 |     | /**
 380 |     |  * @dev Library for deploying and managing upgradeable contracts from Forge tests, without validations.
 381 |     |  *
 382 |     |  * Can be used with `forge coverage`. Requires implementation contracts to be instantiated first.
 383 |     |  * Does not require `--ffi` and does not require a clean compilation before each run.
 384 |     |  *
 385 |     |  * Not supported for OpenZeppelin Defender deployments.
 386 |     |  *
 387 |     |  * WARNING: Not recommended for use in Forge scripts.
 388 |     |  * `UnsafeUpgrades` does not validate whether your contracts are upgrade safe or whether new implementations are compatible with previous ones.
 389 |     |  * Use `Upgrades` if you want validations to be run.
 390 |     |  *
 391 |     |  * NOTE: Requires OpenZeppelin Contracts v5 or higher.
 392 |     |  */
 393 |     | library UnsafeUpgrades {
 394 |     |     /**
 395 |     |      * @dev Deploys a UUPS proxy using the given contract address as the implementation.
 396 |     |      *
 397 |     |      * @param impl Address of the contract to use as the implementation
 398 |     |      * @param initializerData Encoded call data of the initializer function to call during creation of the proxy, or empty if no initialization is required
 399 |     |      * @return Proxy address
 400 |     |      */
 401 | *   |     function deployUUPSProxy(address impl, bytes memory initializerData) internal returns (address) {
 402 | *   |         return address(new ERC1967Proxy(impl, initializerData));
 403 |     |     }
 404 |     | 
 405 |     |     /**
 406 |     |      * @dev Deploys a transparent proxy using the given contract address as the implementation.
 407 |     |      *
 408 |     |      * @param impl Address of the contract to use as the implementation
 409 |     |      * @param initialOwner Address to set as the owner of the ProxyAdmin contract which gets deployed by the proxy
 410 |     |      * @param initializerData Encoded call data of the initializer function to call during creation of the proxy, or empty if no initialization is required
 411 |     |      * @return Proxy address
 412 |     |      */
 413 |     |     function deployTransparentProxy(
 414 |     |         address impl,
 415 |     |         address initialOwner,
 416 |     |         bytes memory initializerData
 417 |     |     ) internal returns (address) {
 418 |     |         return address(new TransparentUpgradeableProxy(impl, initialOwner, initializerData));
 419 |     |     }
 420 |     | 
 421 |     |     /**
 422 |     |      * @dev Upgrades a proxy to a new implementation contract address. Only supported for UUPS or transparent proxies.
 423 |     |      *
 424 |     |      * @param proxy Address of the proxy to upgrade
 425 |     |      * @param newImpl Address of the new implementation contract to upgrade to
 426 |     |      * @param data Encoded call data of an arbitrary function to call during the upgrade process, or empty if no function needs to be called during the upgrade
 427 |     |      */
 428 |     |     function upgradeProxy(address proxy, address newImpl, bytes memory data) internal {
 429 |     |         Core.upgradeProxyTo(proxy, newImpl, data);
 430 |     |     }
 431 |     | 
 432 |     |     /**
 433 |     |      * @notice For tests only. If broadcasting in scripts, use the `--sender <ADDRESS>` option with `forge script` instead.
 434 |     |      *
 435 |     |      * @dev Upgrades a proxy to a new implementation contract address. Only supported for UUPS or transparent proxies.
 436 |     |      *
 437 |     |      * This function provides an additional `tryCaller` parameter to test an upgrade using a specific caller address.
 438 |     |      * Use this if you encounter `OwnableUnauthorizedAccount` errors in your tests.
 439 |     |      *
 440 |     |      * @param proxy Address of the proxy to upgrade
 441 |     |      * @param newImpl Address of the new implementation contract to upgrade to
 442 |     |      * @param data Encoded call data of an arbitrary function to call during the upgrade process, or empty if no function needs to be called during the upgrade
 443 |     |      * @param tryCaller Address to use as the caller of the upgrade function. This should be the address that owns the proxy or its ProxyAdmin.
 444 |     |      */
 445 |     |     function upgradeProxy(address proxy, address newImpl, bytes memory data, address tryCaller) internal {
 446 |     |         Core.upgradeProxyTo(proxy, newImpl, data, tryCaller);
 447 |     |     }
 448 |     | 
 449 |     |     /**
 450 |     |      * @dev Deploys an upgradeable beacon using the given contract address as the implementation.
 451 |     |      *
 452 |     |      * @param impl Address of the contract to use as the implementation
 453 |     |      * @param initialOwner Address to set as the owner of the UpgradeableBeacon contract which gets deployed
 454 |     |      * @return Beacon address
 455 |     |      */
 456 |     |     function deployBeacon(address impl, address initialOwner) internal returns (address) {
 457 |     |         return address(new UpgradeableBeacon(impl, initialOwner));
 458 |     |     }
 459 |     | 
 460 |     |     /**
 461 |     |      * @dev Upgrades a beacon to a new implementation contract address.
 462 |     |      *
 463 |     |      * @param beacon Address of the beacon to upgrade
 464 |     |      * @param newImpl Address of the new implementation contract to upgrade to
 465 |     |      */
 466 |     |     function upgradeBeacon(address beacon, address newImpl) internal {
 467 |     |         Core.upgradeBeaconTo(beacon, newImpl);
 468 |     |     }
 469 |     | 
 470 |     |     /**
 471 |     |      * @notice For tests only. If broadcasting in scripts, use the `--sender <ADDRESS>` option with `forge script` instead.
 472 |     |      *
 473 |     |      * @dev Upgrades a beacon to a new implementation contract address.
 474 |     |      *
 475 |     |      * This function provides an additional `tryCaller` parameter to test an upgrade using a specific caller address.
 476 |     |      * Use this if you encounter `OwnableUnauthorizedAccount` errors in your tests.
 477 |     |      *
 478 |     |      * @param beacon Address of the beacon to upgrade
 479 |     |      * @param newImpl Address of the new implementation contract to upgrade to
 480 |     |      * @param tryCaller Address to use as the caller of the upgrade function. This should be the address that owns the beacon.
 481 |     |      */
 482 |     |     function upgradeBeacon(address beacon, address newImpl, address tryCaller) internal {
 483 |     |         Core.upgradeBeaconTo(beacon, newImpl, tryCaller);
 484 |     |     }
 485 |     | 
 486 |     |     /**
 487 |     |      * @dev Deploys a beacon proxy using the given beacon and call data.
 488 |     |      *
 489 |     |      * @param beacon Address of the beacon to use
 490 |     |      * @param data Encoded call data of the initializer function to call during creation of the proxy, or empty if no initialization is required
 491 |     |      * @return Proxy address
 492 |     |      */
 493 |     |     function deployBeaconProxy(address beacon, bytes memory data) internal returns (address) {
 494 |     |         return address(new BeaconProxy(beacon, data));
 495 |     |     }
 496 |     | 
 497 |     |     /**
 498 |     |      * @dev Gets the admin address of a transparent proxy from its ERC1967 admin storage slot.
 499 |     |      *
 500 |     |      * @param proxy Address of a transparent proxy
 501 |     |      * @return Admin address
 502 |     |      */
 503 |     |     function getAdminAddress(address proxy) internal view returns (address) {
 504 |     |         return Core.getAdminAddress(proxy);
 505 |     |     }
 506 |     | 
 507 |     |     /**
 508 |     |      * @dev Gets the implementation address of a transparent or UUPS proxy from its ERC1967 implementation storage slot.
 509 |     |      *
 510 |     |      * @param proxy Address of a transparent or UUPS proxy
 511 |     |      * @return Implementation address
 512 |     |      */
 513 |     |     function getImplementationAddress(address proxy) internal view returns (address) {
 514 |     |         return Core.getImplementationAddress(proxy);
 515 |     |     }
 516 |     | 
 517 |     |     /**
 518 |     |      * @dev Gets the beacon address of a beacon proxy from its ERC1967 beacon storage slot.
 519 |     |      *
 520 |     |      * @param proxy Address of a beacon proxy
 521 |     |      * @return Beacon address
 522 |     |      */
 523 |     |     function getBeaconAddress(address proxy) internal view returns (address) {
 524 |     |         return Core.getBeaconAddress(proxy);
 525 |     |     }
 526 |     | }
 527 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/openzeppelin-foundry-upgrades/src/internal/Core.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {Vm} from "forge-std/Vm.sol";
   5 |     | import {console} from "forge-std/console.sol";
   6 |     | 
   7 |     | import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
   8 |     | 
   9 |     | import {Options} from "../Options.sol";
  10 |     | import {Versions} from "./Versions.sol";
  11 |     | import {Utils} from "./Utils.sol";
  12 |     | import {DefenderDeploy} from "./DefenderDeploy.sol";
  13 |     | 
  14 |     | import {IUpgradeableProxy} from "./interfaces/IUpgradeableProxy.sol";
  15 |     | import {IProxyAdmin} from "./interfaces/IProxyAdmin.sol";
  16 |     | import {IUpgradeableBeacon} from "./interfaces/IUpgradeableBeacon.sol";
  17 |     | 
  18 |     | /**
  19 |     |  * @dev Internal helper methods to validate/deploy implementations and perform upgrades.
  20 |     |  *
  21 |     |  * WARNING: DO NOT USE DIRECTLY. Use Upgrades.sol, LegacyUpgrades.sol or Defender.sol instead.
  22 |     |  */
  23 |     | library Core {
  24 |     |     /**
  25 |     |      * @dev Upgrades a proxy to a new implementation contract. Only supported for UUPS or transparent proxies.
  26 |     |      *
  27 |     |      * Requires that either the `referenceContract` option is set, or the new implementation contract has a `@custom:oz-upgrades-from <reference>` annotation.
  28 |     |      *
  29 |     |      * @param proxy Address of the proxy to upgrade
  30 |     |      * @param contractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
  31 |     |      * @param data Encoded call data of an arbitrary function to call during the upgrade process, or empty if no function needs to be called during the upgrade
  32 |     |      * @param opts Common options
  33 |     |      */
  34 |     |     function upgradeProxy(address proxy, string memory contractName, bytes memory data, Options memory opts) internal {
  35 |     |         address newImpl = prepareUpgrade(contractName, opts);
  36 |     |         upgradeProxyTo(proxy, newImpl, data);
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @notice For tests only. If broadcasting in scripts, use the `--sender <ADDRESS>` option with `forge script` instead.
  41 |     |      *
  42 |     |      * @dev Upgrades a proxy to a new implementation contract. Only supported for UUPS or transparent proxies.
  43 |     |      *
  44 |     |      * Requires that either the `referenceContract` option is set, or the new implementation contract has a `@custom:oz-upgrades-from <reference>` annotation.
  45 |     |      *
  46 |     |      * This function provides an additional `tryCaller` parameter to test an upgrade using a specific caller address.
  47 |     |      * Use this if you encounter `OwnableUnauthorizedAccount` errors in your tests.
  48 |     |      *
  49 |     |      * @param proxy Address of the proxy to upgrade
  50 |     |      * @param contractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
  51 |     |      * @param data Encoded call data of an arbitrary function to call during the upgrade process, or empty if no function needs to be called during the upgrade
  52 |     |      * @param opts Common options
  53 |     |      * @param tryCaller Address to use as the caller of the upgrade function. This should be the address that owns the proxy or its ProxyAdmin.
  54 |     |      */
  55 |     |     function upgradeProxy(
  56 |     |         address proxy,
  57 |     |         string memory contractName,
  58 |     |         bytes memory data,
  59 |     |         Options memory opts,
  60 |     |         address tryCaller
  61 |     |     ) internal tryPrank(tryCaller) {
  62 |     |         upgradeProxy(proxy, contractName, data, opts);
  63 |     |     }
  64 |     | 
  65 |     |     using Strings for *;
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev Upgrades a proxy to a new implementation contract. Only supported for UUPS or transparent proxies.
  69 |     |      *
  70 |     |      * @param proxy Address of the proxy to upgrade
  71 |     |      * @param newImpl Address of the new implementation contract to upgrade to
  72 |     |      * @param data Encoded call data of an arbitrary function to call during the upgrade process, or empty if no function needs to be called during the upgrade
  73 |     |      */
  74 |     |     function upgradeProxyTo(address proxy, address newImpl, bytes memory data) internal {
  75 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
  76 |     | 
  77 |     |         bytes32 adminSlot = vm.load(proxy, ADMIN_SLOT);
  78 |     |         if (adminSlot == bytes32(0)) {
  79 |     |             string memory upgradeInterfaceVersion = getUpgradeInterfaceVersion(proxy);
  80 |     |             if (upgradeInterfaceVersion.equal("5.0.0") || data.length > 0) {
  81 |     |                 IUpgradeableProxy(proxy).upgradeToAndCall(newImpl, data);
  82 |     |             } else {
  83 |     |                 IUpgradeableProxy(proxy).upgradeTo(newImpl);
  84 |     |             }
  85 |     |         } else {
  86 |     |             address admin = address(uint160(uint256(adminSlot)));
  87 |     |             string memory upgradeInterfaceVersion = getUpgradeInterfaceVersion(admin);
  88 |     |             if (upgradeInterfaceVersion.equal("5.0.0") || data.length > 0) {
  89 |     |                 IProxyAdmin(admin).upgradeAndCall(proxy, newImpl, data);
  90 |     |             } else {
  91 |     |                 IProxyAdmin(admin).upgrade(proxy, newImpl);
  92 |     |             }
  93 |     |         }
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @notice For tests only. If broadcasting in scripts, use the `--sender <ADDRESS>` option with `forge script` instead.
  98 |     |      *
  99 |     |      * @dev Upgrades a proxy to a new implementation contract. Only supported for UUPS or transparent proxies.
 100 |     |      *
 101 |     |      * This function provides an additional `tryCaller` parameter to test an upgrade using a specific caller address.
 102 |     |      * Use this if you encounter `OwnableUnauthorizedAccount` errors in your tests.
 103 |     |      *
 104 |     |      * @param proxy Address of the proxy to upgrade
 105 |     |      * @param newImpl Address of the new implementation contract to upgrade to
 106 |     |      * @param data Encoded call data of an arbitrary function to call during the upgrade process, or empty if no function needs to be called during the upgrade
 107 |     |      * @param tryCaller Address to use as the caller of the upgrade function. This should be the address that owns the proxy or its ProxyAdmin.
 108 |     |      */
 109 |     |     function upgradeProxyTo(
 110 |     |         address proxy,
 111 |     |         address newImpl,
 112 |     |         bytes memory data,
 113 |     |         address tryCaller
 114 |     |     ) internal tryPrank(tryCaller) {
 115 |     |         upgradeProxyTo(proxy, newImpl, data);
 116 |     |     }
 117 |     | 
 118 |     |     /**
 119 |     |      * @dev Upgrades a beacon to a new implementation contract.
 120 |     |      *
 121 |     |      * Requires that either the `referenceContract` option is set, or the new implementation contract has a `@custom:oz-upgrades-from <reference>` annotation.
 122 |     |      *
 123 |     |      * @param beacon Address of the beacon to upgrade
 124 |     |      * @param contractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 125 |     |      * @param opts Common options
 126 |     |      */
 127 |     |     function upgradeBeacon(address beacon, string memory contractName, Options memory opts) internal {
 128 |     |         address newImpl = prepareUpgrade(contractName, opts);
 129 |     |         upgradeBeaconTo(beacon, newImpl);
 130 |     |     }
 131 |     | 
 132 |     |     /**
 133 |     |      * @notice For tests only. If broadcasting in scripts, use the `--sender <ADDRESS>` option with `forge script` instead.
 134 |     |      *
 135 |     |      * @dev Upgrades a beacon to a new implementation contract.
 136 |     |      *
 137 |     |      * Requires that either the `referenceContract` option is set, or the new implementation contract has a `@custom:oz-upgrades-from <reference>` annotation.
 138 |     |      *
 139 |     |      * This function provides an additional `tryCaller` parameter to test an upgrade using a specific caller address.
 140 |     |      * Use this if you encounter `OwnableUnauthorizedAccount` errors in your tests.
 141 |     |      *
 142 |     |      * @param beacon Address of the beacon to upgrade
 143 |     |      * @param contractName Name of the new implementation contract to upgrade to, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 144 |     |      * @param opts Common options
 145 |     |      * @param tryCaller Address to use as the caller of the upgrade function. This should be the address that owns the beacon.
 146 |     |      */
 147 |     |     function upgradeBeacon(
 148 |     |         address beacon,
 149 |     |         string memory contractName,
 150 |     |         Options memory opts,
 151 |     |         address tryCaller
 152 |     |     ) internal tryPrank(tryCaller) {
 153 |     |         upgradeBeacon(beacon, contractName, opts);
 154 |     |     }
 155 |     | 
 156 |     |     /**
 157 |     |      * @dev Upgrades a beacon to a new implementation contract address.
 158 |     |      *
 159 |     |      * @param beacon Address of the beacon to upgrade
 160 |     |      * @param newImpl Address of the new implementation contract to upgrade to
 161 |     |      */
 162 |     |     function upgradeBeaconTo(address beacon, address newImpl) internal {
 163 |     |         IUpgradeableBeacon(beacon).upgradeTo(newImpl);
 164 |     |     }
 165 |     | 
 166 |     |     /**
 167 |     |      * @notice For tests only. If broadcasting in scripts, use the `--sender <ADDRESS>` option with `forge script` instead.
 168 |     |      *
 169 |     |      * @dev Upgrades a beacon to a new implementation contract.
 170 |     |      *
 171 |     |      * This function provides an additional `tryCaller` parameter to test an upgrade using a specific caller address.
 172 |     |      * Use this if you encounter `OwnableUnauthorizedAccount` errors in your tests.
 173 |     |      *
 174 |     |      * @param beacon Address of the beacon to upgrade
 175 |     |      * @param newImpl Address of the new implementation contract to upgrade to
 176 |     |      * @param tryCaller Address to use as the caller of the upgrade function. This should be the address that owns the beacon.
 177 |     |      */
 178 |     |     function upgradeBeaconTo(address beacon, address newImpl, address tryCaller) internal tryPrank(tryCaller) {
 179 |     |         upgradeBeaconTo(beacon, newImpl);
 180 |     |     }
 181 |     | 
 182 |     |     /**
 183 |     |      * @dev Validates an implementation contract, but does not deploy it.
 184 |     |      *
 185 |     |      * @param contractName Name of the contract to validate, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 186 |     |      * @param opts Common options
 187 |     |      */
 188 |     |     function validateImplementation(string memory contractName, Options memory opts) internal {
 189 |     |         _validate(contractName, opts, false);
 190 |     |     }
 191 |     | 
 192 |     |     /**
 193 |     |      * @dev Validates and deploys an implementation contract, and returns its address.
 194 |     |      *
 195 |     |      * @param contractName Name of the contract to deploy, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 196 |     |      * @param opts Common options
 197 |     |      * @return Address of the implementation contract
 198 |     |      */
 199 |     |     function deployImplementation(string memory contractName, Options memory opts) internal returns (address) {
 200 |     |         validateImplementation(contractName, opts);
 201 |     |         return deploy(contractName, opts.constructorData, opts);
 202 |     |     }
 203 |     | 
 204 |     |     /**
 205 |     |      * @dev Validates a new implementation contract in comparison with a reference contract, but does not deploy it.
 206 |     |      *
 207 |     |      * Requires that either the `referenceContract` option is set, or the contract has a `@custom:oz-upgrades-from <reference>` annotation.
 208 |     |      *
 209 |     |      * @param contractName Name of the contract to validate, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 210 |     |      * @param opts Common options
 211 |     |      */
 212 |     |     function validateUpgrade(string memory contractName, Options memory opts) internal {
 213 |     |         _validate(contractName, opts, true);
 214 |     |     }
 215 |     | 
 216 |     |     /**
 217 |     |      * @dev Validates a new implementation contract in comparison with a reference contract, deploys the new implementation contract,
 218 |     |      * and returns its address.
 219 |     |      *
 220 |     |      * Requires that either the `referenceContract` option is set, or the contract has a `@custom:oz-upgrades-from <reference>` annotation.
 221 |     |      *
 222 |     |      * Use this method to prepare an upgrade to be run from an admin address you do not control directly or cannot use from your deployment environment.
 223 |     |      *
 224 |     |      * @param contractName Name of the contract to deploy, e.g. "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
 225 |     |      * @param opts Common options
 226 |     |      * @return Address of the new implementation contract
 227 |     |      */
 228 |     |     function prepareUpgrade(string memory contractName, Options memory opts) internal returns (address) {
 229 |     |         validateUpgrade(contractName, opts);
 230 |     |         return deploy(contractName, opts.constructorData, opts);
 231 |     |     }
 232 |     | 
 233 |     |     /**
 234 |     |      * @dev Gets the admin address of a transparent proxy from its ERC1967 admin storage slot.
 235 |     |      *
 236 |     |      * @param proxy Address of a transparent proxy
 237 |     |      * @return Admin address
 238 |     |      */
 239 |     |     function getAdminAddress(address proxy) internal view returns (address) {
 240 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 241 |     | 
 242 |     |         bytes32 adminSlot = vm.load(proxy, ADMIN_SLOT);
 243 |     |         return address(uint160(uint256(adminSlot)));
 244 |     |     }
 245 |     | 
 246 |     |     /**
 247 |     |      * @dev Gets the implementation address of a transparent or UUPS proxy from its ERC1967 implementation storage slot.
 248 |     |      *
 249 |     |      * @param proxy Address of a transparent or UUPS proxy
 250 |     |      * @return Implementation address
 251 |     |      */
 252 |     |     function getImplementationAddress(address proxy) internal view returns (address) {
 253 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 254 |     | 
 255 |     |         bytes32 implSlot = vm.load(proxy, IMPLEMENTATION_SLOT);
 256 |     |         return address(uint160(uint256(implSlot)));
 257 |     |     }
 258 |     | 
 259 |     |     /**
 260 |     |      * @dev Gets the beacon address of a beacon proxy from its ERC1967 beacon storage slot.
 261 |     |      *
 262 |     |      * @param proxy Address of a beacon proxy
 263 |     |      * @return Beacon address
 264 |     |      */
 265 |     |     function getBeaconAddress(address proxy) internal view returns (address) {
 266 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 267 |     | 
 268 |     |         bytes32 beaconSlot = vm.load(proxy, BEACON_SLOT);
 269 |     |         return address(uint160(uint256(beaconSlot)));
 270 |     |     }
 271 |     | 
 272 |     |     /**
 273 |     |      * @notice For tests only. If broadcasting in scripts, use the `--sender <ADDRESS>` option with `forge script` instead.
 274 |     |      *
 275 |     |      * @dev Runs a function as a prank, or just runs the function normally if the prank could not be started.
 276 |     |      */
 277 |     |     modifier tryPrank(address deployer) {
 278 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 279 |     | 
 280 |     |         try vm.startPrank(deployer) {
 281 |     |             _;
 282 |     |             vm.stopPrank();
 283 |     |         } catch {
 284 |     |             _;
 285 |     |         }
 286 |     |     }
 287 |     | 
 288 |     |     /**
 289 |     |      * @dev Storage slot with the address of the implementation.
 290 |     |      * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.
 291 |     |      */
 292 |     |     bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
 293 |     | 
 294 |     |     /**
 295 |     |      * @dev Storage slot with the admin of the proxy.
 296 |     |      * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.
 297 |     |      */
 298 |     |     bytes32 private constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
 299 |     | 
 300 |     |     /**
 301 |     |      * @dev Storage slot with the UpgradeableBeacon contract which defines the implementation for the proxy.
 302 |     |      * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.
 303 |     |      */
 304 |     |     bytes32 private constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
 305 |     | 
 306 |     |     /**
 307 |     |      * @dev Gets the upgrade interface version string from a proxy or admin contract using the `UPGRADE_INTERFACE_VERSION()` getter.
 308 |     |      * If the contract does not have the getter or the return data does not look like a string, this function returns an empty string.
 309 |     |      */
 310 |     |     function getUpgradeInterfaceVersion(address addr) internal view returns (string memory) {
 311 |     |         // Use staticcall to prevent forge from broadcasting it, and to ensure no state changes
 312 |     |         (bool success, bytes memory returndata) = addr.staticcall(
 313 |     |             abi.encodeWithSignature("UPGRADE_INTERFACE_VERSION()")
 314 |     |         );
 315 |     |         if (success && returndata.length > 32) {
 316 |     |             return abi.decode(returndata, (string));
 317 |     |         } else {
 318 |     |             return "";
 319 |     |         }
 320 |     |     }
 321 |     | 
 322 |     |     /**
 323 |     |      * @dev Infers whether the address might be a ProxyAdmin contract.
 324 |     |      */
 325 |     |     function inferProxyAdmin(address addr) internal view returns (bool) {
 326 |     |         return _hasOwner(addr);
 327 |     |     }
 328 |     | 
 329 |     |     /**
 330 |     |      * @dev Returns true if the address is a contract with an `owner()` function that is not state-changing and returns something that might be an address,
 331 |     |      * otherwise returns false.
 332 |     |      */
 333 |     |     function _hasOwner(address addr) private view returns (bool) {
 334 |     |         // Use staticcall to prevent forge from broadcasting it, and to ensure no state changes
 335 |     |         (bool success, bytes memory returndata) = addr.staticcall(abi.encodeWithSignature("owner()"));
 336 |     |         return (success && returndata.length == 32);
 337 |     |     }
 338 |     | 
 339 |     |     function _validate(string memory contractName, Options memory opts, bool requireReference) private {
 340 |     |         if (opts.unsafeSkipAllChecks) {
 341 |     |             return;
 342 |     |         }
 343 |     | 
 344 |     |         string[] memory inputs = buildValidateCommand(contractName, opts, requireReference);
 345 |     |         Vm.FfiResult memory result = Utils.runAsBashCommand(inputs);
 346 |     |         string memory stdout = string(result.stdout);
 347 |     | 
 348 |     |         // CLI validate command uses exit code to indicate if the validation passed or failed.
 349 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 350 |     |         if (result.exitCode == 0) {
 351 |     |             // As an extra precaution, we also check stdout for "SUCCESS" to ensure it actually ran.
 352 |     |             if (vm.contains(stdout, "SUCCESS")) {
 353 |     |                 if (result.stderr.length > 0) {
 354 |     |                     // Prints warnings from stderr
 355 |     |                     console.log(string(result.stderr));
 356 |     |                 }
 357 |     |                 return;
 358 |     |             } else {
 359 |     |                 revert(string(abi.encodePacked("Failed to run upgrade safety validation: ", stdout)));
 360 |     |             }
 361 |     |         } else {
 362 |     |             if (vm.contains(stdout, "FAILED")) {
 363 |     |                 if (result.stderr.length > 0) {
 364 |     |                     // Prints warnings from stderr
 365 |     |                     console.log(string(result.stderr));
 366 |     |                 }
 367 |     |                 // Validations ran but some contracts were not upgrade safe
 368 |     |                 revert(string(abi.encodePacked("Upgrade safety validation failed:\n", stdout)));
 369 |     |             } else {
 370 |     |                 // Validations failed to run
 371 |     |                 revert(string(abi.encodePacked("Failed to run upgrade safety validation: ", string(result.stderr))));
 372 |     |             }
 373 |     |         }
 374 |     |     }
 375 |     | 
 376 |     |     function buildValidateCommand(
 377 |     |         string memory contractName,
 378 |     |         Options memory opts,
 379 |     |         bool requireReference
 380 |     |     ) internal view returns (string[] memory) {
 381 |     |         string memory outDir = Utils.getOutDir();
 382 |     | 
 383 |     |         string[] memory inputBuilder = new string[](2 ** 16);
 384 |     | 
 385 |     |         uint16 i = 0;
 386 |     | 
 387 |     |         inputBuilder[i++] = "npx";
 388 |     |         inputBuilder[i++] = string(abi.encodePacked("@openzeppelin/upgrades-core@", Versions.UPGRADES_CORE));
 389 |     |         inputBuilder[i++] = "validate";
 390 |     |         inputBuilder[i++] = string(abi.encodePacked(outDir, "/build-info"));
 391 |     |         inputBuilder[i++] = "--contract";
 392 |     |         inputBuilder[i++] = Utils.getFullyQualifiedName(contractName, outDir);
 393 |     | 
 394 |     |         bool hasReferenceContract = bytes(opts.referenceContract).length != 0;
 395 |     |         bool hasReferenceBuildInfoDir = bytes(opts.referenceBuildInfoDir).length != 0;
 396 |     | 
 397 |     |         if (hasReferenceContract) {
 398 |     |             string memory referenceArg = hasReferenceBuildInfoDir
 399 |     |                 ? opts.referenceContract
 400 |     |                 : Utils.getFullyQualifiedName(opts.referenceContract, outDir);
 401 |     |             inputBuilder[i++] = "--reference";
 402 |     |             inputBuilder[i++] = string(abi.encodePacked('"', referenceArg, '"'));
 403 |     |         }
 404 |     | 
 405 |     |         if (hasReferenceBuildInfoDir) {
 406 |     |             inputBuilder[i++] = "--referenceBuildInfoDirs";
 407 |     |             inputBuilder[i++] = string(abi.encodePacked('"', opts.referenceBuildInfoDir, '"'));
 408 |     |         }
 409 |     | 
 410 |     |         for (uint8 j = 0; j < opts.exclude.length; j++) {
 411 |     |             string memory exclude = opts.exclude[j];
 412 |     |             if (bytes(exclude).length != 0) {
 413 |     |                 inputBuilder[i++] = "--exclude";
 414 |     |                 inputBuilder[i++] = string(abi.encodePacked('"', exclude, '"'));
 415 |     |             }
 416 |     |         }
 417 |     | 
 418 |     |         if (opts.unsafeSkipStorageCheck) {
 419 |     |             inputBuilder[i++] = "--unsafeSkipStorageCheck";
 420 |     |         } else if (requireReference) {
 421 |     |             inputBuilder[i++] = "--requireReference";
 422 |     |         }
 423 |     | 
 424 |     |         if (bytes(opts.unsafeAllow).length != 0) {
 425 |     |             inputBuilder[i++] = "--unsafeAllow";
 426 |     |             inputBuilder[i++] = opts.unsafeAllow;
 427 |     |         }
 428 |     | 
 429 |     |         if (opts.unsafeAllowRenames) {
 430 |     |             inputBuilder[i++] = "--unsafeAllowRenames";
 431 |     |         }
 432 |     | 
 433 |     |         // Create a copy of inputs but with the correct length
 434 |     |         string[] memory inputs = new string[](i);
 435 |     |         for (uint16 j = 0; j < i; j++) {
 436 |     |             inputs[j] = inputBuilder[j];
 437 |     |         }
 438 |     | 
 439 |     |         return inputs;
 440 |     |     }
 441 |     | 
 442 |     |     function deploy(
 443 |     |         string memory contractName,
 444 |     |         bytes memory constructorData,
 445 |     |         Options memory opts
 446 |     |     ) internal returns (address) {
 447 |     |         if (opts.defender.useDefenderDeploy) {
 448 |     |             return DefenderDeploy.deploy(contractName, constructorData, opts.defender);
 449 |     |         } else {
 450 |     |             return _deploy(contractName, constructorData);
 451 |     |         }
 452 |     |     }
 453 |     | 
 454 |     |     function _deploy(string memory contractName, bytes memory constructorData) private returns (address) {
 455 |     |         bytes memory creationCode = Vm(Utils.CHEATCODE_ADDRESS).getCode(contractName);
 456 |     |         address deployedAddress = _deployFromBytecode(abi.encodePacked(creationCode, constructorData));
 457 |     |         if (deployedAddress == address(0)) {
 458 |     |             revert(
 459 |     |                 string(
 460 |     |                     abi.encodePacked(
 461 |     |                         "Failed to deploy contract ",
 462 |     |                         contractName,
 463 |     |                         ' using constructor data "',
 464 |     |                         string(constructorData),
 465 |     |                         '"'
 466 |     |                     )
 467 |     |                 )
 468 |     |             );
 469 |     |         }
 470 |     |         return deployedAddress;
 471 |     |     }
 472 |     | 
 473 |     |     function _deployFromBytecode(bytes memory bytecode) private returns (address) {
 474 |     |         address addr;
 475 |     |         /// @solidity memory-safe-assembly
 476 |     |         assembly {
 477 |     |             addr := create(0, add(bytecode, 32), mload(bytecode))
 478 |     |         }
 479 |     |         return addr;
 480 |     |     }
 481 |     | }
 482 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/openzeppelin-foundry-upgrades/src/internal/DefenderDeploy.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {Vm} from "forge-std/Vm.sol";
   5 |     | import {console} from "forge-std/console.sol";
   6 |     | 
   7 |     | import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
   8 |     | 
   9 |     | import {Utils, ContractInfo} from "./Utils.sol";
  10 |     | import {Versions} from "./Versions.sol";
  11 |     | import {Options, DefenderOptions} from "../Options.sol";
  12 |     | import {ProposeUpgradeResponse, ApprovalProcessResponse} from "../Defender.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @dev Internal helper methods for Defender deployments.
  16 |     |  *
  17 |     |  * WARNING: DO NOT USE DIRECTLY. Use Defender.sol instead.
  18 |     |  */
  19 |     | library DefenderDeploy {
  20 |     |     function deploy(
  21 |     |         string memory contractName,
  22 |     |         bytes memory constructorData,
  23 |     |         DefenderOptions memory defenderOpts
  24 |     |     ) internal returns (address) {
  25 |     |         string memory outDir = Utils.getOutDir();
  26 |     |         ContractInfo memory contractInfo = Utils.getContractInfo(contractName, outDir);
  27 |     |         string memory buildInfoFile = Utils.getBuildInfoFile(
  28 |     |             contractInfo.sourceCodeHash,
  29 |     |             contractInfo.shortName,
  30 |     |             outDir
  31 |     |         );
  32 |     | 
  33 |     |         string[] memory inputs = buildDeployCommand(contractInfo, buildInfoFile, constructorData, defenderOpts);
  34 |     | 
  35 |     |         Vm.FfiResult memory result = Utils.runAsBashCommand(inputs);
  36 |     |         string memory stdout = string(result.stdout);
  37 |     | 
  38 |     |         if (result.exitCode != 0) {
  39 |     |             revert(string(abi.encodePacked("Failed to deploy contract ", contractName, ": ", string(result.stderr))));
  40 |     |         }
  41 |     | 
  42 |     |         string memory deployedAddress = _parseLine("Deployed to address: ", stdout, true);
  43 |     |         return Vm(Utils.CHEATCODE_ADDRESS).parseAddress(deployedAddress);
  44 |     |     }
  45 |     | 
  46 |     |     function buildDeployCommand(
  47 |     |         ContractInfo memory contractInfo,
  48 |     |         string memory buildInfoFile,
  49 |     |         bytes memory constructorData,
  50 |     |         DefenderOptions memory defenderOpts
  51 |     |     ) internal view returns (string[] memory) {
  52 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
  53 |     | 
  54 |     |         if (bytes(defenderOpts.licenseType).length != 0) {
  55 |     |             if (defenderOpts.skipVerifySourceCode) {
  56 |     |                 revert("The `licenseType` option cannot be used when the `skipVerifySourceCode` option is `true`");
  57 |     |             } else if (defenderOpts.skipLicenseType) {
  58 |     |                 revert("The `licenseType` option cannot be used when the `skipLicenseType` option is `true`");
  59 |     |             }
  60 |     |         }
  61 |     | 
  62 |     |         string[] memory inputBuilder = new string[](255);
  63 |     | 
  64 |     |         uint8 i = 0;
  65 |     | 
  66 |     |         inputBuilder[i++] = "npx";
  67 |     |         inputBuilder[i++] = string(
  68 |     |             abi.encodePacked("@openzeppelin/defender-deploy-client-cli@", Versions.DEFENDER_DEPLOY_CLIENT_CLI)
  69 |     |         );
  70 |     |         inputBuilder[i++] = "deploy";
  71 |     |         inputBuilder[i++] = "--contractName";
  72 |     |         inputBuilder[i++] = contractInfo.shortName;
  73 |     |         inputBuilder[i++] = "--contractPath";
  74 |     |         inputBuilder[i++] = contractInfo.contractPath;
  75 |     |         inputBuilder[i++] = "--chainId";
  76 |     |         inputBuilder[i++] = Strings.toString(block.chainid);
  77 |     |         inputBuilder[i++] = "--buildInfoFile";
  78 |     |         inputBuilder[i++] = buildInfoFile;
  79 |     |         if (constructorData.length > 0) {
  80 |     |             inputBuilder[i++] = "--constructorBytecode";
  81 |     |             inputBuilder[i++] = vm.toString(constructorData);
  82 |     |         }
  83 |     |         if (defenderOpts.skipVerifySourceCode) {
  84 |     |             inputBuilder[i++] = "--verifySourceCode";
  85 |     |             inputBuilder[i++] = "false";
  86 |     |         } else if (bytes(defenderOpts.licenseType).length != 0) {
  87 |     |             inputBuilder[i++] = "--licenseType";
  88 |     |             inputBuilder[i++] = string(abi.encodePacked('"', defenderOpts.licenseType, '"'));
  89 |     |         } else if (!defenderOpts.skipLicenseType && bytes(contractInfo.license).length != 0) {
  90 |     |             inputBuilder[i++] = "--licenseType";
  91 |     |             inputBuilder[i++] = string(abi.encodePacked('"', _toLicenseType(contractInfo), '"'));
  92 |     |         }
  93 |     |         if (bytes(defenderOpts.relayerId).length != 0) {
  94 |     |             inputBuilder[i++] = "--relayerId";
  95 |     |             inputBuilder[i++] = defenderOpts.relayerId;
  96 |     |         }
  97 |     |         if (defenderOpts.salt != 0) {
  98 |     |             inputBuilder[i++] = "--salt";
  99 |     |             inputBuilder[i++] = vm.toString(defenderOpts.salt);
 100 |     |         }
 101 |     |         if (defenderOpts.txOverrides.gasLimit != 0) {
 102 |     |             inputBuilder[i++] = "--gasLimit";
 103 |     |             inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.gasLimit);
 104 |     |         }
 105 |     |         if (defenderOpts.txOverrides.gasPrice != 0) {
 106 |     |             inputBuilder[i++] = "--gasPrice";
 107 |     |             inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.gasPrice);
 108 |     |         }
 109 |     |         if (defenderOpts.txOverrides.maxFeePerGas != 0) {
 110 |     |             inputBuilder[i++] = "--maxFeePerGas";
 111 |     |             inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.maxFeePerGas);
 112 |     |         }
 113 |     |         if (defenderOpts.txOverrides.maxPriorityFeePerGas != 0) {
 114 |     |             inputBuilder[i++] = "--maxPriorityFeePerGas";
 115 |     |             inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.maxPriorityFeePerGas);
 116 |     |         }
 117 |     |         if (bytes(defenderOpts.metadata).length != 0) {
 118 |     |             inputBuilder[i++] = "--metadata";
 119 |     |             inputBuilder[i++] = string(abi.encodePacked('"', vm.replace(defenderOpts.metadata, '"', '\\"'), '"'));
 120 |     |         }
 121 |     |         inputBuilder[i++] = "--origin";
 122 |     |         inputBuilder[i++] = "Foundry";
 123 |     | 
 124 |     |         // Create a copy of inputs but with the correct length
 125 |     |         string[] memory inputs = new string[](i);
 126 |     |         for (uint8 j = 0; j < i; j++) {
 127 |     |             inputs[j] = inputBuilder[j];
 128 |     |         }
 129 |     | 
 130 |     |         return inputs;
 131 |     |     }
 132 |     | 
 133 |     |     using Strings for string;
 134 |     | 
 135 |     |     function _toLicenseType(ContractInfo memory contractInfo) private pure returns (string memory) {
 136 |     |         string memory id = contractInfo.license;
 137 |     |         if (id.equal("UNLICENSED")) {
 138 |     |             return "None";
 139 |     |         } else if (id.equal("Unlicense")) {
 140 |     |             return "Unlicense";
 141 |     |         } else if (id.equal("MIT")) {
 142 |     |             return "MIT";
 143 |     |         } else if (id.equal("GPL-2.0-only") || id.equal("GPL-2.0-or-later")) {
 144 |     |             return "GNU GPLv2";
 145 |     |         } else if (id.equal("GPL-3.0-only") || id.equal("GPL-3.0-or-later")) {
 146 |     |             return "GNU GPLv3";
 147 |     |         } else if (id.equal("LGPL-2.1-only") || id.equal("LGPL-2.1-or-later")) {
 148 |     |             return "GNU LGPLv2.1";
 149 |     |         } else if (id.equal("LGPL-3.0-only") || id.equal("LGPL-3.0-or-later")) {
 150 |     |             return "GNU LGPLv3";
 151 |     |         } else if (id.equal("BSD-2-Clause")) {
 152 |     |             return "BSD-2-Clause";
 153 |     |         } else if (id.equal("BSD-3-Clause")) {
 154 |     |             return "BSD-3-Clause";
 155 |     |         } else if (id.equal("MPL-2.0")) {
 156 |     |             return "MPL-2.0";
 157 |     |         } else if (id.equal("OSL-3.0")) {
 158 |     |             return "OSL-3.0";
 159 |     |         } else if (id.equal("Apache-2.0")) {
 160 |     |             return "Apache-2.0";
 161 |     |         } else if (id.equal("AGPL-3.0-only") || id.equal("AGPL-3.0-or-later")) {
 162 |     |             return "GNU AGPLv3";
 163 |     |         } else if (id.equal("BUSL-1.1")) {
 164 |     |             return "BSL 1.1";
 165 |     |         } else {
 166 |     |             revert(
 167 |     |                 string(
 168 |     |                     abi.encodePacked(
 169 |     |                         "SPDX license identifier ",
 170 |     |                         contractInfo.license,
 171 |     |                         " in ",
 172 |     |                         contractInfo.contractPath,
 173 |     |                         " does not look like a supported license for block explorer verification. Use the `licenseType` option to specify a license type, or set the `skipLicenseType` option to `true` to skip."
 174 |     |                     )
 175 |     |                 )
 176 |     |             );
 177 |     |         }
 178 |     |     }
 179 |     | 
 180 |     |     function proposeUpgrade(
 181 |     |         address proxyAddress,
 182 |     |         address proxyAdminAddress,
 183 |     |         address newImplementationAddress,
 184 |     |         string memory newImplementationContractName,
 185 |     |         Options memory opts
 186 |     |     ) internal returns (ProposeUpgradeResponse memory) {
 187 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 188 |     | 
 189 |     |         string memory outDir = Utils.getOutDir();
 190 |     |         ContractInfo memory contractInfo = Utils.getContractInfo(newImplementationContractName, outDir);
 191 |     | 
 192 |     |         string[] memory inputs = buildProposeUpgradeCommand(
 193 |     |             proxyAddress,
 194 |     |             proxyAdminAddress,
 195 |     |             newImplementationAddress,
 196 |     |             contractInfo,
 197 |     |             opts
 198 |     |         );
 199 |     | 
 200 |     |         Vm.FfiResult memory result = Utils.runAsBashCommand(inputs);
 201 |     |         string memory stdout = string(result.stdout);
 202 |     | 
 203 |     |         if (result.exitCode != 0) {
 204 |     |             revert(
 205 |     |                 string(
 206 |     |                     abi.encodePacked(
 207 |     |                         "Failed to propose upgrade for proxy ",
 208 |     |                         vm.toString(proxyAddress),
 209 |     |                         ": ",
 210 |     |                         string(result.stderr)
 211 |     |                     )
 212 |     |                 )
 213 |     |             );
 214 |     |         }
 215 |     | 
 216 |     |         return parseProposeUpgradeResponse(stdout);
 217 |     |     }
 218 |     | 
 219 |     |     function parseProposeUpgradeResponse(string memory stdout) internal returns (ProposeUpgradeResponse memory) {
 220 |     |         ProposeUpgradeResponse memory response;
 221 |     |         response.proposalId = _parseLine("Proposal ID: ", stdout, true);
 222 |     |         response.url = _parseLine("Proposal URL: ", stdout, false);
 223 |     |         return response;
 224 |     |     }
 225 |     | 
 226 |     |     function _parseLine(
 227 |     |         string memory expectedPrefix,
 228 |     |         string memory stdout,
 229 |     |         bool required
 230 |     |     ) private returns (string memory) {
 231 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 232 |     |         if (vm.contains(stdout, expectedPrefix)) {
 233 |     |             // Get the substring after the prefix
 234 |     |             string[] memory segments = vm.split(stdout, expectedPrefix);
 235 |     |             if (segments.length > 2) {
 236 |     |                 revert(
 237 |     |                     string(
 238 |     |                         abi.encodePacked(
 239 |     |                             "Found multiple occurrences of prefix '",
 240 |     |                             expectedPrefix,
 241 |     |                             "' in output: ",
 242 |     |                             stdout
 243 |     |                         )
 244 |     |                     )
 245 |     |                 );
 246 |     |             }
 247 |     |             string memory suffix = segments[1];
 248 |     |             // Keep only the first line
 249 |     |             return vm.split(suffix, "\n")[0];
 250 |     |         } else if (required) {
 251 |     |             revert(
 252 |     |                 string(abi.encodePacked("Failed to find line with prefix '", expectedPrefix, "' in output: ", stdout))
 253 |     |             );
 254 |     |         } else {
 255 |     |             return "";
 256 |     |         }
 257 |     |     }
 258 |     | 
 259 |     |     function buildProposeUpgradeCommand(
 260 |     |         address proxyAddress,
 261 |     |         address proxyAdminAddress,
 262 |     |         address newImplementationAddress,
 263 |     |         ContractInfo memory contractInfo,
 264 |     |         Options memory opts
 265 |     |     ) internal view returns (string[] memory) {
 266 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 267 |     | 
 268 |     |         string[] memory inputBuilder = new string[](255);
 269 |     | 
 270 |     |         uint8 i = 0;
 271 |     | 
 272 |     |         inputBuilder[i++] = "npx";
 273 |     |         inputBuilder[i++] = string(
 274 |     |             abi.encodePacked("@openzeppelin/defender-deploy-client-cli@", Versions.DEFENDER_DEPLOY_CLIENT_CLI)
 275 |     |         );
 276 |     |         inputBuilder[i++] = "proposeUpgrade";
 277 |     |         inputBuilder[i++] = "--proxyAddress";
 278 |     |         inputBuilder[i++] = vm.toString(proxyAddress);
 279 |     |         inputBuilder[i++] = "--newImplementationAddress";
 280 |     |         inputBuilder[i++] = vm.toString(newImplementationAddress);
 281 |     |         inputBuilder[i++] = "--chainId";
 282 |     |         inputBuilder[i++] = Strings.toString(block.chainid);
 283 |     |         inputBuilder[i++] = "--contractArtifactFile";
 284 |     |         inputBuilder[i++] = string(abi.encodePacked('"', contractInfo.artifactPath, '"'));
 285 |     |         if (proxyAdminAddress != address(0)) {
 286 |     |             inputBuilder[i++] = "--proxyAdminAddress";
 287 |     |             inputBuilder[i++] = vm.toString(proxyAdminAddress);
 288 |     |         }
 289 |     |         if (bytes(opts.defender.upgradeApprovalProcessId).length != 0) {
 290 |     |             inputBuilder[i++] = "--approvalProcessId";
 291 |     |             inputBuilder[i++] = opts.defender.upgradeApprovalProcessId;
 292 |     |         }
 293 |     | 
 294 |     |         // Create a copy of inputs but with the correct length
 295 |     |         string[] memory inputs = new string[](i);
 296 |     |         for (uint8 j = 0; j < i; j++) {
 297 |     |             inputs[j] = inputBuilder[j];
 298 |     |         }
 299 |     | 
 300 |     |         return inputs;
 301 |     |     }
 302 |     | 
 303 |     |     function getApprovalProcess(string memory command) internal returns (ApprovalProcessResponse memory) {
 304 |     |         string[] memory inputs = buildGetApprovalProcessCommand(command);
 305 |     | 
 306 |     |         Vm.FfiResult memory result = Utils.runAsBashCommand(inputs);
 307 |     |         string memory stdout = string(result.stdout);
 308 |     | 
 309 |     |         if (result.exitCode != 0) {
 310 |     |             revert(string(abi.encodePacked("Failed to get approval process: ", string(result.stderr))));
 311 |     |         }
 312 |     | 
 313 |     |         return parseApprovalProcessResponse(stdout);
 314 |     |     }
 315 |     | 
 316 |     |     function parseApprovalProcessResponse(string memory stdout) internal returns (ApprovalProcessResponse memory) {
 317 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 318 |     | 
 319 |     |         ApprovalProcessResponse memory response;
 320 |     | 
 321 |     |         response.approvalProcessId = _parseLine("Approval process ID: ", stdout, true);
 322 |     | 
 323 |     |         string memory viaString = _parseLine("Via: ", stdout, false);
 324 |     |         if (bytes(viaString).length != 0) {
 325 |     |             response.via = vm.parseAddress(viaString);
 326 |     |         }
 327 |     | 
 328 |     |         response.viaType = _parseLine("Via type: ", stdout, false);
 329 |     | 
 330 |     |         return response;
 331 |     |     }
 332 |     | 
 333 |     |     function buildGetApprovalProcessCommand(string memory command) internal view returns (string[] memory) {
 334 |     |         string[] memory inputBuilder = new string[](255);
 335 |     | 
 336 |     |         uint8 i = 0;
 337 |     | 
 338 |     |         inputBuilder[i++] = "npx";
 339 |     |         inputBuilder[i++] = string(
 340 |     |             abi.encodePacked("@openzeppelin/defender-deploy-client-cli@", Versions.DEFENDER_DEPLOY_CLIENT_CLI)
 341 |     |         );
 342 |     |         inputBuilder[i++] = command;
 343 |     |         inputBuilder[i++] = "--chainId";
 344 |     |         inputBuilder[i++] = Strings.toString(block.chainid);
 345 |     | 
 346 |     |         // Create a copy of inputs but with the correct length
 347 |     |         string[] memory inputs = new string[](i);
 348 |     |         for (uint8 j = 0; j < i; j++) {
 349 |     |             inputs[j] = inputBuilder[j];
 350 |     |         }
 351 |     | 
 352 |     |         return inputs;
 353 |     |     }
 354 |     | }
 355 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/openzeppelin-foundry-upgrades/src/internal/StringFinder.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {Vm} from "forge-std/Vm.sol";
  5 |     | import {Utils} from "./Utils.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * String finder functions using Forge's string cheatcodes.
  9 |     |  * For internal use only.
 10 |     |  */
 11 |     | library StringFinder {
 12 |     |     /**
 13 |     |      * Returns whether the subject string contains the search string.
 14 |     |      */
 15 |     |     function contains(string memory subject, string memory search) internal returns (bool) {
 16 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 17 |     |         return vm.contains(subject, search);
 18 |     |     }
 19 |     | 
 20 |     |     /**
 21 |     |      * Returns whether the subject string starts with the search string.
 22 |     |      */
 23 |     |     function startsWith(string memory subject, string memory search) internal pure returns (bool) {
 24 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 25 |     |         uint256 index = vm.indexOf(subject, search);
 26 |     |         return index == 0;
 27 |     |     }
 28 |     | 
 29 |     |     /**
 30 |     |      * Returns whether the subject string ends with the search string.
 31 |     |      */
 32 |     |     function endsWith(string memory subject, string memory search) internal pure returns (bool) {
 33 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 34 |     |         string[] memory tokens = vm.split(subject, search);
 35 |     |         return tokens.length > 1 && bytes(tokens[tokens.length - 1]).length == 0;
 36 |     |     }
 37 |     | 
 38 |     |     /**
 39 |     |      * Returns the number of non-overlapping occurrences of the search string in the subject string.
 40 |     |      */
 41 |     |     function count(string memory subject, string memory search) internal pure returns (uint256) {
 42 |     |         Vm vm = Vm(Utils.CHEATCODE_ADDRESS);
 43 |     |         string[] memory tokens = vm.split(subject, search);
 44 |     |         return tokens.length - 1;
 45 |     |     }
 46 |     | }
 47 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/openzeppelin-foundry-upgrades/src/internal/Utils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {Vm} from "forge-std/Vm.sol";
   5 |     | import {console} from "forge-std/console.sol";
   6 |     | 
   7 |     | import {StringFinder} from "./StringFinder.sol";
   8 |     | 
   9 |     | struct ContractInfo {
  10 |     |     /*
  11 |     |      * Contract path, e.g. "src/MyContract.sol"
  12 |     |      */
  13 |     |     string contractPath;
  14 |     |     /*
  15 |     |      * Contract short name, e.g. "MyContract"
  16 |     |      */
  17 |     |     string shortName;
  18 |     |     /*
  19 |     |      * License identifier from the compiled artifact. Empty if not found.
  20 |     |      */
  21 |     |     string license;
  22 |     |     /*
  23 |     |      * keccak256 hash of the source code from metadata
  24 |     |      */
  25 |     |     string sourceCodeHash;
  26 |     |     /*
  27 |     |      * Artifact file path e.g. the path of the file 'out/MyContract.sol/MyContract.json'
  28 |     |      */
  29 |     |     string artifactPath;
  30 |     | }
  31 |     | 
  32 |     | /**
  33 |     |  * @dev Internal helper methods used by Upgrades and Defender libraries.
  34 |     |  */
  35 |     | library Utils {
  36 |     |     address constant CHEATCODE_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Gets the fully qualified name of a contract.
  40 |     |      *
  41 |     |      * @param contractName Contract name in the format "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
  42 |     |      * @param outDir Foundry output directory to search in if contractName is not an artifact path
  43 |     |      * @return Fully qualified name of the contract, e.g. "src/MyContract.sol:MyContract"
  44 |     |      */
  45 |     |     function getFullyQualifiedName(
  46 |     |         string memory contractName,
  47 |     |         string memory outDir
  48 |     |     ) internal view returns (string memory) {
  49 |     |         ContractInfo memory info = getContractInfo(contractName, outDir);
  50 |     |         return string(abi.encodePacked(info.contractPath, ":", info.shortName));
  51 |     |     }
  52 |     | 
  53 |     |     /**
  54 |     |      * @dev Gets information about a contract from its Foundry artifact.
  55 |     |      *
  56 |     |      * @param contractName Contract name in the format "MyContract.sol" or "MyContract.sol:MyContract" or artifact path relative to the project root directory
  57 |     |      * @param outDir Foundry output directory to search in if contractName is not an artifact path
  58 |     |      * @return ContractInfo struct containing information about the contract
  59 |     |      */
  60 |     |     function getContractInfo(
  61 |     |         string memory contractName,
  62 |     |         string memory outDir
  63 |     |     ) internal view returns (ContractInfo memory) {
  64 |     |         Vm vm = Vm(CHEATCODE_ADDRESS);
  65 |     | 
  66 |     |         ContractInfo memory info;
  67 |     | 
  68 |     |         info.shortName = _toShortName(contractName);
  69 |     | 
  70 |     |         string memory fileName = _toFileName(contractName);
  71 |     | 
  72 |     |         string memory artifactPath = string(
  73 |     |             abi.encodePacked(vm.projectRoot(), "/", outDir, "/", fileName, "/", info.shortName, ".json")
  74 |     |         );
  75 |     |         string memory artifactJson = vm.readFile(artifactPath);
  76 |     | 
  77 |     |         if (!vm.keyExistsJson(artifactJson, ".ast")) {
  78 |     |             revert(
  79 |     |                 string(
  80 |     |                     abi.encodePacked(
  81 |     |                         "Could not find AST in artifact ",
  82 |     |                         artifactPath,
  83 |     |                         ". Set `ast = true` in foundry.toml"
  84 |     |                     )
  85 |     |                 )
  86 |     |             );
  87 |     |         }
  88 |     |         info.contractPath = vm.parseJsonString(artifactJson, ".ast.absolutePath");
  89 |     |         if (vm.keyExistsJson(artifactJson, ".ast.license")) {
  90 |     |             info.license = vm.parseJsonString(artifactJson, ".ast.license");
  91 |     |         }
  92 |     |         info.sourceCodeHash = vm.parseJsonString(
  93 |     |             artifactJson,
  94 |     |             string(abi.encodePacked(".metadata.sources.['", info.contractPath, "'].keccak256"))
  95 |     |         );
  96 |     |         info.artifactPath = artifactPath;
  97 |     | 
  98 |     |         return info;
  99 |     |     }
 100 |     | 
 101 |     |     using StringFinder for string;
 102 |     | 
 103 |     |     /**
 104 |     |      * Gets the path to the build-info file that contains the given bytecode.
 105 |     |      *
 106 |     |      * @param sourceCodeHash keccak256 hash of the source code from metadata
 107 |     |      * @param contractName Contract name to display in error message if build-info file is not found
 108 |     |      * @param outDir Foundry output directory that contains a build-info directory
 109 |     |      * @return The path to the build-info file that contains the given bytecode
 110 |     |      */
 111 |     |     function getBuildInfoFile(
 112 |     |         string memory sourceCodeHash,
 113 |     |         string memory contractName,
 114 |     |         string memory outDir
 115 |     |     ) internal returns (string memory) {
 116 |     |         string[] memory inputs = new string[](4);
 117 |     |         inputs[0] = "grep";
 118 |     |         inputs[1] = "-rl";
 119 |     |         inputs[2] = string(abi.encodePacked('"', sourceCodeHash, '"'));
 120 |     |         inputs[3] = string(abi.encodePacked(outDir, "/build-info"));
 121 |     | 
 122 |     |         Vm.FfiResult memory result = runAsBashCommand(inputs);
 123 |     |         string memory stdout = string(result.stdout);
 124 |     | 
 125 |     |         if (!stdout.endsWith(".json")) {
 126 |     |             revert(
 127 |     |                 string(
 128 |     |                     abi.encodePacked(
 129 |     |                         "Could not find build-info file with matching source code hash for contract ",
 130 |     |                         contractName
 131 |     |                     )
 132 |     |                 )
 133 |     |             );
 134 |     |         }
 135 |     | 
 136 |     |         return stdout;
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Gets the output directory from the FOUNDRY_OUT environment variable, or defaults to "out" if not set.
 141 |     |      */
 142 |     |     function getOutDir() internal view returns (string memory) {
 143 |     |         Vm vm = Vm(CHEATCODE_ADDRESS);
 144 |     | 
 145 |     |         string memory defaultOutDir = "out";
 146 |     |         return vm.envOr("FOUNDRY_OUT", defaultOutDir);
 147 |     |     }
 148 |     | 
 149 |     |     function _toFileName(string memory name) private pure returns (string memory) {
 150 |     |         Vm vm = Vm(CHEATCODE_ADDRESS);
 151 |     |         if (name.endsWith(".sol")) {
 152 |     |             return name;
 153 |     |         } else if (name.count(":") == 1) {
 154 |     |             return vm.split(name, ":")[0];
 155 |     |         } else {
 156 |     |             if (name.endsWith(".json")) {
 157 |     |                 string[] memory parts = vm.split(name, "/");
 158 |     |                 if (parts.length > 1) {
 159 |     |                     return parts[parts.length - 2];
 160 |     |                 }
 161 |     |             }
 162 |     | 
 163 |     |             revert(
 164 |     |                 string(
 165 |     |                     abi.encodePacked(
 166 |     |                         "Contract name ",
 167 |     |                         name,
 168 |     |                         " must be in the format MyContract.sol:MyContract or MyContract.sol or out/MyContract.sol/MyContract.json"
 169 |     |                     )
 170 |     |                 )
 171 |     |             );
 172 |     |         }
 173 |     |     }
 174 |     | 
 175 |     |     function _toShortName(string memory name) private pure returns (string memory) {
 176 |     |         Vm vm = Vm(CHEATCODE_ADDRESS);
 177 |     |         if (name.endsWith(".sol") && name.count(".sol") == 1) {
 178 |     |             return vm.replace(name, ".sol", "");
 179 |     |         } else if (name.count(":") == 1) {
 180 |     |             return vm.split(name, ":")[1];
 181 |     |         } else if (name.endsWith(".json") && name.count(".json") == 1) {
 182 |     |             string[] memory parts = vm.split(name, "/");
 183 |     |             string memory jsonName = parts[parts.length - 1];
 184 |     |             return vm.replace(jsonName, ".json", "");
 185 |     |         } else {
 186 |     |             revert(
 187 |     |                 string(
 188 |     |                     abi.encodePacked(
 189 |     |                         "Contract name ",
 190 |     |                         name,
 191 |     |                         " must be in the format MyContract.sol:MyContract or MyContract.sol or out/MyContract.sol/MyContract.json"
 192 |     |                     )
 193 |     |                 )
 194 |     |             );
 195 |     |         }
 196 |     |     }
 197 |     | 
 198 |     |     /**
 199 |     |      * @dev Converts an array of inputs to a bash command.
 200 |     |      * @param inputs Inputs for a command, e.g. ["grep", "-rl", "0x1234", "out/build-info"]
 201 |     |      * @param bashPath Path to the bash executable or just "bash" if it is in the PATH
 202 |     |      * @return A bash command that runs the given inputs, e.g. ["bash", "-c", "grep -rl 0x1234 out/build-info"]
 203 |     |      */
 204 |     |     function toBashCommand(string[] memory inputs, string memory bashPath) internal pure returns (string[] memory) {
 205 |     |         string memory commandString;
 206 |     |         for (uint i = 0; i < inputs.length; i++) {
 207 |     |             commandString = string(abi.encodePacked(commandString, inputs[i]));
 208 |     |             if (i != inputs.length - 1) {
 209 |     |                 commandString = string(abi.encodePacked(commandString, " "));
 210 |     |             }
 211 |     |         }
 212 |     | 
 213 |     |         string[] memory result = new string[](3);
 214 |     |         result[0] = bashPath;
 215 |     |         result[1] = "-c";
 216 |     |         result[2] = commandString;
 217 |     |         return result;
 218 |     |     }
 219 |     | 
 220 |     |     /**
 221 |     |      * @dev Runs an arbitrary command using bash.
 222 |     |      * @param inputs Inputs for a command, e.g. ["grep", "-rl", "0x1234", "out/build-info"]
 223 |     |      * @return The result of the corresponding bash command as a Vm.FfiResult struct
 224 |     |      */
 225 |     |     function runAsBashCommand(string[] memory inputs) internal returns (Vm.FfiResult memory) {
 226 |     |         Vm vm = Vm(CHEATCODE_ADDRESS);
 227 |     |         string memory defaultBashPath = "bash";
 228 |     |         string memory bashPath = vm.envOr("OPENZEPPELIN_BASH_PATH", defaultBashPath);
 229 |     | 
 230 |     |         string[] memory bashCommand = toBashCommand(inputs, bashPath);
 231 |     |         Vm.FfiResult memory result = vm.tryFfi(bashCommand);
 232 |     |         if (result.exitCode != 0 && result.stdout.length == 0 && result.stderr.length == 0) {
 233 |     |             // On Windows, using the bash executable from WSL leads to a non-zero exit code and no output
 234 |     |             revert(
 235 |     |                 string(
 236 |     |                     abi.encodePacked(
 237 |     |                         'Failed to run bash command with "',
 238 |     |                         bashCommand[0],
 239 |     |                         '". If you are using Windows, set the OPENZEPPELIN_BASH_PATH environment variable to the fully qualified path of the bash executable. For example, if you are using Git for Windows, add the following line in the .env file of your project (using forward slashes):\nOPENZEPPELIN_BASH_PATH="C:/Program Files/Git/bin/bash"'
 240 |     |                     )
 241 |     |                 )
 242 |     |             );
 243 |     |         } else {
 244 |     |             return result;
 245 |     |         }
 246 |     |     }
 247 |     | }
 248 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/openzeppelin-foundry-upgrades/src/internal/Versions.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | library Versions {
  5 |     |     // TODO add a workflow to update this automatically based on package.json
  6 |     |     string constant UPGRADES_CORE = "^1.37.0";
  7 |     |     string constant DEFENDER_DEPLOY_CLIENT_CLI = "0.0.1-alpha.10";
  8 |     | }
  9 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/openzeppelin-foundry-upgrades/src/internal/interfaces/IProxyAdmin.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IProxyAdmin {
  5 |     |     /**
  6 |     |      * Upgrades a proxy to a new implementation without calling a function on the new implementation.
  7 |     |      */
  8 |     |     function upgrade(address, address) external;
  9 |     | 
 10 |     |     /**
 11 |     |      * Upgrades a proxy to a new implementation and calls a function on the new implementation.
 12 |     |      * If UPGRADE_INTERFACE_VERSION is "5.0.0", bytes can be empty if no function should be called on the new implementation.
 13 |     |      */
 14 |     |     function upgradeAndCall(address, address, bytes memory) external payable;
 15 |     | }
 16 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/openzeppelin-foundry-upgrades/src/internal/interfaces/IUpgradeableBeacon.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IUpgradeableBeacon {
  5 |     |     /**
  6 |     |      * Upgrades the beacon to a new implementation.
  7 |     |      */
  8 |     |     function upgradeTo(address) external;
  9 |     | }
 10 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/openzeppelin-foundry-upgrades/src/internal/interfaces/IUpgradeableProxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IUpgradeableProxy {
  5 |     |     /**
  6 |     |      * Upgrades the proxy to a new implementation without calling a function on the new implementation.
  7 |     |      */
  8 |     |     function upgradeTo(address) external;
  9 |     | 
 10 |     |     /**
 11 |     |      * Upgrades the proxy to a new implementation and calls a function on the new implementation.
 12 |     |      * If UPGRADE_INTERFACE_VERSION is "5.0.0", bytes can be empty if no function should be called on the new implementation.
 13 |     |      */
 14 |     |     function upgradeToAndCall(address, bytes memory) external payable;
 15 |     | }
 16 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/uniswap-v4-periphery/src/base/ReentrancyLock.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.24;
  3 |     | 
  4 |     | import {Locker} from "../libraries/Locker.sol";
  5 |     | 
  6 |     | /// @notice A transient reentrancy lock, that stores the caller's address as the lock
  7 |     | contract ReentrancyLock {
  8 |     |     error ContractLocked();
  9 |     | 
 10 |     |     modifier isNotLocked() {
 11 | *   |         if (Locker.get() != address(0)) revert ContractLocked();
 12 | *   |         Locker.set(msg.sender);
 13 |     |         _;
 14 |     |         Locker.set(address(0));
 15 |     |     }
 16 |     | 
 17 |     |     function _getLocker() internal view returns (address) {
 18 |     |         return Locker.get();
 19 |     |     }
 20 |     | }
 21 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/uniswap-v4-periphery/src/interfaces/IMsgSender.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title IMsgSender
  5 |     | /// @notice Interface for contracts that expose the original caller
  6 |     | interface IMsgSender {
  7 |     |     /// @notice Returns the address of the original caller (msg.sender)
  8 |     |     /// @dev Uniswap v4 periphery contracts implement a callback pattern which lose
  9 |     |     /// the original msg.sender caller context. This view function provides a way for
 10 |     |     /// integrating contracts (e.g. hooks) to access the original caller address.
 11 |     |     /// @return The address of the original caller
 12 |     |     function msgSender() external view returns (address);
 13 |     | }
 14 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/lib/uniswap-v4-periphery/src/libraries/Locker.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.24;
  3 |     | 
  4 |     | /// @notice This is a temporary library that allows us to use transient storage (tstore/tload)
  5 |     | /// TODO: This library can be deleted when we have the transient keyword support in solidity.
  6 |     | library Locker {
  7 |     |     // The slot holding the locker state, transiently. bytes32(uint256(keccak256("LockedBy")) - 1)
  8 |     |     bytes32 constant LOCKED_BY_SLOT = 0x0aedd6bde10e3aa2adec092b02a3e3e805795516cda41f27aa145b8f300af87a;
  9 |     | 
 10 | *   |     function set(address locker) internal {
 11 |     |         assembly {
 12 | *   |             tstore(LOCKED_BY_SLOT, locker)
 13 |     |         }
 14 |     |     }
 15 |     | 
 16 | *   |     function get() internal view returns (address locker) {
 17 |     |         assembly {
 18 | *   |             locker := tload(LOCKED_BY_SLOT)
 19 |     |         }
 20 |     |     }
 21 |     | }
 22 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  *
 14 |     |  * ==== Security Considerations
 15 |     |  *
 16 |     |  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 17 |     |  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 18 |     |  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 19 |     |  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 20 |     |  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 21 |     |  * generally recommended is:
 22 |     |  *
 23 |     |  * ```solidity
 24 |     |  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 25 |     |  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 26 |     |  *     doThing(..., value);
 27 |     |  * }
 28 |     |  *
 29 |     |  * function doThing(..., uint256 value) public {
 30 |     |  *     token.safeTransferFrom(msg.sender, address(this), value);
 31 |     |  *     ...
 32 |     |  * }
 33 |     |  * ```
 34 |     |  *
 35 |     |  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 36 |     |  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 37 |     |  * {SafeERC20-safeTransferFrom}).
 38 |     |  *
 39 |     |  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 40 |     |  * contracts should have entry points that don't rely on permit.
 41 |     |  */
 42 |     | interface IERC20Permit {
 43 |     |     /**
 44 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 45 |     |      * given ``owner``'s signed approval.
 46 |     |      *
 47 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 48 |     |      * ordering also apply here.
 49 |     |      *
 50 |     |      * Emits an {Approval} event.
 51 |     |      *
 52 |     |      * Requirements:
 53 |     |      *
 54 |     |      * - `spender` cannot be the zero address.
 55 |     |      * - `deadline` must be a timestamp in the future.
 56 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 57 |     |      * over the EIP712-formatted function arguments.
 58 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 59 |     |      *
 60 |     |      * For more information on the signature format, see the
 61 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 62 |     |      * section].
 63 |     |      *
 64 |     |      * CAUTION: See Security Considerations above.
 65 |     |      */
 66 |     |     function permit(
 67 |     |         address owner,
 68 |     |         address spender,
 69 |     |         uint256 value,
 70 |     |         uint256 deadline,
 71 |     |         uint8 v,
 72 |     |         bytes32 r,
 73 |     |         bytes32 s
 74 |     |     ) external;
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Returns the current nonce for `owner`. This value must be
 78 |     |      * included whenever a signature is generated for {permit}.
 79 |     |      *
 80 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 81 |     |      * prevents a signature from being used multiple times.
 82 |     |      */
 83 |     |     function nonces(address owner) external view returns (uint256);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 87 |     |      */
 88 |     |     // solhint-disable-next-line func-name-mixedcase
 89 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 90 |     | }
 91 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/token/ERC721/ERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC721.sol";
   7 |     | import "./IERC721Receiver.sol";
   8 |     | import "./extensions/IERC721Metadata.sol";
   9 |     | import "../../utils/Address.sol";
  10 |     | import "../../utils/Context.sol";
  11 |     | import "../../utils/Strings.sol";
  12 |     | import "../../utils/introspection/ERC165.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
  16 |     |  * the Metadata extension, but not including the Enumerable extension, which is available separately as
  17 |     |  * {ERC721Enumerable}.
  18 |     |  */
  19 |     | contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
  20 |     |     using Address for address;
  21 |     |     using Strings for uint256;
  22 |     | 
  23 |     |     // Token name
  24 |     |     string private _name;
  25 |     | 
  26 |     |     // Token symbol
  27 |     |     string private _symbol;
  28 |     | 
  29 |     |     // Mapping from token ID to owner address
  30 |     |     mapping(uint256 => address) private _owners;
  31 |     | 
  32 |     |     // Mapping owner address to token count
  33 |     |     mapping(address => uint256) private _balances;
  34 |     | 
  35 |     |     // Mapping from token ID to approved address
  36 |     |     mapping(uint256 => address) private _tokenApprovals;
  37 |     | 
  38 |     |     // Mapping from owner to operator approvals
  39 |     |     mapping(address => mapping(address => bool)) private _operatorApprovals;
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
  43 |     |      */
  44 | *   |     constructor(string memory name_, string memory symbol_) {
  45 | *   |         _name = name_;
  46 | *   |         _symbol = symbol_;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev See {IERC165-supportsInterface}.
  51 |     |      */
  52 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
  53 |     |         return
  54 |     |             interfaceId == type(IERC721).interfaceId ||
  55 |     |             interfaceId == type(IERC721Metadata).interfaceId ||
  56 |     |             super.supportsInterface(interfaceId);
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev See {IERC721-balanceOf}.
  61 |     |      */
  62 | *   |     function balanceOf(address owner) public view virtual override returns (uint256) {
  63 | *   |         require(owner != address(0), "ERC721: address zero is not a valid owner");
  64 | *   |         return _balances[owner];
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev See {IERC721-ownerOf}.
  69 |     |      */
  70 |     |     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
  71 |     |         address owner = _ownerOf(tokenId);
  72 |     |         require(owner != address(0), "ERC721: invalid token ID");
  73 |     |         return owner;
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev See {IERC721Metadata-name}.
  78 |     |      */
  79 |     |     function name() public view virtual override returns (string memory) {
  80 |     |         return _name;
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev See {IERC721Metadata-symbol}.
  85 |     |      */
  86 |     |     function symbol() public view virtual override returns (string memory) {
  87 |     |         return _symbol;
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev See {IERC721Metadata-tokenURI}.
  92 |     |      */
  93 |     |     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
  94 |     |         _requireMinted(tokenId);
  95 |     | 
  96 |     |         string memory baseURI = _baseURI();
  97 |     |         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
 102 |     |      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
 103 |     |      * by default, can be overridden in child contracts.
 104 |     |      */
 105 |     |     function _baseURI() internal view virtual returns (string memory) {
 106 |     |         return "";
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev See {IERC721-approve}.
 111 |     |      */
 112 |     |     function approve(address to, uint256 tokenId) public virtual override {
 113 |     |         address owner = ERC721.ownerOf(tokenId);
 114 |     |         require(to != owner, "ERC721: approval to current owner");
 115 |     | 
 116 |     |         require(
 117 |     |             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
 118 |     |             "ERC721: approve caller is not token owner or approved for all"
 119 |     |         );
 120 |     | 
 121 |     |         _approve(to, tokenId);
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev See {IERC721-getApproved}.
 126 |     |      */
 127 |     |     function getApproved(uint256 tokenId) public view virtual override returns (address) {
 128 |     |         _requireMinted(tokenId);
 129 |     | 
 130 |     |         return _tokenApprovals[tokenId];
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @dev See {IERC721-setApprovalForAll}.
 135 |     |      */
 136 |     |     function setApprovalForAll(address operator, bool approved) public virtual override {
 137 |     |         _setApprovalForAll(_msgSender(), operator, approved);
 138 |     |     }
 139 |     | 
 140 |     |     /**
 141 |     |      * @dev See {IERC721-isApprovedForAll}.
 142 |     |      */
 143 |     |     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
 144 |     |         return _operatorApprovals[owner][operator];
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev See {IERC721-transferFrom}.
 149 |     |      */
 150 |     |     function transferFrom(address from, address to, uint256 tokenId) public virtual override {
 151 |     |         //solhint-disable-next-line max-line-length
 152 |     |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
 153 |     | 
 154 |     |         _transfer(from, to, tokenId);
 155 |     |     }
 156 |     | 
 157 |     |     /**
 158 |     |      * @dev See {IERC721-safeTransferFrom}.
 159 |     |      */
 160 |     |     function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
 161 |     |         safeTransferFrom(from, to, tokenId, "");
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev See {IERC721-safeTransferFrom}.
 166 |     |      */
 167 |     |     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {
 168 |     |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
 169 |     |         _safeTransfer(from, to, tokenId, data);
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
 174 |     |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
 175 |     |      *
 176 |     |      * `data` is additional data, it has no specified format and it is sent in call to `to`.
 177 |     |      *
 178 |     |      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
 179 |     |      * implement alternative mechanisms to perform token transfer, such as signature-based.
 180 |     |      *
 181 |     |      * Requirements:
 182 |     |      *
 183 |     |      * - `from` cannot be the zero address.
 184 |     |      * - `to` cannot be the zero address.
 185 |     |      * - `tokenId` token must exist and be owned by `from`.
 186 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
 187 |     |      *
 188 |     |      * Emits a {Transfer} event.
 189 |     |      */
 190 |     |     function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {
 191 |     |         _transfer(from, to, tokenId);
 192 |     |         require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist
 197 |     |      */
 198 | *   |     function _ownerOf(uint256 tokenId) internal view virtual returns (address) {
 199 | *   |         return _owners[tokenId];
 200 |     |     }
 201 |     | 
 202 |     |     /**
 203 |     |      * @dev Returns whether `tokenId` exists.
 204 |     |      *
 205 |     |      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
 206 |     |      *
 207 |     |      * Tokens start existing when they are minted (`_mint`),
 208 |     |      * and stop existing when they are burned (`_burn`).
 209 |     |      */
 210 | *   |     function _exists(uint256 tokenId) internal view virtual returns (bool) {
 211 | *   |         return _ownerOf(tokenId) != address(0);
 212 |     |     }
 213 |     | 
 214 |     |     /**
 215 |     |      * @dev Returns whether `spender` is allowed to manage `tokenId`.
 216 |     |      *
 217 |     |      * Requirements:
 218 |     |      *
 219 |     |      * - `tokenId` must exist.
 220 |     |      */
 221 |     |     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
 222 |     |         address owner = ERC721.ownerOf(tokenId);
 223 |     |         return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
 224 |     |     }
 225 |     | 
 226 |     |     /**
 227 |     |      * @dev Safely mints `tokenId` and transfers it to `to`.
 228 |     |      *
 229 |     |      * Requirements:
 230 |     |      *
 231 |     |      * - `tokenId` must not exist.
 232 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
 233 |     |      *
 234 |     |      * Emits a {Transfer} event.
 235 |     |      */
 236 |     |     function _safeMint(address to, uint256 tokenId) internal virtual {
 237 |     |         _safeMint(to, tokenId, "");
 238 |     |     }
 239 |     | 
 240 |     |     /**
 241 |     |      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
 242 |     |      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
 243 |     |      */
 244 |     |     function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {
 245 |     |         _mint(to, tokenId);
 246 |     |         require(
 247 |     |             _checkOnERC721Received(address(0), to, tokenId, data),
 248 |     |             "ERC721: transfer to non ERC721Receiver implementer"
 249 |     |         );
 250 |     |     }
 251 |     | 
 252 |     |     /**
 253 |     |      * @dev Mints `tokenId` and transfers it to `to`.
 254 |     |      *
 255 |     |      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
 256 |     |      *
 257 |     |      * Requirements:
 258 |     |      *
 259 |     |      * - `tokenId` must not exist.
 260 |     |      * - `to` cannot be the zero address.
 261 |     |      *
 262 |     |      * Emits a {Transfer} event.
 263 |     |      */
 264 | *   |     function _mint(address to, uint256 tokenId) internal virtual {
 265 | *   |         require(to != address(0), "ERC721: mint to the zero address");
 266 | *   |         require(!_exists(tokenId), "ERC721: token already minted");
 267 |     | 
 268 | *   |         _beforeTokenTransfer(address(0), to, tokenId, 1);
 269 |     | 
 270 |     |         // Check that tokenId was not minted by `_beforeTokenTransfer` hook
 271 | *   |         require(!_exists(tokenId), "ERC721: token already minted");
 272 |     | 
 273 |     |         unchecked {
 274 |     |             // Will not overflow unless all 2**256 token ids are minted to the same owner.
 275 |     |             // Given that tokens are minted one by one, it is impossible in practice that
 276 |     |             // this ever happens. Might change if we allow batch minting.
 277 |     |             // The ERC fails to describe this case.
 278 | *   |             _balances[to] += 1;
 279 |     |         }
 280 |     | 
 281 | *   |         _owners[tokenId] = to;
 282 |     | 
 283 | *   |         emit Transfer(address(0), to, tokenId);
 284 |     | 
 285 | *   |         _afterTokenTransfer(address(0), to, tokenId, 1);
 286 |     |     }
 287 |     | 
 288 |     |     /**
 289 |     |      * @dev Destroys `tokenId`.
 290 |     |      * The approval is cleared when the token is burned.
 291 |     |      * This is an internal function that does not check if the sender is authorized to operate on the token.
 292 |     |      *
 293 |     |      * Requirements:
 294 |     |      *
 295 |     |      * - `tokenId` must exist.
 296 |     |      *
 297 |     |      * Emits a {Transfer} event.
 298 |     |      */
 299 |     |     function _burn(uint256 tokenId) internal virtual {
 300 |     |         address owner = ERC721.ownerOf(tokenId);
 301 |     | 
 302 |     |         _beforeTokenTransfer(owner, address(0), tokenId, 1);
 303 |     | 
 304 |     |         // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook
 305 |     |         owner = ERC721.ownerOf(tokenId);
 306 |     | 
 307 |     |         // Clear approvals
 308 |     |         delete _tokenApprovals[tokenId];
 309 |     | 
 310 |     |         unchecked {
 311 |     |             // Cannot overflow, as that would require more tokens to be burned/transferred
 312 |     |             // out than the owner initially received through minting and transferring in.
 313 |     |             _balances[owner] -= 1;
 314 |     |         }
 315 |     |         delete _owners[tokenId];
 316 |     | 
 317 |     |         emit Transfer(owner, address(0), tokenId);
 318 |     | 
 319 |     |         _afterTokenTransfer(owner, address(0), tokenId, 1);
 320 |     |     }
 321 |     | 
 322 |     |     /**
 323 |     |      * @dev Transfers `tokenId` from `from` to `to`.
 324 |     |      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
 325 |     |      *
 326 |     |      * Requirements:
 327 |     |      *
 328 |     |      * - `to` cannot be the zero address.
 329 |     |      * - `tokenId` token must be owned by `from`.
 330 |     |      *
 331 |     |      * Emits a {Transfer} event.
 332 |     |      */
 333 |     |     function _transfer(address from, address to, uint256 tokenId) internal virtual {
 334 |     |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
 335 |     |         require(to != address(0), "ERC721: transfer to the zero address");
 336 |     | 
 337 |     |         _beforeTokenTransfer(from, to, tokenId, 1);
 338 |     | 
 339 |     |         // Check that tokenId was not transferred by `_beforeTokenTransfer` hook
 340 |     |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
 341 |     | 
 342 |     |         // Clear approvals from the previous owner
 343 |     |         delete _tokenApprovals[tokenId];
 344 |     | 
 345 |     |         unchecked {
 346 |     |             // `_balances[from]` cannot overflow for the same reason as described in `_burn`:
 347 |     |             // `from`'s balance is the number of token held, which is at least one before the current
 348 |     |             // transfer.
 349 |     |             // `_balances[to]` could overflow in the conditions described in `_mint`. That would require
 350 |     |             // all 2**256 token ids to be minted, which in practice is impossible.
 351 |     |             _balances[from] -= 1;
 352 |     |             _balances[to] += 1;
 353 |     |         }
 354 |     |         _owners[tokenId] = to;
 355 |     | 
 356 |     |         emit Transfer(from, to, tokenId);
 357 |     | 
 358 |     |         _afterTokenTransfer(from, to, tokenId, 1);
 359 |     |     }
 360 |     | 
 361 |     |     /**
 362 |     |      * @dev Approve `to` to operate on `tokenId`
 363 |     |      *
 364 |     |      * Emits an {Approval} event.
 365 |     |      */
 366 |     |     function _approve(address to, uint256 tokenId) internal virtual {
 367 |     |         _tokenApprovals[tokenId] = to;
 368 |     |         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
 369 |     |     }
 370 |     | 
 371 |     |     /**
 372 |     |      * @dev Approve `operator` to operate on all of `owner` tokens
 373 |     |      *
 374 |     |      * Emits an {ApprovalForAll} event.
 375 |     |      */
 376 |     |     function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {
 377 |     |         require(owner != operator, "ERC721: approve to caller");
 378 |     |         _operatorApprovals[owner][operator] = approved;
 379 |     |         emit ApprovalForAll(owner, operator, approved);
 380 |     |     }
 381 |     | 
 382 |     |     /**
 383 |     |      * @dev Reverts if the `tokenId` has not been minted yet.
 384 |     |      */
 385 |     |     function _requireMinted(uint256 tokenId) internal view virtual {
 386 |     |         require(_exists(tokenId), "ERC721: invalid token ID");
 387 |     |     }
 388 |     | 
 389 |     |     /**
 390 |     |      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
 391 |     |      * The call is not executed if the target address is not a contract.
 392 |     |      *
 393 |     |      * @param from address representing the previous owner of the given token ID
 394 |     |      * @param to target address that will receive the tokens
 395 |     |      * @param tokenId uint256 ID of the token to be transferred
 396 |     |      * @param data bytes optional data to send along with the call
 397 |     |      * @return bool whether the call correctly returned the expected magic value
 398 |     |      */
 399 |     |     function _checkOnERC721Received(
 400 |     |         address from,
 401 |     |         address to,
 402 |     |         uint256 tokenId,
 403 |     |         bytes memory data
 404 |     |     ) private returns (bool) {
 405 |     |         if (to.isContract()) {
 406 |     |             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
 407 |     |                 return retval == IERC721Receiver.onERC721Received.selector;
 408 |     |             } catch (bytes memory reason) {
 409 |     |                 if (reason.length == 0) {
 410 |     |                     revert("ERC721: transfer to non ERC721Receiver implementer");
 411 |     |                 } else {
 412 |     |                     /// @solidity memory-safe-assembly
 413 |     |                     assembly {
 414 |     |                         revert(add(32, reason), mload(reason))
 415 |     |                     }
 416 |     |                 }
 417 |     |             }
 418 |     |         } else {
 419 |     |             return true;
 420 |     |         }
 421 |     |     }
 422 |     | 
 423 |     |     /**
 424 |     |      * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is
 425 |     |      * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
 426 |     |      *
 427 |     |      * Calling conditions:
 428 |     |      *
 429 |     |      * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.
 430 |     |      * - When `from` is zero, the tokens will be minted for `to`.
 431 |     |      * - When `to` is zero, ``from``'s tokens will be burned.
 432 |     |      * - `from` and `to` are never both zero.
 433 |     |      * - `batchSize` is non-zero.
 434 |     |      *
 435 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 436 |     |      */
 437 | *   |     function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}
 438 |     | 
 439 |     |     /**
 440 |     |      * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is
 441 |     |      * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
 442 |     |      *
 443 |     |      * Calling conditions:
 444 |     |      *
 445 |     |      * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.
 446 |     |      * - When `from` is zero, the tokens were minted for `to`.
 447 |     |      * - When `to` is zero, ``from``'s tokens were burned.
 448 |     |      * - `from` and `to` are never both zero.
 449 |     |      * - `batchSize` is non-zero.
 450 |     |      *
 451 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 452 |     |      */
 453 | *   |     function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}
 454 |     | 
 455 |     |     /**
 456 |     |      * @dev Unsafe write access to the balances, used by extensions that "mint" tokens using an {ownerOf} override.
 457 |     |      *
 458 |     |      * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant
 459 |     |      * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such
 460 |     |      * that `ownerOf(tokenId)` is `a`.
 461 |     |      */
 462 |     |     // solhint-disable-next-line func-name-mixedcase
 463 |     |     function __unsafe_increaseBalance(address account, uint256 amount) internal {
 464 |     |         _balances[account] += amount;
 465 |     |     }
 466 |     | }
 467 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/token/ERC721/IERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../../utils/introspection/IERC165.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Required interface of an ERC721 compliant contract.
  10 |     |  */
  11 |     | interface IERC721 is IERC165 {
  12 |     |     /**
  13 |     |      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
  14 |     |      */
  15 |     |     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
  16 |     | 
  17 |     |     /**
  18 |     |      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
  19 |     |      */
  20 |     |     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
  24 |     |      */
  25 |     |     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Returns the number of tokens in ``owner``'s account.
  29 |     |      */
  30 |     |     function balanceOf(address owner) external view returns (uint256 balance);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Returns the owner of the `tokenId` token.
  34 |     |      *
  35 |     |      * Requirements:
  36 |     |      *
  37 |     |      * - `tokenId` must exist.
  38 |     |      */
  39 |     |     function ownerOf(uint256 tokenId) external view returns (address owner);
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`.
  43 |     |      *
  44 |     |      * Requirements:
  45 |     |      *
  46 |     |      * - `from` cannot be the zero address.
  47 |     |      * - `to` cannot be the zero address.
  48 |     |      * - `tokenId` token must exist and be owned by `from`.
  49 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  50 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
  51 |     |      *
  52 |     |      * Emits a {Transfer} event.
  53 |     |      */
  54 |     |     function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
  58 |     |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
  59 |     |      *
  60 |     |      * Requirements:
  61 |     |      *
  62 |     |      * - `from` cannot be the zero address.
  63 |     |      * - `to` cannot be the zero address.
  64 |     |      * - `tokenId` token must exist and be owned by `from`.
  65 |     |      * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
  66 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
  67 |     |      *
  68 |     |      * Emits a {Transfer} event.
  69 |     |      */
  70 |     |     function safeTransferFrom(address from, address to, uint256 tokenId) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Transfers `tokenId` token from `from` to `to`.
  74 |     |      *
  75 |     |      * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
  76 |     |      * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
  77 |     |      * understand this adds an external call which potentially creates a reentrancy vulnerability.
  78 |     |      *
  79 |     |      * Requirements:
  80 |     |      *
  81 |     |      * - `from` cannot be the zero address.
  82 |     |      * - `to` cannot be the zero address.
  83 |     |      * - `tokenId` token must be owned by `from`.
  84 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  85 |     |      *
  86 |     |      * Emits a {Transfer} event.
  87 |     |      */
  88 |     |     function transferFrom(address from, address to, uint256 tokenId) external;
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
  92 |     |      * The approval is cleared when the token is transferred.
  93 |     |      *
  94 |     |      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
  95 |     |      *
  96 |     |      * Requirements:
  97 |     |      *
  98 |     |      * - The caller must own the token or be an approved operator.
  99 |     |      * - `tokenId` must exist.
 100 |     |      *
 101 |     |      * Emits an {Approval} event.
 102 |     |      */
 103 |     |     function approve(address to, uint256 tokenId) external;
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev Approve or remove `operator` as an operator for the caller.
 107 |     |      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
 108 |     |      *
 109 |     |      * Requirements:
 110 |     |      *
 111 |     |      * - The `operator` cannot be the caller.
 112 |     |      *
 113 |     |      * Emits an {ApprovalForAll} event.
 114 |     |      */
 115 |     |     function setApprovalForAll(address operator, bool approved) external;
 116 |     | 
 117 |     |     /**
 118 |     |      * @dev Returns the account approved for `tokenId` token.
 119 |     |      *
 120 |     |      * Requirements:
 121 |     |      *
 122 |     |      * - `tokenId` must exist.
 123 |     |      */
 124 |     |     function getApproved(uint256 tokenId) external view returns (address operator);
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
 128 |     |      *
 129 |     |      * See {setApprovalForAll}
 130 |     |      */
 131 |     |     function isApprovedForAll(address owner, address operator) external view returns (bool);
 132 |     | }
 133 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/token/ERC721/IERC721Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @title ERC721 token receiver interface
  8 |     |  * @dev Interface for any contract that wants to support safeTransfers
  9 |     |  * from ERC721 asset contracts.
 10 |     |  */
 11 |     | interface IERC721Receiver {
 12 |     |     /**
 13 |     |      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
 14 |     |      * by `operator` from `from`, this function is called.
 15 |     |      *
 16 |     |      * It must return its Solidity selector to confirm the token transfer.
 17 |     |      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
 18 |     |      *
 19 |     |      * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
 20 |     |      */
 21 |     |     function onERC721Received(
 22 |     |         address operator,
 23 |     |         address from,
 24 |     |         uint256 tokenId,
 25 |     |         bytes calldata data
 26 |     |     ) external returns (bytes4);
 27 |     | }
 28 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/token/ERC721/extensions/ERC721Enumerable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../ERC721.sol";
   7 |     | import "./IERC721Enumerable.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev This implements an optional extension of {ERC721} defined in the EIP that adds
  11 |     |  * enumerability of all the token ids in the contract as well as all token ids owned by each
  12 |     |  * account.
  13 |     |  */
  14 |     | abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
  15 |     |     // Mapping from owner to list of owned token IDs
  16 |     |     mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
  17 |     | 
  18 |     |     // Mapping from token ID to index of the owner tokens list
  19 |     |     mapping(uint256 => uint256) private _ownedTokensIndex;
  20 |     | 
  21 |     |     // Array with all token ids, used for enumeration
  22 |     |     uint256[] private _allTokens;
  23 |     | 
  24 |     |     // Mapping from token id to position in the allTokens array
  25 |     |     mapping(uint256 => uint256) private _allTokensIndex;
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev See {IERC165-supportsInterface}.
  29 |     |      */
  30 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
  31 |     |         return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);
  32 |     |     }
  33 |     | 
  34 |     |     /**
  35 |     |      * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
  36 |     |      */
  37 |     |     function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
  38 |     |         require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
  39 |     |         return _ownedTokens[owner][index];
  40 |     |     }
  41 |     | 
  42 |     |     /**
  43 |     |      * @dev See {IERC721Enumerable-totalSupply}.
  44 |     |      */
  45 |     |     function totalSupply() public view virtual override returns (uint256) {
  46 |     |         return _allTokens.length;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev See {IERC721Enumerable-tokenByIndex}.
  51 |     |      */
  52 |     |     function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
  53 |     |         require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
  54 |     |         return _allTokens[index];
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev See {ERC721-_beforeTokenTransfer}.
  59 |     |      */
  60 | *   |     function _beforeTokenTransfer(
  61 |     |         address from,
  62 |     |         address to,
  63 |     |         uint256 firstTokenId,
  64 |     |         uint256 batchSize
  65 | *   |     ) internal virtual override {
  66 | *   |         super._beforeTokenTransfer(from, to, firstTokenId, batchSize);
  67 |     | 
  68 | *   |         if (batchSize > 1) {
  69 |     |             // Will only trigger during construction. Batch transferring (minting) is not available afterwards.
  70 |     |             revert("ERC721Enumerable: consecutive transfers not supported");
  71 |     |         }
  72 |     | 
  73 | *   |         uint256 tokenId = firstTokenId;
  74 |     | 
  75 | *   |         if (from == address(0)) {
  76 | *   |             _addTokenToAllTokensEnumeration(tokenId);
  77 |     |         } else if (from != to) {
  78 |     |             _removeTokenFromOwnerEnumeration(from, tokenId);
  79 |     |         }
  80 | *   |         if (to == address(0)) {
  81 |     |             _removeTokenFromAllTokensEnumeration(tokenId);
  82 | *   |         } else if (to != from) {
  83 | *   |             _addTokenToOwnerEnumeration(to, tokenId);
  84 |     |         }
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev Private function to add a token to this extension's ownership-tracking data structures.
  89 |     |      * @param to address representing the new owner of the given token ID
  90 |     |      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address
  91 |     |      */
  92 | *   |     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
  93 | *   |         uint256 length = ERC721.balanceOf(to);
  94 | *   |         _ownedTokens[to][length] = tokenId;
  95 | *   |         _ownedTokensIndex[tokenId] = length;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev Private function to add a token to this extension's token tracking data structures.
 100 |     |      * @param tokenId uint256 ID of the token to be added to the tokens list
 101 |     |      */
 102 | *   |     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
 103 | *   |         _allTokensIndex[tokenId] = _allTokens.length;
 104 | *   |         _allTokens.push(tokenId);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that
 109 |     |      * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for
 110 |     |      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).
 111 |     |      * This has O(1) time complexity, but alters the order of the _ownedTokens array.
 112 |     |      * @param from address representing the previous owner of the given token ID
 113 |     |      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address
 114 |     |      */
 115 |     |     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
 116 |     |         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and
 117 |     |         // then delete the last slot (swap and pop).
 118 |     | 
 119 |     |         uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
 120 |     |         uint256 tokenIndex = _ownedTokensIndex[tokenId];
 121 |     | 
 122 |     |         // When the token to delete is the last token, the swap operation is unnecessary
 123 |     |         if (tokenIndex != lastTokenIndex) {
 124 |     |             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
 125 |     | 
 126 |     |             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
 127 |     |             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
 128 |     |         }
 129 |     | 
 130 |     |         // This also deletes the contents at the last position of the array
 131 |     |         delete _ownedTokensIndex[tokenId];
 132 |     |         delete _ownedTokens[from][lastTokenIndex];
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Private function to remove a token from this extension's token tracking data structures.
 137 |     |      * This has O(1) time complexity, but alters the order of the _allTokens array.
 138 |     |      * @param tokenId uint256 ID of the token to be removed from the tokens list
 139 |     |      */
 140 |     |     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
 141 |     |         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and
 142 |     |         // then delete the last slot (swap and pop).
 143 |     | 
 144 |     |         uint256 lastTokenIndex = _allTokens.length - 1;
 145 |     |         uint256 tokenIndex = _allTokensIndex[tokenId];
 146 |     | 
 147 |     |         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so
 148 |     |         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding
 149 |     |         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)
 150 |     |         uint256 lastTokenId = _allTokens[lastTokenIndex];
 151 |     | 
 152 |     |         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
 153 |     |         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
 154 |     | 
 155 |     |         // This also deletes the contents at the last position of the array
 156 |     |         delete _allTokensIndex[tokenId];
 157 |     |         _allTokens.pop();
 158 |     |     }
 159 |     | }
 160 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/token/ERC721/extensions/IERC721Enumerable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC721.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 10 |     |  * @dev See https://eips.ethereum.org/EIPS/eip-721
 11 |     |  */
 12 |     | interface IERC721Enumerable is IERC721 {
 13 |     |     /**
 14 |     |      * @dev Returns the total amount of tokens stored by the contract.
 15 |     |      */
 16 |     |     function totalSupply() external view returns (uint256);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
 20 |     |      * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
 21 |     |      */
 22 |     |     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
 26 |     |      * Use along with {totalSupply} to enumerate all tokens.
 27 |     |      */
 28 |     |     function tokenByIndex(uint256 index) external view returns (uint256);
 29 |     | }
 30 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/token/ERC721/extensions/IERC721Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC721.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 10 |     |  * @dev See https://eips.ethereum.org/EIPS/eip-721
 11 |     |  */
 12 |     | interface IERC721Metadata is IERC721 {
 13 |     |     /**
 14 |     |      * @dev Returns the token collection name.
 15 |     |      */
 16 |     |     function name() external view returns (string memory);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Returns the token collection symbol.
 20 |     |      */
 21 |     |     function symbol() external view returns (string memory);
 22 |     | 
 23 |     |     /**
 24 |     |      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
 25 |     |      */
 26 |     |     function tokenURI(uint256 tokenId) external view returns (string memory);
 27 |     | }
 28 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      *
  26 |     |      * Furthermore, `isContract` will also return true if the target contract within
  27 |     |      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
  28 |     |      * which only has an effect at the end of a transaction.
  29 |     |      * ====
  30 |     |      *
  31 |     |      * [IMPORTANT]
  32 |     |      * ====
  33 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  34 |     |      *
  35 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  36 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  37 |     |      * constructor.
  38 |     |      * ====
  39 |     |      */
  40 |     |     function isContract(address account) internal view returns (bool) {
  41 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  42 |     |         // for contracts in construction, since the code is only stored at the end
  43 |     |         // of the constructor execution.
  44 |     | 
  45 |     |         return account.code.length > 0;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  50 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  51 |     |      *
  52 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  53 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  54 |     |      * imposed by `transfer`, making them unable to receive funds via
  55 |     |      * `transfer`. {sendValue} removes this limitation.
  56 |     |      *
  57 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  58 |     |      *
  59 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  60 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  61 |     |      * {ReentrancyGuard} or the
  62 |     |      * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  63 |     |      */
  64 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  65 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  66 |     | 
  67 |     |         (bool success, ) = recipient.call{value: amount}("");
  68 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  73 |     |      * plain `call` is an unsafe replacement for a function call: use this
  74 |     |      * function instead.
  75 |     |      *
  76 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  77 |     |      * function (like regular Solidity function calls).
  78 |     |      *
  79 |     |      * Returns the raw returned data. To convert to the expected return value,
  80 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `target` must be a contract.
  85 |     |      * - calling `target` with `data` must not revert.
  86 |     |      *
  87 |     |      * _Available since v3.1._
  88 |     |      */
  89 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  90 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  95 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  96 |     |      *
  97 |     |      * _Available since v3.1._
  98 |     |      */
  99 |     |     function functionCall(
 100 |     |         address target,
 101 |     |         bytes memory data,
 102 |     |         string memory errorMessage
 103 |     |     ) internal returns (bytes memory) {
 104 |     |         return functionCallWithValue(target, data, 0, errorMessage);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 109 |     |      * but also transferring `value` wei to `target`.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - the calling contract must have an ETH balance of at least `value`.
 114 |     |      * - the called Solidity function must be `payable`.
 115 |     |      *
 116 |     |      * _Available since v3.1._
 117 |     |      */
 118 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 |     |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 |     |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 |     |     ) internal view returns (bytes memory) {
 201 |     |         if (success) {
 202 |     |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 |     |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 |     |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/utils/Strings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./math/Math.sol";
  7 |     | import "./math/SignedMath.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev String operations.
 11 |     |  */
 12 |     | library Strings {
 13 |     |     bytes16 private constant _SYMBOLS = "0123456789abcdef";
 14 |     |     uint8 private constant _ADDRESS_LENGTH = 20;
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 18 |     |      */
 19 |     |     function toString(uint256 value) internal pure returns (string memory) {
 20 |     |         unchecked {
 21 |     |             uint256 length = Math.log10(value) + 1;
 22 |     |             string memory buffer = new string(length);
 23 |     |             uint256 ptr;
 24 |     |             /// @solidity memory-safe-assembly
 25 |     |             assembly {
 26 |     |                 ptr := add(buffer, add(32, length))
 27 |     |             }
 28 |     |             while (true) {
 29 |     |                 ptr--;
 30 |     |                 /// @solidity memory-safe-assembly
 31 |     |                 assembly {
 32 |     |                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
 33 |     |                 }
 34 |     |                 value /= 10;
 35 |     |                 if (value == 0) break;
 36 |     |             }
 37 |     |             return buffer;
 38 |     |         }
 39 |     |     }
 40 |     | 
 41 |     |     /**
 42 |     |      * @dev Converts a `int256` to its ASCII `string` decimal representation.
 43 |     |      */
 44 |     |     function toString(int256 value) internal pure returns (string memory) {
 45 |     |         return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 50 |     |      */
 51 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 52 |     |         unchecked {
 53 |     |             return toHexString(value, Math.log256(value) + 1);
 54 |     |         }
 55 |     |     }
 56 |     | 
 57 |     |     /**
 58 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 59 |     |      */
 60 |     |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 61 |     |         bytes memory buffer = new bytes(2 * length + 2);
 62 |     |         buffer[0] = "0";
 63 |     |         buffer[1] = "x";
 64 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 65 |     |             buffer[i] = _SYMBOLS[value & 0xf];
 66 |     |             value >>= 4;
 67 |     |         }
 68 |     |         require(value == 0, "Strings: hex length insufficient");
 69 |     |         return string(buffer);
 70 |     |     }
 71 |     | 
 72 |     |     /**
 73 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
 74 |     |      */
 75 |     |     function toHexString(address addr) internal pure returns (string memory) {
 76 |     |         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Returns true if the two strings are equal.
 81 |     |      */
 82 |     |     function equal(string memory a, string memory b) internal pure returns (bool) {
 83 |     |         return keccak256(bytes(a)) == keccak256(bytes(b));
 84 |     |     }
 85 |     | }
 86 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  *
 20 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 21 |     |  */
 22 |     | abstract contract ERC165 is IERC165 {
 23 |     |     /**
 24 |     |      * @dev See {IERC165-supportsInterface}.
 25 |     |      */
 26 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 27 |     |         return interfaceId == type(IERC165).interfaceId;
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 |     | library Math {
  10 |     |     enum Rounding {
  11 |     |         Down, // Toward negative infinity
  12 |     |         Up, // Toward infinity
  13 |     |         Zero // Toward zero
  14 |     |     }
  15 |     | 
  16 |     |     /**
  17 |     |      * @dev Returns the largest of two numbers.
  18 |     |      */
  19 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  20 |     |         return a > b ? a : b;
  21 |     |     }
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Returns the smallest of two numbers.
  25 |     |      */
  26 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  27 |     |         return a < b ? a : b;
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  32 |     |      * zero.
  33 |     |      */
  34 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  35 |     |         // (a + b) / 2 can overflow.
  36 |     |         return (a & b) + (a ^ b) / 2;
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Returns the ceiling of the division of two numbers.
  41 |     |      *
  42 |     |      * This differs from standard division with `/` in that it rounds up instead
  43 |     |      * of rounding down.
  44 |     |      */
  45 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
  46 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
  47 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  52 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
  53 |     |      * with further edits by Uniswap Labs also under MIT license.
  54 |     |      */
  55 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
  56 |     |         unchecked {
  57 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
  58 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
  59 |     |             // variables such that product = prod1 * 2^256 + prod0.
  60 |     |             uint256 prod0; // Least significant 256 bits of the product
  61 |     |             uint256 prod1; // Most significant 256 bits of the product
  62 |     |             assembly {
  63 |     |                 let mm := mulmod(x, y, not(0))
  64 |     |                 prod0 := mul(x, y)
  65 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  66 |     |             }
  67 |     | 
  68 |     |             // Handle non-overflow cases, 256 by 256 division.
  69 |     |             if (prod1 == 0) {
  70 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
  71 |     |                 // The surrounding unchecked block does not change this fact.
  72 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
  73 |     |                 return prod0 / denominator;
  74 |     |             }
  75 |     | 
  76 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
  77 |     |             require(denominator > prod1, "Math: mulDiv overflow");
  78 |     | 
  79 |     |             ///////////////////////////////////////////////
  80 |     |             // 512 by 256 division.
  81 |     |             ///////////////////////////////////////////////
  82 |     | 
  83 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
  84 |     |             uint256 remainder;
  85 |     |             assembly {
  86 |     |                 // Compute remainder using mulmod.
  87 |     |                 remainder := mulmod(x, y, denominator)
  88 |     | 
  89 |     |                 // Subtract 256 bit number from 512 bit number.
  90 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  91 |     |                 prod0 := sub(prod0, remainder)
  92 |     |             }
  93 |     | 
  94 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
  95 |     |             // See https://cs.stackexchange.com/q/138556/92363.
  96 |     | 
  97 |     |             // Does not overflow because the denominator cannot be zero at this stage in the function.
  98 |     |             uint256 twos = denominator & (~denominator + 1);
  99 |     |             assembly {
 100 |     |                 // Divide denominator by twos.
 101 |     |                 denominator := div(denominator, twos)
 102 |     | 
 103 |     |                 // Divide [prod1 prod0] by twos.
 104 |     |                 prod0 := div(prod0, twos)
 105 |     | 
 106 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 107 |     |                 twos := add(div(sub(0, twos), twos), 1)
 108 |     |             }
 109 |     | 
 110 |     |             // Shift in bits from prod1 into prod0.
 111 |     |             prod0 |= prod1 * twos;
 112 |     | 
 113 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 114 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 115 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 116 |     |             uint256 inverse = (3 * denominator) ^ 2;
 117 |     | 
 118 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
 119 |     |             // in modular arithmetic, doubling the correct bits in each step.
 120 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 121 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 122 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 123 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 124 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 125 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 126 |     | 
 127 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 128 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 129 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 130 |     |             // is no longer required.
 131 |     |             result = prod0 * inverse;
 132 |     |             return result;
 133 |     |         }
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 138 |     |      */
 139 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 140 |     |         uint256 result = mulDiv(x, y, denominator);
 141 |     |         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
 142 |     |             result += 1;
 143 |     |         }
 144 |     |         return result;
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
 149 |     |      *
 150 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 151 |     |      */
 152 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 153 |     |         if (a == 0) {
 154 |     |             return 0;
 155 |     |         }
 156 |     | 
 157 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 158 |     |         //
 159 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 160 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 161 |     |         //
 162 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 163 |     |         //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 164 |     |         //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 165 |     |         //
 166 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 167 |     |         uint256 result = 1 << (log2(a) >> 1);
 168 |     | 
 169 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 170 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 171 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 172 |     |         // into the expected uint128 result.
 173 |     |         unchecked {
 174 |     |             result = (result + a / result) >> 1;
 175 |     |             result = (result + a / result) >> 1;
 176 |     |             result = (result + a / result) >> 1;
 177 |     |             result = (result + a / result) >> 1;
 178 |     |             result = (result + a / result) >> 1;
 179 |     |             result = (result + a / result) >> 1;
 180 |     |             result = (result + a / result) >> 1;
 181 |     |             return min(result, a / result);
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 187 |     |      */
 188 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 189 |     |         unchecked {
 190 |     |             uint256 result = sqrt(a);
 191 |     |             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Return the log in base 2, rounded down, of a positive value.
 197 |     |      * Returns 0 if given 0.
 198 |     |      */
 199 |     |     function log2(uint256 value) internal pure returns (uint256) {
 200 |     |         uint256 result = 0;
 201 |     |         unchecked {
 202 |     |             if (value >> 128 > 0) {
 203 |     |                 value >>= 128;
 204 |     |                 result += 128;
 205 |     |             }
 206 |     |             if (value >> 64 > 0) {
 207 |     |                 value >>= 64;
 208 |     |                 result += 64;
 209 |     |             }
 210 |     |             if (value >> 32 > 0) {
 211 |     |                 value >>= 32;
 212 |     |                 result += 32;
 213 |     |             }
 214 |     |             if (value >> 16 > 0) {
 215 |     |                 value >>= 16;
 216 |     |                 result += 16;
 217 |     |             }
 218 |     |             if (value >> 8 > 0) {
 219 |     |                 value >>= 8;
 220 |     |                 result += 8;
 221 |     |             }
 222 |     |             if (value >> 4 > 0) {
 223 |     |                 value >>= 4;
 224 |     |                 result += 4;
 225 |     |             }
 226 |     |             if (value >> 2 > 0) {
 227 |     |                 value >>= 2;
 228 |     |                 result += 2;
 229 |     |             }
 230 |     |             if (value >> 1 > 0) {
 231 |     |                 result += 1;
 232 |     |             }
 233 |     |         }
 234 |     |         return result;
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 239 |     |      * Returns 0 if given 0.
 240 |     |      */
 241 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 242 |     |         unchecked {
 243 |     |             uint256 result = log2(value);
 244 |     |             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Return the log in base 10, rounded down, of a positive value.
 250 |     |      * Returns 0 if given 0.
 251 |     |      */
 252 |     |     function log10(uint256 value) internal pure returns (uint256) {
 253 |     |         uint256 result = 0;
 254 |     |         unchecked {
 255 |     |             if (value >= 10 ** 64) {
 256 |     |                 value /= 10 ** 64;
 257 |     |                 result += 64;
 258 |     |             }
 259 |     |             if (value >= 10 ** 32) {
 260 |     |                 value /= 10 ** 32;
 261 |     |                 result += 32;
 262 |     |             }
 263 |     |             if (value >= 10 ** 16) {
 264 |     |                 value /= 10 ** 16;
 265 |     |                 result += 16;
 266 |     |             }
 267 |     |             if (value >= 10 ** 8) {
 268 |     |                 value /= 10 ** 8;
 269 |     |                 result += 8;
 270 |     |             }
 271 |     |             if (value >= 10 ** 4) {
 272 |     |                 value /= 10 ** 4;
 273 |     |                 result += 4;
 274 |     |             }
 275 |     |             if (value >= 10 ** 2) {
 276 |     |                 value /= 10 ** 2;
 277 |     |                 result += 2;
 278 |     |             }
 279 |     |             if (value >= 10 ** 1) {
 280 |     |                 result += 1;
 281 |     |             }
 282 |     |         }
 283 |     |         return result;
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 288 |     |      * Returns 0 if given 0.
 289 |     |      */
 290 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 291 |     |         unchecked {
 292 |     |             uint256 result = log10(value);
 293 |     |             return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Return the log in base 256, rounded down, of a positive value.
 299 |     |      * Returns 0 if given 0.
 300 |     |      *
 301 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 302 |     |      */
 303 |     |     function log256(uint256 value) internal pure returns (uint256) {
 304 |     |         uint256 result = 0;
 305 |     |         unchecked {
 306 |     |             if (value >> 128 > 0) {
 307 |     |                 value >>= 128;
 308 |     |                 result += 16;
 309 |     |             }
 310 |     |             if (value >> 64 > 0) {
 311 |     |                 value >>= 64;
 312 |     |                 result += 8;
 313 |     |             }
 314 |     |             if (value >> 32 > 0) {
 315 |     |                 value >>= 32;
 316 |     |                 result += 4;
 317 |     |             }
 318 |     |             if (value >> 16 > 0) {
 319 |     |                 value >>= 16;
 320 |     |                 result += 2;
 321 |     |             }
 322 |     |             if (value >> 8 > 0) {
 323 |     |                 result += 1;
 324 |     |             }
 325 |     |         }
 326 |     |         return result;
 327 |     |     }
 328 |     | 
 329 |     |     /**
 330 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 331 |     |      * Returns 0 if given 0.
 332 |     |      */
 333 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 334 |     |         unchecked {
 335 |     |             uint256 result = log256(value);
 336 |     |             return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);
 337 |     |         }
 338 |     |     }
 339 |     | }
 340 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/node_modules/@openzeppelin/contracts-v4/utils/math/SignedMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Standard signed math utilities missing in the Solidity language.
  8 |     |  */
  9 |     | library SignedMath {
 10 |     |     /**
 11 |     |      * @dev Returns the largest of two signed numbers.
 12 |     |      */
 13 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 14 |     |         return a > b ? a : b;
 15 |     |     }
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the smallest of two signed numbers.
 19 |     |      */
 20 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 21 |     |         return a < b ? a : b;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the average of two signed numbers without overflow.
 26 |     |      * The result is rounded towards zero.
 27 |     |      */
 28 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 29 |     |         // Formula from the book "Hacker's Delight"
 30 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 31 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 32 |     |     }
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Returns the absolute unsigned value of a signed value.
 36 |     |      */
 37 |     |     function abs(int256 n) internal pure returns (uint256) {
 38 |     |         unchecked {
 39 |     |             // must be unchecked in order to support `n = type(int256).min`
 40 |     |             return uint256(n >= 0 ? n : -n);
 41 |     |         }
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/MExtension.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | import { ERC20ExtendedUpgradeable } from "../lib/common/src/ERC20ExtendedUpgradeable.sol";
   6 |     | 
   7 |     | import { IERC20 } from "../lib/common/src/interfaces/IERC20.sol";
   8 |     | 
   9 |     | import { IMTokenLike } from "./interfaces/IMTokenLike.sol";
  10 |     | import { IMExtension } from "./interfaces/IMExtension.sol";
  11 |     | import { ISwapFacility } from "./swap/interfaces/ISwapFacility.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @title  MExtension
  15 |     |  * @notice Upgradeable ERC20 Token contract for wrapping M into a non-rebasing token.
  16 |     |  * @author M0 Labs
  17 |     |  */
  18 |     | abstract contract MExtension is IMExtension, ERC20ExtendedUpgradeable {
  19 |     |     /* ============ Variables ============ */
  20 |     | 
  21 |     |     /// @custom:oz-upgrades-unsafe-allow state-variable-immutable
  22 |     |     /// @inheritdoc IMExtension
  23 |     |     address public immutable mToken;
  24 |     | 
  25 |     |     /// @custom:oz-upgrades-unsafe-allow state-variable-immutable
  26 |     |     /// @inheritdoc IMExtension
  27 |     |     address public immutable swapFacility;
  28 |     | 
  29 |     |     /* ============ Modifiers ============ */
  30 |     | 
  31 |     |     /// @dev Modifier to check if caller is SwapFacility.
  32 |     |     modifier onlySwapFacility() {
  33 | *   |         if (msg.sender != swapFacility) revert NotSwapFacility();
  34 |     |         _;
  35 |     |     }
  36 |     | 
  37 |     |     /* ============ Constructor ============ */
  38 |     | 
  39 |     |     /**
  40 |     |      * @custom:oz-upgrades-unsafe-allow constructor
  41 |     |      * @notice Constructs MExtension Implementation contract
  42 |     |      * @dev    Sets immutable storage.
  43 |     |      * @param  mToken_       The address of $M token.
  44 |     |      * @param  swapFacility_ The address of Swap Facility.
  45 |     |      */
  46 | *   |     constructor(address mToken_, address swapFacility_) {
  47 | *   |         _disableInitializers();
  48 |     | 
  49 | *   |         if ((mToken = mToken_) == address(0)) revert ZeroMToken();
  50 | *   |         if ((swapFacility = swapFacility_) == address(0)) revert ZeroSwapFacility();
  51 |     |     }
  52 |     | 
  53 |     |     /* ============ Initializer ============ */
  54 |     | 
  55 |     |     /**
  56 |     |      * @notice Initializes the generic M extension token.
  57 |     |      * @param name          The name of the token (e.g. "HALO USD").
  58 |     |      * @param symbol        The symbol of the token (e.g. "HUSD").
  59 |     |      */
  60 | *   |     function __MExtension_init(string memory name, string memory symbol) internal onlyInitializing {
  61 | *   |         __ERC20ExtendedUpgradeable_init(name, symbol, 6);
  62 |     |     }
  63 |     | 
  64 |     |     /* ============ Interactive Functions ============ */
  65 |     | 
  66 |     |     /// @inheritdoc IMExtension
  67 | *   |     function wrap(address recipient, uint256 amount) external onlySwapFacility {
  68 |     |         // NOTE: `msg.sender` is always SwapFacility contract.
  69 |     |         //       `ISwapFacility.msgSender()` is used to ensure that the original caller is passed to `_beforeWrap`.
  70 | *   |         _wrap(ISwapFacility(msg.sender).msgSender(), recipient, amount);
  71 |     |     }
  72 |     | 
  73 |     |     /// @inheritdoc IMExtension
  74 | *   |     function unwrap(address /* recipient */, uint256 amount) external onlySwapFacility {
  75 |     |         // NOTE: `msg.sender` is always SwapFacility contract.
  76 |     |         //       `ISwapFacility.msgSender()` is used to ensure that the original caller is passed to `_beforeUnwrap`.
  77 |     |         // NOTE: `recipient` is not used in this function as the $M is always sent to SwapFacility contract.
  78 | *   |         _unwrap(ISwapFacility(msg.sender).msgSender(), amount);
  79 |     |     }
  80 |     | 
  81 |     |     /// @inheritdoc IMExtension
  82 | *   |     function enableEarning() external virtual {
  83 | *   |         if (isEarningEnabled()) revert EarningIsEnabled();
  84 |     | 
  85 | *   |         emit EarningEnabled(currentIndex());
  86 |     | 
  87 | *   |         IMTokenLike(mToken).startEarning();
  88 |     |     }
  89 |     | 
  90 |     |     /// @inheritdoc IMExtension
  91 | *   |     function disableEarning() external virtual {
  92 | *   |         if (!isEarningEnabled()) revert EarningIsDisabled();
  93 |     | 
  94 | *   |         emit EarningDisabled(currentIndex());
  95 |     | 
  96 | *   |         IMTokenLike(mToken).stopEarning(address(this));
  97 |     |     }
  98 |     | 
  99 |     |     /* ============ View/Pure Functions ============ */
 100 |     | 
 101 |     |     /// @inheritdoc IMExtension
 102 | *   |     function currentIndex() public view virtual returns (uint128) {
 103 | *   |         return IMTokenLike(mToken).currentIndex();
 104 |     |     }
 105 |     | 
 106 |     |     /// @inheritdoc IMExtension
 107 | *   |     function isEarningEnabled() public view virtual returns (bool) {
 108 | *   |         return IMTokenLike(mToken).isEarning(address(this));
 109 |     |     }
 110 |     | 
 111 |     |     /// @inheritdoc IERC20
 112 |     |     function balanceOf(address account) public view virtual returns (uint256);
 113 |     | 
 114 |     |     /* ============ Hooks For Internal Interactive Functions ============ */
 115 |     | 
 116 |     |     /**
 117 |     |      * @dev   Hook called before approval of M Extension token.
 118 |     |      * @param account   The sender's address.
 119 |     |      * @param spender   The spender address.
 120 |     |      * @param amount    The amount to be approved.
 121 |     |      */
 122 | *   |     function _beforeApprove(address account, address spender, uint256 amount) internal virtual {}
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev    Hook called before wrapping M into M Extension token.
 126 |     |      * @param  account   The account from which M is deposited.
 127 |     |      * @param  recipient The account receiving the minted M Extension token.
 128 |     |      * @param  amount    The amount of M deposited.
 129 |     |      */
 130 |     |     function _beforeWrap(address account, address recipient, uint256 amount) internal virtual {}
 131 |     | 
 132 |     |     /**
 133 |     |      * @dev   Hook called before unwrapping M Extension token.
 134 |     |      * @param account   The account from which M Extension token is burned.
 135 |     |      * @param amount    The amount of M Extension token burned.
 136 |     |      */
 137 |     |     function _beforeUnwrap(address account, uint256 amount) internal virtual {}
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev   Hook called before transferring M Extension token.
 141 |     |      * @param sender    The sender's address.
 142 |     |      * @param recipient The recipient's address.
 143 |     |      * @param amount    The amount to be transferred.
 144 |     |      */
 145 | *   |     function _beforeTransfer(address sender, address recipient, uint256 amount) internal virtual {}
 146 |     | 
 147 |     |     /* ============ Internal Interactive Functions ============ */
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Approve `spender` to spend `amount` of tokens from `account`.
 151 |     |      * @param account The address approving the allowance.
 152 |     |      * @param spender The address approved to spend the tokens.
 153 |     |      * @param amount  The amount of tokens being approved for spending.
 154 |     |      */
 155 | *   |     function _approve(address account, address spender, uint256 amount) internal override {
 156 |     |         // NOTE: Add extension-specific checks before approval.
 157 | *   |         _beforeApprove(account, spender, amount);
 158 |     | 
 159 | *   |         super._approve(account, spender, amount);
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @dev    Wraps `amount` M from `account` into M Extension for `recipient`.
 164 |     |      * @param  account   The original caller of SwapFacility functions.
 165 |     |      * @param  recipient The account receiving the minted M Extension token.
 166 |     |      * @param  amount    The amount of M deposited.
 167 |     |      */
 168 | *   |     function _wrap(address account, address recipient, uint256 amount) internal {
 169 | *   |         _revertIfInvalidRecipient(recipient);
 170 | *   |         _revertIfInsufficientAmount(amount);
 171 |     | 
 172 |     |         // NOTE: Add extension-specific checks before wrapping.
 173 | *   |         _beforeWrap(account, recipient, amount);
 174 |     | 
 175 |     |         // NOTE: `msg.sender` is always SwapFacility contract.
 176 |     |         // NOTE: The behavior of `IMTokenLike.transferFrom` is known, so its return can be ignored.
 177 | *   |         IMTokenLike(mToken).transferFrom(msg.sender, address(this), amount);
 178 |     | 
 179 |     |         // NOTE: This method is overridden by the inheriting M Extension contract.
 180 |     |         // NOTE: Mints precise amount of $M Extension token to `recipient`.
 181 |     |         //       Option 1: $M transfer from an $M earner to another $M earner ($M Extension in earning state): rounds up  rounds up,
 182 |     |         //                 0, 1, or XX extra wei may be locked in M Extension compared to the minted amount of $M Extension token.
 183 |     |         //       Option 2: $M transfer from an $M non-earner to an $M earner ($M Extension in earning state): precise $M transfer  rounds down,
 184 |     |         //                 0, -1, or -XX wei may be locked in $M Extension compared to the minted amount of $M Extension token.
 185 |     |         //
 186 | *   |         _mint(recipient, amount);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev    Unwraps `amount` M Extension token from `account` into $M and transfers to SwapFacility.
 191 |     |      * @param  account   The original caller of SwapFacility functions.
 192 |     |      * @param  amount    The amount of M Extension token burned.
 193 |     |      */
 194 | *   |     function _unwrap(address account, uint256 amount) internal {
 195 | *   |         _revertIfInsufficientAmount(amount);
 196 |     | 
 197 |     |         // NOTE: Add extension-specific checks before unwrapping.
 198 | *   |         _beforeUnwrap(account, amount);
 199 |     | 
 200 | *   |         _revertIfInsufficientBalance(msg.sender, amount);
 201 |     | 
 202 |     |         // NOTE: This method will be overridden by the inheriting M Extension contract.
 203 |     |         // NOTE: Computes the actual decrease in the $M balance of the $M Extension contract.
 204 |     |         //       Option 1: $M transfer from an $M earner ($M Extension in earning state) to another $M earner: round up  rounds up.
 205 |     |         //       Option 2: $M transfer from an $M earner ($M Extension in earning state) to an $M non-earner: round up  precise $M transfer.
 206 |     |         //       In both cases, 0, 1, or XX extra wei may be deducted from the $M Extension contract's $M balance compared to the burned amount of $M Extension token.
 207 |     |         // NOTE: Always burn from SwapFacility as it is the only contract that can call this function.
 208 | *   |         _burn(msg.sender, amount);
 209 |     | 
 210 |     |         // NOTE: The behavior of `IMTokenLike.transfer` is known, so its return can be ignored.
 211 |     |         // NOTE: `msg.sender` is always SwapFacility contract.
 212 | *   |         IMTokenLike(mToken).transfer(msg.sender, amount);
 213 |     |     }
 214 |     | 
 215 |     |     /**
 216 |     |      * @dev   Mints `amount` tokens to `recipient`.
 217 |     |      * @param recipient The address to which the tokens will be minted.
 218 |     |      * @param amount    The amount of tokens to mint.
 219 |     |      */
 220 |     |     function _mint(address recipient, uint256 amount) internal virtual;
 221 |     | 
 222 |     |     /**
 223 |     |      * @dev   Burns `amount` tokens from `account`.
 224 |     |      * @param account The address from which the tokens will be burned.
 225 |     |      * @param amount  The amount of tokens to burn.
 226 |     |      */
 227 |     |     function _burn(address account, uint256 amount) internal virtual;
 228 |     | 
 229 |     |     /**
 230 |     |      * @dev   Internal balance update function that needs to be implemented by the inheriting contract.
 231 |     |      * @param sender    The sender's address.
 232 |     |      * @param recipient The recipient's address.
 233 |     |      * @param amount    The amount to be transferred.
 234 |     |      */
 235 |     |     function _update(address sender, address recipient, uint256 amount) internal virtual;
 236 |     | 
 237 |     |     /**
 238 |     |      * @dev   Internal ERC20 transfer function.
 239 |     |      * @param sender    The sender's address.
 240 |     |      * @param recipient The recipient's address.
 241 |     |      * @param amount    The amount to be transferred.
 242 |     |      */
 243 | *   |     function _transfer(address sender, address recipient, uint256 amount) internal override {
 244 | *   |         _revertIfInvalidRecipient(recipient);
 245 |     | 
 246 |     |         // NOTE: Add extension-specific checks before transfers.
 247 | *   |         _beforeTransfer(sender, recipient, amount);
 248 |     | 
 249 | *   |         emit Transfer(sender, recipient, amount);
 250 |     | 
 251 | *   |         if (amount == 0) return;
 252 |     | 
 253 | *   |         _revertIfInsufficientBalance(sender, amount);
 254 |     | 
 255 |     |         // NOTE: This method will be overridden by the inheriting M Extension contract.
 256 | *   |         _update(sender, recipient, amount);
 257 |     |     }
 258 |     | 
 259 |     |     /* ============ Internal View/Pure Functions ============ */
 260 |     | 
 261 |     |     /**
 262 |     |      * @dev    Returns the M Token balance of `account`.
 263 |     |      * @param  account The account being queried.
 264 |     |      * @return balance The M Token balance of the account.
 265 |     |      */
 266 | *   |     function _mBalanceOf(address account) internal view returns (uint256) {
 267 | *   |         return IMTokenLike(mToken).balanceOf(account);
 268 |     |     }
 269 |     | 
 270 |     |     /**
 271 |     |      * @dev   Reverts if `recipient` is address(0).
 272 |     |      * @param recipient Address of a recipient.
 273 |     |      */
 274 | *   |     function _revertIfInvalidRecipient(address recipient) internal pure {
 275 | *   |         if (recipient == address(0)) revert InvalidRecipient(recipient);
 276 |     |     }
 277 |     | 
 278 |     |     /**
 279 |     |      * @dev   Reverts if `amount` is equal to 0.
 280 |     |      * @param amount Amount of token.
 281 |     |      */
 282 | *   |     function _revertIfInsufficientAmount(uint256 amount) internal pure {
 283 | *   |         if (amount == 0) revert InsufficientAmount(amount);
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev   Reverts if `account` balance is below `amount`.
 288 |     |      * @param account Address of an account.
 289 |     |      * @param amount  Amount to transfer or burn.
 290 |     |      */
 291 | *   |     function _revertIfInsufficientBalance(address account, uint256 amount) internal view {
 292 | *   |         uint256 balance = balanceOf(account);
 293 | *   |         if (balance < amount) revert InsufficientBalance(account, balance, amount);
 294 |     |     }
 295 |     | }
 296 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/components/freezable/Freezable.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity ^0.8.26;
   4 |     | 
   5 |     | import { AccessControlUpgradeable } from "../../../lib/common/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol";
   6 |     | 
   7 |     | import { IFreezable } from "./IFreezable.sol";
   8 |     | 
   9 |     | abstract contract FreezableStorageLayout {
  10 |     |     /// @custom:storage-location erc7201:M0.storage.Freezable
  11 |     |     struct FreezableStorageStruct {
  12 |     |         mapping(address account => bool isFrozen) isFrozen;
  13 |     |     }
  14 |     | 
  15 |     |     // keccak256(abi.encode(uint256(keccak256("M0.storage.Freezable")) - 1)) & ~bytes32(uint256(0xff))
  16 |     |     bytes32 private constant _FREEZABLE_STORAGE_LOCATION =
  17 |     |         0x2fd5767309dce890c526ace85d7fe164825199d7dcd99c33588befc51b32ce00;
  18 |     | 
  19 | *   |     function _getFreezableStorageLocation() internal pure returns (FreezableStorageStruct storage $) {
  20 |     |         assembly {
  21 | *   |             $.slot := _FREEZABLE_STORAGE_LOCATION
  22 |     |         }
  23 |     |     }
  24 |     | }
  25 |     | 
  26 |     | /**
  27 |     |  * @title Freezable
  28 |     |  * @notice Upgradeable contract that allows for the freezing of accounts.
  29 |     |  * @dev This contract is used to prevent certain accounts from interacting with the contract.
  30 |     |  * @author M0 Labs
  31 |     |  */
  32 |     | abstract contract Freezable is IFreezable, FreezableStorageLayout, AccessControlUpgradeable {
  33 |     |     /* ============ Variables ============ */
  34 |     | 
  35 |     |     /// @inheritdoc IFreezable
  36 | *   |     bytes32 public constant FREEZE_MANAGER_ROLE = keccak256("FREEZE_MANAGER_ROLE");
  37 |     | 
  38 |     |     /* ============ Initializer ============ */
  39 |     | 
  40 |     |     /**
  41 |     |      * @notice Initializes the contract with the given freeze manager.
  42 |     |      * @param freezeManager The address of a freeze manager.
  43 |     |      */
  44 | *   |     function __Freezable_init(address freezeManager) internal onlyInitializing {
  45 | *   |         if (freezeManager == address(0)) revert ZeroFreezeManager();
  46 | *   |         _grantRole(FREEZE_MANAGER_ROLE, freezeManager);
  47 |     |     }
  48 |     | 
  49 |     |     /* ============ Interactive Functions ============ */
  50 |     | 
  51 |     |     /// @inheritdoc IFreezable
  52 |     |     function freeze(address account) external onlyRole(FREEZE_MANAGER_ROLE) {
  53 |     |         _freeze(_getFreezableStorageLocation(), account);
  54 |     |     }
  55 |     | 
  56 |     |     /// @inheritdoc IFreezable
  57 |     |     function freezeAccounts(address[] calldata accounts) external onlyRole(FREEZE_MANAGER_ROLE) {
  58 |     |         FreezableStorageStruct storage $ = _getFreezableStorageLocation();
  59 |     | 
  60 |     |         for (uint256 i; i < accounts.length; ++i) {
  61 |     |             _freeze($, accounts[i]);
  62 |     |         }
  63 |     |     }
  64 |     | 
  65 |     |     /// @inheritdoc IFreezable
  66 |     |     function unfreeze(address account) external onlyRole(FREEZE_MANAGER_ROLE) {
  67 |     |         _unfreeze(_getFreezableStorageLocation(), account);
  68 |     |     }
  69 |     | 
  70 |     |     /// @inheritdoc IFreezable
  71 |     |     function unfreezeAccounts(address[] calldata accounts) external onlyRole(FREEZE_MANAGER_ROLE) {
  72 |     |         FreezableStorageStruct storage $ = _getFreezableStorageLocation();
  73 |     | 
  74 |     |         for (uint256 i; i < accounts.length; ++i) {
  75 |     |             _unfreeze($, accounts[i]);
  76 |     |         }
  77 |     |     }
  78 |     | 
  79 |     |     /* ============ View/Pure Functions ============ */
  80 |     | 
  81 |     |     /// @inheritdoc IFreezable
  82 |     |     function isFrozen(address account) public view returns (bool) {
  83 |     |         return _getFreezableStorageLocation().isFrozen[account];
  84 |     |     }
  85 |     | 
  86 |     |     /* ============ Internal Interactive Functions ============ */
  87 |     | 
  88 |     |     /**
  89 |     |      * @notice Internal function that freezes an account.
  90 |     |      * @param $ The storage location of the freezable contract.
  91 |     |      * @param account The account to freeze.
  92 |     |      */
  93 |     |     function _freeze(FreezableStorageStruct storage $, address account) internal {
  94 |     |         // Return early if the account is already frozen
  95 |     |         if ($.isFrozen[account]) return;
  96 |     | 
  97 |     |         $.isFrozen[account] = true;
  98 |     | 
  99 |     |         emit Frozen(account, block.timestamp);
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @notice Internal function that unfreezes an account.
 104 |     |      * @param $ The storage location of the freezable contract.
 105 |     |      * @param account The account to unfreeze.
 106 |     |      */
 107 |     |     function _unfreeze(FreezableStorageStruct storage $, address account) internal {
 108 |     |         // Return early if the account is not frozen
 109 |     |         if (!$.isFrozen[account]) return;
 110 |     | 
 111 |     |         $.isFrozen[account] = false;
 112 |     | 
 113 |     |         emit Unfrozen(account, block.timestamp);
 114 |     |     }
 115 |     | 
 116 |     |     /* ============ Internal View/Pure Functions ============ */
 117 |     | 
 118 |     |     /**
 119 |     |      * @notice Internal function that reverts if an account is frozen.
 120 |     |      * @dev Called by inheriting contracts to check if an account is frozen.
 121 |     |      * @param $ The storage location of the freezable contract.
 122 |     |      * @param account The account to check.
 123 |     |      */
 124 | *   |     function _revertIfFrozen(FreezableStorageStruct storage $, address account) internal view {
 125 | *   |         if ($.isFrozen[account]) revert AccountFrozen(account);
 126 |     |     }
 127 |     | 
 128 |     |     /**
 129 |     |      * @notice Internal function that reverts if an account is frozen.
 130 |     |      * @dev Called by inheriting contracts to check if an account is frozen.
 131 |     |      * @param account The account to check.
 132 |     |      */
 133 |     |     function _revertIfFrozen(address account) internal view {
 134 |     |         if (_getFreezableStorageLocation().isFrozen[account]) revert AccountFrozen(account);
 135 |     |     }
 136 |     | 
 137 |     |     /**
 138 |     |      * @notice Internal function that reverts if an account is not frozen.
 139 |     |      * @dev Called by inheriting contracts to check if an account is not frozen.
 140 |     |      * @param $ The storage location of the freezable contract.
 141 |     |      * @param account The account to check.
 142 |     |      */
 143 |     |     function _revertIfNotFrozen(FreezableStorageStruct storage $, address account) internal view {
 144 |     |         if (!$.isFrozen[account]) revert AccountNotFrozen(account);
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @notice Internal function that reverts if an account is not frozen.
 149 |     |      * @dev Called by inheriting contracts to check if an account is not frozen.
 150 |     |      * @param account The account to check.
 151 |     |      */
 152 |     |     function _revertIfNotFrozen(address account) internal view {
 153 |     |         if (!_getFreezableStorageLocation().isFrozen[account]) revert AccountNotFrozen(account);
 154 |     |     }
 155 |     | }
 156 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/components/freezable/IFreezable.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | 
  3 |     | pragma solidity ^0.8.26;
  4 |     | 
  5 |     | /**
  6 |     |  * @title Freezable interface.
  7 |     |  * @author M0 Labs
  8 |     |  */
  9 |     | interface IFreezable {
 10 |     |     /* ============ Events ============ */
 11 |     | 
 12 |     |     /**
 13 |     |      * @notice Emitted when an account is frozen.
 14 |     |      * @param account The address of the frozen account.
 15 |     |      * @param timestamp The timestamp at which the account was frozen.
 16 |     |      */
 17 |     |     event Frozen(address indexed account, uint256 timestamp);
 18 |     | 
 19 |     |     /**
 20 |     |      * @notice Emitted when an account is unfrozen.
 21 |     |      * @param account The address of the unfrozen account.
 22 |     |      * @param timestamp The timestamp at which the account was unfrozen.
 23 |     |      */
 24 |     |     event Unfrozen(address indexed account, uint256 timestamp);
 25 |     | 
 26 |     |     /* ============ Errors ============ */
 27 |     | 
 28 |     |     /**
 29 |     |      * @notice Emitted when an account is already frozen.
 30 |     |      * @param account The address of the frozen account.
 31 |     |      */
 32 |     |     error AccountFrozen(address account);
 33 |     | 
 34 |     |     /**
 35 |     |      * @notice Emitted when an account is not frozen.
 36 |     |      * @param account The address of the account that is not frozen.
 37 |     |      */
 38 |     |     error AccountNotFrozen(address account);
 39 |     | 
 40 |     |     /// @notice Emitted if no freeze manager is set.
 41 |     |     error ZeroFreezeManager();
 42 |     | 
 43 |     |     /* ============ Interactive Functions ============ */
 44 |     | 
 45 |     |     /**
 46 |     |      * @notice Freezes an account.
 47 |     |      * @dev MUST only be callable by the FREEZE_MANAGER_ROLE.
 48 |     |      * @param account The address of the account to freeze.
 49 |     |      */
 50 |     |     function freeze(address account) external;
 51 |     | 
 52 |     |     /**
 53 |     |      * @notice Freezes multiple accounts.
 54 |     |      * @dev MUST only be callable by the FREEZE_MANAGER_ROLE.
 55 |     |      * @param accounts The list of addresses to freeze.
 56 |     |      */
 57 |     |     function freezeAccounts(address[] calldata accounts) external;
 58 |     | 
 59 |     |     /**
 60 |     |      * @notice Unfreezes an account.
 61 |     |      * @dev MUST only be callable by the FREEZE_MANAGER_ROLE.
 62 |     |      * @param account The address of the account to unfreeze.
 63 |     |      */
 64 |     |     function unfreeze(address account) external;
 65 |     | 
 66 |     |     /**
 67 |     |      * @notice Unfreezes multiple accounts.
 68 |     |      * @dev MUST only be callable by the FREEZE_MANAGER_ROLE.
 69 |     |      * @param accounts The list of addresses to unfreeze.
 70 |     |      */
 71 |     |     function unfreezeAccounts(address[] calldata accounts) external;
 72 |     | 
 73 |     |     /* ============ View/Pure Functions ============ */
 74 |     | 
 75 |     |     /// @notice The role that can manage the freezelist.
 76 |     |     function FREEZE_MANAGER_ROLE() external view returns (bytes32);
 77 |     | 
 78 |     |     /**
 79 |     |      * @notice Returns whether an account is frozen or not.
 80 |     |      * @param account The address of the account to check.
 81 |     |      * @return True if the account is frozen, false otherwise.
 82 |     |      */
 83 |     |     function isFrozen(address account) external view returns (bool);
 84 |     | }
 85 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/components/pausable/IPausable.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | 
  3 |     | pragma solidity ^0.8.26;
  4 |     | 
  5 |     | /**
  6 |     |  * @title Pausable interface.
  7 |     |  * @author M0 Labs
  8 |     |  */
  9 |     | interface IPausable {
 10 |     |     /* ============ Errors ============ */
 11 |     | 
 12 |     |     /// @notice Emitted if no pauser is set.
 13 |     |     error ZeroPauser();
 14 |     | 
 15 |     |     /* ============ Interactive Functions ============ */
 16 |     | 
 17 |     |     /**
 18 |     |      * @notice Pauses the contract.
 19 |     |      * @dev    Can only be called by an account with the PAUSER_ROLE.
 20 |     |      * @dev    When paused, wrap/unwrap and transfer of tokens should be disabled.
 21 |     |      *         Approval should still be enabled to allow users to change their allowances.
 22 |     |      */
 23 |     |     function pause() external;
 24 |     | 
 25 |     |     /**
 26 |     |      * @notice Unpauses the contract.
 27 |     |      * @dev    Can only be called by an account with the PAUSER_ROLE.
 28 |     |      */
 29 |     |     function unpause() external;
 30 |     | 
 31 |     |     /* ============ View/Pure Functions ============ */
 32 |     | 
 33 |     |     /// @notice The role that can pause/unpause the contract.
 34 |     |     function PAUSER_ROLE() external view returns (bytes32);
 35 |     | }
 36 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/components/pausable/Pausable.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | 
  3 |     | pragma solidity ^0.8.26;
  4 |     | 
  5 |     | import { AccessControlUpgradeable } from "../../../lib/common/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol";
  6 |     | import { PausableUpgradeable } from "../../../lib/common/lib/openzeppelin-contracts-upgradeable/contracts/utils/PausableUpgradeable.sol";
  7 |     | 
  8 |     | import { IPausable } from "./IPausable.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @title Pausable
 12 |     |  * @notice Upgradeable contract that allows to pause the inheriting contract.
 13 |     |  * @dev Relies on PausableUpgradeable from OpenZeppelin for pause functionality.
 14 |     |  * @author M0 Labs
 15 |     |  */
 16 |     | abstract contract Pausable is IPausable, AccessControlUpgradeable, PausableUpgradeable {
 17 |     |     /* ============ Variables ============ */
 18 |     | 
 19 |     |     /// @inheritdoc IPausable
 20 | *   |     bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
 21 |     | 
 22 |     |     /* ============ Initializer ============ */
 23 |     | 
 24 |     |     /**
 25 |     |      * @notice Initializes the contract with the given pauser.
 26 |     |      * @param pauser The address of a pauser.
 27 |     |      */
 28 | *   |     function __Pausable_init(address pauser) internal onlyInitializing {
 29 | *   |         if (pauser == address(0)) revert ZeroPauser();
 30 | *   |         _grantRole(PAUSER_ROLE, pauser);
 31 |     |     }
 32 |     | 
 33 |     |     /* ============ Interactive Functions ============ */
 34 |     | 
 35 |     |     /// @inheritdoc IPausable
 36 |     |     function pause() external onlyRole(PAUSER_ROLE) {
 37 |     |         _pause();
 38 |     |     }
 39 |     | 
 40 |     |     /// @inheritdoc IPausable
 41 |     |     function unpause() external onlyRole(PAUSER_ROLE) {
 42 |     |         _unpause();
 43 |     |     }
 44 |     | }
 45 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/interfaces/IMExtension.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | import { IERC20Extended } from "../../lib/common/src/interfaces/IERC20Extended.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title  M Extension interface extending Extended ERC20,
   9 |     |  *         includes additional enable/disable earnings and index logic.
  10 |     |  * @author M0 Labs
  11 |     |  */
  12 |     | interface IMExtension is IERC20Extended {
  13 |     |     /* ============ Events ============ */
  14 |     | 
  15 |     |     /**
  16 |     |      * @notice Emitted when M extension earning is enabled.
  17 |     |      * @param  index The index at the moment earning is enabled.
  18 |     |      */
  19 |     |     event EarningEnabled(uint128 index);
  20 |     | 
  21 |     |     /**
  22 |     |      * @notice Emitted when M extension earning is disabled.
  23 |     |      * @param  index The index at the moment earning is disabled.
  24 |     |      */
  25 |     |     event EarningDisabled(uint128 index);
  26 |     | 
  27 |     |     /* ============ Custom Errors ============ */
  28 |     | 
  29 |     |     /// @notice Emitted when performing an operation that is not allowed when earning is disabled.
  30 |     |     error EarningIsDisabled();
  31 |     | 
  32 |     |     /// @notice Emitted when performing an operation that is not allowed when earning is enabled.
  33 |     |     error EarningIsEnabled();
  34 |     | 
  35 |     |     /**
  36 |     |      * @notice Emitted when there is insufficient balance to decrement from `account`.
  37 |     |      * @param  account The account with insufficient balance.
  38 |     |      * @param  balance The balance of the account.
  39 |     |      * @param  amount  The amount to decrement.
  40 |     |      */
  41 |     |     error InsufficientBalance(address account, uint256 balance, uint256 amount);
  42 |     | 
  43 |     |     /// @notice Emitted in constructor if M Token is 0x0.
  44 |     |     error ZeroMToken();
  45 |     | 
  46 |     |     /// @notice Emitted in constructor if Swap Facility is 0x0.
  47 |     |     error ZeroSwapFacility();
  48 |     | 
  49 |     |     /// @notice Emitted in `wrap` and `unwrap` functions if the caller is not the Swap Facility.
  50 |     |     error NotSwapFacility();
  51 |     | 
  52 |     |     /* ============ Interactive Functions ============ */
  53 |     | 
  54 |     |     /**
  55 |     |      * @notice Enables earning of extension token if allowed by the TTG Registrar and if it has never been done.
  56 |     |      * @dev SHOULD be virtual to allow extensions to override it.
  57 |     |      */
  58 |     |     function enableEarning() external;
  59 |     | 
  60 |     |     /**
  61 |     |      * @notice Disables earning of extension token if disallowed by the TTG Registrar and if it has never been done.
  62 |     |      * @dev SHOULD be virtual to allow extensions to override it.
  63 |     |      */
  64 |     |     function disableEarning() external;
  65 |     | 
  66 |     |     /**
  67 |     |      * @notice Wraps `amount` M from the caller into extension token for `recipient`.
  68 |     |      * @dev    Can only be called by the SwapFacility.
  69 |     |      * @param  recipient The account receiving the minted M extension token.
  70 |     |      * @param  amount    The amount of M extension token minted.
  71 |     |      */
  72 |     |     function wrap(address recipient, uint256 amount) external;
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice Unwraps `amount` extension token from the caller into M for `recipient`.
  76 |     |      * @dev    Can only be called by the SwapFacility.
  77 |     |      * @param  recipient The account receiving the withdrawn M,
  78 |     |      *         it will always be the SwapFacility (keep `recipient` for backward compatibility).
  79 |     |      * @param  amount    The amount of M extension token burned.
  80 |     |      */
  81 |     |     function unwrap(address recipient, uint256 amount) external;
  82 |     | 
  83 |     |     /* ============ View/Pure Functions ============ */
  84 |     | 
  85 |     |     /// @notice The address of the M Token contract.
  86 |     |     function mToken() external view returns (address);
  87 |     | 
  88 |     |     /// @notice The address of the SwapFacility contract.
  89 |     |     function swapFacility() external view returns (address);
  90 |     | 
  91 |     |     /**
  92 |     |      * @notice Whether M extension earning is enabled.
  93 |     |      * @dev SHOULD be virtual to allow extensions to override it.
  94 |     |      */
  95 |     |     function isEarningEnabled() external view returns (bool);
  96 |     | 
  97 |     |     /**
  98 |     |      * @notice Returns the current index for M extension earnings.
  99 |     |      * @dev SHOULD be virtual to allow extensions to override it.
 100 |     |      */
 101 |     |     function currentIndex() external view returns (uint128);
 102 |     | }
 103 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/interfaces/IMTokenLike.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | /**
   6 |     |  * @title  Subset of M Token interface required for source contracts.
   7 |     |  * @author M0 Labs
   8 |     |  */
   9 |     | interface IMTokenLike {
  10 |     |     /* ============ Custom Errors ============ */
  11 |     | 
  12 |     |     /// @notice Emitted when calling `stopEarning` for an account approved as earner by TTG.
  13 |     |     error IsApprovedEarner();
  14 |     | 
  15 |     |     /// @notice Emitted when calling `startEarning` for an account not approved as earner by TTG.
  16 |     |     error NotApprovedEarner();
  17 |     | 
  18 |     |     /* ============ Interactive Functions ============ */
  19 |     | 
  20 |     |     /**
  21 |     |      * @notice Allows a calling account to approve `spender` to spend up to `amount` of its token balance.
  22 |     |      * @dev    MUST emit an `Approval` event.
  23 |     |      * @param  spender The address of the account being allowed to spend up to the allowed amount.
  24 |     |      * @param  amount  The amount of the allowance being approved.
  25 |     |      * @return Whether or not the approval was successful.
  26 |     |      */
  27 |     |     function approve(address spender, uint256 amount) external returns (bool);
  28 |     | 
  29 |     |     /**
  30 |     |      * @notice Approves `spender` to spend up to `amount` of the token balance of `owner`, via a signature.
  31 |     |      * @param  owner    The address of the account who's token balance is being approved to be spent by `spender`.
  32 |     |      * @param  spender  The address of an account allowed to spend on behalf of `owner`.
  33 |     |      * @param  value    The amount of the allowance being approved.
  34 |     |      * @param  deadline The last timestamp where the signature is still valid.
  35 |     |      * @param  v        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
  36 |     |      * @param  r        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
  37 |     |      * @param  s        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
  38 |     |      */
  39 |     |     function permit(
  40 |     |         address owner,
  41 |     |         address spender,
  42 |     |         uint256 value,
  43 |     |         uint256 deadline,
  44 |     |         uint8 v,
  45 |     |         bytes32 r,
  46 |     |         bytes32 s
  47 |     |     ) external;
  48 |     | 
  49 |     |     /**
  50 |     |      * @notice Approves `spender` to spend up to `amount` of the token balance of `owner`, via a signature.
  51 |     |      * @param  owner     The address of the account who's token balance is being approved to be spent by `spender`.
  52 |     |      * @param  spender   The address of an account allowed to spend on behalf of `owner`.
  53 |     |      * @param  value     The amount of the allowance being approved.
  54 |     |      * @param  deadline  The last timestamp where the signature is still valid.
  55 |     |      * @param  signature An arbitrary signature (EIP-712).
  56 |     |      */
  57 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) external;
  58 |     | 
  59 |     |     /**
  60 |     |      * @notice Allows a calling account to transfer `amount` tokens to `recipient`.
  61 |     |      * @param  recipient The address of the recipient who's token balance will be incremented.
  62 |     |      * @param  amount    The amount of tokens being transferred.
  63 |     |      * @return success   Whether or not the transfer was successful.
  64 |     |      */
  65 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
  66 |     | 
  67 |     |     /**
  68 |     |      * @notice Allows a calling account to transfer `amount` tokens from `sender`, with allowance, to a `recipient`.
  69 |     |      * @param  sender    The address of the sender who's token balance will be decremented.
  70 |     |      * @param  recipient The address of the recipient who's token balance will be incremented.
  71 |     |      * @param  amount    The amount of tokens being transferred.
  72 |     |      * @return success   Whether or not the transfer was successful.
  73 |     |      */
  74 |     |     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
  75 |     | 
  76 |     |     /// @notice Starts earning for caller if allowed by the Registrar.
  77 |     |     function startEarning() external;
  78 |     | 
  79 |     |     /**
  80 |     |      * @notice Stops earning for `account`.
  81 |     |      * @dev    MUST revert if `account` is an approved earner in TTG Registrar.
  82 |     |      * @param  account The account to stop earning for.
  83 |     |      */
  84 |     |     function stopEarning(address account) external;
  85 |     | 
  86 |     |     /* ============ View/Pure Functions ============ */
  87 |     | 
  88 |     |     /**
  89 |     |      * @notice Checks if account is an earner.
  90 |     |      * @param  account The account to check.
  91 |     |      * @return earning True if account is an earner, false otherwise.
  92 |     |      */
  93 |     |     function isEarning(address account) external view returns (bool);
  94 |     | 
  95 |     |     /**
  96 |     |      * @notice Returns the token balance of `account`.
  97 |     |      * @param  account The address of some account.
  98 |     |      * @return balance The token balance of `account`.
  99 |     |      */
 100 |     |     function balanceOf(address account) external view returns (uint256);
 101 |     | 
 102 |     |     /**
 103 |     |      * @notice Returns the token balance of `account`.
 104 |     |      * @param  account The address of some account.
 105 |     |      * @return principal The principal token balance of `account`.
 106 |     |      */
 107 |     |     function principalBalanceOf(address account) external view returns (uint240);
 108 |     | 
 109 |     |     /// @notice The current index that would be written to storage if `updateIndex` is called.
 110 |     |     function currentIndex() external view returns (uint128);
 111 |     | 
 112 |     |     /// @notice The current value of earner rate in basis points.
 113 |     |     function earnerRate() external view returns (uint32);
 114 |     | 
 115 |     |     /// @notice Returns the EIP712 domain separator used in the encoding of a signed digest.
 116 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 117 |     | 
 118 |     |     /// @notice Returns the EIP712 typehash used in the encoding of the digest for the permit function.
 119 |     |     function PERMIT_TYPEHASH() external view returns (bytes32);
 120 |     | 
 121 |     |     /// @notice Updates the index and returns it.
 122 |     |     function updateIndex() external returns (uint128);
 123 |     | }
 124 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/interfaces/IMinterGateway.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import { IERC712 } from "lib/common/src/interfaces/IERC712.sol";
   6 |     | 
   7 |     | import { IContinuousIndexing } from "test/fuzzing/lifeSupport/IContinuousIndexing.sol";
   8 |     | import { ContinuousIndexingMath } from "lib/common/src/libs/ContinuousIndexingMath.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title  Minter Gateway Interface.
  12 |     |  * @author M^0 Labs
  13 |     |  */
  14 |     | interface IMinterGateway is IContinuousIndexing, IERC712 {
  15 |     |     /* ============ Events ============ */
  16 |     | 
  17 |     |     /**
  18 |     |      * @notice Emitted when M tokens are burned and an inactive minter's owed M balance decreased.
  19 |     |      * @param  minter The address of the minter.
  20 |     |      * @param  amount The amount of M tokens burned.
  21 |     |      * @param  payer  The address of the payer.
  22 |     |      */
  23 |     |     event BurnExecuted(address indexed minter, uint240 amount, address indexed payer);
  24 |     | 
  25 |     |     /**
  26 |     |      * @notice Emitted when M tokens are burned and an active minter's owed M balance decreased.
  27 |     |      * @param  minter          The address of the minter.
  28 |     |      * @param  principalAmount The principal amount of M tokens burned.
  29 |     |      * @param  amount          The amount of M tokens burned.
  30 |     |      * @param  payer           The address of the payer.
  31 |     |      */
  32 |     |     event BurnExecuted(address indexed minter, uint112 principalAmount, uint240 amount, address indexed payer);
  33 |     | 
  34 |     |     /**
  35 |     |      * @notice Emitted when a minter's collateral is updated.
  36 |     |      * @param  minter                           Address of the minter
  37 |     |      * @param  collateral                       The latest amount of collateral
  38 |     |      * @param  totalResolvedCollateralRetrieval The total collateral amount of outstanding retrievals resolved.
  39 |     |      * @param  metadataHash                     The hash of some metadata reserved for future informational use.
  40 |     |      * @param  timestamp                        The timestamp of the collateral update,
  41 |     |      *                                          minimum of given validators' signatures.
  42 |     |      */
  43 |     |     event CollateralUpdated(
  44 |     |         address indexed minter,
  45 |     |         uint240 collateral,
  46 |     |         uint240 totalResolvedCollateralRetrieval,
  47 |     |         bytes32 indexed metadataHash,
  48 |     |         uint40 timestamp
  49 |     |     );
  50 |     | 
  51 |     |     /**
  52 |     |      * @notice Emitted when a minter is activated.
  53 |     |      * @param  minter Address of the minter that was activated
  54 |     |      * @param  caller Address who called the function
  55 |     |      */
  56 |     |     event MinterActivated(address indexed minter, address indexed caller);
  57 |     | 
  58 |     |     /**
  59 |     |      * @notice Emitted when a minter is deactivated.
  60 |     |      * @param  minter        Address of the minter that was deactivated.
  61 |     |      * @param  inactiveOwedM Amount of M tokens owed by the minter (in an inactive state).
  62 |     |      * @param  caller        Address who called the function.
  63 |     |      */
  64 |     |     event MinterDeactivated(address indexed minter, uint240 inactiveOwedM, address indexed caller);
  65 |     | 
  66 |     |     /**
  67 |     |      * @notice Emitted when a minter is frozen.
  68 |     |      * @param  minter      Address of the minter that was frozen
  69 |     |      * @param  frozenUntil Timestamp until the minter is frozen
  70 |     |      */
  71 |     |     event MinterFrozen(address indexed minter, uint40 frozenUntil);
  72 |     | 
  73 |     |     /**
  74 |     |      * @notice Emitted when a mint proposal is canceled.
  75 |     |      * @param  mintId    The id of the canceled mint proposal.
  76 |     |      * @param  minter    The address of the minter for which the mint was canceled.
  77 |     |      * @param  canceller The address of the validator who canceled the mint proposal.
  78 |     |      */
  79 |     |     event MintCanceled(uint48 indexed mintId, address indexed minter, address indexed canceller);
  80 |     | 
  81 |     |     /**
  82 |     |      * @notice Emitted when a mint proposal is executed.
  83 |     |      * @param  mintId          The id of the executed mint proposal.
  84 |     |      * @param  minter          The address of the minter that executed the mint.
  85 |     |      * @param  principalAmount The principal amount of M tokens minted.
  86 |     |      * @param  amount          The amount of M tokens minted.
  87 |     |      */
  88 |     |     event MintExecuted(uint48 indexed mintId, address indexed minter, uint112 principalAmount, uint240 amount);
  89 |     | 
  90 |     |     /**
  91 |     |      * @notice Emitted when a mint proposal is created.
  92 |     |      * @param  mintId      The id of mint proposal.
  93 |     |      * @param  minter      The address of the minter that proposed the mint.
  94 |     |      * @param  amount      The amount of M tokens to mint.
  95 |     |      * @param  destination The address to mint to.
  96 |     |      */
  97 |     |     event MintProposed(uint48 indexed mintId, address indexed minter, uint240 amount, address indexed destination);
  98 |     | 
  99 |     |     /**
 100 |     |      * @notice Emitted when a penalty is imposed on `minter` for missed update collateral intervals.
 101 |     |      * @param  minter          The address of the minter.
 102 |     |      * @param  missedIntervals The number of update intervals missed.
 103 |     |      * @param  penaltyAmount   The present amount of penalty charge.
 104 |     |      */
 105 |     |     event MissedIntervalsPenaltyImposed(address indexed minter, uint40 missedIntervals, uint240 penaltyAmount);
 106 |     | 
 107 |     |     /**
 108 |     |      * @notice Emitted when a penalty is imposed on `minter` for undercollateralization.
 109 |     |      * @param  minter        The address of the minter.
 110 |     |      * @param  excessOwedM   The present amount of owed M in excess of allowed owed M.
 111 |     |      * @param  timeSpan      The span of time over which the undercollateralization penalty was applied.
 112 |     |      * @param  penaltyAmount The present amount of penalty charge.
 113 |     |      */
 114 |     |     event UndercollateralizedPenaltyImposed(
 115 |     |         address indexed minter,
 116 |     |         uint240 excessOwedM,
 117 |     |         uint40 timeSpan,
 118 |     |         uint240 penaltyAmount
 119 |     |     );
 120 |     | 
 121 |     |     /**
 122 |     |      * @notice Emitted when a collateral retrieval proposal is created.
 123 |     |      * @param  retrievalId The id of retrieval proposal.
 124 |     |      * @param  minter      The address of the minter.
 125 |     |      * @param  amount      The amount of collateral to retrieve.
 126 |     |      */
 127 |     |     event RetrievalCreated(uint48 indexed retrievalId, address indexed minter, uint240 amount);
 128 |     | 
 129 |     |     /**
 130 |     |      * @notice Emitted when a collateral retrieval proposal is resolved.
 131 |     |      * @param  retrievalId The id of retrieval proposal.
 132 |     |      * @param  minter      The address of the minter.
 133 |     |      */
 134 |     |     event RetrievalResolved(uint48 indexed retrievalId, address indexed minter);
 135 |     | 
 136 |     |     /* ============ Custom Errors ============ */
 137 |     | 
 138 |     |     /// @notice Emitted when calling `activateMinter` with a minter who was previously deactivated.
 139 |     |     error DeactivatedMinter();
 140 |     | 
 141 |     |     /// @notice Emitted when repay will burn more M than the repay specified.
 142 |     |     error ExceedsMaxRepayAmount(uint240 amount, uint240 maxAmount);
 143 |     | 
 144 |     |     /// @notice Emitted when calling `mintM` with a proposal that was created more than `mintDelay + mintTTL` time ago.
 145 |     |     error ExpiredMintProposal(uint40 deadline);
 146 |     | 
 147 |     |     /// @notice Emitted when calling `mintM` or `proposeMint` by a minter who was frozen by validator.
 148 |     |     error FrozenMinter();
 149 |     | 
 150 |     |     /// @notice Emitted when calling `updateCollateral` with any validator timestamp in the future.
 151 |     |     error FutureTimestamp();
 152 |     | 
 153 |     |     /// @notice Emitted when calling a function only allowed for active minters.
 154 |     |     error InactiveMinter();
 155 |     | 
 156 |     |     /// @notice Emitted when calling `cancelMint` or `mintM` with invalid `mintId`.
 157 |     |     error InvalidMintProposal();
 158 |     | 
 159 |     |     /// @notice Emitted when calling `updateCollateral` if `validators` addresses are not ordered in ascending order.
 160 |     |     error InvalidSignatureOrder();
 161 |     | 
 162 |     |     /// @notice Emitted when calling `activateMinter` if minter was not approved by TTG.
 163 |     |     error NotApprovedMinter();
 164 |     | 
 165 |     |     /// @notice Emitted when calling `cancelMint` or `freezeMinter` if `validator` was not approved by TTG.
 166 |     |     error NotApprovedValidator(address validator);
 167 |     | 
 168 |     |     /// @notice Emitted when calling `updateCollateral` if `validatorThreshold` of signatures was not reached.
 169 |     |     error NotEnoughValidSignatures(uint256 validSignatures, uint256 requiredThreshold);
 170 |     | 
 171 |     |     /// @notice Emitted when principal of total owed M (active and inactive) will overflow a `type(uint112).max`.
 172 |     |     error OverflowsPrincipalOfTotalOwedM();
 173 |     | 
 174 |     |     /// @notice Emitted when calling `mintM` if `mintDelay` time has not passed yet.
 175 |     |     error PendingMintProposal(uint40 activeTimestamp);
 176 |     | 
 177 |     |     /// @notice Emitted when calling `proposeRetrieval` if sum of all outstanding retrievals
 178 |     |     ///         Plus new proposed retrieval amount is greater than collateral.
 179 |     |     error RetrievalsExceedCollateral(uint240 totalPendingRetrievals, uint240 collateral);
 180 |     | 
 181 |     |     /// @notice Emitted when calling `updateCollateral`
 182 |     |     ///         If `validators`, `signatures`, `timestamps` lengths do not match.
 183 |     |     error SignatureArrayLengthsMismatch();
 184 |     | 
 185 |     |     /// @notice Emitted when updating collateral with a timestamp earlier than allowed.
 186 |     |     error StaleCollateralUpdate(uint40 newTimestamp, uint40 earliestAllowedTimestamp);
 187 |     | 
 188 |     |     /// @notice Emitted when calling `updateCollateral` with any validator timestamp older than the last signature
 189 |     |     ///         timestamp for that minter and validator.
 190 |     |     error OutdatedValidatorTimestamp(address validator, uint256 timestamp, uint256 lastSignatureTimestamp);
 191 |     | 
 192 |     |     /// @notice Emitted when calling `deactivateMinter` with a minter still approved in TTG Registrar.
 193 |     |     error StillApprovedMinter();
 194 |     | 
 195 |     |     /**
 196 |     |      * @notice Emitted when calling `proposeMint`, `mintM`, `proposeRetrieval`
 197 |     |      *         If minter position becomes undercollateralized.
 198 |     |      * @dev    `activeOwedM` is a `uint256` because it may represent some resulting owed M from computations.
 199 |     |      */
 200 |     |     error Undercollateralized(uint256 activeOwedM, uint256 maxAllowedOwedM);
 201 |     | 
 202 |     |     /// @notice Emitted when calling `burnM` if amount is 0.
 203 |     |     error ZeroBurnAmount();
 204 |     | 
 205 |     |     /// @notice Emitted in constructor if M Token is 0x0.
 206 |     |     error ZeroMToken();
 207 |     | 
 208 |     |     /// @notice Emitted when calling `proposeMint` if amount is 0.
 209 |     |     error ZeroMintAmount();
 210 |     | 
 211 |     |     /// @notice Emitted when calling `proposeMint` if destination is 0x0.
 212 |     |     error ZeroMintDestination();
 213 |     | 
 214 |     |     /// @notice Emitted when calling `proposeRetrieval` if collateral is 0.
 215 |     |     error ZeroRetrievalAmount();
 216 |     | 
 217 |     |     /// @notice Emitted in constructor if TTG Registrar is 0x0.
 218 |     |     error ZeroTTGRegistrar();
 219 |     | 
 220 |     |     /// @notice Emitted in constructor if TTG Distribution Vault is set to 0x0 in TTG Registrar.
 221 |     |     error ZeroTTGVault();
 222 |     | 
 223 |     |     /// @notice Emitted when calling `updateCollateral` with any validator timestamp of 0.
 224 |     |     error ZeroTimestamp();
 225 |     | 
 226 |     |     /* ============ Interactive Functions ============ */
 227 |     | 
 228 |     |     /**
 229 |     |      * @notice Updates collateral for minters
 230 |     |      * @param  collateral   The amount of collateral
 231 |     |      * @param  retrievalIds The list of active proposeRetrieval requests to close
 232 |     |      * @param  metadataHash The hash of metadata of the collateral update, reserved for future informational use
 233 |     |      * @param  validators   The list of validators
 234 |     |      * @param  timestamps   The list of timestamps of validators' signatures
 235 |     |      * @param  signatures   The list of signatures
 236 |     |      * @return minTimestamp The minimum timestamp of all validators' signatures
 237 |     |      */
 238 |     |     function updateCollateral(
 239 |     |         uint256 collateral,
 240 |     |         uint256[] calldata retrievalIds,
 241 |     |         bytes32 metadataHash,
 242 |     |         address[] calldata validators,
 243 |     |         uint256[] calldata timestamps,
 244 |     |         bytes[] calldata signatures
 245 |     |     ) external returns (uint40 minTimestamp);
 246 |     | 
 247 |     |     /**
 248 |     |      * @notice Proposes retrieval of minter's off-chain collateral
 249 |     |      * @param  collateral  The amount of collateral to retrieve
 250 |     |      * @return retrievalId The unique id of created retrieval proposal
 251 |     |      */
 252 |     |     function proposeRetrieval(uint256 collateral) external returns (uint48 retrievalId);
 253 |     | 
 254 |     |     /**
 255 |     |      * @notice Proposes minting of M tokens
 256 |     |      * @param  amount      The amount of M tokens to mint
 257 |     |      * @param  destination The address to mint to
 258 |     |      * @return mintId      The unique id of created mint proposal
 259 |     |      */
 260 |     |     function proposeMint(uint256 amount, address destination) external returns (uint48 mintId);
 261 |     | 
 262 |     |     /**
 263 |     |      * @notice Executes minting of M tokens
 264 |     |      * @param  mintId          The id of outstanding mint proposal for minter
 265 |     |      * @return principalAmount The amount of principal of owed M minted.
 266 |     |      * @return amount          The amount of M tokens minted.
 267 |     |      */
 268 |     |     function mintM(uint256 mintId) external returns (uint112 principalAmount, uint240 amount);
 269 |     | 
 270 |     |     /**
 271 |     |      * @notice Burns M tokens
 272 |     |      * @dev    If amount to burn is greater than minter's owedM including penalties, burn all up to owedM.
 273 |     |      * @param  minter          The address of the minter to burn M tokens for.
 274 |     |      * @param  maxAmount       The max amount of M tokens to burn.
 275 |     |      * @return principalAmount The amount of principal of owed M burned.
 276 |     |      * @return amount          The amount of M tokens burned.
 277 |     |      */
 278 |     |     function burnM(address minter, uint256 maxAmount) external returns (uint112 principalAmount, uint240 amount);
 279 |     | 
 280 |     |     /**
 281 |     |      * @notice Burns M tokens
 282 |     |      * @dev    If amount to burn is greater than minter's owedM including penalties, burn all up to owedM.
 283 |     |      * @param  minter             The address of the minter to burn M tokens for.
 284 |     |      * @param  maxPrincipalAmount The max amount of principal of owed M to burn.
 285 |     |      * @param  maxAmount          The max amount of M tokens to burn.
 286 |     |      * @return principalAmount    The amount of principal of owed M burned.
 287 |     |      * @return amount             The amount of M tokens burned.
 288 |     |      */
 289 |     |     function burnM(
 290 |     |         address minter,
 291 |     |         uint256 maxPrincipalAmount,
 292 |     |         uint256 maxAmount
 293 |     |     ) external returns (uint112 principalAmount, uint240 amount);
 294 |     | 
 295 |     |     /**
 296 |     |      * @notice Cancels minting request for selected minter by validator
 297 |     |      * @param  minter The address of the minter to cancelMint minting request for
 298 |     |      * @param  mintId The id of outstanding mint request
 299 |     |      */
 300 |     |     function cancelMint(address minter, uint256 mintId) external;
 301 |     | 
 302 |     |     /**
 303 |     |      * @notice Freezes minter
 304 |     |      * @param  minter      The address of the minter to freeze
 305 |     |      * @return frozenUntil The timestamp until which minter is frozen
 306 |     |      */
 307 |     |     function freezeMinter(address minter) external returns (uint40 frozenUntil);
 308 |     | 
 309 |     |     /**
 310 |     |      * @notice Activate an approved minter.
 311 |     |      * @dev    MUST revert if `minter` is not recorded as an approved minter in TTG Registrar.
 312 |     |      * @dev    MUST revert if `minter` has been deactivated.
 313 |     |      * @param  minter The address of the minter to activate
 314 |     |      */
 315 |     |     function activateMinter(address minter) external;
 316 |     | 
 317 |     |     /**
 318 |     |      * @notice Deactivates an active minter.
 319 |     |      * @dev    MUST revert if the minter is still approved.
 320 |     |      * @dev    MUST revert if the minter is not active.
 321 |     |      * @param  minter        The address of the minter to deactivate.
 322 |     |      * @return inactiveOwedM The inactive owed M for the deactivated minter.
 323 |     |      */
 324 |     |     function deactivateMinter(address minter) external returns (uint240 inactiveOwedM);
 325 |     | 
 326 |     |     /* ============ View/Pure Functions ============ */
 327 |     | 
 328 |     |     /// @notice The address of M token
 329 |     |     function mToken() external view returns (address);
 330 |     | 
 331 |     |     /// @notice The address of TTG Registrar contract.
 332 |     |     function ttgRegistrar() external view returns (address);
 333 |     | 
 334 |     |     /// @notice The address of TTG Vault contract.
 335 |     |     function ttgVault() external view returns (address);
 336 |     | 
 337 |     |     /// @notice The last saved value of Minter rate.
 338 |     |     function minterRate() external view returns (uint32);
 339 |     | 
 340 |     |     /// @notice The principal of total owed M for all active minters.
 341 |     |     function principalOfTotalActiveOwedM() external view returns (uint112);
 342 |     | 
 343 |     |     /// @notice The total owed M for all active minters.
 344 |     |     function totalActiveOwedM() external view returns (uint240);
 345 |     | 
 346 |     |     /// @notice The total owed M for all inactive minters.
 347 |     |     function totalInactiveOwedM() external view returns (uint240);
 348 |     | 
 349 |     |     /// @notice The total owed M for all minters.
 350 |     |     function totalOwedM() external view returns (uint240);
 351 |     | 
 352 |     |     /// @notice The difference between total owed M and M token total supply.
 353 |     |     function excessOwedM() external view returns (uint240);
 354 |     | 
 355 |     |     /// @notice The principal of active owed M of minter.
 356 |     |     function principalOfActiveOwedMOf(address minter_) external view returns (uint112);
 357 |     | 
 358 |     |     /// @notice The active owed M of minter.
 359 |     |     function activeOwedMOf(address minter) external view returns (uint240);
 360 |     | 
 361 |     |     /**
 362 |     |      * @notice The max allowed active owed M of minter taking into account collateral amount and retrieval proposals.
 363 |     |      * @dev    This is the only present value that requires a `uint256` since it is the result of a multiplication
 364 |     |      *         between a `uint240` and a value that has a max of `65,000` (the mint ratio).
 365 |     |      */
 366 |     |     function maxAllowedActiveOwedMOf(address minter) external view returns (uint256);
 367 |     | 
 368 |     |     /// @notice The inactive owed M of deactivated minter.
 369 |     |     function inactiveOwedMOf(address minter) external view returns (uint240);
 370 |     | 
 371 |     |     /// @notice The collateral of a given minter.
 372 |     |     function collateralOf(address minter) external view returns (uint240);
 373 |     | 
 374 |     |     /// @notice The timestamp of the last collateral update of minter.
 375 |     |     function collateralUpdateTimestampOf(address minter) external view returns (uint40);
 376 |     | 
 377 |     |     /// @notice The timestamp after which an additional penalty for a missed update interval will be charged.
 378 |     |     function collateralPenaltyDeadlineOf(address minter) external view returns (uint40);
 379 |     | 
 380 |     |     /// @notice The timestamp after which the minter's collateral is assumed to be 0 due to a missed update.
 381 |     |     function collateralExpiryTimestampOf(address minter) external view returns (uint40);
 382 |     | 
 383 |     |     /// @notice The timestamp until which minter is already penalized for missed collateral updates.
 384 |     |     function penalizedUntilOf(address minter) external view returns (uint40);
 385 |     | 
 386 |     |     /// @notice The timestamp when `minter` created their latest retrieval proposal.
 387 |     |     function latestProposedRetrievalTimestampOf(address minter) external view returns (uint40);
 388 |     | 
 389 |     |     /**
 390 |     |      * @notice Returns the last signature timestamp used by `validator` to update collateral for `minter`.
 391 |     |      * @param  minter    The address of the minter.
 392 |     |      * @param  validator The address of the validator.
 393 |     |      * @return The last signature timestamp used.
 394 |     |      */
 395 |     |     function getLastSignatureTimestamp(address minter, address validator) external view returns (uint256);
 396 |     | 
 397 |     |     /**
 398 |     |      * @notice Returns the EIP-712 digest for updateCollateral method.
 399 |     |      * @param  minter       The address of the minter.
 400 |     |      * @param  collateral   The amount of collateral.
 401 |     |      * @param  retrievalIds The list of outstanding collateral retrieval IDs to resolve.
 402 |     |      * @param  metadataHash The hash of metadata of the collateral update, reserved for future informational use.
 403 |     |      * @param  timestamp    The timestamp of the collateral update.
 404 |     |      */
 405 |     |     function getUpdateCollateralDigest(
 406 |     |         address minter,
 407 |     |         uint256 collateral,
 408 |     |         uint256[] calldata retrievalIds,
 409 |     |         bytes32 metadataHash,
 410 |     |         uint256 timestamp
 411 |     |     ) external view returns (bytes32);
 412 |     | 
 413 |     |     /// @notice The mint proposal of minters, only 1 active proposal per minter
 414 |     |     function mintProposalOf(
 415 |     |         address minter
 416 |     |     ) external view returns (uint48 mintId, uint40 createdAt, address destination, uint240 amount);
 417 |     | 
 418 |     |     /// @notice The amount of a pending retrieval request for an active minter.
 419 |     |     function pendingCollateralRetrievalOf(address minter, uint256 retrievalId) external view returns (uint240);
 420 |     | 
 421 |     |     /// @notice The total amount of pending retrieval requests for an active minter.
 422 |     |     function totalPendingCollateralRetrievalOf(address minter) external view returns (uint240);
 423 |     | 
 424 |     |     /// @notice The timestamp when minter becomes unfrozen after being frozen by validator.
 425 |     |     function frozenUntilOf(address minter) external view returns (uint40);
 426 |     | 
 427 |     |     /// @notice Checks if minter was activated after approval by TTG
 428 |     |     function isActiveMinter(address minter) external view returns (bool);
 429 |     | 
 430 |     |     /// @notice Checks if minter was deactivated after removal by TTG
 431 |     |     function isDeactivatedMinter(address minter) external view returns (bool);
 432 |     | 
 433 |     |     /// @notice Checks if minter was frozen by validator
 434 |     |     function isFrozenMinter(address minter) external view returns (bool);
 435 |     | 
 436 |     |     /// @notice Checks if minter was approved by TTG
 437 |     |     function isMinterApproved(address minter) external view returns (bool);
 438 |     | 
 439 |     |     /// @notice Checks if validator was approved by TTG
 440 |     |     function isValidatorApproved(address validator) external view returns (bool);
 441 |     | 
 442 |     |     /// @notice The delay between mint proposal creation and its earliest execution.
 443 |     |     function mintDelay() external view returns (uint32);
 444 |     | 
 445 |     |     /// @notice The time while mint request can still be processed before it is considered expired.
 446 |     |     function mintTTL() external view returns (uint32);
 447 |     | 
 448 |     |     /// @notice The freeze time for minter.
 449 |     |     function minterFreezeTime() external view returns (uint32);
 450 |     | 
 451 |     |     /// @notice The allowed activeOwedM to collateral ratio.
 452 |     |     function mintRatio() external view returns (uint32);
 453 |     | 
 454 |     |     /// @notice The % that defines penalty amount for missed collateral updates or excessive owedM value
 455 |     |     function penaltyRate() external view returns (uint32);
 456 |     | 
 457 |     |     /// @notice The smart contract that defines the minter rate.
 458 |     |     function rateModel() external view returns (address);
 459 |     | 
 460 |     |     /// @notice The interval that defines the required frequency of collateral updates.
 461 |     |     function updateCollateralInterval() external view returns (uint32);
 462 |     | 
 463 |     |     /// @notice The number of signatures required for successful collateral update.
 464 |     |     function updateCollateralValidatorThreshold() external view returns (uint256);
 465 |     | 
 466 |     |     /// @notice Descaler for variables in basis points. Effectively, 100% in basis points.
 467 |     |     function ONE() external pure returns (uint16);
 468 |     | 
 469 |     |     /// @notice Mint ratio cap. 650% in basis points.
 470 |     |     function MAX_MINT_RATIO() external pure returns (uint32);
 471 |     | 
 472 |     |     /// @notice Update collateral interval lower cap in seconds.
 473 |     |     function MIN_UPDATE_COLLATERAL_INTERVAL() external pure returns (uint32);
 474 |     | 
 475 |     |     /// @notice The EIP-712 typehash for the `updateCollateral` method.
 476 |     |     function UPDATE_COLLATERAL_TYPEHASH() external pure returns (bytes32);
 477 |     | }
 478 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/interfaces/ITTGRegistar.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  TTG (Two Token Governance) Registrar interface.
  7 |     |  * @author M^0 Labs
  8 |     |  */
  9 |     | interface ITTGRegistrar {
 10 |     |     /**
 11 |     |      * @notice Key value pair getter.
 12 |     |      * @param  key The key to get the value of.
 13 |     |      * @return value The value of the key.
 14 |     |      */
 15 |     |     function get(bytes32 key) external view returns (bytes32 value);
 16 |     | 
 17 |     |     /**
 18 |     |      * @notice Checks if the list contains the account.
 19 |     |      * @param  list The list to check.
 20 |     |      * @param  account The account to check.
 21 |     |      * @return True if the list contains the account, false otherwise.
 22 |     |      */
 23 |     |     function listContains(bytes32 list, address account) external view returns (bool);
 24 |     | 
 25 |     |     /// @notice Returns the vault contract address.
 26 |     |     function vault() external view returns (address);
 27 |     | }
 28 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/libs/IndexingMath.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity >=0.8.20 <0.9.0;
   4 |     | 
   5 |     | import { UIntMath } from "../../lib/common/src/libs/UIntMath.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title  Helper library for indexing math functions.
   9 |     |  * @author M0 Labs
  10 |     |  */
  11 |     | library IndexingMath {
  12 |     |     /* ============ Variables ============ */
  13 |     | 
  14 |     |     /// @notice The scaling of indexes for exponent math.
  15 | *   |     uint56 internal constant EXP_SCALED_ONE = 1e12;
  16 |     | 
  17 |     |     /* ============ Custom Errors ============ */
  18 |     | 
  19 |     |     /// @notice Emitted when a division by zero occurs.
  20 |     |     error DivisionByZero();
  21 |     | 
  22 |     |     /* ============ Exposed Functions ============ */
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev    Returns the present amount (rounded down) given the principal amount and an index.
  26 |     |      * @param  principal The principal amount.
  27 |     |      * @param  index     An index.
  28 |     |      * @return The present amount rounded down.
  29 |     |      */
  30 | *   |     function getPresentAmountRoundedDown(uint112 principal, uint128 index) internal pure returns (uint256) {
  31 |     |         unchecked {
  32 | *   |             return (uint256(principal) * index) / EXP_SCALED_ONE;
  33 |     |         }
  34 |     |     }
  35 |     | 
  36 |     |     /**
  37 |     |      * @dev    Returns the present amount (rounded up) given the principal amount and an index.
  38 |     |      * @param  principal The principal amount.
  39 |     |      * @param  index     An index.
  40 |     |      * @return The present amount rounded up.
  41 |     |      */
  42 | *   |     function getPresentAmountRoundedUp(uint112 principal, uint128 index) internal pure returns (uint256) {
  43 |     |         unchecked {
  44 | *   |             return ((uint256(principal) * index) + (EXP_SCALED_ONE - 1)) / EXP_SCALED_ONE;
  45 |     |         }
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev    Returns the principal amount given the present amount, using the current index.
  50 |     |      * @param  presentAmount The present amount.
  51 |     |      * @param  index         An index.
  52 |     |      * @return The principal amount rounded down.
  53 |     |      */
  54 | *   |     function getPrincipalAmountRoundedDown(uint256 presentAmount, uint128 index) internal pure returns (uint112) {
  55 | *   |         if (index == 0) revert DivisionByZero();
  56 |     | 
  57 |     |         unchecked {
  58 |     |             // NOTE: While `uint256(presentAmount) * EXP_SCALED_ONE` can technically overflow, these divide/multiply functions are
  59 |     |             //       only used for the purpose of principal/present amount calculations for continuous indexing, and
  60 |     |             //       so for an `presentAmount` to be large enough to overflow this, it would have to be a possible result of
  61 |     |             //       `multiply112By128Down` or `multiply112By128Up`, which would already satisfy
  62 |     |             //       `uint256(presentAmount) * EXP_SCALED_ONE < type(uint240).max`.
  63 | *   |             return UIntMath.safe112((presentAmount * EXP_SCALED_ONE) / index);
  64 |     |         }
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev    Returns the principal amount given the present amount, using the current index.
  69 |     |      * @param  presentAmount The present amount.
  70 |     |      * @param  index         An index.
  71 |     |      * @return The principal amount rounded up.
  72 |     |      */
  73 | *   |     function getPrincipalAmountRoundedUp(uint256 presentAmount, uint128 index) internal pure returns (uint112) {
  74 | *   |         if (index == 0) revert DivisionByZero();
  75 |     | 
  76 |     |         unchecked {
  77 |     |             // NOTE: While `uint256(presentAmount) * EXP_SCALED_ONE` can technically overflow, these divide/multiply functions are
  78 |     |             //       only used for the purpose of principal/present amount calculations for continuous indexing, and
  79 |     |             //       so for an `presentAmount` to be large enough to overflow this, it would have to be a possible result of
  80 |     |             //       `multiply112By128Down` or `multiply112By128Up`, which would already satisfy
  81 |     |             //       `uint256(presentAmount) * EXP_SCALED_ONE < type(uint240).max`.
  82 | *   |             return UIntMath.safe112(((presentAmount * EXP_SCALED_ONE) + index - 1) / index);
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev    Returns the safely capped principal amount given the present amount, using the current index.
  88 |     |      * @param  presentAmount The present amount.
  89 |     |      * @param  index         An index.
  90 |     |      * @param  maxPrincipalAmount The maximum principal amount.
  91 |     |      * @return The principal amount rounded up, capped at maxPrincipalAmount.
  92 |     |      */
  93 | *   |     function getSafePrincipalAmountRoundedUp(
  94 |     |         uint256 presentAmount,
  95 |     |         uint128 index,
  96 |     |         uint112 maxPrincipalAmount
  97 | *   |     ) internal pure returns (uint112) {
  98 | *   |         uint112 principalAmount = getPrincipalAmountRoundedUp(presentAmount, index);
  99 | *   |         return principalAmount > maxPrincipalAmount ? maxPrincipalAmount : principalAmount;
 100 |     |     }
 101 |     | }
 102 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/libs/TTGRegistrarReader.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import { ITTGRegistrar } from "src/interfaces/ITTGRegistar.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title  Library to read TTG (Two Token Governance) Registrar contract parameters.
   9 |     |  * @author M^0 Labs
  10 |     |  */
  11 |     | library TTGRegistrarReader {
  12 |     |     /* ============ Variables ============ */
  13 |     | 
  14 |     |     /// @notice The name of parameter in TTG that defines the earner rate model contract.
  15 |     |     bytes32 internal constant EARNER_RATE_MODEL = "earner_rate_model";
  16 |     | 
  17 |     |     /// @notice The parameter name in TTG that defines the earners list.
  18 |     |     bytes32 internal constant EARNERS_LIST = "earners";
  19 |     | 
  20 |     |     /// @notice The parameter name in TTG that defines whether to ignore the earners list or not.
  21 |     |     bytes32 internal constant EARNERS_LIST_IGNORED = "earners_list_ignored";
  22 |     | 
  23 |     |     /// @notice The parameter name in TTG that defines the time to wait for mint request to be processed.
  24 |     |     bytes32 internal constant MINT_DELAY = "mint_delay";
  25 |     | 
  26 |     |     /// @notice The parameter name in TTG that defines the mint ratio.
  27 |     |     bytes32 internal constant MINT_RATIO = "mint_ratio"; // bps
  28 |     | 
  29 |     |     /// @notice The parameter name in TTG that defines the time while mint request can still be processed.
  30 |     |     bytes32 internal constant MINT_TTL = "mint_ttl";
  31 |     | 
  32 |     |     /// @notice The parameter name in TTG that defines the time to freeze minter.
  33 |     |     bytes32 internal constant MINTER_FREEZE_TIME = "minter_freeze_time";
  34 |     | 
  35 |     |     /// @notice The parameter name in TTG that defines the minter rate model contract.
  36 |     |     bytes32 internal constant MINTER_RATE_MODEL = "minter_rate_model";
  37 |     | 
  38 |     |     /// @notice The parameter name in TTG that defines the minters list.
  39 |     |     bytes32 internal constant MINTERS_LIST = "minters";
  40 |     | 
  41 |     |     /// @notice The parameter name in TTG that defines the penalty rate.
  42 |     |     bytes32 internal constant PENALTY_RATE = "penalty_rate"; // bps
  43 |     | 
  44 |     |     /// @notice The parameter name in TTG that defines the required interval to update collateral.
  45 |     |     bytes32 internal constant UPDATE_COLLATERAL_INTERVAL = "update_collateral_interval";
  46 |     | 
  47 |     |     /// @notice The parameter name that defines number of signatures required for successful collateral update.
  48 |     |     bytes32 internal constant UPDATE_COLLATERAL_VALIDATOR_THRESHOLD = "update_collateral_threshold";
  49 |     | 
  50 |     |     /// @notice The parameter name in TTG that defines the validators list.
  51 |     |     bytes32 internal constant VALIDATORS_LIST = "validators";
  52 |     | 
  53 |     |     /* ============ Internal View/Pure Functions ============ */
  54 |     | 
  55 |     |     /// @notice Gets the earner rate model contract address.
  56 | *   |     function getEarnerRateModel(address registrar_) internal view returns (address) {
  57 | *   |         return toAddress(_get(registrar_, EARNER_RATE_MODEL));
  58 |     |     }
  59 |     | 
  60 |     |     /// @notice Gets the mint delay.
  61 |     |     function getMintDelay(address registrar_) internal view returns (uint256) {
  62 |     |         return uint256(_get(registrar_, MINT_DELAY));
  63 |     |     }
  64 |     | 
  65 |     |     /// @notice Gets the minter freeze time.
  66 |     |     function getMinterFreezeTime(address registrar_) internal view returns (uint256) {
  67 |     |         return uint256(_get(registrar_, MINTER_FREEZE_TIME));
  68 |     |     }
  69 |     | 
  70 |     |     /// @notice Gets the minter rate model contract address.
  71 |     |     function getMinterRateModel(address registrar_) internal view returns (address) {
  72 |     |         return toAddress(_get(registrar_, MINTER_RATE_MODEL));
  73 |     |     }
  74 |     | 
  75 |     |     /// @notice Gets the mint TTL.
  76 |     |     function getMintTTL(address registrar_) internal view returns (uint256) {
  77 |     |         return uint256(_get(registrar_, MINT_TTL));
  78 |     |     }
  79 |     | 
  80 |     |     /// @notice Gets the mint ratio.
  81 |     |     function getMintRatio(address registrar_) internal view returns (uint256) {
  82 |     |         return uint256(_get(registrar_, MINT_RATIO));
  83 |     |     }
  84 |     | 
  85 |     |     /// @notice Gets the update collateral interval.
  86 |     |     function getUpdateCollateralInterval(address registrar_) internal view returns (uint256) {
  87 |     |         return uint256(_get(registrar_, UPDATE_COLLATERAL_INTERVAL));
  88 |     |     }
  89 |     | 
  90 |     |     /// @notice Gets the update collateral validator threshold.
  91 |     |     function getUpdateCollateralValidatorThreshold(address registrar_) internal view returns (uint256) {
  92 |     |         return uint256(_get(registrar_, UPDATE_COLLATERAL_VALIDATOR_THRESHOLD));
  93 |     |     }
  94 |     | 
  95 |     |     /// @notice Checks if the given earner is approved.
  96 |     |     function isApprovedEarner(address registrar_, address earner_) internal view returns (bool) {
  97 |     |         return _contains(registrar_, EARNERS_LIST, earner_);
  98 |     |     }
  99 |     | 
 100 |     |     /// @notice Checks if the `earners_list_ignored` exists.
 101 |     |     function isEarnersListIgnored(address registrar_) internal view returns (bool) {
 102 |     |         return _get(registrar_, EARNERS_LIST_IGNORED) != bytes32(0);
 103 |     |     }
 104 |     | 
 105 |     |     /// @notice Checks if the given minter is approved.
 106 |     |     function isApprovedMinter(address registrar_, address minter_) internal view returns (bool) {
 107 |     |         return _contains(registrar_, MINTERS_LIST, minter_);
 108 |     |     }
 109 |     | 
 110 |     |     /// @notice Checks if the given validator is approved.
 111 |     |     function isApprovedValidator(address registrar_, address validator_) internal view returns (bool) {
 112 |     |         return _contains(registrar_, VALIDATORS_LIST, validator_);
 113 |     |     }
 114 |     | 
 115 |     |     /// @notice Gets the penalty rate.
 116 |     |     function getPenaltyRate(address registrar_) internal view returns (uint256) {
 117 |     |         return uint256(_get(registrar_, PENALTY_RATE));
 118 |     |     }
 119 |     | 
 120 |     |     /// @notice Gets the vault contract address.
 121 |     |     function getVault(address registrar_) internal view returns (address) {
 122 |     |         return ITTGRegistrar(registrar_).vault();
 123 |     |     }
 124 |     | 
 125 |     |     /// @notice Converts given bytes32 to address.
 126 | *   |     function toAddress(bytes32 input_) internal pure returns (address) {
 127 | *   |         return address(uint160(uint256(input_)));
 128 |     |     }
 129 |     | 
 130 |     |     /// @notice Checks if the given list contains the given account.
 131 |     |     function _contains(address registrar_, bytes32 listName_, address account_) private view returns (bool) {
 132 |     |         return ITTGRegistrar(registrar_).listContains(listName_, account_);
 133 |     |     }
 134 |     | 
 135 |     |     /// @notice Gets the value of the given key.
 136 | *   |     function _get(address registrar_, bytes32 key_) private view returns (bytes32) {
 137 | *   |         return ITTGRegistrar(registrar_).get(key_);
 138 |     |     }
 139 |     | }
 140 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/projects/earnerManager/IMEarnerManager.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | /**
   6 |     |  * @title M Extension where Earner Manager whitelists earners and sets fee rates for them.
   7 |     |  * @author M0 Labs
   8 |     |  */
   9 |     | interface IMEarnerManager {
  10 |     |     /* ============ Events ============ */
  11 |     | 
  12 |     |     /**
  13 |     |      * @notice Emitted when an account's yield is claimed.
  14 |     |      * @param  account   The address that yield is claimed for.
  15 |     |      * @param  yield     The amount of M extension yield claimed.
  16 |     |      */
  17 |     |     event YieldClaimed(address indexed account, uint256 yield);
  18 |     | 
  19 |     |     /**
  20 |     |      * @notice Emitted when an account's yield fee is claimed.
  21 |     |      * @param  account      The address that yield fee is claimed for.
  22 |     |      * @param  feeRecipient The address of the fee recipient.
  23 |     |      * @param  fee          The amount of M extension yield fee claimed.
  24 |     |      */
  25 |     |     event FeeClaimed(address indexed account, address indexed feeRecipient, uint256 fee);
  26 |     | 
  27 |     |     /**
  28 |     |      * @notice Emitted when account is added/removed to/from  the whitelist or fee rate is adjusted
  29 |     |      * @param  account   The address to set earner status and details.
  30 |     |      * @param  status    The whitelisted status of account.
  31 |     |      * @param  feeRate   The fee rate in bps of the account.
  32 |     |      */
  33 |     |     event AccountInfoSet(address indexed account, bool status, uint16 feeRate);
  34 |     | 
  35 |     |     /**
  36 |     |      * @notice Emitted when the fee recipient is set.
  37 |     |      * @param  feeRecipient The address of the new fee recipient.
  38 |     |      */
  39 |     |     event FeeRecipientSet(address indexed feeRecipient);
  40 |     | 
  41 |     |     /* ============ Custom Errors ============ */
  42 |     | 
  43 |     |     /// @notice Emitted in constructor if fee recipient is 0x0.
  44 |     |     error ZeroFeeRecipient();
  45 |     | 
  46 |     |     /// @notice Emitted in constructor if earner manager is 0x0.
  47 |     |     error ZeroEarnerManager();
  48 |     | 
  49 |     |     /// @notice Emitted in constructor if default admin is 0x0.
  50 |     |     error ZeroAdmin();
  51 |     | 
  52 |     |     /// @notice Emitted if account is 0x0.
  53 |     |     error ZeroAccount();
  54 |     | 
  55 |     |     /// @notice Emitted if the fee rate provided exceeds 100% in bps.
  56 |     |     error InvalidFeeRate();
  57 |     | 
  58 |     |     /// @notice Emitted if account is not whitelisted and fee rate is not zero.
  59 |     |     error InvalidAccountInfo();
  60 |     | 
  61 |     |     /// @notice Emitted if the account is not whitelisted.
  62 |     |     error NotWhitelisted(address account);
  63 |     | 
  64 |     |     /// @notice Emitted in `setAccountInfo` if lengths of arrays mismatch.
  65 |     |     error ArrayLengthMismatch();
  66 |     | 
  67 |     |     /// @notice Emitted in `setAccountInfo` if the array is empty.
  68 |     |     error ArrayLengthZero();
  69 |     | 
  70 |     |     /// @notice Emitted in `enableEarning` if earning was already previously enabled.
  71 |     |     error EarningCannotBeReenabled();
  72 |     | 
  73 |     |     /* ============ Interactive Functions ============ */
  74 |     | 
  75 |     |     /**
  76 |     |      * @notice Claims accrued yield to the account and % in fees to fee recipient.
  77 |     |      * @param  account The address of the account to claim yield for.
  78 |     |      * @return yieldWithFee The total amount of M extension yield claimed for the account.
  79 |     |      * @return fee The amount of M extension yield fee sent to fee recipient.
  80 |     |      * @return yieldNetOfFee The amount of M extension yield net of fees.
  81 |     |      */
  82 |     |     function claimFor(address account) external returns (uint256, uint256, uint256);
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice Claims accrued yield to the accounts and % in fees to fee recipient.
  86 |     |      * @param  accounts The addresses of the accounts to claim yield for.
  87 |     |      * @return yieldWithFees The total amount of M extension yield claimed for each account.
  88 |     |      * @return fees The amount of M extension yield fee sent to fee recipient for each account.
  89 |     |      * @return yieldNetOfFees The amount of M extension yield net of fees for each account.
  90 |     |      */
  91 |     |     function claimFor(
  92 |     |         address[] calldata accounts
  93 |     |     ) external returns (uint256[] memory yieldWithFees, uint256[] memory fees, uint256[] memory yieldNetOfFees);
  94 |     | 
  95 |     |     /**
  96 |     |      * @notice Sets the account info like:
  97 |     |      *         - whitelisting or removing account from whitelist,
  98 |     |      *         - fee rate for the account.
  99 |     |      * @dev    MUST only be callable by the EARNER_MANAGER_ROLE.
 100 |     |      * @dev    SHOULD revert if account is 0x0.
 101 |     |      * @param  account The address of the account to whitelist for earning.
 102 |     |      * @param  status  Whether the account is whitelisted as an earner.
 103 |     |      * @param  feeRate The fee rate, in bps, that will be taken from the yield generated by the account.
 104 |     |      */
 105 |     |     function setAccountInfo(address account, bool status, uint16 feeRate) external;
 106 |     | 
 107 |     |     /**
 108 |     |      * @notice Sets the account info like:
 109 |     |      *         - whitelisting or removing account from whitelist,
 110 |     |      *         - fee rate for the account.
 111 |     |      * @dev    MUST only be callable by the EARNER_MANAGER_ROLE.
 112 |     |      * @dev    SHOULD revert if account is 0x0.
 113 |     |      * @param  accounts The addresses of the accounts to whitelist for earning or remove from the whitelist.
 114 |     |      * @param  statuses Whether each account is a whitelisted, respectively, according to the admin.
 115 |     |      * @param  feeRates The fee rate, in bps, that will be taken from the yield generated by the accounts.
 116 |     |      */
 117 |     |     function setAccountInfo(address[] calldata accounts, bool[] calldata statuses, uint16[] calldata feeRates) external;
 118 |     | 
 119 |     |     /**
 120 |     |      * @notice Sets the yield fee recipient.
 121 |     |      * @dev    MUST only be callable by the EARNER_MANAGER_ROLE.
 122 |     |      * @dev    SHOULD revert if `feeRecipient` is 0x0.
 123 |     |      * @dev    SHOULD return early if `feeRecipient` is already the fee recipient.
 124 |     |      * @param  feeRecipient The address of the new fee recipient.
 125 |     |      */
 126 |     |     function setFeeRecipient(address feeRecipient) external;
 127 |     | 
 128 |     |     /* ============ View/Pure Functions ============ */
 129 |     | 
 130 |     |     /// @notice Returns total accrued yield, fee and yield net of fee for `account`.
 131 |     |     function accruedYieldAndFeeOf(address account) external view returns (uint256, uint256, uint256);
 132 |     | 
 133 |     |     /// @notice Returns yield net of fee for `account`.
 134 |     |     function accruedYieldOf(address account) external view returns (uint256);
 135 |     | 
 136 |     |     /// @notice Returns fee accrued as a part of yield for `account`.
 137 |     |     function accruedFeeOf(address account) external view returns (uint256);
 138 |     | 
 139 |     |     /// @notice Returns balance with yield net of fee for `account`.
 140 |     |     function balanceWithYieldOf(address account) external view returns (uint256);
 141 |     | 
 142 |     |     /// @notice Returns the fee rate in basis points for `account` - [0..100%]
 143 |     |     function feeRateOf(address account) external view returns (uint16);
 144 |     | 
 145 |     |     /// @notice Returns the principal accruing yield for `account`.
 146 |     |     function principalOf(address account) external view returns (uint112);
 147 |     | 
 148 |     |     /// @notice Returns whether `account` is whitelisted for earning yield and be whitelisted holder of M extension token.
 149 |     |     function isWhitelisted(address account) external view returns (bool);
 150 |     | 
 151 |     |     /// @notice The address of the yield fee recipient for all whitelisted accounts.
 152 |     |     function feeRecipient() external view returns (address);
 153 |     | 
 154 |     |     /// @notice The M index when earning for the M extension was disabled.
 155 |     |     function disableIndex() external view returns (uint128);
 156 |     | 
 157 |     |     /// @notice Whether earning was enabled at least once for this M extension.
 158 |     |     function wasEarningEnabled() external view returns (bool);
 159 |     | 
 160 |     |     /// @notice The projected total supply if all accrued yield was claimed at this moment.
 161 |     |     function projectedTotalSupply() external view returns (uint256);
 162 |     | 
 163 |     |     /// @notice The total amount of principal of all whitelisted accounts.
 164 |     |     function totalPrincipal() external view returns (uint112);
 165 |     | 
 166 |     |     /// @notice 100% in basis points.
 167 |     |     function ONE_HUNDRED_PERCENT() external view returns (uint16);
 168 |     | 
 169 |     |     /// @notice The role that can manage the yield recipient.
 170 |     |     function EARNER_MANAGER_ROLE() external view returns (bytes32);
 171 |     | }
 172 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/projects/earnerManager/MEarnerManager.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | import { IERC20 } from "../../../lib/common/src/interfaces/IERC20.sol";
   6 |     | 
   7 |     | import { AccessControlUpgradeable } from "../../../lib/common/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol";
   8 |     | 
   9 |     | import { IndexingMath } from "../../libs/IndexingMath.sol";
  10 |     | import { UIntMath } from "../../../lib/common/src/libs/UIntMath.sol";
  11 |     | 
  12 |     | import { IMExtension } from "../../interfaces/IMExtension.sol";
  13 |     | import { IMTokenLike } from "../../interfaces/IMTokenLike.sol";
  14 |     | import { IMEarnerManager } from "./IMEarnerManager.sol";
  15 |     | 
  16 |     | import { MExtension } from "../../MExtension.sol";
  17 |     | 
  18 |     | abstract contract MEarnerManagerStorageLayout {
  19 |     |     /**
  20 |     |      * @dev   Struct to represent an account's balance, whitelisted status, and earning details like `feeRate` and earning principal.
  21 |     |      * @param balance       The current balance of the account.
  22 |     |      * @param isWhitelisted Whether the account is whitelisted by an earner manager.
  23 |     |      * @param feeRate       The fee rate that defines yield split between account and earner manager.
  24 |     |      * @param principal     The earning principal for the account.
  25 |     |      */
  26 |     |     struct Account {
  27 |     |         // Slot 1
  28 |     |         uint256 balance;
  29 |     |         // Slot 2
  30 |     |         bool isWhitelisted;
  31 |     |         uint16 feeRate;
  32 |     |         uint112 principal;
  33 |     |     }
  34 |     | 
  35 |     |     /// @custom:storage-location erc7201:M0.storage.MEarnerManager
  36 |     |     struct MEarnerManagerStorageStruct {
  37 |     |         // Slot 1
  38 |     |         address feeRecipient;
  39 |     |         // Slot 2
  40 |     |         uint256 totalSupply;
  41 |     |         // Slot 3
  42 |     |         uint112 totalPrincipal;
  43 |     |         bool wasEarningEnabled;
  44 |     |         uint128 disableIndex;
  45 |     |         // Slot 4
  46 |     |         mapping(address account => Account) accounts;
  47 |     |     }
  48 |     | 
  49 |     |     // keccak256(abi.encode(uint256(keccak256("M0.storage.MEarnerManager")) - 1)) & ~bytes32(uint256(0xff))
  50 |     |     bytes32 private constant _M_EARNER_MANAGER_STORAGE_LOCATION =
  51 |     |         0x1c4485857d96206482b943eeab7f941848f1c52b84a4bd59d8c2a3e8468f8300;
  52 |     | 
  53 | *   |     function _getMEarnerManagerStorageLocation() internal pure returns (MEarnerManagerStorageStruct storage $) {
  54 |     |         assembly {
  55 | *   |             $.slot := _M_EARNER_MANAGER_STORAGE_LOCATION
  56 |     |         }
  57 |     |     }
  58 |     | }
  59 |     | 
  60 |     | /**
  61 |     |  * @title M Extension where Earner Manager whitelists accounts and sets fee rates for them.
  62 |     |  * @author M0 Labs
  63 |     |  */
  64 |     | contract MEarnerManager is IMEarnerManager, AccessControlUpgradeable, MEarnerManagerStorageLayout, MExtension {
  65 |     |     /* ============ Variables ============ */
  66 |     | 
  67 |     |     /// @inheritdoc IMEarnerManager
  68 | *   |     uint16 public constant ONE_HUNDRED_PERCENT = 10_000;
  69 |     | 
  70 |     |     /// @inheritdoc IMEarnerManager
  71 | *   |     bytes32 public constant EARNER_MANAGER_ROLE = keccak256("EARNER_MANAGER_ROLE");
  72 |     | 
  73 |     |     /* ============ Constructor ============ */
  74 |     | 
  75 |     |     /**
  76 |     |      * @custom:oz-upgrades-unsafe-allow constructor
  77 |     |      * @notice Constructs MYieldFee Implementation contract
  78 |     |      * @dev    Sets immutable storage.
  79 |     |      * @param  mToken       The address of $M token.
  80 |     |      * @param  swapFacility The address of Swap Facility.
  81 |     |      */
  82 | *   |     constructor(address mToken, address swapFacility) MExtension(mToken, swapFacility) {}
  83 |     | 
  84 |     |     /* ============ Initializer ============ */
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev   Initializes the M extension token with earner manager role and different fee tiers.
  88 |     |      * @param name               The name of the token (e.g. "M Earner Manager").
  89 |     |      * @param symbol             The symbol of the token (e.g. "MEM").
  90 |     |      * @param admin              The address administrating the M extension. Can grant and revoke roles.
  91 |     |      * @param earnerManager      The address of earner manager
  92 |     |      * @param feeRecipient_      The address that will receive the fees from all the earners.
  93 |     |      */
  94 | *   |     function initialize(
  95 |     |         string memory name,
  96 |     |         string memory symbol,
  97 |     |         address admin,
  98 |     |         address earnerManager,
  99 |     |         address feeRecipient_
 100 |     |     ) public virtual initializer {
 101 | *   |         if (admin == address(0)) revert ZeroAdmin();
 102 | *   |         if (earnerManager == address(0)) revert ZeroEarnerManager();
 103 |     | 
 104 | *   |         __MExtension_init(name, symbol);
 105 |     | 
 106 | *   |         _setFeeRecipient(feeRecipient_);
 107 |     | 
 108 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, admin);
 109 | *   |         _grantRole(EARNER_MANAGER_ROLE, earnerManager);
 110 |     |     }
 111 |     | 
 112 |     |     /* ============ Interactive Functions ============ */
 113 |     | 
 114 |     |     /// @inheritdoc IMEarnerManager
 115 | *   |     function setAccountInfo(address account, bool status, uint16 feeRate) public onlyRole(EARNER_MANAGER_ROLE) {
 116 | *   |         _setAccountInfo(account, status, feeRate);
 117 |     |     }
 118 |     | 
 119 |     |     /// @inheritdoc IMEarnerManager
 120 |     |     function setAccountInfo(
 121 |     |         address[] calldata accounts,
 122 |     |         bool[] calldata statuses,
 123 |     |         uint16[] calldata feeRates
 124 |     |     ) external onlyRole(EARNER_MANAGER_ROLE) {
 125 |     |         if (accounts.length == 0) revert ArrayLengthZero();
 126 |     |         if (accounts.length != statuses.length || accounts.length != feeRates.length) revert ArrayLengthMismatch();
 127 |     | 
 128 |     |         for (uint256 index_; index_ < accounts.length; ++index_) {
 129 |     |             _setAccountInfo(accounts[index_], statuses[index_], feeRates[index_]);
 130 |     |         }
 131 |     |     }
 132 |     | 
 133 |     |     /// @inheritdoc IMEarnerManager
 134 | *   |     function setFeeRecipient(address feeRecipient_) external onlyRole(EARNER_MANAGER_ROLE) {
 135 | *   |         _setFeeRecipient(feeRecipient_);
 136 |     |     }
 137 |     | 
 138 |     |     /// @inheritdoc IMEarnerManager
 139 | *   |     function claimFor(address account) public returns (uint256 yieldWithFee, uint256 fee, uint256 yieldNetOfFee) {
 140 | *   |         if (account == address(0)) revert ZeroAccount();
 141 |     | 
 142 | *   |         (yieldWithFee, fee, yieldNetOfFee) = accruedYieldAndFeeOf(account);
 143 |     | 
 144 | *   |         if (yieldWithFee == 0) return (0, 0, 0);
 145 |     | 
 146 |     |         // Emit the appropriate `YieldClaimed` and `Transfer` events.
 147 |     |         emit YieldClaimed(account, yieldNetOfFee);
 148 |     |         emit Transfer(address(0), account, yieldWithFee);
 149 |     | 
 150 |     |         MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();
 151 |     | 
 152 |     |         // NOTE: No change in principal, only the balance is updated to include the newly claimed yield.
 153 |     |         unchecked {
 154 |     |             $.accounts[account].balance += yieldWithFee;
 155 |     |             $.totalSupply += yieldWithFee;
 156 |     |         }
 157 |     | 
 158 |     |         if (fee == 0) return (yieldWithFee, 0, yieldNetOfFee);
 159 |     | 
 160 |     |         address feeRecipient_ = $.feeRecipient;
 161 |     | 
 162 |     |         // Emit the appropriate `FeeClaimed` and `Transfer` events.
 163 |     |         emit FeeClaimed(account, feeRecipient_, fee);
 164 |     |         emit Transfer(account, feeRecipient_, fee);
 165 |     | 
 166 |     |         // Transfer fee to the fee recipient.
 167 |     |         _update(account, feeRecipient_, fee);
 168 |     |     }
 169 |     | 
 170 |     |     /// @inheritdoc IMEarnerManager
 171 |     |     function claimFor(
 172 |     |         address[] calldata accounts
 173 |     |     ) external returns (uint256[] memory yieldWithFees, uint256[] memory fees, uint256[] memory yieldNetOfFees) {
 174 |     |         if (accounts.length == 0) revert ArrayLengthZero();
 175 |     | 
 176 |     |         // Initialize the return arrays with the same length as the `accounts` array.
 177 |     |         yieldWithFees = new uint256[](accounts.length);
 178 |     |         fees = new uint256[](accounts.length);
 179 |     |         yieldNetOfFees = new uint256[](accounts.length);
 180 |     | 
 181 |     |         // NOTE: Expected to loop over unique whitelisted addresses; otherwise, no yield will be claimed.
 182 |     |         for (uint256 index_ = 0; index_ < accounts.length; ++index_) {
 183 |     |             (yieldWithFees[index_], fees[index_], yieldNetOfFees[index_]) = claimFor(accounts[index_]);
 184 |     |         }
 185 |     |     }
 186 |     | 
 187 |     |     /// @inheritdoc IMExtension
 188 | *   |     function enableEarning() external override {
 189 | *   |         MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();
 190 |     | 
 191 | *   |         if ($.wasEarningEnabled) revert EarningCannotBeReenabled();
 192 |     | 
 193 | *   |         $.wasEarningEnabled = true;
 194 |     | 
 195 | *   |         emit EarningEnabled(currentIndex());
 196 |     | 
 197 | *   |         IMTokenLike(mToken).startEarning();
 198 |     |     }
 199 |     | 
 200 |     |     /// @inheritdoc IMExtension
 201 | *   |     function disableEarning() external override {
 202 | *   |         MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();
 203 |     | 
 204 | *   |         if (!isEarningEnabled()) revert EarningIsDisabled();
 205 |     | 
 206 | *   |         emit EarningDisabled($.disableIndex = currentIndex());
 207 |     | 
 208 | *   |         IMTokenLike(mToken).stopEarning(address(this));
 209 |     |     }
 210 |     | 
 211 |     |     /* ============ External/Public view functions ============ */
 212 |     | 
 213 |     |     /// @inheritdoc IMExtension
 214 | *   |     function isEarningEnabled() public view override returns (bool) {
 215 | *   |         MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();
 216 |     | 
 217 | *   |         return $.wasEarningEnabled && $.disableIndex == 0;
 218 |     |     }
 219 |     | 
 220 |     |     /// @inheritdoc IMEarnerManager
 221 | *   |     function accruedYieldAndFeeOf(
 222 |     |         address account
 223 | *   |     ) public view returns (uint256 yieldWithFee, uint256 fee, uint256 yieldNetOfFee) {
 224 | *   |         Account storage accountInfo_ = _getMEarnerManagerStorageLocation().accounts[account];
 225 |     | 
 226 | *   |         yieldWithFee = _getAccruedYield(accountInfo_.balance, accountInfo_.principal, currentIndex());
 227 | *   |         uint16 feeRate_ = accountInfo_.feeRate;
 228 |     | 
 229 | *   |         if (feeRate_ == 0 || yieldWithFee == 0) return (yieldWithFee, 0, yieldWithFee);
 230 |     | 
 231 |     |         unchecked {
 232 | *   |             fee = (yieldWithFee * feeRate_) / ONE_HUNDRED_PERCENT;
 233 | *   |             yieldNetOfFee = yieldWithFee - fee;
 234 |     |         }
 235 |     |     }
 236 |     | 
 237 |     |     /// @inheritdoc IMEarnerManager
 238 | *   |     function accruedYieldOf(address account) public view returns (uint256 yieldNetOfFee) {
 239 | *   |         (, , yieldNetOfFee) = accruedYieldAndFeeOf(account);
 240 |     |     }
 241 |     | 
 242 |     |     /// @inheritdoc IMEarnerManager
 243 | *   |     function accruedFeeOf(address account) public view returns (uint256 fee) {
 244 | *   |         (, fee, ) = accruedYieldAndFeeOf(account);
 245 |     |     }
 246 |     | 
 247 |     |     /// @inheritdoc IMEarnerManager
 248 |     |     function balanceWithYieldOf(address account) external view returns (uint256) {
 249 |     |         unchecked {
 250 |     |             return balanceOf(account) + accruedYieldOf(account);
 251 |     |         }
 252 |     |     }
 253 |     | 
 254 |     |     /// @inheritdoc IERC20
 255 | *   |     function balanceOf(address account) public view override returns (uint256) {
 256 | *   |         return _getMEarnerManagerStorageLocation().accounts[account].balance;
 257 |     |     }
 258 |     | 
 259 |     |     /// @inheritdoc IERC20
 260 | *   |     function totalSupply() public view returns (uint256) {
 261 | *   |         return _getMEarnerManagerStorageLocation().totalSupply;
 262 |     |     }
 263 |     | 
 264 |     |     /// @inheritdoc IMEarnerManager
 265 | *   |     function projectedTotalSupply() public view returns (uint256) {
 266 | *   |         return IndexingMath.getPresentAmountRoundedUp(totalPrincipal(), currentIndex());
 267 |     |     }
 268 |     | 
 269 |     |     /// @inheritdoc IMEarnerManager
 270 | *   |     function totalPrincipal() public view returns (uint112) {
 271 | *   |         return _getMEarnerManagerStorageLocation().totalPrincipal;
 272 |     |     }
 273 |     | 
 274 |     |     /// @inheritdoc IMEarnerManager
 275 |     |     function feeRecipient() public view returns (address) {
 276 |     |         return _getMEarnerManagerStorageLocation().feeRecipient;
 277 |     |     }
 278 |     | 
 279 |     |     /// @inheritdoc IMEarnerManager
 280 |     |     function isWhitelisted(address account) public view returns (bool) {
 281 |     |         return _getMEarnerManagerStorageLocation().accounts[account].isWhitelisted;
 282 |     |     }
 283 |     | 
 284 |     |     /// @inheritdoc IMEarnerManager
 285 |     |     function principalOf(address account) public view returns (uint112) {
 286 |     |         return _getMEarnerManagerStorageLocation().accounts[account].principal;
 287 |     |     }
 288 |     | 
 289 |     |     /// @inheritdoc IMEarnerManager
 290 |     |     function feeRateOf(address account) public view returns (uint16) {
 291 |     |         return _getMEarnerManagerStorageLocation().accounts[account].feeRate;
 292 |     |     }
 293 |     | 
 294 |     |     /// @inheritdoc IMExtension
 295 | *   |     function currentIndex() public view override returns (uint128) {
 296 | *   |         uint128 disableIndex_ = disableIndex();
 297 | *   |         return disableIndex_ == 0 ? IMTokenLike(mToken).currentIndex() : disableIndex_;
 298 |     |     }
 299 |     | 
 300 |     |     /// @inheritdoc IMEarnerManager
 301 | *   |     function disableIndex() public view returns (uint128) {
 302 | *   |         return _getMEarnerManagerStorageLocation().disableIndex;
 303 |     |     }
 304 |     | 
 305 |     |     /// @inheritdoc IMEarnerManager
 306 |     |     function wasEarningEnabled() public view returns (bool) {
 307 |     |         return _getMEarnerManagerStorageLocation().wasEarningEnabled;
 308 |     |     }
 309 |     | 
 310 |     |     /* ============ Hooks For Internal Interactive Functions ============ */
 311 |     | 
 312 |     |     /**
 313 |     |      * @dev   Hook called before approving an allowance.
 314 |     |      * @param account  The account that is approving the allowance.
 315 |     |      * @param spender  The account that is being approved to spend tokens.
 316 |     |      */
 317 | *   |     function _beforeApprove(address account, address spender, uint256 /* amount */) internal view override {
 318 | *   |         MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();
 319 |     | 
 320 | *   |         _revertIfNotWhitelisted($, account);
 321 | *   |         _revertIfNotWhitelisted($, spender);
 322 |     |     }
 323 |     | 
 324 |     |     /**
 325 |     |      * @dev    Hooks called before wrapping M into M Extension token.
 326 |     |      * @param  account   The account from which M is deposited.
 327 |     |      * @param  recipient The account receiving the minted M Extension token.
 328 |     |      */
 329 | *   |     function _beforeWrap(address account, address recipient, uint256 /* amount */) internal view override {
 330 | *   |         if (!isEarningEnabled()) revert EarningIsDisabled();
 331 |     | 
 332 | *   |         MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();
 333 |     | 
 334 | *   |         _revertIfNotWhitelisted($, account);
 335 | *   |         _revertIfNotWhitelisted($, recipient);
 336 |     |     }
 337 |     | 
 338 |     |     /**
 339 |     |      * @dev   Hook called before unwrapping M Extension token.
 340 |     |      * @param account The account from which M Extension token is burned.
 341 |     |      */
 342 | *   |     function _beforeUnwrap(address account, uint256 /* amount */) internal view override {
 343 | *   |         _revertIfNotWhitelisted(_getMEarnerManagerStorageLocation(), account);
 344 |     |     }
 345 |     | 
 346 |     |     /**
 347 |     |      * @dev   Hook called before transferring tokens.
 348 |     |      * @param sender    The sender's address.
 349 |     |      * @param recipient The recipient's address.
 350 |     |      */
 351 | *   |     function _beforeTransfer(address sender, address recipient, uint256 /* amount */) internal view override {
 352 | *   |         MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();
 353 |     | 
 354 | *   |         _revertIfNotWhitelisted($, msg.sender);
 355 |     | 
 356 | *   |         _revertIfNotWhitelisted($, sender);
 357 | *   |         _revertIfNotWhitelisted($, recipient);
 358 |     |     }
 359 |     | 
 360 |     |     /* ============ Internal Interactive Functions ============ */
 361 |     | 
 362 |     |     /**
 363 |     |      * @notice Sets the account info like:
 364 |     |      *         - whitelisting or removing account from whitelist,
 365 |     |      *         - fee rate for the account.
 366 |     |      * @param  account The address of the accounts to whitelist for earning or remove from the whitelist.
 367 |     |      * @param  status Whether an account is a whitelisted account, respectively, according to the admin.
 368 |     |      * @param  feeRate The fee rate, in bps, that will be taken from the yield generated by the account.
 369 |     |      */
 370 | *   |     function _setAccountInfo(address account, bool status, uint16 feeRate) internal {
 371 | *   |         if (account == address(0)) revert ZeroAccount();
 372 | *   |         if (feeRate > ONE_HUNDRED_PERCENT) revert InvalidFeeRate();
 373 | *   |         if (status == false && feeRate != 0) revert InvalidAccountInfo();
 374 |     | 
 375 | *   |         Account storage accountInfo_ = _getMEarnerManagerStorageLocation().accounts[account];
 376 | *   |         bool isWhitelisted_ = accountInfo_.isWhitelisted;
 377 |     | 
 378 |     |         // No change, no-op action
 379 | *   |         if (!isWhitelisted_ && !status) return;
 380 |     | 
 381 |     |         // No change, no-op action
 382 | *   |         if (isWhitelisted_ && status && accountInfo_.feeRate == feeRate) return;
 383 |     | 
 384 | *   |         emit AccountInfoSet(account, status, feeRate);
 385 |     | 
 386 |     |         // Claim yield for an `account` as the action below will lead to the change in the account info.
 387 |     |         // NOTE: Handle addresses being re-whitelisted by claiming any previously accrued yield to the `feeRecipient`.
 388 | *   |         claimFor(account);
 389 |     | 
 390 |     |         // Set up a new whitelisted account.
 391 | *   |         if (!isWhitelisted_ && status) {
 392 | *   |             accountInfo_.isWhitelisted = true;
 393 | *   |             accountInfo_.feeRate = feeRate;
 394 | *   |             return;
 395 |     |         }
 396 |     | 
 397 | *   |         if (!status) {
 398 |     |             // Remove whitelisted account info.
 399 | *   |             accountInfo_.isWhitelisted = false;
 400 |     |             // fee recipient will receive all yield from such 'un-whitelisted' accounts.
 401 | *   |             accountInfo_.feeRate = ONE_HUNDRED_PERCENT;
 402 |     |         } else {
 403 |     |             // Change fee rate for the whitelisted account.
 404 | *   |             accountInfo_.feeRate = feeRate;
 405 |     |         }
 406 |     |     }
 407 |     | 
 408 |     |     /**
 409 |     |      * @notice Sets the yield fee recipient that will receive part of the yield generated by token.
 410 |     |      * @dev    Reverts if the yield fee recipient is address zero.
 411 |     |      * @dev    Returns early if the yield fee recipient is the same as the current one.
 412 |     |      * @param  feeRecipient_ The yield fee recipient address.
 413 |     |      */
 414 | *   |     function _setFeeRecipient(address feeRecipient_) internal {
 415 | *   |         if (feeRecipient_ == address(0)) revert ZeroFeeRecipient();
 416 |     | 
 417 | *   |         MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();
 418 |     | 
 419 | *   |         if ($.feeRecipient == feeRecipient_) return;
 420 |     | 
 421 |     |         // Yield fee recipient does not pay fees.
 422 | *   |         _setAccountInfo(feeRecipient_, true, 0);
 423 |     | 
 424 | *   |         $.feeRecipient = feeRecipient_;
 425 |     | 
 426 | *   |         emit FeeRecipientSet(feeRecipient_);
 427 |     |     }
 428 |     | 
 429 |     |     /**
 430 |     |      * @dev   Mints `amount` tokens to `account`.
 431 |     |      * @param account The address that will receive tokens.
 432 |     |      * @param amount  The amount of tokens to mint.
 433 |     |      */
 434 | *   |     function _mint(address account, uint256 amount) internal override {
 435 | *   |         MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();
 436 | *   |         Account storage accountInfo_ = $.accounts[account];
 437 |     | 
 438 |     |         // Slightly underestimate the principal amount to be minted, round down in favor of protocol.
 439 | *   |         uint112 principal_ = IndexingMath.getPrincipalAmountRoundedDown(amount, currentIndex());
 440 |     | 
 441 |     |         // NOTE: Can be `unchecked` because the max amount of $M is never greater than `type(uint240).max`.
 442 |     |         //       Can be `unchecked` because UIntMath.safe112 is used for principal addition safety for `principal[account]`
 443 |     |         unchecked {
 444 | *   |             accountInfo_.balance += amount;
 445 | *   |             $.totalSupply += amount;
 446 |     | 
 447 | *   |             $.totalPrincipal = UIntMath.safe112(uint256($.totalPrincipal) + principal_);
 448 |     |             // No need for `UIntMath.safe112`, `accountInfo_.principal` cannot be greater than `totalPrincipal`.
 449 | *   |             accountInfo_.principal += principal_;
 450 |     |         }
 451 |     | 
 452 | *   |         emit Transfer(address(0), account, amount);
 453 |     |     }
 454 |     | 
 455 |     |     /**
 456 |     |      * @dev   Burns `amount` tokens from `account`.
 457 |     |      * @param account The address whose account balance will be decremented.
 458 |     |      * @param amount  The present amount of tokens to burn.
 459 |     |      */
 460 | *   |     function _burn(address account, uint256 amount) internal override {
 461 | *   |         MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();
 462 | *   |         Account storage accountInfo_ = $.accounts[account];
 463 |     | 
 464 |     |         // Slightly overestimate the principal amount to be burned and use safe value to avoid underflow in the unchecked block.
 465 | *   |         uint112 fromPrincipal_ = accountInfo_.principal;
 466 | *   |         uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);
 467 |     | 
 468 |     |         // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` is used.
 469 |     |         //       Can be `unchecked` because safety adjustment to `principal_` is applied above
 470 |     |         unchecked {
 471 | *   |             accountInfo_.balance -= amount;
 472 | *   |             $.totalSupply -= amount;
 473 |     | 
 474 | *   |             accountInfo_.principal = fromPrincipal_ - principal_;
 475 | *   |             $.totalPrincipal -= principal_;
 476 |     |         }
 477 |     | 
 478 | *   |         emit Transfer(account, address(0), amount);
 479 |     |     }
 480 |     | 
 481 |     |     /**
 482 |     |      * @dev   Internal balance update function called on transfer.
 483 |     |      * @param sender    The sender's address.
 484 |     |      * @param recipient The recipient's address.
 485 |     |      * @param amount    The amount to be transferred.
 486 |     |      */
 487 | *   |     function _update(address sender, address recipient, uint256 amount) internal override {
 488 | *   |         MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();
 489 | *   |         Account storage senderAccount_ = $.accounts[sender];
 490 | *   |         Account storage recipientAccount_ = $.accounts[recipient];
 491 |     | 
 492 |     |         // Slightly overestimate the principal amount to be moved on transfer
 493 | *   |         uint112 fromPrincipal_ = senderAccount_.principal;
 494 | *   |         uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);
 495 |     | 
 496 |     |         // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` is used in MExtension.
 497 |     |         //       Can be `unchecked` because safety adjustment to `principal_` is applied above, and
 498 |     |         unchecked {
 499 | *   |             senderAccount_.balance -= amount;
 500 | *   |             recipientAccount_.balance += amount;
 501 |     | 
 502 | *   |             senderAccount_.principal = fromPrincipal_ - principal_;
 503 | *   |             recipientAccount_.principal += principal_;
 504 |     |         }
 505 |     |     }
 506 |     | 
 507 |     |     /* ============ Internal View/Pure Functions ============ */
 508 |     | 
 509 |     |     /**
 510 |     |      * @dev    Compute the yield given a balance, principal and index.
 511 |     |      * @param  balance   The current balance of the account.
 512 |     |      * @param  principal The principal of the account.
 513 |     |      * @param  index     The current index.
 514 |     |      * @return The yield accrued since the last claim.
 515 |     |      */
 516 | *   |     function _getAccruedYield(uint256 balance, uint112 principal, uint128 index) internal pure returns (uint256) {
 517 | *   |         if (principal == 0) return 0;
 518 |     | 
 519 | *   |         uint256 balanceWithYield_ = IndexingMath.getPresentAmountRoundedDown(principal, index);
 520 |     |         unchecked {
 521 | *   |             return balanceWithYield_ > balance ? balanceWithYield_ - balance : 0;
 522 |     |         }
 523 |     |     }
 524 |     | 
 525 |     |     /**
 526 |     |      * @dev Reverts if `account` is not whitelisted by earner manager.
 527 |     |      */
 528 | *   |     function _revertIfNotWhitelisted(MEarnerManagerStorageStruct storage $, address account) internal view {
 529 | *   |         if (!$.accounts[account].isWhitelisted) revert NotWhitelisted(account);
 530 |     |     }
 531 |     | }
 532 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/projects/jmi/IJMIExtension.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | import { IMYieldToOne } from "../yieldToOne/IMYieldToOne.sol";
   6 |     | 
   7 |     | interface IJMIExtension is IMYieldToOne {
   8 |     |     /* ============ Events ============ */
   9 |     | 
  10 |     |     /**
  11 |     |      * @notice Emitted when asset cap is set.
  12 |     |      * @param  asset Address of the asset.
  13 |     |      * @param  cap   Maximum allowed amount of `asset` that can back the extension.
  14 |     |      */
  15 |     |     event AssetCapSet(address indexed asset, uint256 cap);
  16 |     | 
  17 |     |     /**
  18 |     |      * @notice Emitted when an asset is replaced with M.
  19 |     |      * @param  asset       Address of the asset.
  20 |     |      * @param  assetAmount Amount of asset replaced with M.
  21 |     |      * @param  recipient   Address that received the M.
  22 |     |      * @param  mAmount     Amount of M sent to the recipient.
  23 |     |      */
  24 |     |     event AssetReplacedWithM(address indexed asset, uint256 assetAmount, address indexed recipient, uint256 mAmount);
  25 |     | 
  26 |     |     /* ============ Custom Errors ============ */
  27 |     | 
  28 |     |     /**
  29 |     |      * @notice Emitted if the asset cap is reached.
  30 |     |      * @param  asset Address of the asset.
  31 |     |      */
  32 |     |     error AssetCapReached(address asset);
  33 |     | 
  34 |     |     /**
  35 |     |      * @notice Emitted if `replaceAssetWithM` is called but there is not enough asset to replace M with.
  36 |     |      * @param  asset          Address of the asset.
  37 |     |      * @param  amount         Amount of M to unwrap requested.
  38 |     |      * @param  assetAvailable Amount of M available.
  39 |     |      */
  40 |     |     error InsufficientAssetBacking(address asset, uint256 amount, uint256 assetAvailable);
  41 |     | 
  42 |     |     /**
  43 |     |      * @notice Emitted when wrapping `asset` for extension token and receiving less than expected.
  44 |     |      * @param  asset          Address of the asset.
  45 |     |      * @param  amountExpected Amount of `asset` expected.
  46 |     |      * @param  amountReceived Amount of `asset` received.
  47 |     |      */
  48 |     |     error InsufficientAssetReceived(address asset, uint256 amountExpected, uint256 amountReceived);
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Emitted if `unwrap()` is called but there is not enough M to unwrap with.
  52 |     |      * @param  amount     Amount of M to unwrap requested.
  53 |     |      * @param  mAvailable Amount of M available.
  54 |     |      */
  55 |     |     error InsufficientMBacking(uint256 amount, uint256 mAvailable);
  56 |     | 
  57 |     |     /**
  58 |     |      * @notice Emitted if an invalid asset is used.
  59 |     |      * @param  asset Address of the invalid asset.
  60 |     |      */
  61 |     |     error InvalidAsset(address asset);
  62 |     | 
  63 |     |     /* ============ Interactive Functions ============ */
  64 |     | 
  65 |     |     /*
  66 |     |      * @notice Mint extension tokens by depositing `asset` tokens.
  67 |     |      * @dev    MUST only be callable by the SwapFacility.
  68 |     |      * @dev    `amount` must be formatted in the `asset` token's decimals.
  69 |     |      * @param  asset     Address of the asset to deposit.
  70 |     |      * @param  recipient Address that will receive the extension tokens.
  71 |     |      * @param  amount    Amount of extension tokens to mint.
  72 |     |      */
  73 |     |     function wrap(address asset, address recipient, uint256 amount) external;
  74 |     | 
  75 |     |     /*
  76 |     |      * @notice Allows a M holder to swap M for the `asset` token.
  77 |     |      * @dev    MUST only be callable by the SwapFacility.
  78 |     |      * @dev    `amount` MUST be formatted in the M token's decimals.
  79 |     |      * @param  asset     Address of the asset to receive.
  80 |     |      * @param  recipient Address that will receive the `asset` token.
  81 |     |      * @param  amount    Amount of M to swap for `asset` token, formatted in M decimals.
  82 |     |      */
  83 |     |     function replaceAssetWithM(address asset, address recipient, uint256 amount) external;
  84 |     | 
  85 |     |     /*
  86 |     |      * @notice Sets the asset cap for a given `asset`.
  87 |     |      * @dev    MUST only be callable by an account with the ASSET_CAP_MANAGER_ROLE.
  88 |     |      * @param  asset Address of the asset.
  89 |     |      * @param  cap   Maximum allowed amount of `asset` that can back the extension.
  90 |     |      */
  91 |     |     function setAssetCap(address asset, uint256 cap) external;
  92 |     | 
  93 |     |     /* ============ View/Pure Functions ============ */
  94 |     | 
  95 |     |     /// @notice The role that can set the assets cap.
  96 |     |     function ASSET_CAP_MANAGER_ROLE() external view returns (bytes32);
  97 |     | 
  98 |     |     /// @notice Number of decimals used by the M token.
  99 |     |     function M_DECIMALS() external view returns (uint8);
 100 |     | 
 101 |     |     /// @notice Gets the cached balance of a given asset held by the extension.
 102 |     |     function assetBalanceOf(address asset) external view returns (uint256);
 103 |     | 
 104 |     |     /// @notice Gets the asset cap for a given asset.
 105 |     |     function assetCap(address asset) external view returns (uint256);
 106 |     | 
 107 |     |     /// @notice Gets the cached decimals of a given asset.
 108 |     |     function assetDecimals(address asset) external view returns (uint8);
 109 |     | 
 110 |     |     /// @notice Gets the total non-M assets held by the extension.
 111 |     |     function totalAssets() external view returns (uint256);
 112 |     | 
 113 |     |     /// @notice Checks if an asset is allowed as backing.
 114 |     |     function isAllowedAsset(address asset) external view returns (bool);
 115 |     | 
 116 |     |     /**
 117 |     |      * @notice Checks if wrapping a `amount` of `asset` is allowed.
 118 |     |      * @dev    `amount` MUST be formatted in `asset`'s decimals.
 119 |     |      * @param  asset  Address of the asset.
 120 |     |      * @param  amount Amount of `asset` to wrap.
 121 |     |      * @return True if allowed, false otherwise.
 122 |     |      */
 123 |     |     function isAllowedToWrap(address asset, uint256 amount) external view returns (bool);
 124 |     | 
 125 |     |     /*
 126 |     |      * @notice Checks if unwrapping `amount` of extension tokens is allowed.
 127 |     |      * @dev    `amount` MUST be formatted in extension's decimals (i.e. 6).
 128 |     |      * @param  amount Amount of extension tokens to unwrap, formatted in extension's decimals.
 129 |     |      * @return True if allowed, false otherwise.
 130 |     |      */
 131 |     |     function isAllowedToUnwrap(uint256 amount) external view returns (bool);
 132 |     | 
 133 |     |     /**
 134 |     |      * @notice Checks if replacing `asset` with M is allowed.
 135 |     |      * @dev    `amount` MUST be formatted in `asset`'s decimals.
 136 |     |      * @param  asset  Address of the asset.
 137 |     |      * @param  amount Amount of `asset` to replace, formatted in `asset`'s decimals.
 138 |     |      * @return True if allowed, false otherwise.
 139 |     |      */
 140 |     |     function isAllowedToReplaceAssetWithM(address asset, uint256 amount) external view returns (bool);
 141 |     | }
 142 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/projects/jmi/JMIExtension.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | import { IERC20Metadata as IERC20 } from "../../../lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol";
   6 |     | 
   7 |     | import { SafeERC20 } from "../../../lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
   8 |     | 
   9 |     | import { Pausable } from "../../components/pausable/Pausable.sol";
  10 |     | 
  11 |     | import { IMTokenLike } from "../../interfaces/IMTokenLike.sol";
  12 |     | import { ISwapFacility } from "../../swap/interfaces/ISwapFacility.sol";
  13 |     | 
  14 |     | import { IMYieldToOne } from "../yieldToOne/IMYieldToOne.sol";
  15 |     | import { MYieldToOne } from "../yieldToOne/MYieldToOne.sol";
  16 |     | 
  17 |     | import { IJMIExtension } from "./IJMIExtension.sol";
  18 |     | 
  19 |     | /**
  20 |     | 
  21 |     |                       
  22 |     |                    
  23 |     |                                 
  24 |     |                              
  25 |     |                           
  26 |     |                                   
  27 |     | 
  28 |     | */
  29 |     | 
  30 |     | abstract contract JMIExtensionLayout {
  31 |     |     struct Asset {
  32 |     |         // Cap amount for the asset, formatted in the asset's decimals (i.e. 18 decimals for DAI).
  33 |     |         // Primary asset (M) is implicit and has no cap.
  34 |     |         uint256 cap;
  35 |     |         // Balance of the asset backing the extension token.
  36 |     |         // M token's supply can't exceed uint240, so uint240 is safe to use.
  37 |     |         uint240 balance;
  38 |     |         // Decimals of the asset.
  39 |     |         uint8 decimals;
  40 |     |     }
  41 |     | 
  42 |     |     struct JMIExtensionStorageStruct {
  43 |     |         // All supported collateral assets and their properties.
  44 |     |         // If an asset is not present in the mapping or has a cap of 0, it is not allowed.
  45 |     |         mapping(address asset => Asset) assets;
  46 |     |         // Total amount of non M assets backing the extension token, formatted in extension decimals (i.e. 6 decimals).
  47 |     |         uint256 totalAssets;
  48 |     |     }
  49 |     | 
  50 |     |     // keccak256(abi.encode(uint256(keccak256("M0.storage.JMIExtension")) - 1)) & ~bytes32(uint256(0xff))
  51 |     |     bytes32 private constant _JMI_EXTENSION_STORAGE_LOCATION =
  52 |     |         0x4717d46f2e033163981fa31651301a35281b6b08316965d315fd1577bad94b00;
  53 |     | 
  54 | *   |     function _getJMIExtensionStorageLocation() internal pure returns (JMIExtensionStorageStruct storage $) {
  55 |     |         assembly {
  56 | *   |             $.slot := _JMI_EXTENSION_STORAGE_LOCATION
  57 |     |         }
  58 |     |     }
  59 |     | }
  60 |     | 
  61 |     | /**
  62 |     |  * @title  JMIExtension
  63 |     |  * @notice Upgradeable ERC20 Token contract for wrapping M into a non-rebasing token
  64 |     |  *         with yield claimable by a single recipient and JMI (Just Mint It) backing model.
  65 |     |  *         The JMI backing model allows users to mint the extension token
  66 |     |  *         by depositing either M or an allowed asset token.
  67 |     |  *         It assumes that both tokens are pegged 1:1.
  68 |     |  *         Fee on transfer tokens are not supported.
  69 |     |  * @author M0 Labs
  70 |     |  */
  71 | *   | contract JMIExtension is IJMIExtension, JMIExtensionLayout, MYieldToOne, Pausable {
  72 |     |     using SafeERC20 for IERC20;
  73 |     | 
  74 |     |     /* ============ Variables ============ */
  75 |     | 
  76 |     |     /// @inheritdoc IJMIExtension
  77 | *   |     bytes32 public constant ASSET_CAP_MANAGER_ROLE = keccak256("ASSET_CAP_MANAGER_ROLE");
  78 |     | 
  79 |     |     /// @inheritdoc IJMIExtension
  80 |     |     uint8 public constant M_DECIMALS = 6;
  81 |     | 
  82 |     |     /* ============ Constructor ============ */
  83 |     | 
  84 |     |     /**
  85 |     |      * @custom:oz-upgrades-unsafe-allow constructor
  86 |     |      * @notice Constructs JMIExtension Implementation contract
  87 |     |      * @dev    Sets immutable storage.
  88 |     |      * @param  mToken       The address of $M token.
  89 |     |      * @param  swapFacility The address of Swap Facility.
  90 |     |      */
  91 | *   |     constructor(address mToken, address swapFacility) MYieldToOne(mToken, swapFacility) {}
  92 |     | 
  93 |     |     /* ============ Initializer ============ */
  94 |     | 
  95 |     |     /**
  96 |     |      * @dev   Initializes the M extension token with JMI backing model and yield claimable by a single recipient.
  97 |     |      * @param name                  The name of the token (e.g. "Just Mint It").
  98 |     |      * @param symbol                The symbol of the token (e.g. "JMI").
  99 |     |      * @param yieldRecipient        The address of a yield recipient.
 100 |     |      * @param admin                 The address of an admin.
 101 |     |      * @param assetCapManager       The address of an asset cap manager.
 102 |     |      * @param freezeManager         The address of a freeze manager.
 103 |     |      * @param pauser                The address of a pauser.
 104 |     |      * @param yieldRecipientManager The address of a yield recipient manager.
 105 |     |      */
 106 | *   |     function initialize(
 107 |     |         string memory name,
 108 |     |         string memory symbol,
 109 |     |         address yieldRecipient,
 110 |     |         address admin,
 111 |     |         address assetCapManager,
 112 |     |         address freezeManager,
 113 |     |         address pauser,
 114 |     |         address yieldRecipientManager
 115 |     |     ) public virtual initializer {
 116 | *   |         __JMIExtension_init(
 117 | *   |             name,
 118 | *   |             symbol,
 119 | *   |             yieldRecipient,
 120 | *   |             admin,
 121 | *   |             assetCapManager,
 122 | *   |             freezeManager,
 123 | *   |             pauser,
 124 | *   |             yieldRecipientManager
 125 |     |         );
 126 |     |     }
 127 |     | 
 128 |     |     /**
 129 |     |      * @dev   Initializes the JMIExtension token.
 130 |     |      * @param name                  The name of the token (e.g. "Just Mint It").
 131 |     |      * @param symbol                The symbol of the token (e.g. "JMI").
 132 |     |      * @param yieldRecipient        The address of a yield destination.
 133 |     |      * @param admin                 The address of an admin.
 134 |     |      * @param assetCapManager       The address of an asset cap manager.
 135 |     |      * @param freezeManager         The address of a freeze manager.
 136 |     |      * @param pauser                The address of a pauser.
 137 |     |      * @param yieldRecipientManager The address of a yield recipient setter.
 138 |     |      */
 139 | *   |     function __JMIExtension_init(
 140 |     |         string memory name,
 141 |     |         string memory symbol,
 142 |     |         address yieldRecipient,
 143 |     |         address admin,
 144 |     |         address assetCapManager,
 145 |     |         address freezeManager,
 146 |     |         address pauser,
 147 |     |         address yieldRecipientManager
 148 |     |     ) internal onlyInitializing {
 149 | *   |         __MYieldToOne_init(name, symbol, yieldRecipient, admin, freezeManager, yieldRecipientManager);
 150 | *   |         __Pausable_init(pauser);
 151 |     | 
 152 | *   |         _grantRole(ASSET_CAP_MANAGER_ROLE, assetCapManager);
 153 |     |     }
 154 |     | 
 155 |     |     /* ============ Interactive Functions ============ */
 156 |     | 
 157 |     |     /// @inheritdoc IJMIExtension
 158 |     |     function wrap(address asset, address recipient, uint256 amount) external onlySwapFacility {
 159 |     |         // NOTE: `msg.sender` is always SwapFacility contract.
 160 |     |         //       `ISwapFacility.msgSender()` is used to ensure that the original caller is passed to `_beforeWrap`.
 161 |     |         _wrap(asset, ISwapFacility(msg.sender).msgSender(), recipient, amount);
 162 |     |     }
 163 |     | 
 164 |     |     /// @inheritdoc IJMIExtension
 165 |     |     function replaceAssetWithM(address asset, address recipient, uint256 amount) external onlySwapFacility {
 166 |     |         _replaceAssetWithM(asset, recipient, amount);
 167 |     |     }
 168 |     | 
 169 |     |     /* ============ Admin Controlled Interactive Functions ============ */
 170 |     | 
 171 |     |     /// @inheritdoc IJMIExtension
 172 | *   |     function setAssetCap(address asset, uint256 cap) external onlyRole(ASSET_CAP_MANAGER_ROLE) {
 173 | *   |         _revertIfInvalidAsset(asset);
 174 |     | 
 175 | *   |         JMIExtensionStorageStruct storage $ = _getJMIExtensionStorageLocation();
 176 |     | 
 177 | *   |         if ($.assets[asset].cap == cap) return;
 178 |     | 
 179 |     |         // NOTE: Fetch and store asset decimals only once.
 180 | *   |         if ($.assets[asset].decimals == 0) $.assets[asset].decimals = IERC20(asset).decimals();
 181 |     | 
 182 | *   |         $.assets[asset].cap = cap;
 183 |     | 
 184 | *   |         emit AssetCapSet(asset, cap);
 185 |     |     }
 186 |     | 
 187 |     |     /* ============ View/Pure Functions ============ */
 188 |     | 
 189 |     |     /// @inheritdoc IJMIExtension
 190 |     |     function assetBalanceOf(address asset) public view returns (uint256) {
 191 |     |         return _getJMIExtensionStorageLocation().assets[asset].balance;
 192 |     |     }
 193 |     | 
 194 |     |     /// @inheritdoc IJMIExtension
 195 |     |     function assetCap(address asset) public view returns (uint256) {
 196 |     |         return _getJMIExtensionStorageLocation().assets[asset].cap;
 197 |     |     }
 198 |     | 
 199 |     |     /// @inheritdoc IJMIExtension
 200 |     |     function assetDecimals(address asset) public view returns (uint8) {
 201 |     |         return _getJMIExtensionStorageLocation().assets[asset].decimals;
 202 |     |     }
 203 |     | 
 204 |     |     /// @inheritdoc IJMIExtension
 205 |     |     function totalAssets() public view returns (uint256) {
 206 |     |         return _getJMIExtensionStorageLocation().totalAssets;
 207 |     |     }
 208 |     | 
 209 |     |     /// @inheritdoc IJMIExtension
 210 |     |     function isAllowedAsset(address asset) public view returns (bool) {
 211 |     |         return (asset == mToken) || (assetCap(asset) != 0);
 212 |     |     }
 213 |     | 
 214 |     |     /// @inheritdoc IJMIExtension
 215 |     |     function isAllowedToWrap(address asset, uint256 amount) public view returns (bool) {
 216 |     |         if (amount == 0) return false;
 217 |     | 
 218 |     |         // NOTE: Allow any amount of M (primary asset) to be wrapped into JMI extension token.
 219 |     |         if (asset == mToken) return true;
 220 |     | 
 221 |     |         // NOTE: Check cap for other assets.
 222 |     |         return assetCap(asset) >= (assetBalanceOf(asset) + amount);
 223 |     |     }
 224 |     | 
 225 |     |     /// @inheritdoc IJMIExtension
 226 |     |     function isAllowedToUnwrap(uint256 amount) external view returns (bool) {
 227 |     |         return amount != 0 && _mBacking() >= amount;
 228 |     |     }
 229 |     | 
 230 |     |     /// @inheritdoc IJMIExtension
 231 |     |     function isAllowedToReplaceAssetWithM(address asset, uint256 amount) external view returns (bool) {
 232 |     |         return amount != 0 && assetBalanceOf(asset) >= amount;
 233 |     |     }
 234 |     | 
 235 |     |     /// @inheritdoc IMYieldToOne
 236 |     |     function yield() public view override(IMYieldToOne, MYieldToOne) returns (uint256) {
 237 |     |         uint256 mBalance_ = _mBalanceOf(address(this));
 238 |     |         uint256 mBacking_ = _mBacking();
 239 |     | 
 240 |     |         unchecked {
 241 |     |             return mBalance_ > mBacking_ ? mBalance_ - mBacking_ : 0;
 242 |     |         }
 243 |     |     }
 244 |     | 
 245 |     |     /* ============ Hooks For Internal Interactive Functions ============ */
 246 |     | 
 247 |     |     /**
 248 |     |      * @dev    Hook called before wrapping M into extension tokens.
 249 |     |      * @param  account   The account from which M is deposited.
 250 |     |      * @param  recipient The account receiving the minted extension tokens.
 251 |     |      * @param  amount    The amount of M deposited.
 252 |     |      */
 253 |     |     function _beforeWrap(address account, address recipient, uint256 amount) internal view virtual override {
 254 |     |         _requireNotPaused();
 255 |     | 
 256 |     |         super._beforeWrap(account, recipient, amount);
 257 |     |     }
 258 |     | 
 259 |     |     /**
 260 |     |      * @dev   Hook called before wrapping `asset` into extension's tokens.
 261 |     |      * @param asset     Address of the asset being deposited.
 262 |     |      * @param account   The account initiating the wrap.
 263 |     |      * @param recipient The address that will receive extension tokens.
 264 |     |      * @param amount    The amount of `asset` being deposited.
 265 |     |      */
 266 |     |     function _beforeWrap(address asset, address account, address recipient, uint256 amount) internal view virtual {
 267 |     |         _requireNotPaused();
 268 |     | 
 269 |     |         if (!isAllowedToWrap(asset, amount)) revert AssetCapReached(asset);
 270 |     | 
 271 |     |         super._beforeWrap(account, recipient, amount);
 272 |     |     }
 273 |     | 
 274 |     |     /**
 275 |     |      * @dev   Hook called before unwrapping `amount` of extension tokens for M.
 276 |     |      * @param account The account from which `amount` of tokens is burned.
 277 |     |      * @param amount  The amount of tokens to burn.
 278 |     |      */
 279 |     |     function _beforeUnwrap(address account, uint256 amount) internal view virtual override {
 280 |     |         _requireNotPaused();
 281 |     |         _revertIfInsufficientMBacking(amount);
 282 |     | 
 283 |     |         super._beforeUnwrap(account, amount);
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev   Hook called before transferring extension tokens.
 288 |     |      * @param sender    The address from which the tokens are being transferred.
 289 |     |      * @param recipient The address to which the tokens are being transferred.
 290 |     |      * @param amount    The amount of tokens to transfer.
 291 |     |      */
 292 | *   |     function _beforeTransfer(address sender, address recipient, uint256 amount) internal view override {
 293 | *   |         _requireNotPaused();
 294 |     | 
 295 | *   |         super._beforeTransfer(sender, recipient, amount);
 296 |     |     }
 297 |     | 
 298 |     |     /* ============ Internal Interactive Functions ============ */
 299 |     | 
 300 |     |     function _wrap(address asset, address account, address recipient, uint256 amount) internal virtual {
 301 |     |         _revertIfInvalidAsset(asset);
 302 |     |         _revertIfInvalidRecipient(recipient);
 303 |     |         _revertIfInsufficientAmount(amount);
 304 |     | 
 305 |     |         // NOTE: MYieldToOne's `_beforeWrap` checks that `account` and `recipient` are not frozen.
 306 |     |         _beforeWrap(asset, account, recipient, amount);
 307 |     | 
 308 |     |         uint256 assetBalanceBefore_ = IERC20(asset).balanceOf(address(this));
 309 |     | 
 310 |     |         // NOTE: Transfers asset from SwapFacility to this contract (amount is in asset decimals).
 311 |     |         IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);
 312 |     | 
 313 |     |         // NOTE: Check actual amount received and revert if less than expected (to prevent fee on transfer tokens).
 314 |     |         uint256 amountReceived_ = IERC20(asset).balanceOf(address(this)) - assetBalanceBefore_;
 315 |     |         if (amountReceived_ < amount) revert InsufficientAssetReceived(asset, amount, amountReceived_);
 316 |     | 
 317 |     |         uint256 jmiAmount_ = amount;
 318 |     | 
 319 |     |         if (asset != mToken) {
 320 |     |             // NOTE: Converts to extension amount and reverts in case it truncates to zero.
 321 |     |             jmiAmount_ = _fromAssetToExtensionAmount(asset, amount);
 322 |     |             _revertIfInsufficientAmount(jmiAmount_);
 323 |     | 
 324 |     |             JMIExtensionStorageStruct storage $ = _getJMIExtensionStorageLocation();
 325 |     | 
 326 |     |             // NOTE: Update non-M asset amount backing JMI extension token.
 327 |     |             $.assets[asset].balance += uint240(amount);
 328 |     |             $.totalAssets += jmiAmount_;
 329 |     |         }
 330 |     | 
 331 |     |         _mint(recipient, jmiAmount_);
 332 |     |     }
 333 |     | 
 334 |     |     /*
 335 |     |      * @notice Allows a M holder to swap M for the `asset` token.
 336 |     |      * @dev    `amount` MUST be formatted in the M token's decimals.
 337 |     |      * @param  asset     Address of the asset being replaced.
 338 |     |      * @param  recipient Address that will receive the `asset` token.
 339 |     |      * @param  amount    Amount of M to swap for `asset` token, formatted in M decimals.
 340 |     |      */
 341 |     |     function _replaceAssetWithM(address asset, address recipient, uint256 amount) internal virtual {
 342 |     |         _requireNotPaused();
 343 |     |         _revertIfInvalidAsset(asset);
 344 |     |         _revertIfInvalidRecipient(recipient);
 345 |     |         _revertIfInsufficientAmount(amount);
 346 |     | 
 347 |     |         // NOTE: Converts to asset amount and reverts in case it truncates to zero.
 348 |     |         uint256 assetAmount_ = _fromExtensionToAssetAmount(asset, amount);
 349 |     |         _revertIfInsufficientAmount(assetAmount_);
 350 |     |         _revertIfInsufficientAssetBacking(asset, assetAmount_);
 351 |     | 
 352 |     |         JMIExtensionStorageStruct storage $ = _getJMIExtensionStorageLocation();
 353 |     | 
 354 |     |         // NOTE: Update non-M asset amount backing JMI extension token.
 355 |     |         $.assets[asset].balance -= uint240(assetAmount_);
 356 |     |         $.totalAssets -= amount;
 357 |     | 
 358 |     |         // NOTE: `msg.sender` is always SwapFacility contract.
 359 |     |         // NOTE: The behavior of `IMTokenLike.transferFrom` is known, so its return can be ignored.
 360 |     |         IMTokenLike(mToken).transferFrom(msg.sender, address(this), amount);
 361 |     |         IERC20(asset).safeTransfer(recipient, assetAmount_);
 362 |     | 
 363 |     |         emit AssetReplacedWithM(asset, assetAmount_, recipient, amount);
 364 |     |     }
 365 |     | 
 366 |     |     /* ============ Internal View Functions ============ */
 367 |     | 
 368 |     |     /// @dev Returns the current supply of M backing the extension token.
 369 |     |     function _mBacking() internal view returns (uint256) {
 370 |     |         uint256 totalSupply_ = totalSupply();
 371 |     |         uint256 totalAssets_ = totalAssets();
 372 |     | 
 373 |     |         unchecked {
 374 |     |             return totalSupply_ > totalAssets_ ? totalSupply_ - totalAssets_ : 0;
 375 |     |         }
 376 |     |     }
 377 |     | 
 378 |     |     /**
 379 |     |      * @dev   Reverts if `asset` is address(0) or M token.
 380 |     |      *       `wrap(address recipient, uint256 amount)` MUST be used to wrap M.
 381 |     |      * @param asset Address of an asset.
 382 |     |      */
 383 | *   |     function _revertIfInvalidAsset(address asset) internal view {
 384 | *   |         if (asset == address(0) || asset == mToken) revert InvalidAsset(asset);
 385 |     |     }
 386 |     | 
 387 |     |     /**
 388 |     |      * @dev   Reverts if there is not enough M backing to unwrap the requested amount.
 389 |     |      * @param amount Amount of M to unwrap.
 390 |     |      */
 391 |     |     function _revertIfInsufficientMBacking(uint256 amount) internal view {
 392 |     |         uint256 mBacking_ = _mBacking();
 393 |     |         if (amount > mBacking_) revert InsufficientMBacking(amount, mBacking_);
 394 |     |     }
 395 |     | 
 396 |     |     /**
 397 |     |      * @dev   Reverts if `amount` of `asset` is greater than the available balance held by the extension.
 398 |     |      * @param asset  Address of an asset.
 399 |     |      * @param amount Amount of `asset` to check.
 400 |     |      */
 401 |     |     function _revertIfInsufficientAssetBacking(address asset, uint256 amount) internal view {
 402 |     |         uint256 assetBacking_ = assetBalanceOf(asset);
 403 |     |         if (amount > assetBacking_) revert InsufficientAssetBacking(asset, amount, assetBacking_);
 404 |     |     }
 405 |     | 
 406 |     |     /**
 407 |     |      * @dev    Converts `amount` from asset decimals to extension decimals.
 408 |     |      * @param  asset  Address of an asset.
 409 |     |      * @param  amount Amount in `asset` decimals.
 410 |     |      * @return Amount in extension decimals.
 411 |     |      */
 412 |     |     function _fromAssetToExtensionAmount(address asset, uint256 amount) internal view returns (uint256) {
 413 |     |         return _convertAmounts(assetDecimals(asset), M_DECIMALS, amount);
 414 |     |     }
 415 |     | 
 416 |     |     /**
 417 |     |      * @dev    Converts `amount` from extension decimals to asset decimals.
 418 |     |      * @param  asset  Address of an asset.
 419 |     |      * @param  amount Amount in extension decimals.
 420 |     |      * @return Amount in `asset` decimals.
 421 |     |      */
 422 |     |     function _fromExtensionToAssetAmount(address asset, uint256 amount) internal view returns (uint256) {
 423 |     |         return _convertAmounts(M_DECIMALS, assetDecimals(asset), amount);
 424 |     |     }
 425 |     | 
 426 |     |     /* ============ Internal Pure Functions ============ */
 427 |     | 
 428 |     |     /**
 429 |     |      * @dev    Converts `amount` from `fromDecimals` to `toDecimals`.
 430 |     |      * @param  fromDecimals The decimals of the input amount.
 431 |     |      * @param  toDecimals   The decimals of the output amount.
 432 |     |      * @param  amount       The amount to convert.
 433 |     |      * @return The converted amount.
 434 |     |      */
 435 |     |     function _convertAmounts(uint8 fromDecimals, uint8 toDecimals, uint256 amount) internal pure returns (uint256) {
 436 |     |         if (fromDecimals == toDecimals) return amount;
 437 |     | 
 438 |     |         return
 439 |     |             fromDecimals > toDecimals
 440 |     |                 ? amount / (10 ** (fromDecimals - toDecimals))
 441 |     |                 : amount * (10 ** (toDecimals - fromDecimals));
 442 |     |     }
 443 |     | }
 444 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/projects/yieldToAllWithFee/MYieldFee.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | import { AccessControlUpgradeable } from "../../../lib/common/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol";
   6 |     | 
   7 |     | import { IERC20 } from "../../../lib/common/src/interfaces/IERC20.sol";
   8 |     | 
   9 |     | import { ContinuousIndexingMath } from "../../../lib/common/src/libs/ContinuousIndexingMath.sol";
  10 |     | import { UIntMath } from "../../../lib/common/src/libs/UIntMath.sol";
  11 |     | 
  12 |     | import { IndexingMath } from "../../libs/IndexingMath.sol";
  13 |     | 
  14 |     | import { IMExtension } from "../../interfaces/IMExtension.sol";
  15 |     | import { IMTokenLike } from "../../interfaces/IMTokenLike.sol";
  16 |     | 
  17 |     | import { IMYieldFee } from "./interfaces/IMYieldFee.sol";
  18 |     | import { IContinuousIndexing } from "./interfaces/IContinuousIndexing.sol";
  19 |     | 
  20 |     | import { MExtension } from "../../MExtension.sol";
  21 |     | 
  22 |     | abstract contract MYieldFeeStorageLayout {
  23 |     |     /// @custom:storage-location erc7201:M0.storage.MYieldFee
  24 |     |     struct MYieldFeeStorageStruct {
  25 |     |         // NOTE: Slot 1
  26 |     |         uint256 totalSupply;
  27 |     |         // NOTE: Slot 2
  28 |     |         uint112 totalPrincipal;
  29 |     |         uint128 latestIndex;
  30 |     |         uint16 feeRate;
  31 |     |         // NOTE: Slot 3
  32 |     |         address feeRecipient;
  33 |     |         uint40 latestUpdateTimestamp;
  34 |     |         uint32 latestRate;
  35 |     |         bool isEarningEnabled;
  36 |     |         // NOTE: Slot 4
  37 |     |         mapping(address account => uint256 balance) balanceOf;
  38 |     |         // NOTE: Slot 5
  39 |     |         mapping(address account => uint112 principal) principalOf;
  40 |     |         // NOTE: Slot 6
  41 |     |         mapping(address account => address claimRecipient) claimRecipients;
  42 |     |     }
  43 |     | 
  44 |     |     // keccak256(abi.encode(uint256(keccak256("M0.storage.MYieldFee")) - 1)) & ~bytes32(uint256(0xff))
  45 |     |     bytes32 private constant _M_YIELD_FEE_STORAGE_LOCATION =
  46 |     |         0x9d728c135b5b2cd0ace61885d69c4f72215f10f82e77822fb7c6bf472237dd00;
  47 |     | 
  48 | *   |     function _getMYieldFeeStorageLocation() internal pure returns (MYieldFeeStorageStruct storage $) {
  49 |     |         assembly {
  50 | *   |             $.slot := _M_YIELD_FEE_STORAGE_LOCATION
  51 |     |         }
  52 |     |     }
  53 |     | }
  54 |     | 
  55 |     | /**
  56 |     |  * @title MYieldFee
  57 |     |  * @notice Upgradeable ERC20 Token contract for wrapping M into a non-rebasing token.
  58 |     |  *         Extended to take a fee from the yield generated by M.
  59 |     |  * @dev    All holders of this ERC20 token are earners.
  60 |     |  * @author M0 Labs
  61 |     |  */
  62 |     | contract MYieldFee is IContinuousIndexing, IMYieldFee, AccessControlUpgradeable, MYieldFeeStorageLayout, MExtension {
  63 |     |     /* ============ Variables ============ */
  64 |     | 
  65 |     |     /// @inheritdoc IMYieldFee
  66 | *   |     uint16 public constant ONE_HUNDRED_PERCENT = 10_000;
  67 |     | 
  68 |     |     /// @inheritdoc IMYieldFee
  69 | *   |     bytes32 public constant FEE_MANAGER_ROLE = keccak256("FEE_MANAGER_ROLE");
  70 |     | 
  71 |     |     /// @inheritdoc IMYieldFee
  72 | *   |     bytes32 public constant CLAIM_RECIPIENT_MANAGER_ROLE = keccak256("CLAIM_RECIPIENT_MANAGER_ROLE");
  73 |     | 
  74 |     |     /* ============ Constructor ============ */
  75 |     | 
  76 |     |     /**
  77 |     |      * @custom:oz-upgrades-unsafe-allow constructor
  78 |     |      * @notice Constructs MYieldFee Implementation contract
  79 |     |      * @dev    Sets immutable storage.
  80 |     |      * @param  mToken       The address of $M token.
  81 |     |      * @param  swapFacility The address of Swap Facility.
  82 |     |      */
  83 | *   |     constructor(address mToken, address swapFacility) MExtension(mToken, swapFacility) {}
  84 |     | 
  85 |     |     /* ============ Initializer ============ */
  86 |     | 
  87 |     |     /**
  88 |     |      * @notice Initializes the generic M Yield Fee extension token.
  89 |     |      * @param name                  The name of the token (e.g. "M Yield Fee").
  90 |     |      * @param symbol                The symbol of the token (e.g. "MYF").
  91 |     |      * @param feeRate_              The fee rate, in bps, that will be taken from the yield generated by M.
  92 |     |      * @param feeRecipient_         The address of the recipient of the yield fee.
  93 |     |      * @param admin                 The address administrating the M extension. Can grant and revoke roles.
  94 |     |      * @param feeManager            The address managing the fee rate and recipient.
  95 |     |      * @param claimRecipientManager The address managing claim recipients for accounts.
  96 |     |      */
  97 | *   |     function initialize(
  98 |     |         string memory name,
  99 |     |         string memory symbol,
 100 |     |         uint16 feeRate_,
 101 |     |         address feeRecipient_,
 102 |     |         address admin,
 103 |     |         address feeManager,
 104 |     |         address claimRecipientManager
 105 |     |     ) public virtual initializer {
 106 | *   |         if (admin == address(0)) revert ZeroAdmin();
 107 | *   |         if (feeManager == address(0)) revert ZeroFeeManager();
 108 | *   |         if (claimRecipientManager == address(0)) revert ZeroClaimRecipientManager();
 109 |     | 
 110 | *   |         __MExtension_init(name, symbol);
 111 |     | 
 112 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, admin);
 113 | *   |         _grantRole(FEE_MANAGER_ROLE, feeManager);
 114 | *   |         _grantRole(CLAIM_RECIPIENT_MANAGER_ROLE, claimRecipientManager);
 115 |     | 
 116 | *   |         _setFeeRate(feeRate_);
 117 | *   |         _setFeeRecipient(feeRecipient_);
 118 |     | 
 119 | *   |         _getMYieldFeeStorageLocation().latestIndex = ContinuousIndexingMath.EXP_SCALED_ONE;
 120 |     |     }
 121 |     | 
 122 |     |     /* ============ Interactive Functions ============ */
 123 |     | 
 124 |     |     /// @inheritdoc IMYieldFee
 125 | *   |     function claimYieldFor(address account) public returns (uint256) {
 126 | *   |         if (account == address(0)) revert ZeroAccount();
 127 |     | 
 128 | *   |         uint256 yield_ = accruedYieldOf(account);
 129 |     | 
 130 | *   |         if (yield_ == 0) return 0;
 131 |     | 
 132 |     |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 133 |     | 
 134 |     |         // NOTE: No change in principal, only the balance is updated to include the newly claimed yield.
 135 |     |         unchecked {
 136 |     |             $.balanceOf[account] += yield_;
 137 |     |             $.totalSupply += yield_;
 138 |     |         }
 139 |     | 
 140 |     |         address claimRecipient_ = claimRecipientFor(account);
 141 |     | 
 142 |     |         // Emit the appropriate `YieldClaimed` and `Transfer` events, depending on the claim override recipient
 143 |     |         emit YieldClaimed(account, claimRecipient_, yield_);
 144 |     |         emit Transfer(address(0), claimRecipient_, yield_);
 145 |     | 
 146 |     |         if (claimRecipient_ == account) return yield_;
 147 |     | 
 148 |     |         // Distribute the yield to the claim recipient.
 149 |     |         _update(account, claimRecipient_, yield_);
 150 |     | 
 151 |     |         return yield_;
 152 |     |     }
 153 |     | 
 154 |     |     /// @inheritdoc IMYieldFee
 155 | *   |     function claimFee() public returns (uint256) {
 156 | *   |         uint256 yieldFee_ = totalAccruedFee();
 157 |     | 
 158 | *   |         if (yieldFee_ == 0) return 0;
 159 |     | 
 160 |     |         address recipient_ = _getMYieldFeeStorageLocation().feeRecipient;
 161 |     | 
 162 |     |         emit FeeClaimed(msg.sender, recipient_, yieldFee_);
 163 |     | 
 164 |     |         // NOTE: Round up to allow claiming the whole amount of yield fee.
 165 |     |         _mint(recipient_, yieldFee_, IndexingMath.getPrincipalAmountRoundedUp(yieldFee_, currentIndex()));
 166 |     | 
 167 |     |         return yieldFee_;
 168 |     |     }
 169 |     | 
 170 |     |     /// @inheritdoc IMExtension
 171 | *   |     function enableEarning() external override {
 172 | *   |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 173 |     | 
 174 | *   |         if ($.isEarningEnabled) revert EarningIsEnabled();
 175 |     | 
 176 | *   |         $.isEarningEnabled = true;
 177 |     | 
 178 |     |         // NOTE: update the index to store the latest state, current index won't accrue since `latestRate` is 0.
 179 | *   |         emit EarningEnabled(updateIndex());
 180 |     | 
 181 | *   |         IMTokenLike(mToken).startEarning();
 182 |     |     }
 183 |     | 
 184 |     |     /// @inheritdoc IMExtension
 185 | *   |     function disableEarning() external override {
 186 | *   |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 187 |     | 
 188 | *   |         if (!$.isEarningEnabled) revert EarningIsDisabled();
 189 |     | 
 190 |     |         // NOTE: update the index to store the latest state.
 191 | *   |         emit EarningDisabled(updateIndex());
 192 |     | 
 193 |     |         // NOTE: disable earning by resetting values to their defaults.
 194 | *   |         delete $.isEarningEnabled;
 195 | *   |         delete $.latestRate;
 196 |     | 
 197 | *   |         IMTokenLike(mToken).stopEarning(address(this));
 198 |     |     }
 199 |     | 
 200 |     |     /// @inheritdoc IContinuousIndexing
 201 | *   |     function updateIndex() public virtual returns (uint128 currentIndex_) {
 202 | *   |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 203 |     | 
 204 |     |         // NOTE: return early if earning is disabled, no need to update the index.
 205 | *   |         if (!$.isEarningEnabled) return $.latestIndex;
 206 |     | 
 207 |     |         // NOTE: Read the current M token rate adjusted by fee rate split.
 208 | *   |         uint32 rate_ = earnerRate();
 209 | *   |         uint40 latestAccrualTimestamp_ = _latestEarnerRateAccrualTimestamp();
 210 |     | 
 211 |     |         // NOTE: Return early if the index has already been updated in the current block and the rate has not changed.
 212 | *   |         if ($.latestUpdateTimestamp == latestAccrualTimestamp_ && $.latestRate == rate_) return $.latestIndex;
 213 |     | 
 214 |     |         // NOTE: `currentIndex()` depends on `_latestRate`, so only update it after this.
 215 | *   |         $.latestIndex = currentIndex_ = currentIndex();
 216 | *   |         $.latestRate = rate_;
 217 | *   |         $.latestUpdateTimestamp = latestAccrualTimestamp_;
 218 |     | 
 219 | *   |         emit IndexUpdated(currentIndex_, rate_);
 220 |     |     }
 221 |     | 
 222 |     |     /// @inheritdoc IMYieldFee
 223 | *   |     function setFeeRate(uint16 feeRate_) external onlyRole(FEE_MANAGER_ROLE) {
 224 | *   |         _setFeeRate(feeRate_);
 225 |     | 
 226 |     |         // NOTE: Update the index to store the new adjusted rate.
 227 | *   |         if (isEarningEnabled()) updateIndex();
 228 |     |     }
 229 |     | 
 230 |     |     /// @inheritdoc IMYieldFee
 231 | *   |     function setFeeRecipient(address feeRecipient_) external onlyRole(FEE_MANAGER_ROLE) {
 232 |     |         // Claim fee for the previous fee recipient.
 233 | *   |         claimFee();
 234 |     | 
 235 | *   |         _setFeeRecipient(feeRecipient_);
 236 |     |     }
 237 |     | 
 238 |     |     /// @inheritdoc IMYieldFee
 239 | *   |     function setClaimRecipient(
 240 |     |         address account,
 241 |     |         address claimRecipient
 242 | *   |     ) external onlyRole(CLAIM_RECIPIENT_MANAGER_ROLE) {
 243 | *   |         if (account == address(0)) revert ZeroAccount();
 244 | *   |         if (claimRecipient == address(0)) revert ZeroClaimRecipient();
 245 |     | 
 246 | *   |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 247 |     | 
 248 | *   |         if ($.claimRecipients[account] == claimRecipient) return;
 249 |     | 
 250 |     |         // NOTE: Optionally consider not claiming yield for the previous claim recipient.
 251 | *   |         claimYieldFor(account);
 252 |     | 
 253 | *   |         $.claimRecipients[account] = claimRecipient;
 254 |     | 
 255 | *   |         emit ClaimRecipientSet(account, claimRecipient);
 256 |     |     }
 257 |     | 
 258 |     |     /* ============ External/Public view functions ============ */
 259 |     | 
 260 |     |     /// @inheritdoc IMYieldFee
 261 | *   |     function accruedYieldOf(address account) public view returns (uint256) {
 262 | *   |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 263 | *   |         return _getAccruedYield($.balanceOf[account], $.principalOf[account], currentIndex());
 264 |     |     }
 265 |     | 
 266 |     |     /// @inheritdoc IERC20
 267 | *   |     function balanceOf(address account) public view override returns (uint256) {
 268 | *   |         return _getMYieldFeeStorageLocation().balanceOf[account];
 269 |     |     }
 270 |     | 
 271 |     |     /// @inheritdoc IMYieldFee
 272 |     |     function balanceWithYieldOf(address account) external view returns (uint256) {
 273 |     |         unchecked {
 274 |     |             return balanceOf(account) + accruedYieldOf(account);
 275 |     |         }
 276 |     |     }
 277 |     | 
 278 |     |     /// @inheritdoc IMYieldFee
 279 |     |     function principalOf(address account) public view returns (uint112) {
 280 |     |         return _getMYieldFeeStorageLocation().principalOf[account];
 281 |     |     }
 282 |     | 
 283 |     |     /// @inheritdoc IContinuousIndexing
 284 | *   |     function currentIndex() public view virtual override(IContinuousIndexing, MExtension) returns (uint128) {
 285 | *   |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 286 |     | 
 287 | *   |         if (!$.isEarningEnabled) return $.latestIndex;
 288 |     | 
 289 |     |         // NOTE: Safe to use unchecked here, since `block.timestamp` is always greater than `latestUpdateTimestamp`.
 290 |     |         unchecked {
 291 | *   |             return
 292 |     |                 // NOTE: Cap the index to `type(uint128).max` to prevent overflow in present value math.
 293 | *   |                 UIntMath.bound128(
 294 | *   |                     ContinuousIndexingMath.multiplyIndicesDown(
 295 | *   |                         $.latestIndex,
 296 | *   |                         ContinuousIndexingMath.getContinuousIndex(
 297 | *   |                             ContinuousIndexingMath.convertFromBasisPoints($.latestRate),
 298 | *   |                             uint32(_latestEarnerRateAccrualTimestamp() - $.latestUpdateTimestamp)
 299 |     |                         )
 300 |     |                     )
 301 |     |                 );
 302 |     |         }
 303 |     |     }
 304 |     | 
 305 |     |     /// @inheritdoc IMYieldFee
 306 | *   |     function earnerRate() public view virtual returns (uint32) {
 307 | *   |         return
 308 | *   |             isEarningEnabled()
 309 | *   |                 ? UIntMath.safe32(
 310 | *   |                     (uint256(ONE_HUNDRED_PERCENT - feeRate()) * _currentEarnerRate()) / ONE_HUNDRED_PERCENT
 311 |     |                 )
 312 |     |                 : 0;
 313 |     |     }
 314 |     | 
 315 |     |     /// @inheritdoc IMExtension
 316 | *   |     function isEarningEnabled() public view override returns (bool) {
 317 | *   |         return _getMYieldFeeStorageLocation().isEarningEnabled;
 318 |     |     }
 319 |     | 
 320 |     |     /// @inheritdoc IContinuousIndexing
 321 | *   |     function latestIndex() public view returns (uint128) {
 322 | *   |         return _getMYieldFeeStorageLocation().latestIndex;
 323 |     |     }
 324 |     | 
 325 |     |     /// @inheritdoc IContinuousIndexing
 326 | *   |     function latestRate() public view returns (uint32) {
 327 | *   |         return _getMYieldFeeStorageLocation().latestRate;
 328 |     |     }
 329 |     | 
 330 |     |     /// @inheritdoc IContinuousIndexing
 331 |     |     function latestUpdateTimestamp() public view returns (uint40) {
 332 |     |         return _getMYieldFeeStorageLocation().latestUpdateTimestamp;
 333 |     |     }
 334 |     | 
 335 |     |     /// @inheritdoc IMYieldFee
 336 | *   |     function projectedTotalSupply() public view returns (uint256) {
 337 | *   |         return IndexingMath.getPresentAmountRoundedUp(_getMYieldFeeStorageLocation().totalPrincipal, currentIndex());
 338 |     |     }
 339 |     | 
 340 |     |     /// @inheritdoc IMYieldFee
 341 | *   |     function totalAccruedYield() public view returns (uint256) {
 342 | *   |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 343 | *   |         return _getAccruedYield($.totalSupply, $.totalPrincipal, currentIndex());
 344 |     |     }
 345 |     | 
 346 |     |     /// @inheritdoc IMYieldFee
 347 | *   |     function totalAccruedFee() public view returns (uint256) {
 348 | *   |         uint256 mBalance_ = _mBalanceOf(address(this));
 349 | *   |         uint256 projectedTotalSupply_ = projectedTotalSupply();
 350 |     | 
 351 |     |         unchecked {
 352 | *   |             return mBalance_ > projectedTotalSupply_ ? mBalance_ - projectedTotalSupply_ : 0;
 353 |     |         }
 354 |     |     }
 355 |     | 
 356 |     |     /// @inheritdoc IMYieldFee
 357 |     |     function totalPrincipal() public view returns (uint112) {
 358 |     |         return _getMYieldFeeStorageLocation().totalPrincipal;
 359 |     |     }
 360 |     | 
 361 |     |     /// @inheritdoc IERC20
 362 |     |     function totalSupply() public view returns (uint256) {
 363 |     |         return _getMYieldFeeStorageLocation().totalSupply;
 364 |     |     }
 365 |     | 
 366 |     |     /// @inheritdoc IMYieldFee
 367 | *   |     function feeRate() public view returns (uint16) {
 368 | *   |         return _getMYieldFeeStorageLocation().feeRate;
 369 |     |     }
 370 |     | 
 371 |     |     /// @inheritdoc IMYieldFee
 372 |     |     function feeRecipient() public view returns (address) {
 373 |     |         return _getMYieldFeeStorageLocation().feeRecipient;
 374 |     |     }
 375 |     | 
 376 |     |     /// @inheritdoc IMYieldFee
 377 |     |     function claimRecipientFor(address account) public view returns (address) {
 378 |     |         address recipient_ = _getMYieldFeeStorageLocation().claimRecipients[account];
 379 |     | 
 380 |     |         // If no claim recipient is set, return the account itself.
 381 |     |         return recipient_ == address(0) ? account : recipient_;
 382 |     |     }
 383 |     | 
 384 |     |     /* ============ Internal Interactive Functions ============ */
 385 |     | 
 386 |     |     /**
 387 |     |      * @dev   Mints `amount` tokens to `recipient`.
 388 |     |      * @param recipient The address that will receive tokens.
 389 |     |      * @param amount    The amount of tokens to mint.
 390 |     |      */
 391 |     |     function _mint(address recipient, uint256 amount) internal override {
 392 |     |         _mint(recipient, amount, IndexingMath.getPrincipalAmountRoundedDown(amount, currentIndex()));
 393 |     |     }
 394 |     | 
 395 |     |     /**
 396 |     |      * @dev   Mints `amount` tokens to `recipient` with a specified principal.
 397 |     |      * @param recipient The address that will receive tokens.
 398 |     |      * @param amount    The amount of tokens to mint.
 399 |     |      * @param principal The principal amount to be associated with the minted tokens.
 400 |     |      */
 401 |     |     function _mint(address recipient, uint256 amount, uint112 principal) internal {
 402 |     |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 403 |     | 
 404 |     |         // NOTE: Can be `unchecked` because the max amount of  M is never greater than `type(uint240).max`.
 405 |     |         //       Can be `unchecked` because UIntMath.safe112 is used for principal addition safety for `totalPrincipal`
 406 |     |         unchecked {
 407 |     |             $.balanceOf[recipient] += amount;
 408 |     |             $.totalSupply += amount;
 409 |     | 
 410 |     |             $.totalPrincipal = UIntMath.safe112(uint256($.totalPrincipal) + principal);
 411 |     |             // No need for `UIntMath.safe112`, `principalOf[recipient]` cannot be greater than `totalPrincipal`.
 412 |     |             $.principalOf[recipient] += principal;
 413 |     |         }
 414 |     | 
 415 |     |         emit Transfer(address(0), recipient, amount);
 416 |     |     }
 417 |     | 
 418 |     |     /**
 419 |     |      * @dev   Burns `amount` tokens from `account`.
 420 |     |      * @param account The address whose account balance will be decremented.
 421 |     |      * @param amount  The present amount of tokens to burn.
 422 |     |      */
 423 |     |     function _burn(address account, uint256 amount) internal override {
 424 |     |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 425 |     | 
 426 |     |         // Slightly overestimate the principal amount to be burned and use safe value to avoid underflow in unchecked block
 427 |     |         uint112 fromPrincipal_ = $.principalOf[account];
 428 |     |         uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);
 429 |     | 
 430 |     |         // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` is used.
 431 |     |         //       Can be `unchecked` because safety adjustment to `principal_` is applied above, and
 432 |     |         //       `principalOf[account]` cannot be greater than `totalPrincipal`.
 433 |     |         unchecked {
 434 |     |             $.balanceOf[account] -= amount;
 435 |     |             $.totalSupply -= amount;
 436 |     | 
 437 |     |             $.principalOf[account] = fromPrincipal_ - principal_;
 438 |     |             $.totalPrincipal -= principal_;
 439 |     |         }
 440 |     | 
 441 |     |         emit Transfer(account, address(0), amount);
 442 |     |     }
 443 |     | 
 444 |     |     /**
 445 |     |      * @dev   Internal balance update function called on transfer.
 446 |     |      * @param sender    The sender's address.
 447 |     |      * @param recipient The recipient's address.
 448 |     |      * @param amount    The amount to be transferred.
 449 |     |      */
 450 |     |     function _update(address sender, address recipient, uint256 amount) internal override {
 451 |     |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 452 |     | 
 453 |     |         // Slightly overestimate the principal amount to be moved on transfer
 454 |     |         uint112 fromPrincipal_ = $.principalOf[sender];
 455 |     |         uint112 principal_ = IndexingMath.getSafePrincipalAmountRoundedUp(amount, currentIndex(), fromPrincipal_);
 456 |     | 
 457 |     |         // NOTE: Can be `unchecked` because we check for insufficient sender balance above.
 458 |     |         //       Can be `unchecked` because safety adjustment to `principal_` is applied above, and
 459 |     |         unchecked {
 460 |     |             $.balanceOf[sender] -= amount;
 461 |     |             $.balanceOf[recipient] += amount;
 462 |     | 
 463 |     |             $.principalOf[sender] = fromPrincipal_ - principal_;
 464 |     |             $.principalOf[recipient] += principal_;
 465 |     |         }
 466 |     |     }
 467 |     | 
 468 |     |     /**
 469 |     |      * @notice Sets the yield fee rate, in bps, that will be taken from the yield generated by M.
 470 |     |      * @dev    Reverts if the yield fee rate is greater than ONE_HUNDRED_PERCENT.
 471 |     |      * @dev    Returns early if the yield fee rate is the same as the current one.
 472 |     |      * @param  feeRate_ The yield fee rate.
 473 |     |      */
 474 | *   |     function _setFeeRate(uint16 feeRate_) internal {
 475 | *   |         if (feeRate_ > ONE_HUNDRED_PERCENT) revert FeeRateTooHigh(feeRate_, ONE_HUNDRED_PERCENT);
 476 |     | 
 477 | *   |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 478 |     | 
 479 | *   |         if ($.feeRate == feeRate_) return;
 480 |     | 
 481 | *   |         $.feeRate = feeRate_;
 482 |     | 
 483 | *   |         emit FeeRateSet(feeRate_);
 484 |     |     }
 485 |     | 
 486 |     |     /**
 487 |     |      * @notice Sets the yield fee recipient that will receive part of the yield generated by M.
 488 |     |      * @dev    Reverts if the yield fee recipient is address zero.
 489 |     |      * @dev    Returns early if the yield fee recipient is the same as the current one.
 490 |     |      * @param  feeRecipient_ The yield fee recipient address.
 491 |     |      */
 492 | *   |     function _setFeeRecipient(address feeRecipient_) internal {
 493 | *   |         if (feeRecipient_ == address(0)) revert ZeroFeeRecipient();
 494 |     | 
 495 | *   |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 496 |     | 
 497 | *   |         if ($.feeRecipient == feeRecipient_) return;
 498 |     | 
 499 | *   |         $.feeRecipient = feeRecipient_;
 500 |     | 
 501 | *   |         emit FeeRecipientSet(feeRecipient_);
 502 |     |     }
 503 |     | 
 504 |     |     /* ============ Internal View/Pure Functions ============ */
 505 |     | 
 506 |     |     /**
 507 |     |      * @dev   Returns the timestamp when the earner rate was last accrued to accounts.
 508 |     |      *        For L1: returns the current `block.timestamp` as the rate accrues continuously.
 509 |     |      *        For L2: returns the `latestUpdateTimestamp` from the M token when the index was propagated from L1.
 510 |     |      *        Can be overridden by the inheriting contract (for EVM L2 contracts with index propagation).
 511 |     |      *        MUST return the current block timestamp for an M extension token deployed on the mainnet.
 512 |     |      *        MUST return spoke M token's `latestUpdateTimestamp` for an M extension token deployed on a spoke chain.
 513 |     |      * @return The current block timestamp.
 514 |     |      */
 515 | *   |     function _latestEarnerRateAccrualTimestamp() internal view virtual returns (uint40) {
 516 | *   |         return uint40(block.timestamp);
 517 |     |     }
 518 |     | 
 519 |     |     /**
 520 |     |      * @dev    Returns the current earner rate.
 521 |     |      *         Needs to be overridden by the inheriting contract.
 522 |     |      *         MUST return M token's earner rate for an M extension token deployed on the mainnet.
 523 |     |      *         MUST return a rate oracle's earner rate for an M extension token deployed on a spoke chain.
 524 |     |      * @return The current earner rate.
 525 |     |      */
 526 | *   |     function _currentEarnerRate() internal view virtual returns (uint32) {
 527 |     |         // NOTE: The behavior of M is known, so we can safely retrieve the earner rate.
 528 | *   |         return IMTokenLike(mToken).earnerRate();
 529 |     |     }
 530 |     | 
 531 |     |     /**
 532 |     |      * @dev    Compute the yield given a balance, principal and index.
 533 |     |      * @param  balance   The current balance of the account.
 534 |     |      * @param  principal The principal of the account.
 535 |     |      * @param  index     The current index.
 536 |     |      * @return The yield accrued since the last claim.
 537 |     |      */
 538 | *   |     function _getAccruedYield(uint256 balance, uint112 principal, uint128 index) internal pure returns (uint256) {
 539 | *   |         uint256 balanceWithYield_ = IndexingMath.getPresentAmountRoundedDown(principal, index);
 540 |     |         unchecked {
 541 | *   |             return balanceWithYield_ > balance ? balanceWithYield_ - balance : 0;
 542 |     |         }
 543 |     |     }
 544 |     | }
 545 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/projects/yieldToAllWithFee/interfaces/IContinuousIndexing.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | 
  3 |     | pragma solidity 0.8.26;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  Continuous Indexing Interface.
  7 |     |  * @author M0 Labs
  8 |     |  */
  9 |     | interface IContinuousIndexing {
 10 |     |     /* ============ Events ============ */
 11 |     | 
 12 |     |     /**
 13 |     |      * @notice Emitted when the index is updated.
 14 |     |      * @param  index The new index.
 15 |     |      * @param  rate  The current rate.
 16 |     |      */
 17 |     |     event IndexUpdated(uint128 indexed index, uint32 indexed rate);
 18 |     | 
 19 |     |     /* ============ Interactive Functions ============ */
 20 |     | 
 21 |     |     /**
 22 |     |      * @notice Updates the latest index and latest accrual time in storage.
 23 |     |      * @return index The new stored index for computing present amounts from principal amounts.
 24 |     |      */
 25 |     |     function updateIndex() external returns (uint128);
 26 |     | 
 27 |     |     /* ============ View/Pure Functions ============ */
 28 |     | 
 29 |     |     /// @notice The current index that would be written to storage if `updateIndex` is called.
 30 |     |     function currentIndex() external view returns (uint128);
 31 |     | 
 32 |     |     /// @notice The latest updated index.
 33 |     |     function latestIndex() external view returns (uint128);
 34 |     | 
 35 |     |     /// @notice The latest timestamp when the index was updated.
 36 |     |     function latestUpdateTimestamp() external view returns (uint40);
 37 |     | 
 38 |     |     /// @notice The latest rate when the index was updated.
 39 |     |     function latestRate() external view returns (uint32);
 40 |     | }
 41 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/projects/yieldToAllWithFee/interfaces/IMSpokeYieldFee.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | 
  3 |     | pragma solidity 0.8.26;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  M Spoke Yield Fee interface.
  7 |     |  * @author M0 Labs
  8 |     |  */
  9 |     | interface IMSpokeYieldFee {
 10 |     |     /* ============ Custom Errors ============ */
 11 |     | 
 12 |     |     /// @notice Emitted in constructor if Rate Oracle is 0x0.
 13 |     |     error ZeroRateOracle();
 14 |     | 
 15 |     |     /* ============ View/Pure Functions ============ */
 16 |     | 
 17 |     |     /// @notice Returns the address of the Rate Oracle.
 18 |     |     function rateOracle() external view returns (address);
 19 |     | }
 20 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/projects/yieldToAllWithFee/interfaces/IMYieldFee.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | /**
   6 |     |  * @title  Interface for M Yield Fee.
   7 |     |  * @author M0 Labs
   8 |     |  */
   9 |     | interface IMYieldFee {
  10 |     |     /* ============ Events ============ */
  11 |     | 
  12 |     |     /**
  13 |     |      * @notice Emitted when an account's yield is claimed.
  14 |     |      * @param  claimer   The address that claimed the yield fee.
  15 |     |      * @param  recipient The address of the recipient.
  16 |     |      * @param  yield     The amount of M yield claimed.
  17 |     |      */
  18 |     |     event YieldClaimed(address indexed claimer, address indexed recipient, uint256 yield);
  19 |     | 
  20 |     |     /**
  21 |     |      * @notice Emitted when the yield fee is claimed.
  22 |     |      * @param  claimer   The address that claimed the yield fee.
  23 |     |      * @param  recipient The address of the recipient.
  24 |     |      * @param  fee  The amount of yield fee claimed.
  25 |     |      */
  26 |     |     event FeeClaimed(address indexed claimer, address indexed recipient, uint256 fee);
  27 |     | 
  28 |     |     /**
  29 |     |      * @notice Emitted when the fee rate is set.
  30 |     |      * @param  feeRate The fee rate in bps.
  31 |     |      */
  32 |     |     event FeeRateSet(uint16 feeRate);
  33 |     | 
  34 |     |     /**
  35 |     |      * @notice Emitted when the yield fee recipient address is set.
  36 |     |      * @param  feeRecipient The yield fee recipient address.
  37 |     |      */
  38 |     |     event FeeRecipientSet(address indexed feeRecipient);
  39 |     | 
  40 |     |     /**
  41 |     |      * @notice Emitted when the claim recipient is set.
  42 |     |      * @param account The address of the account that accrued yield.
  43 |     |      * @param claimRecipient The address of the claim recipient.
  44 |     |      */
  45 |     |     event ClaimRecipientSet(address indexed account, address indexed claimRecipient);
  46 |     | 
  47 |     |     /* ============ Custom Errors ============ */
  48 |     | 
  49 |     |     /**
  50 |     |      * @notice Emitted when the yield fee rate provided exceeds the max yield fee rate.
  51 |     |      * @param  feeRate The yield fee rate provided.
  52 |     |      * @param  maxFeeRate The max yield fee rate settable.
  53 |     |      */
  54 |     |     error FeeRateTooHigh(uint16 feeRate, uint16 maxFeeRate);
  55 |     | 
  56 |     |     /// @notice Emitted in constructor if the admin is 0x0.
  57 |     |     error ZeroAdmin();
  58 |     | 
  59 |     |     /// @notice Emitted in constructor if the yield fee manager is 0x0.
  60 |     |     error ZeroFeeManager();
  61 |     | 
  62 |     |     /// @notice Emitted in constructor if the claim recipient manager is 0x0.
  63 |     |     error ZeroClaimRecipientManager();
  64 |     | 
  65 |     |     /// @notice Emitted if the yield fee recipient is 0x0.
  66 |     |     error ZeroFeeRecipient();
  67 |     | 
  68 |     |     /// @notice Emitted if the claim recipient is 0x0.
  69 |     |     error ZeroClaimRecipient();
  70 |     | 
  71 |     |     /// @notice Emitted if the account is 0x0.
  72 |     |     error ZeroAccount();
  73 |     | 
  74 |     |     /* ============ Interactive Functions ============ */
  75 |     | 
  76 |     |     /**
  77 |     |      * @notice Claims `account`'s accrued yield.
  78 |     |      * @dev    Can be used to claim yield on behalf of `account`.
  79 |     |      * @param  account The address of the account.
  80 |     |      */
  81 |     |     function claimYieldFor(address account) external returns (uint256);
  82 |     | 
  83 |     |     /**
  84 |     |      * @notice Claims current accrued yield fee.
  85 |     |      * @dev    Can be used to claim yield fee on behalf of the `feeRecipient`.
  86 |     |      * @dev    SHOULD return early if the claimable yield fee is zero.
  87 |     |      * @return The amount of yield fee claimed.
  88 |     |      */
  89 |     |     function claimFee() external returns (uint256);
  90 |     | 
  91 |     |     /**
  92 |     |      * @notice Sets the yield fee rate, in bps, that will be taken from the yield generated by M.
  93 |     |      * @dev    MUST only be callable by the yield fee manager.
  94 |     |      * @dev    MUST revert if the fee rate is greater than MAX_FEE_RATE.
  95 |     |      * @param  feeRate The yield fee rate in bps.
  96 |     |      */
  97 |     |     function setFeeRate(uint16 feeRate) external;
  98 |     | 
  99 |     |     /**
 100 |     |      * @notice Sets the yield fee recipient that will receive part of the yield generated by M.
 101 |     |      * @dev    MUST only be callable by the yield fee manager.
 102 |     |      * @dev    MUST revert if the yield fee recipient is address zero.
 103 |     |      * @param  feeRecipient The yield fee recipient address.
 104 |     |      */
 105 |     |     function setFeeRecipient(address feeRecipient) external;
 106 |     | 
 107 |     |     /**
 108 |     |      * @notice Sets the claim recipient that will receive the yield fee.
 109 |     |      * @dev    MUST only be callable by the claim recipient manager.
 110 |     |      * @dev    MUST revert if the claim recipient is address zero.
 111 |     |      * @param  account The address that accrued yield.
 112 |     |      * @param  claimRecipient The claim recipient address.
 113 |     |      */
 114 |     |     function setClaimRecipient(address account, address claimRecipient) external;
 115 |     | 
 116 |     |     /* ============ View/Pure Functions ============ */
 117 |     | 
 118 |     |     /// @notice Returns 100% in basis points.
 119 |     |     function ONE_HUNDRED_PERCENT() external pure returns (uint16);
 120 |     | 
 121 |     |     /// @notice Returns the yield fee manager role hash.
 122 |     |     function FEE_MANAGER_ROLE() external pure returns (bytes32);
 123 |     | 
 124 |     |     /// @notice Returns the claim recipient manager role hash.
 125 |     |     function CLAIM_RECIPIENT_MANAGER_ROLE() external pure returns (bytes32);
 126 |     | 
 127 |     |     /**
 128 |     |      * @notice Returns the yield accrued for `account`, which is claimable.
 129 |     |      * @param  account The account being queried.
 130 |     |      * @return The amount of yield that is claimable.
 131 |     |      */
 132 |     |     function accruedYieldOf(address account) external view returns (uint256);
 133 |     | 
 134 |     |     /// @notice Returns the current value of the earner rate in basis points.
 135 |     |     function earnerRate() external view returns (uint32);
 136 |     | 
 137 |     |     /**
 138 |     |      * @notice Returns the token balance of `account` including any accrued yield.
 139 |     |      * @param  account The address of some account.
 140 |     |      * @return The token balance of `account` including any accrued yield.
 141 |     |      */
 142 |     |     function balanceWithYieldOf(address account) external view returns (uint256);
 143 |     | 
 144 |     |     /**
 145 |     |      * @notice Returns the principal of `account`.
 146 |     |      * @param  account The address of some account.
 147 |     |      * @return The principal of `account`.
 148 |     |      */
 149 |     |     function principalOf(address account) external view returns (uint112);
 150 |     | 
 151 |     |     /// @notice The projected total supply if all accrued yield was claimed at this moment.
 152 |     |     function projectedTotalSupply() external view returns (uint256);
 153 |     | 
 154 |     |     /// @notice The current total accrued yield claimable by holders.
 155 |     |     function totalAccruedYield() external view returns (uint256);
 156 |     | 
 157 |     |     /// @notice The current total accrued yield fee claimable by the yield fee recipient.
 158 |     |     function totalAccruedFee() external view returns (uint256);
 159 |     | 
 160 |     |     /// @notice The total principal to help compute `totalAccruedYield()` and yield fee.
 161 |     |     function totalPrincipal() external view returns (uint112);
 162 |     | 
 163 |     |     /// @notice Returns the yield fee rate, in bps, that is taken from the yield generated by M.
 164 |     |     function feeRate() external view returns (uint16);
 165 |     | 
 166 |     |     /// @notice Returns the current yield fee recipient that receives part of the yield generated by M.
 167 |     |     function feeRecipient() external view returns (address);
 168 |     | 
 169 |     |     /**
 170 |     |      * @notice Returns the claim recipient for the given account.
 171 |     |      * @dev    The claim recipient is the address set for claim recipient manager or account itself.
 172 |     |      * @param  account The address of the account.
 173 |     |      * @return The claim recipient address for the account.
 174 |     |      */
 175 |     |     function claimRecipientFor(address account) external view returns (address);
 176 |     | }
 177 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/projects/yieldToOne/IMYieldToOne.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | 
  3 |     | pragma solidity 0.8.26;
  4 |     | 
  5 |     | /**
  6 |     |  * @title M Extension where all yield is claimable by a single recipient.
  7 |     |  * @author M0 Labs
  8 |     |  */
  9 |     | interface IMYieldToOne {
 10 |     |     /* ============ Events ============ */
 11 |     | 
 12 |     |     /**
 13 |     |      * @notice Emitted when this contract's excess M is claimed.
 14 |     |      * @param  yield The amount of M yield claimed.
 15 |     |      */
 16 |     |     event YieldClaimed(uint256 yield);
 17 |     | 
 18 |     |     /**
 19 |     |      * @notice Emitted when the yield recipient is set.
 20 |     |      * @param  yieldRecipient The address of the new yield recipient.
 21 |     |      */
 22 |     |     event YieldRecipientSet(address indexed yieldRecipient);
 23 |     | 
 24 |     |     /* ============ Custom Errors ============ */
 25 |     | 
 26 |     |     /// @notice Emitted in constructor if Yield Recipient is 0x0.
 27 |     |     error ZeroYieldRecipient();
 28 |     | 
 29 |     |     /// @notice Emitted in constructor if Yield Recipient Manager is 0x0.
 30 |     |     error ZeroYieldRecipientManager();
 31 |     | 
 32 |     |     /// @notice Emitted in constructor if Admin is 0x0.
 33 |     |     error ZeroAdmin();
 34 |     | 
 35 |     |     /* ============ Interactive Functions ============ */
 36 |     | 
 37 |     |     /// @notice Claims accrued yield to yield recipient.
 38 |     |     function claimYield() external returns (uint256);
 39 |     | 
 40 |     |     /**
 41 |     |      * @notice Sets the yield recipient.
 42 |     |      * @dev    MUST only be callable by the YIELD_RECIPIENT_MANAGER_ROLE.
 43 |     |      * @dev    SHOULD revert if `yieldRecipient` is 0x0.
 44 |     |      * @dev    SHOULD return early if the `yieldRecipient` is already the actual yield recipient.
 45 |     |      * @param  yieldRecipient The address of the new yield recipient.
 46 |     |      */
 47 |     |     function setYieldRecipient(address yieldRecipient) external;
 48 |     | 
 49 |     |     /* ============ View/Pure Functions ============ */
 50 |     | 
 51 |     |     /// @notice The role that can manage the yield recipient.
 52 |     |     function YIELD_RECIPIENT_MANAGER_ROLE() external view returns (bytes32);
 53 |     | 
 54 |     |     /// @notice The amount of accrued yield.
 55 |     |     function yield() external view returns (uint256);
 56 |     | 
 57 |     |     /// @notice The address of the yield recipient.
 58 |     |     function yieldRecipient() external view returns (address);
 59 |     | }
 60 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/projects/yieldToOne/MYieldToOne.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | import { IERC20 } from "../../../lib/common/src/interfaces/IERC20.sol";
   6 |     | 
   7 |     | import { IMYieldToOne } from "./IMYieldToOne.sol";
   8 |     | 
   9 |     | import { Freezable } from "../../components/freezable/Freezable.sol";
  10 |     | import { MExtension } from "../../MExtension.sol";
  11 |     | 
  12 |     | abstract contract MYieldToOneStorageLayout {
  13 |     |     /// @custom:storage-location erc7201:M0.storage.MYieldToOne
  14 |     |     struct MYieldToOneStorageStruct {
  15 |     |         uint256 totalSupply;
  16 |     |         address yieldRecipient;
  17 |     |         mapping(address account => uint256 balance) balanceOf;
  18 |     |     }
  19 |     | 
  20 |     |     // keccak256(abi.encode(uint256(keccak256("M0.storage.MYieldToOne")) - 1)) & ~bytes32(uint256(0xff))
  21 |     |     bytes32 private constant _M_YIELD_TO_ONE_STORAGE_LOCATION =
  22 |     |         0xee2f6fc7e2e5879b17985791e0d12536cba689bda43c77b8911497248f4af100;
  23 |     | 
  24 | *   |     function _getMYieldToOneStorageLocation() internal pure returns (MYieldToOneStorageStruct storage $) {
  25 |     |         assembly {
  26 | *   |             $.slot := _M_YIELD_TO_ONE_STORAGE_LOCATION
  27 |     |         }
  28 |     |     }
  29 |     | }
  30 |     | 
  31 |     | /**
  32 |     |  * @title  MYieldToOne
  33 |     |  * @notice Upgradeable ERC20 Token contract for wrapping M into a non-rebasing token
  34 |     |  *         with yield claimable by a single recipient.
  35 |     |  * @author M0 Labs
  36 |     |  */
  37 | *   | contract MYieldToOne is IMYieldToOne, MYieldToOneStorageLayout, MExtension, Freezable {
  38 |     |     /* ============ Variables ============ */
  39 |     | 
  40 |     |     /// @inheritdoc IMYieldToOne
  41 | *   |     bytes32 public constant YIELD_RECIPIENT_MANAGER_ROLE = keccak256("YIELD_RECIPIENT_MANAGER_ROLE");
  42 |     | 
  43 |     |     /* ============ Constructor ============ */
  44 |     | 
  45 |     |     /**
  46 |     |      * @custom:oz-upgrades-unsafe-allow constructor
  47 |     |      * @notice Constructs MYieldToOne Implementation contract
  48 |     |      * @dev    Sets immutable storage.
  49 |     |      * @param  mToken       The address of $M token.
  50 |     |      * @param  swapFacility The address of Swap Facility.
  51 |     |      */
  52 | *   |     constructor(address mToken, address swapFacility) MExtension(mToken, swapFacility) {}
  53 |     | 
  54 |     |     /* ============ Initializer ============ */
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev   Initializes the M extension token with yield claimable by a single recipient.
  58 |     |      * @param name                  The name of the token (e.g. "M Yield to One").
  59 |     |      * @param symbol                The symbol of the token (e.g. "MYO").
  60 |     |      * @param yieldRecipient_       The address of a yield destination.
  61 |     |      * @param admin                 The address of an admin.
  62 |     |      * @param freezeManager         The address of a freeze manager.
  63 |     |      * @param yieldRecipientManager The address of a yield recipient setter.
  64 |     |      */
  65 | *   |     function initialize(
  66 |     |         string memory name,
  67 |     |         string memory symbol,
  68 |     |         address yieldRecipient_,
  69 |     |         address admin,
  70 |     |         address freezeManager,
  71 |     |         address yieldRecipientManager
  72 |     |     ) public virtual initializer {
  73 | *   |         __MYieldToOne_init(name, symbol, yieldRecipient_, admin, freezeManager, yieldRecipientManager);
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @notice Initializes the MYieldToOne token.
  78 |     |      * @param name                  The name of the token (e.g. "M Yield to One").
  79 |     |      * @param symbol                The symbol of the token (e.g. "MYO").
  80 |     |      * @param yieldRecipient_       The address of a yield destination.
  81 |     |      * @param admin                 The address of an admin.
  82 |     |      * @param freezeManager         The address of a freeze manager.
  83 |     |      * @param yieldRecipientManager The address of a yield recipient setter.
  84 |     |      */
  85 | *   |     function __MYieldToOne_init(
  86 |     |         string memory name,
  87 |     |         string memory symbol,
  88 |     |         address yieldRecipient_,
  89 |     |         address admin,
  90 |     |         address freezeManager,
  91 |     |         address yieldRecipientManager
  92 |     |     ) internal onlyInitializing {
  93 | *   |         if (yieldRecipientManager == address(0)) revert ZeroYieldRecipientManager();
  94 | *   |         if (admin == address(0)) revert ZeroAdmin();
  95 |     | 
  96 | *   |         __MExtension_init(name, symbol);
  97 | *   |         __Freezable_init(freezeManager);
  98 |     | 
  99 | *   |         _setYieldRecipient(yieldRecipient_);
 100 |     | 
 101 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, admin);
 102 | *   |         _grantRole(YIELD_RECIPIENT_MANAGER_ROLE, yieldRecipientManager);
 103 |     |     }
 104 |     | 
 105 |     |     /* ============ Interactive Functions ============ */
 106 |     | 
 107 |     |     /// @inheritdoc IMYieldToOne
 108 | *   |     function claimYield() public returns (uint256) {
 109 | *   |         _beforeClaimYield();
 110 |     | 
 111 | *   |         uint256 yield_ = yield();
 112 |     | 
 113 | *   |         if (yield_ == 0) return 0;
 114 |     | 
 115 |     |         emit YieldClaimed(yield_);
 116 |     | 
 117 |     |         _mint(yieldRecipient(), yield_);
 118 |     | 
 119 |     |         return yield_;
 120 |     |     }
 121 |     | 
 122 |     |     /// @inheritdoc IMYieldToOne
 123 | *   |     function setYieldRecipient(address account) external onlyRole(YIELD_RECIPIENT_MANAGER_ROLE) {
 124 |     |         // Claim yield for the previous yield recipient.
 125 | *   |         claimYield();
 126 |     | 
 127 | *   |         _setYieldRecipient(account);
 128 |     |     }
 129 |     | 
 130 |     |     /* ============ View/Pure Functions ============ */
 131 |     | 
 132 |     |     /// @inheritdoc IERC20
 133 | *   |     function balanceOf(address account) public view override returns (uint256) {
 134 | *   |         return _getMYieldToOneStorageLocation().balanceOf[account];
 135 |     |     }
 136 |     | 
 137 |     |     /// @inheritdoc IERC20
 138 | *   |     function totalSupply() public view returns (uint256) {
 139 | *   |         return _getMYieldToOneStorageLocation().totalSupply;
 140 |     |     }
 141 |     | 
 142 |     |     /// @inheritdoc IMYieldToOne
 143 | *   |     function yield() public view virtual returns (uint256) {
 144 |     |         unchecked {
 145 | *   |             uint256 balance_ = _mBalanceOf(address(this));
 146 | *   |             uint256 totalSupply_ = totalSupply();
 147 |     | 
 148 | *   |             return balance_ > totalSupply_ ? balance_ - totalSupply_ : 0;
 149 |     |         }
 150 |     |     }
 151 |     | 
 152 |     |     /// @inheritdoc IMYieldToOne
 153 |     |     function yieldRecipient() public view returns (address) {
 154 |     |         return _getMYieldToOneStorageLocation().yieldRecipient;
 155 |     |     }
 156 |     | 
 157 |     |     /* ============ Hooks For Internal Interactive Functions ============ */
 158 |     | 
 159 |     |     /**
 160 |     |      * @dev    Hooks called before approval of M extension spend.
 161 |     |      * @param  account The account from which M is deposited.
 162 |     |      * @param  spender The account spending M Extension token.
 163 |     |      */
 164 | *   |     function _beforeApprove(address account, address spender, uint256 /* amount */) internal view virtual override {
 165 | *   |         FreezableStorageStruct storage $ = _getFreezableStorageLocation();
 166 |     | 
 167 | *   |         _revertIfFrozen($, account);
 168 | *   |         _revertIfFrozen($, spender);
 169 |     |     }
 170 |     | 
 171 |     |     /**
 172 |     |      * @dev    Hooks called before wrapping M into M Extension token.
 173 |     |      * @param  account   The account from which M is deposited.
 174 |     |      * @param  recipient The account receiving the minted M Extension token.
 175 |     |      */
 176 | *   |     function _beforeWrap(address account, address recipient, uint256 /* amount */) internal view virtual override {
 177 | *   |         FreezableStorageStruct storage $ = _getFreezableStorageLocation();
 178 |     | 
 179 | *   |         _revertIfFrozen($, account);
 180 | *   |         _revertIfFrozen($, recipient);
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev   Hook called before unwrapping M Extension token.
 185 |     |      * @param account The account from which M Extension token is burned.
 186 |     |      */
 187 |     |     function _beforeUnwrap(address account, uint256 /* amount */) internal view virtual override {
 188 |     |         _revertIfFrozen(_getFreezableStorageLocation(), account);
 189 |     |     }
 190 |     | 
 191 |     |     /**
 192 |     |      * @dev   Hook called before transferring M Extension token.
 193 |     |      * @param sender    The address from which the tokens are being transferred.
 194 |     |      * @param recipient The address to which the tokens are being transferred.
 195 |     |      */
 196 | *   |     function _beforeTransfer(address sender, address recipient, uint256 /* amount */) internal view virtual override {
 197 | *   |         FreezableStorageStruct storage $ = _getFreezableStorageLocation();
 198 |     | 
 199 | *   |         _revertIfFrozen($, msg.sender);
 200 |     | 
 201 | *   |         _revertIfFrozen($, sender);
 202 | *   |         _revertIfFrozen($, recipient);
 203 |     |     }
 204 |     | 
 205 |     |     /**
 206 |     |      * @dev   Hook called before claiming yield from the M Extension token. To be overridden in derived extensions.
 207 |     |      */
 208 | *   |     function _beforeClaimYield() internal view virtual {}
 209 |     | 
 210 |     |     /* ============ Internal Interactive Functions ============ */
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev   Mints `amount` tokens to `recipient`.
 214 |     |      * @param recipient The address whose account balance will be incremented.
 215 |     |      * @param amount    The present amount of tokens to mint.`
 216 |     |      */
 217 | *   |     function _mint(address recipient, uint256 amount) internal override {
 218 | *   |         MYieldToOneStorageStruct storage $ = _getMYieldToOneStorageLocation();
 219 |     | 
 220 |     |         // NOTE: Can be `unchecked` because the max amount of $M is never greater than `type(uint240).max`.
 221 |     |         unchecked {
 222 | *   |             $.balanceOf[recipient] += amount;
 223 | *   |             $.totalSupply += amount;
 224 |     |         }
 225 |     | 
 226 | *   |         emit Transfer(address(0), recipient, amount);
 227 |     |     }
 228 |     | 
 229 |     |     /**
 230 |     |      * @dev   Burns `amount` tokens from `account`.
 231 |     |      * @param account The address whose account balance will be decremented.
 232 |     |      * @param amount  The present amount of tokens to burn.
 233 |     |      */
 234 |     |     function _burn(address account, uint256 amount) internal override {
 235 |     |         MYieldToOneStorageStruct storage $ = _getMYieldToOneStorageLocation();
 236 |     | 
 237 |     |         // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` is used in MExtension.
 238 |     |         unchecked {
 239 |     |             $.balanceOf[account] -= amount;
 240 |     |             $.totalSupply -= amount;
 241 |     |         }
 242 |     | 
 243 |     |         emit Transfer(account, address(0), amount);
 244 |     |     }
 245 |     | 
 246 |     |     /**
 247 |     |      * @dev   Internal balance update function called on transfer.
 248 |     |      * @param sender    The sender's address.
 249 |     |      * @param recipient The recipient's address.
 250 |     |      * @param amount    The amount to be transferred.
 251 |     |      */
 252 |     |     function _update(address sender, address recipient, uint256 amount) internal override {
 253 |     |         MYieldToOneStorageStruct storage $ = _getMYieldToOneStorageLocation();
 254 |     | 
 255 |     |         // NOTE: Can be `unchecked` because `_revertIfInsufficientBalance` for `sender` is used in MExtension.
 256 |     |         unchecked {
 257 |     |             $.balanceOf[sender] -= amount;
 258 |     |             $.balanceOf[recipient] += amount;
 259 |     |         }
 260 |     |     }
 261 |     | 
 262 |     |     /**
 263 |     |      * @dev Sets the yield recipient.
 264 |     |      * @param yieldRecipient_ The address of the new yield recipient.
 265 |     |      */
 266 | *   |     function _setYieldRecipient(address yieldRecipient_) internal {
 267 | *   |         if (yieldRecipient_ == address(0)) revert ZeroYieldRecipient();
 268 |     | 
 269 | *   |         MYieldToOneStorageStruct storage $ = _getMYieldToOneStorageLocation();
 270 |     | 
 271 | *   |         if (yieldRecipient_ == $.yieldRecipient) return;
 272 |     | 
 273 | *   |         $.yieldRecipient = yieldRecipient_;
 274 |     | 
 275 | *   |         emit YieldRecipientSet(yieldRecipient_);
 276 |     |     }
 277 |     | }
 278 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/swap/ReentrancyLock.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | 
  3 |     | pragma solidity 0.8.26;
  4 |     | 
  5 |     | import { Locker } from "../../lib/uniswap-v4-periphery/src/libraries/Locker.sol";
  6 |     | 
  7 |     | import { AccessControlUpgradeable } from "../../lib/common/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol";
  8 |     | 
  9 |     | import { IMsgSender } from "../../lib/uniswap-v4-periphery/src/interfaces/IMsgSender.sol";
 10 |     | 
 11 |     | import { IReentrancyLock } from "./interfaces/IReentrancyLock.sol";
 12 |     | 
 13 |     | abstract contract ReentrancyLockStorageLayout {
 14 |     |     /// @custom:storage-location erc7201:M0.storage.ReentrancyLock
 15 |     |     struct ReentrancyLockStorageStruct {
 16 |     |         mapping(address router => bool isTrusted) trustedRouters;
 17 |     |     }
 18 |     | 
 19 |     |     // keccak256(abi.encode(uint256(keccak256("M0.storage.ReentrancyLock")) - 1)) & ~bytes32(uint256(0xff))
 20 |     |     bytes32 private constant _REENTRANCY_LOCK_STORAGE_LOCATION =
 21 |     |         0x157708201859ed3ceee295d1baf4381ae5b622de496b1cee3705ed07c6a50200;
 22 |     | 
 23 | *   |     function _getReentrancyLockStorageLocation() internal pure returns (ReentrancyLockStorageStruct storage $) {
 24 |     |         assembly {
 25 | *   |             $.slot := _REENTRANCY_LOCK_STORAGE_LOCATION
 26 |     |         }
 27 |     |     }
 28 |     | }
 29 |     | 
 30 |     | /// @notice A transient reentrancy lock, that stores the caller's address as the lock
 31 |     | contract ReentrancyLock is IReentrancyLock, ReentrancyLockStorageLayout, AccessControlUpgradeable {
 32 |     |     /* ============ Modifiers ============ */
 33 |     | 
 34 | *   |     modifier isNotLocked() {
 35 | *   |         if (Locker.get() != address(0)) revert ContractLocked();
 36 |     | 
 37 | *   |         address caller_ = isTrustedRouter(msg.sender) ? IMsgSender(msg.sender).msgSender() : msg.sender;
 38 |     | 
 39 | *   |         Locker.set(caller_);
 40 |     |         _;
 41 | *   |         Locker.set(address(0));
 42 |     |     }
 43 |     | 
 44 |     |     /* ============ Initializer ============ */
 45 |     | 
 46 |     |     /**
 47 |     |      * @notice Initializes the contract with the given admin.
 48 |     |      * @param admin The address of an admin.
 49 |     |      */
 50 | *   |     function __ReentrancyLock_init(address admin) internal onlyInitializing {
 51 | *   |         if (admin == address(0)) revert ZeroAdmin();
 52 |     | 
 53 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, admin);
 54 |     |     }
 55 |     | 
 56 |     |     /* ============ Interactive Functions ============ */
 57 |     | 
 58 |     |     /// @inheritdoc IReentrancyLock
 59 |     |     function setTrustedRouter(address router, bool trusted) external onlyRole(DEFAULT_ADMIN_ROLE) {
 60 |     |         if (router == address(0)) revert ZeroRouter();
 61 |     | 
 62 |     |         ReentrancyLockStorageStruct storage $ = _getReentrancyLockStorageLocation();
 63 |     |         if ($.trustedRouters[router] == trusted) return;
 64 |     | 
 65 |     |         $.trustedRouters[router] = trusted;
 66 |     | 
 67 |     |         emit TrustedRouterSet(router, trusted);
 68 |     |     }
 69 |     | 
 70 |     |     /* ============ View/Pure Functions ============ */
 71 |     | 
 72 |     |     /// @inheritdoc IReentrancyLock
 73 | *   |     function isTrustedRouter(address router) public view returns (bool) {
 74 | *   |         return _getReentrancyLockStorageLocation().trustedRouters[router];
 75 |     |     }
 76 |     | 
 77 |     |     /* ============ Private View/Pure Functions ============ */
 78 |     | 
 79 | *   |     function _getLocker() internal view returns (address) {
 80 | *   |         return Locker.get();
 81 |     |     }
 82 |     | }
 83 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/swap/SwapFacility.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | import { IERC20 } from "../../lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
   6 |     | 
   7 |     | import { SafeERC20 } from "../../lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
   8 |     | 
   9 |     | import { Pausable } from "../components/pausable/Pausable.sol";
  10 |     | 
  11 |     | import { IJMIExtension } from "../projects/jmi/JMIExtension.sol";
  12 |     | 
  13 |     | import { IMTokenLike } from "../interfaces/IMTokenLike.sol";
  14 |     | import { IMExtension } from "../interfaces/IMExtension.sol";
  15 |     | 
  16 |     | import { ISwapFacility } from "./interfaces/ISwapFacility.sol";
  17 |     | import { IRegistrarLike } from "./interfaces/IRegistrarLike.sol";
  18 |     | 
  19 |     | import { ReentrancyLock } from "./ReentrancyLock.sol";
  20 |     | 
  21 |     | abstract contract SwapFacilityUpgradeableStorageLayout {
  22 |     |     /// @custom:storage-location erc7201:M0.storage.SwapFacility
  23 |     |     struct SwapFacilityStorageStruct {
  24 |     |         mapping(address extension => bool permissioned) permissionedExtensions;
  25 |     |         mapping(address extension => mapping(address mSwapper => bool allowed)) permissionedMSwappers;
  26 |     |         mapping(address extension => bool approved) adminApprovedExtensions;
  27 |     |     }
  28 |     | 
  29 |     |     // keccak256(abi.encode(uint256(keccak256("M0.storage.SwapFacility")) - 1)) & ~bytes32(uint256(0xff))
  30 |     |     bytes32 private constant _SWAP_FACILITY_EXTENDED_STORAGE_LOCATION =
  31 |     |         0x2f6671d90ec6fb8a38d5fa4043e503b2789e716b6e5219d1b20da9c6434dde00;
  32 |     | 
  33 | *   |     function _getSwapFacilityStorageLocation() internal pure returns (SwapFacilityStorageStruct storage $) {
  34 |     |         assembly {
  35 | *   |             $.slot := _SWAP_FACILITY_EXTENDED_STORAGE_LOCATION
  36 |     |         }
  37 |     |     }
  38 |     | }
  39 |     | 
  40 |     | /**
  41 |     |  * @title  Swap Facility
  42 |     |  * @notice A contract responsible for swapping between $M Extensions.
  43 |     |  * @author M0 Labs
  44 |     |  */
  45 | *   | contract SwapFacility is ISwapFacility, Pausable, ReentrancyLock, SwapFacilityUpgradeableStorageLayout {
  46 |     |     using SafeERC20 for IERC20;
  47 |     | 
  48 |     |     /// @inheritdoc ISwapFacility
  49 |     |     bytes32 public constant EARNERS_LIST_NAME = "earners";
  50 |     | 
  51 |     |     /// @inheritdoc ISwapFacility
  52 |     |     bytes32 public constant EARNERS_LIST_IGNORED_KEY = "earners_list_ignored";
  53 |     | 
  54 |     |     /// @inheritdoc ISwapFacility
  55 | *   |     bytes32 public constant M_SWAPPER_ROLE = keccak256("M_SWAPPER_ROLE");
  56 |     | 
  57 |     |     /// @inheritdoc ISwapFacility
  58 |     |     /// @custom:oz-upgrades-unsafe-allow state-variable-immutable
  59 |     |     address public immutable mToken;
  60 |     | 
  61 |     |     /// @inheritdoc ISwapFacility
  62 |     |     /// @custom:oz-upgrades-unsafe-allow state-variable-immutable
  63 |     |     address public immutable registrar;
  64 |     | 
  65 |     |     /**
  66 |     |      * @custom:oz-upgrades-unsafe-allow constructor
  67 |     |      * @notice Constructs SwapFacility Implementation contract
  68 |     |      * @dev    Sets immutable storage.
  69 |     |      * @param  mToken_      The address of $M token.
  70 |     |      * @param  registrar_   The address of Registrar.
  71 |     |      */
  72 | *   |     constructor(address mToken_, address registrar_) {
  73 | *   |         _disableInitializers();
  74 |     | 
  75 | *   |         if ((mToken = mToken_) == address(0)) revert ZeroMToken();
  76 | *   |         if ((registrar = registrar_) == address(0)) revert ZeroRegistrar();
  77 |     |     }
  78 |     | 
  79 |     |     /* ============ Initializer ============ */
  80 |     | 
  81 |     |     /**
  82 |     |      * @notice Initializes SwapFacility Proxy.
  83 |     |      * @dev    Used to initialize SwapFacility when deploying for the first time.
  84 |     |      * @param  admin  Address of the SwapFacility admin.
  85 |     |      * @param  pauser Address of the SwapFacility pauser.
  86 |     |      */
  87 | *   |     function initialize(address admin, address pauser) external initializer {
  88 | *   |         __ReentrancyLock_init(admin);
  89 | *   |         __Pausable_init(pauser);
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @notice Initializes SwapFacility V2 Proxy.
  94 |     |      * @dev    Used to initialize SwapFacility when upgrading to V2.
  95 |     |      * @param  pauser Address of the SwapFacility pauser.
  96 |     |      */
  97 |     |     function initializeV2(address pauser) external reinitializer(2) {
  98 |     |         __Pausable_init(pauser);
  99 |     |     }
 100 |     | 
 101 |     |     /* ============ Interactive Functions ============ */
 102 |     | 
 103 |     |     /// @inheritdoc ISwapFacility
 104 | *   |     function swap(address tokenIn, address tokenOut, uint256 amount, address recipient) external isNotLocked {
 105 | *   |         _swap(tokenIn, tokenOut, amount, recipient);
 106 |     |     }
 107 |     | 
 108 |     |     /// @inheritdoc ISwapFacility
 109 |     |     function swapWithPermit(
 110 |     |         address tokenIn,
 111 |     |         address tokenOut,
 112 |     |         uint256 amount,
 113 |     |         address recipient,
 114 |     |         uint256 deadline,
 115 |     |         uint8 v,
 116 |     |         bytes32 r,
 117 |     |         bytes32 s
 118 |     |     ) external isNotLocked {
 119 |     |         try IMExtension(tokenIn).permit(msg.sender, address(this), amount, deadline, v, r, s) {} catch {}
 120 |     |         _swap(tokenIn, tokenOut, amount, recipient);
 121 |     |     }
 122 |     | 
 123 |     |     /// @inheritdoc ISwapFacility
 124 |     |     function swapWithPermit(
 125 |     |         address tokenIn,
 126 |     |         address tokenOut,
 127 |     |         uint256 amount,
 128 |     |         address recipient,
 129 |     |         uint256 deadline,
 130 |     |         bytes calldata signature
 131 |     |     ) external isNotLocked {
 132 |     |         try IMExtension(tokenIn).permit(msg.sender, address(this), amount, deadline, signature) {} catch {}
 133 |     |         _swap(tokenIn, tokenOut, amount, recipient);
 134 |     |     }
 135 |     | 
 136 |     |     /// @inheritdoc ISwapFacility
 137 | *   |     function swapInM(address extensionOut, uint256 amount, address recipient) external isNotLocked {
 138 | *   |         _swap(mToken, extensionOut, amount, recipient);
 139 |     |     }
 140 |     | 
 141 |     |     /// @inheritdoc ISwapFacility
 142 | *   |     function swapOutM(address extensionIn, uint256 amount, address recipient) external isNotLocked {
 143 | *   |         _swap(extensionIn, mToken, amount, recipient);
 144 |     |     }
 145 |     | 
 146 |     |     /// @inheritdoc ISwapFacility
 147 |     |     function replaceAssetWithM(
 148 |     |         address asset,
 149 |     |         address extensionIn,
 150 |     |         address extensionOut,
 151 |     |         uint256 amount,
 152 |     |         address recipient
 153 |     |     ) external isNotLocked {
 154 |     |         _replaceAssetWithM(asset, extensionIn, extensionOut, amount, recipient);
 155 |     |     }
 156 |     | 
 157 |     |     /// @inheritdoc ISwapFacility
 158 |     |     function replaceAssetWithMWithPermit(
 159 |     |         address asset,
 160 |     |         address extensionIn,
 161 |     |         address extensionOut,
 162 |     |         uint256 amount,
 163 |     |         address recipient,
 164 |     |         uint256 deadline,
 165 |     |         uint8 v,
 166 |     |         bytes32 r,
 167 |     |         bytes32 s
 168 |     |     ) external isNotLocked {
 169 |     |         try IMExtension(extensionIn).permit(msg.sender, address(this), amount, deadline, v, r, s) {} catch {}
 170 |     |         _replaceAssetWithM(asset, extensionIn, extensionOut, amount, recipient);
 171 |     |     }
 172 |     | 
 173 |     |     /// @inheritdoc ISwapFacility
 174 |     |     function replaceAssetWithMWithPermit(
 175 |     |         address asset,
 176 |     |         address extensionIn,
 177 |     |         address extensionOut,
 178 |     |         uint256 amount,
 179 |     |         address recipient,
 180 |     |         uint256 deadline,
 181 |     |         bytes calldata signature
 182 |     |     ) external isNotLocked {
 183 |     |         try IMExtension(extensionIn).permit(msg.sender, address(this), amount, deadline, signature) {} catch {}
 184 |     |         _replaceAssetWithM(asset, extensionIn, extensionOut, amount, recipient);
 185 |     |     }
 186 |     | 
 187 |     |     /* ============ Admin Controlled Interactive Functions ============ */
 188 |     | 
 189 |     |     /// @inheritdoc ISwapFacility
 190 |     |     function setPermissionedExtension(address extension, bool permissioned) external onlyRole(DEFAULT_ADMIN_ROLE) {
 191 |     |         if (extension == address(0)) revert ZeroExtension();
 192 |     | 
 193 |     |         if (isPermissionedExtension(extension) == permissioned) return;
 194 |     | 
 195 |     |         _getSwapFacilityStorageLocation().permissionedExtensions[extension] = permissioned;
 196 |     | 
 197 |     |         emit PermissionedExtensionSet(extension, permissioned);
 198 |     |     }
 199 |     | 
 200 |     |     /// @inheritdoc ISwapFacility
 201 |     |     function setPermissionedMSwapper(
 202 |     |         address extension,
 203 |     |         address swapper,
 204 |     |         bool allowed
 205 |     |     ) external onlyRole(DEFAULT_ADMIN_ROLE) {
 206 |     |         if (extension == address(0)) revert ZeroExtension();
 207 |     |         if (swapper == address(0)) revert ZeroSwapper();
 208 |     | 
 209 |     |         if (isPermissionedMSwapper(extension, swapper) == allowed) return;
 210 |     | 
 211 |     |         _getSwapFacilityStorageLocation().permissionedMSwappers[extension][swapper] = allowed;
 212 |     | 
 213 |     |         emit PermissionedMSwapperSet(extension, swapper, allowed);
 214 |     |     }
 215 |     | 
 216 |     |     /// @inheritdoc ISwapFacility
 217 |     |     function setAdminApprovedExtension(address extension, bool approved) external onlyRole(DEFAULT_ADMIN_ROLE) {
 218 |     |         if (extension == address(0)) revert ZeroExtension();
 219 |     | 
 220 |     |         if (isAdminApprovedExtension(extension) == approved) return;
 221 |     | 
 222 |     |         _getSwapFacilityStorageLocation().adminApprovedExtensions[extension] = approved;
 223 |     | 
 224 |     |         emit AdminApprovedExtensionSet(extension, approved);
 225 |     |     }
 226 |     | 
 227 |     |     /* ============ View/Pure Functions ============ */
 228 |     | 
 229 |     |     /// @inheritdoc ISwapFacility
 230 | *   |     function isPermissionedExtension(address extension) public view returns (bool) {
 231 | *   |         return _getSwapFacilityStorageLocation().permissionedExtensions[extension];
 232 |     |     }
 233 |     | 
 234 |     |     /// @inheritdoc ISwapFacility
 235 |     |     function isPermissionedMSwapper(address extension, address swapper) public view returns (bool) {
 236 |     |         return _getSwapFacilityStorageLocation().permissionedMSwappers[extension][swapper];
 237 |     |     }
 238 |     | 
 239 |     |     /// @inheritdoc ISwapFacility
 240 | *   |     function isMSwapper(address swapper) public view returns (bool) {
 241 | *   |         return hasRole(M_SWAPPER_ROLE, swapper);
 242 |     |     }
 243 |     | 
 244 |     |     /// @inheritdoc ISwapFacility
 245 |     |     function isAdminApprovedExtension(address extension) public view returns (bool) {
 246 |     |         return _getSwapFacilityStorageLocation().adminApprovedExtensions[extension];
 247 |     |     }
 248 |     | 
 249 |     |     /// @inheritdoc ISwapFacility
 250 | *   |     function isApprovedExtension(address extension) public view returns (bool) {
 251 | *   |         return _isApprovedEarner(extension) || isAdminApprovedExtension(extension);
 252 |     |     }
 253 |     | 
 254 |     |     /// @inheritdoc ISwapFacility
 255 |     |     function canSwapViaPath(address swapper, address tokenIn, address tokenOut) external view returns (bool) {
 256 |     |         bool isTokenInPaused = false;
 257 |     |         bool isTokenOutPaused = false;
 258 |     | 
 259 |     |         // If `tokenIn` or `tokenOut` are not valid contracts, return false
 260 |     |         if (tokenIn.code.length == 0 || tokenOut.code.length == 0) return false;
 261 |     | 
 262 |     |         // If contracts are paused, return false
 263 |     |         try Pausable(tokenIn).paused() returns (bool tokenInPaused) {
 264 |     |             isTokenInPaused = tokenInPaused;
 265 |     |         } catch {}
 266 |     |         try Pausable(tokenOut).paused() returns (bool tokenOutPaused) {
 267 |     |             isTokenOutPaused = tokenOutPaused;
 268 |     |         } catch {}
 269 |     |         if (paused() || isTokenInPaused || isTokenOutPaused) return false;
 270 |     | 
 271 |     |         // If the input token is $M, we swap it for the output token, which must be an extension
 272 |     |         // The tokenOut must be an approved extension and the swapper must be allowed to swap in M
 273 |     |         if (tokenIn == mToken) {
 274 |     |             if (!isApprovedExtension(tokenOut)) return false;
 275 |     |             return isPermissionedExtension(tokenOut) ? isPermissionedMSwapper(tokenOut, swapper) : isMSwapper(swapper);
 276 |     |         }
 277 |     | 
 278 |     |         // If the output token is $M, we swap the input token, which must be an extension, for $M
 279 |     |         // The tokenIn must be an approved extension and the swapper must be allowed to swap out M
 280 |     |         if (tokenOut == mToken) {
 281 |     |             if (!isApprovedExtension(tokenIn)) return false;
 282 |     |             return isPermissionedExtension(tokenIn) ? isPermissionedMSwapper(tokenIn, swapper) : isMSwapper(swapper);
 283 |     |         }
 284 |     | 
 285 |     |         // If both tokens are extensions, we swap one extension for another
 286 |     |         // Both extensions must not be permissioned
 287 |     |         bool tokenOutExtension = isApprovedExtension(tokenOut);
 288 |     |         if (isApprovedExtension(tokenIn) && tokenOutExtension) {
 289 |     |             return !isPermissionedExtension(tokenIn) && !isPermissionedExtension(tokenOut);
 290 |     |         }
 291 |     | 
 292 |     |         // If token out is an extension, we try to swap in via JMI
 293 |     |         // The tokenOut must be an approved extension and support the tokenIn as a JMI asset
 294 |     |         if (tokenOutExtension) {
 295 |     |             try IJMIExtension(tokenOut).isAllowedAsset(tokenIn) returns (bool allowed) {
 296 |     |                 return allowed;
 297 |     |             } catch {
 298 |     |                 return false;
 299 |     |             }
 300 |     |         }
 301 |     | 
 302 |     |         return false;
 303 |     |     }
 304 |     | 
 305 |     |     /// @inheritdoc ISwapFacility
 306 | *   |     function msgSender() public view returns (address) {
 307 | *   |         return _getLocker();
 308 |     |     }
 309 |     | 
 310 |     |     /* ============ Private Interactive Functions ============ */
 311 |     | 
 312 |     |     /**
 313 |     |      * @notice Swaps between two tokens, which can be $M token, $M Extensions, or an external asset used by JMI Extensions.
 314 |     |      * @param  tokenIn   The address of the token to swap from.
 315 |     |      * @param  tokenOut  The address of the token to swap to.
 316 |     |      * @param  amount    The amount to swap.
 317 |     |      * @param  recipient The address to receive the swapped tokens.
 318 |     |      */
 319 | *   |     function _swap(address tokenIn, address tokenOut, uint256 amount, address recipient) private {
 320 | *   |         _requireNotPaused();
 321 |     | 
 322 |     |         // If the input token is $M, we swap it for the output token, which must be an extension
 323 |     |         // This is checked in _swapInM
 324 | *   |         if (tokenIn == mToken) return _swapInM(tokenOut, amount, recipient);
 325 |     | 
 326 |     |         // If the output token is $M, we swap the input token, which must be an extension, for $M
 327 |     |         // This is checked in _swapOutM
 328 | *   |         if (tokenOut == mToken) return _swapOutM(tokenIn, amount, recipient);
 329 |     | 
 330 |     |         // If both tokens are extensions, we swap one extension for another
 331 | *   |         bool tokenOutExtension = isApprovedExtension(tokenOut);
 332 | *   |         if (isApprovedExtension(tokenIn) && tokenOutExtension)
 333 | *   |             return _swapExtensions(tokenIn, tokenOut, amount, recipient);
 334 |     | 
 335 |     |         // If token out is an extension, we try to swap in via JMI
 336 |     |         if (tokenOutExtension) return _swapInJMI(tokenIn, tokenOut, amount, recipient);
 337 |     | 
 338 |     |         // If none of the above, we revert
 339 |     |         revert InvalidSwapPath(tokenIn, tokenOut);
 340 |     |     }
 341 |     | 
 342 |     |     /**
 343 |     |      * @notice Swaps one $M Extension to another.
 344 |     |      * @param  extensionIn  The address of the $M Extension to swap from.
 345 |     |      * @param  extensionOut The address of the $M Extension to swap to.
 346 |     |      * @param  amount       The amount to swap.
 347 |     |      * @param  recipient    The address to receive the swapped $M Extension tokens.
 348 |     |      */
 349 | *   |     function _swapExtensions(address extensionIn, address extensionOut, uint256 amount, address recipient) private {
 350 | *   |         _revertIfPermissionedExtension(extensionIn);
 351 | *   |         _revertIfPermissionedExtension(extensionOut);
 352 |     | 
 353 | *   |         IERC20(extensionIn).transferFrom(msg.sender, address(this), amount);
 354 |     | 
 355 |     |         // NOTE: Added to support WrappedM V1 extension, should be removed in the future after upgrade to V2.
 356 | *   |         uint256 mBalanceBefore = _mBalanceOf(address(this));
 357 |     | 
 358 |     |         // NOTE: Amount and recipient validation is performed in Extensions.
 359 |     |         // Recipient parameter is ignored in the MExtension, keeping it for backward compatibility.
 360 | *   |         IMExtension(extensionIn).unwrap(address(this), amount);
 361 |     | 
 362 |     |         // NOTE: Calculate amount as $M Token balance difference
 363 |     |         //       to account for WrappedM V1 rounding errors.
 364 | *   |         amount = _mBalanceOf(address(this)) - mBalanceBefore;
 365 |     | 
 366 | *   |         IERC20(mToken).approve(extensionOut, amount);
 367 | *   |         IMExtension(extensionOut).wrap(recipient, amount);
 368 |     | 
 369 | *   |         emit Swapped(extensionIn, extensionOut, amount, recipient);
 370 |     |     }
 371 |     | 
 372 |     |     /**
 373 |     |      * @notice Swaps $M token to $M Extension.
 374 |     |      * @param  extensionOut The address of the M Extension to swap to.
 375 |     |      * @param  amount       The amount of $M token to swap.
 376 |     |      * @param  recipient    The address to receive the swapped $M Extension tokens.
 377 |     |      */
 378 | *   |     function _swapInM(address extensionOut, uint256 amount, address recipient) private {
 379 | *   |         _revertIfNotApprovedExtension(extensionOut);
 380 | *   |         _revertIfNotApprovedSwapper(extensionOut, msg.sender);
 381 |     | 
 382 | *   |         IERC20(mToken).transferFrom(msg.sender, address(this), amount);
 383 | *   |         IERC20(mToken).approve(extensionOut, amount);
 384 | *   |         IMExtension(extensionOut).wrap(recipient, amount);
 385 |     | 
 386 | *   |         emit SwappedInM(extensionOut, amount, recipient);
 387 |     |     }
 388 |     | 
 389 |     |     /**
 390 |     |      * @notice Swaps `amount` of `asset` to JMI Extension tokens.
 391 |     |      * @param  asset        The address of the asset to swap.
 392 |     |      * @param  extensionOut The address of the JMI Extension to swap to.
 393 |     |      * @param  amount       The amount of `asset` to swap.
 394 |     |      * @param  recipient    The address to receive `amount` of JMI Extension tokens.
 395 |     |      */
 396 |     |     function _swapInJMI(address asset, address extensionOut, uint256 amount, address recipient) private {
 397 |     |         _revertIfCannotJmi(asset, extensionOut);
 398 |     | 
 399 |     |         // NOTE: Use safeTransferFrom and forceApprove to handle assets that do not return a boolean value.
 400 |     |         IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);
 401 |     |         IERC20(asset).forceApprove(extensionOut, amount);
 402 |     |         IJMIExtension(extensionOut).wrap(asset, recipient, amount);
 403 |     | 
 404 |     |         emit SwappedInJMI(asset, extensionOut, amount, recipient);
 405 |     |     }
 406 |     | 
 407 |     |     /**
 408 |     |      * @notice Replaces `amount` of `asset` held in a JMI Extension with $M.
 409 |     |      * @param  asset        The address of the asset.
 410 |     |      * @param  extensionIn  The address of an $M extension to unwrap $M from and replace `asset` with.
 411 |     |      * @param  extensionOut The address of a JMI Extension.
 412 |     |      * @param  amount       The amount of $M to replace.
 413 |     |      * @param  recipient    The address to receive `amount` of `asset` tokens.
 414 |     |      */
 415 |     |     function _replaceAssetWithM(
 416 |     |         address asset,
 417 |     |         address extensionIn,
 418 |     |         address extensionOut,
 419 |     |         uint256 amount,
 420 |     |         address recipient
 421 |     |     ) private {
 422 |     |         _requireNotPaused();
 423 |     |         _revertIfNotApprovedExtension(extensionIn);
 424 |     |         _revertIfNotApprovedExtension(extensionOut);
 425 |     | 
 426 |     |         _revertIfPermissionedExtension(extensionIn);
 427 |     | 
 428 |     |         IERC20(extensionIn).transferFrom(msg.sender, address(this), amount);
 429 |     | 
 430 |     |         uint256 mBalanceBefore = _mBalanceOf(address(this));
 431 |     | 
 432 |     |         // NOTE: Amount and recipient validation is performed in Extensions.
 433 |     |         // Recipient parameter is ignored in the MExtension, keeping it for backward compatibility.
 434 |     |         IMExtension(extensionIn).unwrap(address(this), amount);
 435 |     | 
 436 |     |         // NOTE: Calculate amount as $M Token balance difference
 437 |     |         //       to account for WrappedM V1 rounding errors.
 438 |     |         amount = _mBalanceOf(address(this)) - mBalanceBefore;
 439 |     | 
 440 |     |         IERC20(mToken).approve(extensionOut, amount);
 441 |     |         IJMIExtension(extensionOut).replaceAssetWithM(asset, recipient, amount);
 442 |     | 
 443 |     |         emit JMIAssetReplaced(asset, extensionOut, amount);
 444 |     |     }
 445 |     | 
 446 |     |     /**
 447 |     |      * @notice Swaps $M Extension to $M token.
 448 |     |      * @param  extensionIn The address of the $M Extension to swap from.
 449 |     |      * @param  amount      The amount of $M Extension tokens to swap.
 450 |     |      * @param  recipient   The address to receive $M tokens.
 451 |     |      */
 452 | *   |     function _swapOutM(address extensionIn, uint256 amount, address recipient) private {
 453 | *   |         _revertIfNotApprovedExtension(extensionIn);
 454 | *   |         _revertIfNotApprovedSwapper(extensionIn, msg.sender);
 455 |     | 
 456 | *   |         IERC20(extensionIn).transferFrom(msg.sender, address(this), amount);
 457 |     | 
 458 |     |         // NOTE: Added to support WrappedM V1 extension, should be removed in the future after upgrade to V2.
 459 |     |         uint256 mBalanceBefore = _mBalanceOf(address(this));
 460 |     | 
 461 |     |         // NOTE: Amount and recipient validation is performed in Extensions.
 462 |     |         // Recipient parameter is ignored in the MExtension, keeping it for backward compatibility.
 463 |     |         IMExtension(extensionIn).unwrap(address(this), amount);
 464 |     | 
 465 |     |         // NOTE: Calculate amount as $M Token balance difference
 466 |     |         //       to account for WrappedM V1 rounding errors.
 467 |     |         amount = _mBalanceOf(address(this)) - mBalanceBefore;
 468 |     | 
 469 |     |         IERC20(mToken).transfer(recipient, amount);
 470 |     | 
 471 |     |         emit SwappedOutM(extensionIn, amount, recipient);
 472 |     |     }
 473 |     | 
 474 |     |     /* ============ Private View/Pure Functions ============ */
 475 |     | 
 476 |     |     /**
 477 |     |      * @dev    Returns the M Token balance of `account`.
 478 |     |      * @param  account The account being queried.
 479 |     |      * @return balance The M Token balance of the account.
 480 |     |      */
 481 | *   |     function _mBalanceOf(address account) internal view returns (uint256) {
 482 | *   |         return IMTokenLike(mToken).balanceOf(account);
 483 |     |     }
 484 |     | 
 485 |     |     /**
 486 |     |      * @dev   Reverts if `extension` is not an approved earner or an admin-approved extension.
 487 |     |      * @param extension Address of an extension.
 488 |     |      */
 489 | *   |     function _revertIfNotApprovedExtension(address extension) private view {
 490 | *   |         if (!isApprovedExtension(extension)) revert NotApprovedExtension(extension);
 491 |     |     }
 492 |     | 
 493 |     |     /**
 494 |     |      * @dev   Reverts if `extension` is a permissioned extension.
 495 |     |      *        A permissioned extension can only be swapped from/to M by an approved swapper.
 496 |     |      * @param extension Address of an extension.
 497 |     |      */
 498 | *   |     function _revertIfPermissionedExtension(address extension) private view {
 499 | *   |         if (isPermissionedExtension(extension)) revert PermissionedExtension(extension);
 500 |     |     }
 501 |     | 
 502 |     |     /**
 503 |     |      * @dev   Reverts if `swapper` is not an approved M token swapper.
 504 |     |      * @param extension Address of an extension.
 505 |     |      * @param swapper   Address of the swapper to check.
 506 |     |      */
 507 | *   |     function _revertIfNotApprovedSwapper(address extension, address swapper) private view {
 508 | *   |         if (isPermissionedExtension(extension)) {
 509 |     |             if (!isPermissionedMSwapper(extension, swapper)) revert NotApprovedPermissionedSwapper(extension, swapper);
 510 |     |         } else {
 511 | *   |             if (!isMSwapper(swapper)) revert NotApprovedSwapper(extension, swapper);
 512 |     |         }
 513 |     |     }
 514 |     | 
 515 |     |     /**
 516 |     |      * @dev   Reverts if `asset` is not an allowed asset in JMI Extension.
 517 |     |      * @param asset        Address of the asset to check.
 518 |     |      * @param extensionOut Address of the JMI Extension.
 519 |     |      */
 520 |     |     function _revertIfCannotJmi(address asset, address extensionOut) private view {
 521 |     |         try IJMIExtension(extensionOut).isAllowedAsset(asset) returns (bool allowed) {
 522 |     |             if (!allowed) revert InvalidSwapPath(asset, extensionOut);
 523 |     |         } catch {
 524 |     |             revert InvalidSwapPath(asset, extensionOut);
 525 |     |         }
 526 |     |     }
 527 |     | 
 528 |     |     /**
 529 |     |      * @dev    Checks if the given extension is an approved earner.
 530 |     |      * @param  extension Address of the extension to check.
 531 |     |      * @return True if the extension is an approved earner, false otherwise.
 532 |     |      */
 533 | *   |     function _isApprovedEarner(address extension) private view returns (bool) {
 534 | *   |         return
 535 | *   |             IRegistrarLike(registrar).get(EARNERS_LIST_IGNORED_KEY) != bytes32(0) ||
 536 |     |             IRegistrarLike(registrar).listContains(EARNERS_LIST_NAME, extension);
 537 |     |     }
 538 |     | }
 539 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/swap/UniswapV3SwapAdapter.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | import { IERC20 } from "../../lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
   6 |     | import { SafeERC20 } from "../../lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
   7 |     | import { AccessControl } from "../../lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/AccessControl.sol";
   8 |     | import { ReentrancyLock } from "../../lib/uniswap-v4-periphery/src/base/ReentrancyLock.sol";
   9 |     | 
  10 |     | import { IUniswapV3SwapAdapter } from "./interfaces/IUniswapV3SwapAdapter.sol";
  11 |     | import { ISwapFacility } from "./interfaces/ISwapFacility.sol";
  12 |     | import { IV3SwapRouter } from "./interfaces/uniswap/IV3SwapRouter.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @title  Uniswap V3 Swap Adapter
  16 |     |  * @author M0 Labs
  17 |     |  *         MetaStreet Foundation
  18 |     |  *         Adapted from https://github.com/metastreet-labs/metastreet-usdai-contracts/blob/main/src/swapAdapters/UniswapV3SwapAdapter.sol
  19 |     |  */
  20 | *   | contract UniswapV3SwapAdapter is IUniswapV3SwapAdapter, AccessControl, ReentrancyLock {
  21 |     |     using SafeERC20 for IERC20;
  22 |     | 
  23 |     |     /// @notice Fee for Uniswap V3 USDC - Wrapped $M pool.
  24 | *   |     uint24 internal constant UNISWAP_V3_FEE = 100;
  25 |     | 
  26 |     |     /// @notice Path address size
  27 |     |     uint256 internal constant PATH_ADDR_SIZE = 20;
  28 |     | 
  29 |     |     /// @notice Path fee size
  30 |     |     uint256 internal constant PATH_FEE_SIZE = 3;
  31 |     | 
  32 |     |     /// @notice Path next offset
  33 |     |     uint256 internal constant PATH_NEXT_OFFSET = PATH_ADDR_SIZE + PATH_FEE_SIZE;
  34 |     | 
  35 |     |     /// @notice Single pool path size
  36 |     |     uint256 internal constant PATH_SINGLE_POOL_SIZE = PATH_ADDR_SIZE + PATH_FEE_SIZE + PATH_ADDR_SIZE;
  37 |     | 
  38 |     |     /// @inheritdoc IUniswapV3SwapAdapter
  39 |     |     address public immutable wrappedMToken;
  40 |     | 
  41 |     |     /// @inheritdoc IUniswapV3SwapAdapter
  42 |     |     address public immutable swapFacility;
  43 |     | 
  44 |     |     /// @inheritdoc IUniswapV3SwapAdapter
  45 |     |     address public immutable uniswapRouter;
  46 |     | 
  47 |     |     /// @inheritdoc IUniswapV3SwapAdapter
  48 |     |     mapping(address token => bool whitelisted) public whitelistedToken;
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Constructs UniswapV3SwapAdapter contract
  52 |     |      * @param  wrappedMToken_      The address of Wrapped $M token.
  53 |     |      * @param  swapFacility_       The address of SwapFacility.
  54 |     |      * @param  uniswapRouter_      The address of the Uniswap V3 swap router.
  55 |     |      * @param  admin               The address of the admin.
  56 |     |      * @param  whitelistedTokens_  The list of whitelisted tokens.
  57 |     |      */
  58 | *   |     constructor(
  59 |     |         address wrappedMToken_,
  60 |     |         address swapFacility_,
  61 |     |         address uniswapRouter_,
  62 |     |         address admin,
  63 |     |         address[] memory whitelistedTokens_
  64 |     |     ) {
  65 | *   |         if ((wrappedMToken = wrappedMToken_) == address(0)) revert ZeroWrappedMToken();
  66 | *   |         if ((swapFacility = swapFacility_) == address(0)) revert ZeroSwapFacility();
  67 | *   |         if ((uniswapRouter = uniswapRouter_) == address(0)) revert ZeroUniswapRouter();
  68 |     | 
  69 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, admin);
  70 |     | 
  71 | *   |         for (uint256 i; i < whitelistedTokens_.length; ++i) {
  72 | *   |             _whitelistToken(whitelistedTokens_[i], true);
  73 |     |         }
  74 |     | 
  75 |     |         // Max approve SwapFacility and Uniswap Router to spend Wrapped $M to save gas
  76 | *   |         IERC20(wrappedMToken).approve(swapFacility, type(uint256).max);
  77 | *   |         IERC20(wrappedMToken).approve(uniswapRouter, type(uint256).max);
  78 |     |     }
  79 |     | 
  80 |     |     /// @inheritdoc IUniswapV3SwapAdapter
  81 | *   |     function swapIn(
  82 |     |         address tokenIn,
  83 |     |         uint256 amountIn,
  84 |     |         address extensionOut,
  85 |     |         uint256 minAmountOut,
  86 |     |         address recipient,
  87 |     |         bytes calldata path
  88 |     |     ) external isNotLocked {
  89 | *   |         _revertIfNotWhitelistedToken(tokenIn);
  90 | *   |         _revertIfZeroAmount(amountIn);
  91 | *   |         _revertIfInvalidSwapInPath(tokenIn, path);
  92 | *   |         _revertIfZeroRecipient(recipient);
  93 |     | 
  94 | *   |         uint256 tokenInBalanceBefore = IERC20(tokenIn).balanceOf(address(this));
  95 |     | 
  96 | *   |         IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);
  97 | *   |         IERC20(tokenIn).forceApprove(uniswapRouter, amountIn);
  98 |     | 
  99 |     |         // Swap tokenIn to Wrapped $M in Uniswap V3 pool
 100 | *   |         uint256 amountOut = IV3SwapRouter(uniswapRouter).exactInput(
 101 | *   |             IV3SwapRouter.ExactInputParams({
 102 |     |                 // If no path is provided, assume tokenIn - Wrapped $M pool with 0.01% fee
 103 | *   |                 path: path.length == 0 ? abi.encodePacked(tokenIn, UNISWAP_V3_FEE, wrappedMToken) : path,
 104 |     |                 // If extensionOut is Wrapped $M, transfer the output token directly to the recipient
 105 | *   |                 recipient: extensionOut == wrappedMToken ? recipient : address(this),
 106 | *   |                 amountIn: amountIn,
 107 | *   |                 amountOutMinimum: minAmountOut
 108 |     |             })
 109 |     |         );
 110 |     | 
 111 |     |         if (extensionOut != wrappedMToken) {
 112 |     |             // Swap the Wrapped $M to extensionOut
 113 |     |             ISwapFacility(swapFacility).swap(wrappedMToken, extensionOut, amountOut, recipient);
 114 |     |         }
 115 |     | 
 116 |     |         // NOTE: UniswapV3 router allows exactInput operation to not fully utilize
 117 |     |         //       the given input token amount if the pool does not have sufficient liquidity.
 118 |     |         //       Refund any remaining input token balance to the caller.
 119 |     |         uint256 remainingBalance = IERC20(tokenIn).balanceOf(address(this)) - tokenInBalanceBefore;
 120 |     |         if (remainingBalance > 0) {
 121 |     |             IERC20(tokenIn).safeTransfer(msg.sender, remainingBalance);
 122 |     |         }
 123 |     | 
 124 |     |         emit SwappedIn(tokenIn, amountIn, extensionOut, amountOut, recipient);
 125 |     |     }
 126 |     | 
 127 |     |     /// @inheritdoc IUniswapV3SwapAdapter
 128 | *   |     function swapOut(
 129 |     |         address extensionIn,
 130 |     |         uint256 amountIn,
 131 |     |         address tokenOut,
 132 |     |         uint256 minAmountOut,
 133 |     |         address recipient,
 134 |     |         bytes calldata path
 135 |     |     ) external isNotLocked {
 136 | *   |         _revertIfNotWhitelistedToken(tokenOut);
 137 | *   |         _revertIfZeroAmount(amountIn);
 138 | *   |         _revertIfInvalidSwapOutPath(tokenOut, path);
 139 | *   |         _revertIfZeroRecipient(recipient);
 140 |     | 
 141 | *   |         uint256 wrappedMBalanceBefore = IERC20(wrappedMToken).balanceOf(address(this));
 142 |     | 
 143 | *   |         IERC20(extensionIn).transferFrom(msg.sender, address(this), amountIn);
 144 |     | 
 145 |     |         // Swap the extensionIn to Wrapped $M token
 146 | *   |         if (extensionIn != wrappedMToken) {
 147 | *   |             IERC20(extensionIn).approve(address(swapFacility), amountIn);
 148 | *   |             ISwapFacility(swapFacility).swap(extensionIn, wrappedMToken, amountIn, address(this));
 149 |     | 
 150 |     |             // NOTE: added to support WrappedM V1 extension, should be removed in the future after upgrade to WrappedM V2.
 151 | *   |             amountIn = IERC20(wrappedMToken).balanceOf(address(this)) - wrappedMBalanceBefore;
 152 |     |         }
 153 |     | 
 154 |     |         // Swap Wrapped $M to tokenOut in Uniswap V3 pool
 155 | *   |         uint256 amountOut = IV3SwapRouter(uniswapRouter).exactInput(
 156 | *   |             IV3SwapRouter.ExactInputParams({
 157 |     |                 // If no path is provided, assume tokenOut - Wrapped $M pool with 0.01% fee
 158 | *   |                 path: path.length == 0 ? abi.encodePacked(wrappedMToken, UNISWAP_V3_FEE, tokenOut) : path,
 159 | *   |                 recipient: recipient,
 160 | *   |                 amountIn: amountIn,
 161 | *   |                 amountOutMinimum: minAmountOut
 162 |     |             })
 163 |     |         );
 164 |     | 
 165 |     |         // NOTE: UniswapV3 router allows exactInput operations to not fully utilize
 166 |     |         //       the given input token amount if the pool does not have sufficient liquidity.
 167 |     |         //       Refund any remaining input token balance to the caller.
 168 |     |         uint256 remainingBalance = IERC20(wrappedMToken).balanceOf(address(this)) - wrappedMBalanceBefore;
 169 |     |         if (remainingBalance > 0) {
 170 |     |             IERC20(wrappedMToken).transfer(msg.sender, remainingBalance);
 171 |     |         }
 172 |     | 
 173 |     |         emit SwappedOut(extensionIn, amountIn, tokenOut, amountOut, recipient);
 174 |     |     }
 175 |     | 
 176 |     |     /// @inheritdoc IUniswapV3SwapAdapter
 177 |     |     function whitelistToken(address token, bool isWhitelisted) external onlyRole(DEFAULT_ADMIN_ROLE) {
 178 |     |         _whitelistToken(token, isWhitelisted);
 179 |     |     }
 180 |     | 
 181 |     |     function msgSender() public view returns (address) {
 182 |     |         return _getLocker();
 183 |     |     }
 184 |     | 
 185 | *   |     function _whitelistToken(address token, bool isWhitelisted) private {
 186 | *   |         if (token == address(0)) revert ZeroToken();
 187 | *   |         if (whitelistedToken[token] == isWhitelisted) return;
 188 |     | 
 189 | *   |         whitelistedToken[token] = isWhitelisted;
 190 |     | 
 191 | *   |         emit TokenWhitelisted(token, isWhitelisted);
 192 |     |     }
 193 |     | 
 194 |     |     /**
 195 |     |      * @notice Decodes input and output tokens from the Uniswap V3 path.
 196 |     |      * @param  path            The UniswapV3 swap path.
 197 |     |      * @return decodedTokenIn  The address of the input token from the path.
 198 |     |      * @return decodedTokenOut The address of the output token from the path.
 199 |     |      */
 200 |     |     function _decodeAndValidatePathTokens(
 201 |     |         bytes calldata path
 202 |     |     ) internal pure returns (address decodedTokenIn, address decodedTokenOut) {
 203 |     |         // Validate path format
 204 |     |         if ((path.length < PATH_SINGLE_POOL_SIZE) || ((path.length - PATH_ADDR_SIZE) % PATH_NEXT_OFFSET != 0))
 205 |     |             revert InvalidPathFormat();
 206 |     | 
 207 |     |         decodedTokenIn = address(bytes20(path[:PATH_ADDR_SIZE]));
 208 |     | 
 209 |     |         // Calculate position of output token
 210 |     |         uint256 numberOfPools = (path.length - PATH_ADDR_SIZE) / PATH_NEXT_OFFSET;
 211 |     |         uint256 outputTokenIndex = numberOfPools * PATH_NEXT_OFFSET;
 212 |     | 
 213 |     |         decodedTokenOut = address(bytes20(path[outputTokenIndex:outputTokenIndex + PATH_ADDR_SIZE]));
 214 |     |     }
 215 |     | 
 216 |     |     /**
 217 |     |      * @dev   Reverts if not whitelisted token.
 218 |     |      * @param token Address of a token.
 219 |     |      */
 220 | *   |     function _revertIfNotWhitelistedToken(address token) internal view {
 221 | *   |         if (!whitelistedToken[token]) revert NotWhitelistedToken(token);
 222 |     |     }
 223 |     | 
 224 |     |     /**
 225 |     |      * @dev   Reverts if `recipient` is address(0).
 226 |     |      * @param recipient Address of a recipient.
 227 |     |      */
 228 | *   |     function _revertIfZeroRecipient(address recipient) internal pure {
 229 | *   |         if (recipient == address(0)) revert ZeroRecipient();
 230 |     |     }
 231 |     | 
 232 |     |     /**
 233 |     |      * @dev   Reverts if `amount` is equal to 0.
 234 |     |      * @param amount Amount of token.
 235 |     |      */
 236 | *   |     function _revertIfZeroAmount(uint256 amount) internal pure {
 237 | *   |         if (amount == 0) revert ZeroAmount();
 238 |     |     }
 239 |     | 
 240 |     |     /**
 241 |     |      * @notice Reverts if the swap path is invalid for swapping in.
 242 |     |      * @param  tokenIn The address of the input token provided in `swapIn` function.
 243 |     |      * @param  path    The Uniswap V3 swap path provided in `swapIn` function.
 244 |     |      */
 245 | *   |     function _revertIfInvalidSwapInPath(address tokenIn, bytes calldata path) internal view {
 246 | *   |         if (path.length != 0) {
 247 |     |             (address decodedTokenIn, address decodedTokenOut) = _decodeAndValidatePathTokens(path);
 248 |     |             if (decodedTokenIn != tokenIn || decodedTokenOut != wrappedMToken) revert InvalidPath();
 249 |     |         }
 250 |     |     }
 251 |     | 
 252 |     |     /**
 253 |     |      * @notice Reverts if the swap path is invalid for swapping out.
 254 |     |      * @param  tokenOut The address of the output token provided in `swapOut` function.
 255 |     |      * @param  path     The Uniswap V3 swap path provided in `swapOut` function.
 256 |     |      */
 257 | *   |     function _revertIfInvalidSwapOutPath(address tokenOut, bytes calldata path) internal view {
 258 | *   |         if (path.length != 0) {
 259 |     |             (address decodedTokenIn, address decodedTokenOut) = _decodeAndValidatePathTokens(path);
 260 |     |             if (decodedTokenIn != wrappedMToken || decodedTokenOut != tokenOut) revert InvalidPath();
 261 |     |         }
 262 |     |     }
 263 |     | }
 264 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/swap/interfaces/IReentrancyLock.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | 
  3 |     | pragma solidity 0.8.26;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  Reentrancy Lock for SwapFacility contract.
  7 |     |  * @author M0 Labs
  8 |     |  */
  9 |     | interface IReentrancyLock {
 10 |     |     /* ============ Events ============ */
 11 |     | 
 12 |     |     /**
 13 |     |      * @notice Emitted when a router is added to or removed from the list of trusted routers.
 14 |     |      * @param router  The address of the router.
 15 |     |      * @param trusted True if the router is trusted, false otherwise.
 16 |     |      */
 17 |     |     event TrustedRouterSet(address indexed router, bool trusted);
 18 |     | 
 19 |     |     /* ============ Custom Errors ============ */
 20 |     | 
 21 |     |     /// @notice Thrown if contract is already locked.
 22 |     |     error ContractLocked();
 23 |     | 
 24 |     |     /// @notice Thrown if the admin is 0x0.
 25 |     |     error ZeroAdmin();
 26 |     | 
 27 |     |     /// @notice Thrown if the router is 0x0.
 28 |     |     error ZeroRouter();
 29 |     | 
 30 |     |     /* ============ Interactive Functions ============ */
 31 |     | 
 32 |     |     /**
 33 |     |      * @notice Sets the trusted status of a router.
 34 |     |      * @param router The address of the router.
 35 |     |      * @param trusted The trusted status to set - `true` to add, `false` to remove router from the trusted list.
 36 |     |      */
 37 |     |     function setTrustedRouter(address router, bool trusted) external;
 38 |     | 
 39 |     |     /* ============ View/Pure Functions ============ */
 40 |     | 
 41 |     |     /**
 42 |     |      * @notice Returns whether a router is trusted or not.
 43 |     |      * @param router The address of the router.
 44 |     |      * @return trusted True if the router is trusted, false otherwise.
 45 |     |      */
 46 |     |     function isTrustedRouter(address router) external view returns (bool trusted);
 47 |     | }
 48 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/swap/interfaces/IRegistrarLike.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | 
  3 |     | pragma solidity 0.8.26;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  Subset of Registrar interface required for source contracts.
  7 |     |  * @author M0 Labs
  8 |     |  */
  9 |     | interface IRegistrarLike {
 10 |     |     /* ============ Interactive Functions ============ */
 11 |     | 
 12 |     |     /// @notice Adds `account` to `list`.
 13 |     |     function addToList(bytes32 list, address account) external;
 14 |     | 
 15 |     |     /// @notice Removes `account` from `list`.
 16 |     |     function removeFromList(bytes32 list, address account) external;
 17 |     | 
 18 |     |     /// @notice Sets the value of `key` to `value`.
 19 |     |     function setKey(bytes32 key, bytes32 value) external;
 20 |     | 
 21 |     |     /* ============ View/Pure Functions ============ */
 22 |     | 
 23 |     |     /// @notice Returns the value of `key`.
 24 |     |     function get(bytes32 key) external view returns (bytes32);
 25 |     | 
 26 |     |     /// @notice Returns whether `list` contains `account` or not.
 27 |     |     function listContains(bytes32 list, address account) external view returns (bool);
 28 |     | }
 29 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/swap/interfaces/ISwapFacility.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | /**
   6 |     |  * @title  Swap Facility interface.
   7 |     |  * @author M0 Labs
   8 |     |  */
   9 |     | interface ISwapFacility {
  10 |     |     /* ============ Events ============ */
  11 |     | 
  12 |     |     /**
  13 |     |      * @notice Emitted when $M Extension is swapped for another $M Extension.
  14 |     |      * @param extensionIn  The address of the input $M Extension.
  15 |     |      * @param extensionOut The address of the output $M Extension.
  16 |     |      * @param amount       The amount swapped.
  17 |     |      * @param recipient    The address to receive the output $M Extension token.
  18 |     |      */
  19 |     |     event Swapped(address indexed extensionIn, address indexed extensionOut, uint256 amount, address indexed recipient);
  20 |     | 
  21 |     |     /**
  22 |     |      * @notice Emitted when $M token is swapped for $M Extension.
  23 |     |      * @param extensionOut The address of the output $M Extension.
  24 |     |      * @param amount       The amount swapped.
  25 |     |      * @param recipient    The address to receive the output $M Extension token.
  26 |     |      */
  27 |     |     event SwappedInM(address indexed extensionOut, uint256 amount, address indexed recipient);
  28 |     | 
  29 |     |     /**
  30 |     |      * @notice Emitted when $M Extension is swapped for $M token.
  31 |     |      * @param extensionIn  The address of the input $M Extension.
  32 |     |      * @param amount       The amount swapped.
  33 |     |      * @param recipient    The address to receive the $M token.
  34 |     |      */
  35 |     |     event SwappedOutM(address indexed extensionIn, uint256 amount, address indexed recipient);
  36 |     | 
  37 |     |     /**
  38 |     |      * @notice Emitted when an $M Extension is set as permissioned or not.
  39 |     |      * @param  extension The address of an $M Extension.
  40 |     |      * @param  allowed   True if the extension is allowed, false otherwise.
  41 |     |      */
  42 |     |     event PermissionedExtensionSet(address indexed extension, bool allowed);
  43 |     | 
  44 |     |     /**
  45 |     |      * @notice Emitted when a `swapper` is allowed or not to swap the permissioned `extension` from/to M.
  46 |     |      * @param  extension The address of an $M extension.
  47 |     |      * @param  swapper   The address of the swapper.
  48 |     |      * @param  allowed   True if the swapper is allowed, false otherwise.
  49 |     |      */
  50 |     |     event PermissionedMSwapperSet(address indexed extension, address indexed swapper, bool allowed);
  51 |     | 
  52 |     |     /**
  53 |     |      * @notice Emitted when an $M Extension is admin approved or not.
  54 |     |      * @param  extension The address of an $M Extension.
  55 |     |      * @param  approved   True if the extension is approved, false otherwise.
  56 |     |      */
  57 |     |     event AdminApprovedExtensionSet(address indexed extension, bool approved);
  58 |     | 
  59 |     |     /**
  60 |     |      * @notice Emitted when $M token is swapped for JMI Extension.
  61 |     |      * @param  asset        The address of the asset.
  62 |     |      * @param  extensionOut The address of the JMI Extension.
  63 |     |      * @param  amount       The amount swapped.
  64 |     |      * @param  recipient    The address to receive the JMI Extension tokens.
  65 |     |      */
  66 |     |     event SwappedInJMI(address indexed asset, address indexed extensionOut, uint256 amount, address indexed recipient);
  67 |     | 
  68 |     |     /**
  69 |     |      * @notice Emitted when `asset` is replaced with $M for a JMI Extension.
  70 |     |      * @param  asset        The address of an asset.
  71 |     |      * @param  extensionOut The address of a JMI Extension.
  72 |     |      * @param  amount       The amount of $M tokens deposited to replace `asset`.
  73 |     |      */
  74 |     |     event JMIAssetReplaced(address indexed asset, address indexed extensionOut, uint256 amount);
  75 |     | 
  76 |     |     /* ============ Custom Errors ============ */
  77 |     | 
  78 |     |     /// @notice Thrown in the constructor if $M Token is 0x0.
  79 |     |     error ZeroMToken();
  80 |     | 
  81 |     |     /// @notice Thrown in the constructor if Registrar is 0x0.
  82 |     |     error ZeroRegistrar();
  83 |     | 
  84 |     |     /// @notice Thrown in `setPermissionedMSwapper()` if the $M extension is 0x0.
  85 |     |     error ZeroExtension();
  86 |     | 
  87 |     |     /// @notice Thrown in `setPermissionedMSwapper()` if the swapper is 0x0.
  88 |     |     error ZeroSwapper();
  89 |     | 
  90 |     |     /// @notice Thrown in `swap` functions if an extension is not a TTG approved earner.
  91 |     |     error NotApprovedExtension(address extension);
  92 |     | 
  93 |     |     /// @notice Thrown in `swap` if `swapper` is not approved to swap a permissioned `extension`.
  94 |     |     error NotApprovedPermissionedSwapper(address extension, address swapper);
  95 |     | 
  96 |     |     /// @notice Thrown in `swap` if `swapper` is not approved to swap the `extension`.
  97 |     |     error NotApprovedSwapper(address extension, address swapper);
  98 |     | 
  99 |     |     /// @notice Thrown in `swap` function if an extension is permissioned.
 100 |     |     error PermissionedExtension(address extension);
 101 |     | 
 102 |     |     /// @notice Thrown in `swap` function if the provided tokens do not represent a valid swap path.
 103 |     |     error InvalidSwapPath(address tokenIn, address tokenOut);
 104 |     | 
 105 |     |     /* ============ Interactive Functions ============ */
 106 |     | 
 107 |     |     /**
 108 |     |      * @notice Swaps between two tokens, which can be $M, $M Extensions, or an asset used by JMI Extensions.
 109 |     |      * @param  tokenIn      The address of the token to swap from.
 110 |     |      * @param  tokenOut     The address of the token to swap to.
 111 |     |      * @param  amount       The amount to swap.
 112 |     |      * @param  recipient    The address to receive the swapped tokens.
 113 |     |      */
 114 |     |     function swap(address tokenIn, address tokenOut, uint256 amount, address recipient) external;
 115 |     | 
 116 |     |     /**
 117 |     |      * @notice Swaps between two tokens using permit.
 118 |     |      * @param  tokenIn      The address of the token to swap from.
 119 |     |      * @param  tokenOut     The address of the token to swap to.
 120 |     |      * @param  amount       The amount to swap.
 121 |     |      * @param  recipient    The address to receive the swapped tokens.
 122 |     |      * @param  deadline     The last timestamp where the signature is still valid.
 123 |     |      * @param  v            An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 124 |     |      * @param  r            An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 125 |     |      * @param  s            An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 126 |     |      */
 127 |     |     function swapWithPermit(
 128 |     |         address tokenIn,
 129 |     |         address tokenOut,
 130 |     |         uint256 amount,
 131 |     |         address recipient,
 132 |     |         uint256 deadline,
 133 |     |         uint8 v,
 134 |     |         bytes32 r,
 135 |     |         bytes32 s
 136 |     |     ) external;
 137 |     | 
 138 |     |     /**
 139 |     |      * @notice Swaps between two tokens using permit.
 140 |     |      * @param  tokenIn      The address of the token to swap from.
 141 |     |      * @param  tokenOut     The address of the token to swap to.
 142 |     |      * @param  amount       The amount to swap.
 143 |     |      * @param  recipient    The address to receive the swapped tokens.
 144 |     |      * @param  deadline     The last timestamp where the signature is still valid.
 145 |     |      * @param  signature    An arbitrary signature (EIP-712).
 146 |     |      */
 147 |     |     function swapWithPermit(
 148 |     |         address tokenIn,
 149 |     |         address tokenOut,
 150 |     |         uint256 amount,
 151 |     |         address recipient,
 152 |     |         uint256 deadline,
 153 |     |         bytes calldata signature
 154 |     |     ) external;
 155 |     | 
 156 |     |     /**
 157 |     |      * @notice Swaps $M token to $M Extension.
 158 |     |      * @param  extensionOut The address of the M Extension to swap to.
 159 |     |      * @param  amount       The amount of $M token to swap.
 160 |     |      * @param  recipient    The address to receive the swapped $M Extension tokens.
 161 |     |      */
 162 |     |     function swapInM(address extensionOut, uint256 amount, address recipient) external;
 163 |     | 
 164 |     |     /**
 165 |     |      * @notice Swaps $M Extension to $M token.
 166 |     |      * @param  extensionIn The address of the $M Extension to swap from.
 167 |     |      * @param  amount      The amount of $M Extension tokens to swap.
 168 |     |      * @param  recipient   The address to receive $M tokens.
 169 |     |      */
 170 |     |     function swapOutM(address extensionIn, uint256 amount, address recipient) external;
 171 |     | 
 172 |     |     /**
 173 |     |      * @notice Replaces `amount` of `asset` held in a JMI Extension with $M.
 174 |     |      * @param  asset        The address of the asset.
 175 |     |      * @param  extensionIn  The address of an $M extension to unwrap $M from and replace `asset` with.
 176 |     |      * @param  extensionOut The address of a JMI Extension.
 177 |     |      * @param  amount       The amount of $M to replace.
 178 |     |      * @param  recipient    The address to receive `amount` of `asset` tokens.
 179 |     |      */
 180 |     |     function replaceAssetWithM(
 181 |     |         address asset,
 182 |     |         address extensionIn,
 183 |     |         address extensionOut,
 184 |     |         uint256 amount,
 185 |     |         address recipient
 186 |     |     ) external;
 187 |     | 
 188 |     |     /**
 189 |     |      * @notice Replaces `amount` of `asset` held in a JMI Extension with $M using permit.
 190 |     |      * @param  asset        The address of the asset.
 191 |     |      * @param  extensionIn  The address of an $M extension to unwrap $M from and replace `asset` with.
 192 |     |      * @param  extensionOut The address of a JMI Extension.
 193 |     |      * @param  amount       The amount of $M to replace.
 194 |     |      * @param  recipient    The address to receive `amount` of `asset` tokens.
 195 |     |      * @param  deadline     The last timestamp where the signature is still valid.
 196 |     |      * @param  v            An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 197 |     |      * @param  r            An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 198 |     |      * @param  s            An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 199 |     |      */
 200 |     |     function replaceAssetWithMWithPermit(
 201 |     |         address asset,
 202 |     |         address extensionIn,
 203 |     |         address extensionOut,
 204 |     |         uint256 amount,
 205 |     |         address recipient,
 206 |     |         uint256 deadline,
 207 |     |         uint8 v,
 208 |     |         bytes32 r,
 209 |     |         bytes32 s
 210 |     |     ) external;
 211 |     | 
 212 |     |     /**
 213 |     |      * @notice Replaces `amount` of `asset` held in a JMI Extension with $M using permit.
 214 |     |      * @param  asset        The address of the asset.
 215 |     |      * @param  extensionIn  The address of an $M extension to unwrap $M from and replace `asset` with.
 216 |     |      * @param  extensionOut The address of a JMI Extension.
 217 |     |      * @param  amount       The amount of $M to replace.
 218 |     |      * @param  recipient    The address to receive `amount` of `asset` tokens.
 219 |     |      * @param  deadline     The last timestamp where the signature is still valid.
 220 |     |      * @param  signature    An arbitrary signature (EIP-712).
 221 |     |      */
 222 |     |     function replaceAssetWithMWithPermit(
 223 |     |         address asset,
 224 |     |         address extensionIn,
 225 |     |         address extensionOut,
 226 |     |         uint256 amount,
 227 |     |         address recipient,
 228 |     |         uint256 deadline,
 229 |     |         bytes calldata signature
 230 |     |     ) external;
 231 |     | 
 232 |     |     /**
 233 |     |      * @notice Sets whether the `extension` is permissioned.
 234 |     |      * @dev    MUST only be callable by an address with the `DEFAULT_ADMIN_ROLE` role.
 235 |     |      * @param  extension    The address of an $M Extension.
 236 |     |      * @param  permissioned True if the extension is permissioned, false otherwise.
 237 |     |      */
 238 |     |     function setPermissionedExtension(address extension, bool permissioned) external;
 239 |     | 
 240 |     |     /**
 241 |     |      * @notice Sets whether `swapper` is allowed to swap the permissioned `extension` from/to M.
 242 |     |      * @dev    MUST only be callable by an address with the `DEFAULT_ADMIN_ROLE` role.
 243 |     |      * @param  extension The address of an extension to set permission for.
 244 |     |      * @param  swapper   The address of the swapper to set permission for.
 245 |     |      * @param  allowed   True if the swapper is allowed, false otherwise.
 246 |     |      */
 247 |     |     function setPermissionedMSwapper(address extension, address swapper, bool allowed) external;
 248 |     | 
 249 |     |     /**
 250 |     |      * @notice Sets whether the `extension` is admin approved.
 251 |     |      * @dev    MUST only be callable by an address with the `DEFAULT_ADMIN_ROLE` role.
 252 |     |      * @param  extension    The address of an $M Extension.
 253 |     |      * @param  approved True if the extension is admin approved, false otherwise.
 254 |     |      */
 255 |     |     function setAdminApprovedExtension(address extension, bool approved) external;
 256 |     | 
 257 |     |     /* ============ View/Pure Functions ============ */
 258 |     | 
 259 |     |     /// @notice The address of the $M Token contract.
 260 |     |     function mToken() external view returns (address);
 261 |     | 
 262 |     |     /// @notice The address of the Registrar.
 263 |     |     function registrar() external view returns (address);
 264 |     | 
 265 |     |     /**
 266 |     |      * @notice Returns the address that called `swap` or `swapM`
 267 |     |      * @dev    Must be used instead of `msg.sender` in $M Extensions contracts to get the original sender.
 268 |     |      */
 269 |     |     function msgSender() external view returns (address);
 270 |     | 
 271 |     |     /**
 272 |     |      * @notice Checks if the extension is permissioned.
 273 |     |      * @param  extension The extension address to check.
 274 |     |      * @return true if allowed, false otherwise.
 275 |     |      */
 276 |     |     function isPermissionedExtension(address extension) external view returns (bool);
 277 |     | 
 278 |     |     /**
 279 |     |      * @notice Checks if `swapper` is allowed to swap the permissioned extension from/to M.
 280 |     |      * @param  extension The $M extension address.
 281 |     |      * @param  swapper   The swapper address to check.
 282 |     |      * @return true if allowed, false otherwise.
 283 |     |      */
 284 |     |     function isPermissionedMSwapper(address extension, address swapper) external view returns (bool);
 285 |     | 
 286 |     |     /**
 287 |     |      * @notice Checks if `swapper` is allowed to swap the permissionless (common) extension from/to M.
 288 |     |      * @param  swapper   The swapper address to check.
 289 |     |      * @return true if allowed, false otherwise.
 290 |     |      */
 291 |     |     function isMSwapper(address swapper) external view returns (bool);
 292 |     | 
 293 |     |     /**
 294 |     |      * @notice Checks if the extension is admin approved.
 295 |     |      * @param  extension The extension address to check.
 296 |     |      * @return true if approved, false otherwise.
 297 |     |      */
 298 |     |     function isAdminApprovedExtension(address extension) external view returns (bool);
 299 |     | 
 300 |     |     /**
 301 |     |      * @notice Checks if the extension is approved (either as an earner or admin approved).
 302 |     |      * @param  extension The extension address to check.
 303 |     |      * @return true if approved, false otherwise.
 304 |     |      */
 305 |     |     function isApprovedExtension(address extension) external view returns (bool);
 306 |     | 
 307 |     |     /**
 308 |     |      * @notice Checks if `swapper` can swap between `tokenIn` and `tokenOut`.
 309 |     |      * @param  swapper   The address of the swapper.
 310 |     |      * @param  tokenIn   The address of the input token.
 311 |     |      * @param  tokenOut  The address of the output token.
 312 |     |      * @return true if can swap, false otherwise.
 313 |     |      */
 314 |     |     function canSwapViaPath(address swapper, address tokenIn, address tokenOut) external view returns (bool);
 315 |     | 
 316 |     |     /// @notice The parameter name in the Registrar that defines the earners list.
 317 |     |     function EARNERS_LIST_NAME() external pure returns (bytes32);
 318 |     | 
 319 |     |     /// @notice The parameter name in the Registrar that defines whether to ignore the earners list.
 320 |     |     function EARNERS_LIST_IGNORED_KEY() external pure returns (bytes32);
 321 |     | 
 322 |     |     /// @notice Swapper role for permissioned extensions.
 323 |     |     function M_SWAPPER_ROLE() external pure returns (bytes32);
 324 |     | }
 325 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/swap/interfaces/IUniswapV3SwapAdapter.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | /**
   6 |     |  * @title  UniswapV3 swap adapter interface.
   7 |     |  * @author M0 Labs
   8 |     |  *         MetaStreet Foundation
   9 |     |  *         Adapted from https://github.com/metastreet-labs/metastreet-usdai-contracts/blob/main/src/swapAdapters/UniswapV3SwapAdapter.sol
  10 |     |  */
  11 |     | interface IUniswapV3SwapAdapter {
  12 |     |     /* ============ Events ============ */
  13 |     | 
  14 |     |     /**
  15 |     |      * @notice Emitted when a token is swapped in for $M Extension.
  16 |     |      * @param tokenIn      The address of the input token.
  17 |     |      * @param amountIn     The amount of the input token swapped.
  18 |     |      * @param extensionOut The address of the output $M Extension.
  19 |     |      * @param amountOut    The amount of $M Extension tokens received from the swap.
  20 |     |      * @param recipient    The address to receive $M Extension tokens.
  21 |     |      */
  22 |     |     event SwappedIn(
  23 |     |         address indexed tokenIn,
  24 |     |         uint256 amountIn,
  25 |     |         address indexed extensionOut,
  26 |     |         uint256 amountOut,
  27 |     |         address indexed recipient
  28 |     |     );
  29 |     | 
  30 |     |     /**
  31 |     |      * @notice Emitted when $M Extension is swapped for a token.
  32 |     |      * @param extensionIn The address of the input $M Extension.
  33 |     |      * @param amountIn    The amount of the input $M Extension swapped.
  34 |     |      * @param tokenOut    The address of the output token.
  35 |     |      * @param amountOut   The amount of the output tokens received from the swap.
  36 |     |      * @param recipient   The address to receive output tokens.
  37 |     |      */
  38 |     |     event SwappedOut(
  39 |     |         address indexed extensionIn,
  40 |     |         uint256 amountIn,
  41 |     |         address indexed tokenOut,
  42 |     |         uint256 amountOut,
  43 |     |         address indexed recipient
  44 |     |     );
  45 |     | 
  46 |     |     /**
  47 |     |      * @notice Emitted when a token is added or removed from the whitelist.
  48 |     |      * @param token The address of the token.
  49 |     |      * @param isWhitelisted True if the token is whitelisted, false otherwise.
  50 |     |      */
  51 |     |     event TokenWhitelisted(address indexed token, bool isWhitelisted);
  52 |     | 
  53 |     |     /* ============ Custom Errors ============ */
  54 |     | 
  55 |     |     /// @notice Thrown in the constructor if Wrapped M Token is 0x0.
  56 |     |     error ZeroWrappedMToken();
  57 |     | 
  58 |     |     /// @notice Thrown in the constructor if SwapFacility is 0x0.
  59 |     |     error ZeroSwapFacility();
  60 |     | 
  61 |     |     /// @notice Thrown in the constructor if Uniswap Swap Router is 0x0.
  62 |     |     error ZeroUniswapRouter();
  63 |     | 
  64 |     |     /// @notice Thrown token address is 0x0.
  65 |     |     error ZeroToken();
  66 |     | 
  67 |     |     /// @notice Thrown if swap amount is 0.
  68 |     |     error ZeroAmount();
  69 |     | 
  70 |     |     /// @notice Thrown if recipient address is 0x0.
  71 |     |     error ZeroRecipient();
  72 |     | 
  73 |     |     /// @notice Thrown if the token is not whitelisted.
  74 |     |     error NotWhitelistedToken(address token);
  75 |     | 
  76 |     |     /// @notice Invalid path
  77 |     |     error InvalidPath();
  78 |     | 
  79 |     |     /// @notice Invalid path format
  80 |     |     error InvalidPathFormat();
  81 |     | 
  82 |     |     /* ============ Interactive Functions ============ */
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice Swaps an external token (e.g. USDC) to $M Extension token using Uniswap pool.
  86 |     |      * @param  tokenIn      The address of the external token to swap from.
  87 |     |      * @param  amountIn     The amount of external tokens to swap.
  88 |     |      * @param  extensionOut The address of the $M Extension to swap to.
  89 |     |      * @param  minAmountOut The minimum amount of $M Extension tokens to receive.
  90 |     |      * @param  recipient    The address to receive $M Extension tokens.
  91 |     |      * @param  path         The Uniswap path. Could be empty for direct pairs.
  92 |     |      */
  93 |     |     function swapIn(
  94 |     |         address tokenIn,
  95 |     |         uint256 amountIn,
  96 |     |         address extensionOut,
  97 |     |         uint256 minAmountOut,
  98 |     |         address recipient,
  99 |     |         bytes calldata path
 100 |     |     ) external;
 101 |     | 
 102 |     |     /**
 103 |     |      * @notice Swaps $M Extension token to an external token (e.g. USDC) using Uniswap pool.
 104 |     |      * @param  extensionIn  The address of the $M Extension to swap from.
 105 |     |      * @param  amountIn     The amount of $M Extension tokens to swap.
 106 |     |      * @param  tokenOut     The address of the external token to swap to.
 107 |     |      * @param  minAmountOut The minimum amount of external tokens to receive.
 108 |     |      * @param  recipient    The address to receive external tokens.
 109 |     |      * @param  path         The Uniswap path. Could be empty for direct pairs.
 110 |     |      */
 111 |     |     function swapOut(
 112 |     |         address extensionIn,
 113 |     |         uint256 amountIn,
 114 |     |         address tokenOut,
 115 |     |         uint256 minAmountOut,
 116 |     |         address recipient,
 117 |     |         bytes calldata path
 118 |     |     ) external;
 119 |     | 
 120 |     |     /**
 121 |     |      * @notice Adds or removes a token from the whitelist of tokens that can be used in Uniswap path.
 122 |     |      * @param  token         The address of the token.
 123 |     |      * @param  isWhitelisted True to whitelist the token, false otherwise.
 124 |     |      */
 125 |     |     function whitelistToken(address token, bool isWhitelisted) external;
 126 |     | 
 127 |     |     /* ============ View/Pure Functions ============ */
 128 |     | 
 129 |     |     /// @notice The address of Wrapped M token.
 130 |     |     function wrappedMToken() external view returns (address wrappedMToken);
 131 |     | 
 132 |     |     /// @notice The address of SwapFacility.
 133 |     |     function swapFacility() external view returns (address swapFacility);
 134 |     | 
 135 |     |     /// @notice The address of the Uniswap V3 swap router.
 136 |     |     function uniswapRouter() external view returns (address uniswapRouter);
 137 |     | 
 138 |     |     /**
 139 |     |      * @notice Indicates whether `token` is whitelisted to be used in Uniswap path.
 140 |     |      * @param  token         The address of the token.
 141 |     |      * @return isWhitelisted True if the token is whitelisted, false otherwise.
 142 |     |      */
 143 |     |     function whitelistedToken(address token) external view returns (bool isWhitelisted);
 144 |     | }
 145 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/src/swap/interfaces/uniswap/IV3SwapRouter.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity 0.8.26;
  3 |     | 
  4 |     | /// @title Router token swapping functionality
  5 |     | /// @notice Functions for swapping tokens via Uniswap V3
  6 |     | interface IV3SwapRouter {
  7 |     |     struct ExactInputParams {
  8 |     |         bytes path;
  9 |     |         address recipient;
 10 |     |         uint256 amountIn;
 11 |     |         uint256 amountOutMinimum;
 12 |     |     }
 13 |     | 
 14 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
 15 |     |     /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,
 16 |     |     /// and swap the entire amount, enabling contracts to send tokens before calling this function.
 17 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
 18 |     |     /// @return amountOut The amount of the received token
 19 |     |     function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);
 20 |     | }
 21 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/Fuzz.sol
  1 |     | // SPDX-License-Identifier: UNTITLED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./FuzzGuided.sol";
  5 |     | 
  6 | *r  | contract Fuzz is FuzzGuided {
  7 |     |     constructor() payable {
  8 | *   |         fuzzSetup();
  9 |     |     }
 10 |     | }
 11 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/FuzzGuided.sol
  1 |     | // SPDX-License-Identifier: UNTITLED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./FuzzMYieldToOne.sol";
  5 |     | import "./FuzzMEarnerManager.sol";
  6 |     | import "./FuzzMYieldFee.sol";
  7 |     | import "./FuzzSwapFacility.sol";
  8 |     | import "./FuzzMToken.sol";
  9 |     | import "./FuzzUni.sol";
 10 |     | import "./FuzzJMIExtension.sol";
 11 |     | 
 12 |     | contract FuzzGuided is FuzzUni, FuzzMYieldToOne, FuzzMEarnerManager, FuzzMYieldFee, FuzzSwapFacility, FuzzMToken, FuzzJMIExtension {
 13 | *   |     function fuzz_randomizeConfigs(
 14 |     |         uint256 baseEarnerRateSeed,
 15 |     |         uint256 baseMinterRateSeed,
 16 |     |         uint256 updateCollateralIntervalSeed,
 17 |     |         uint256 mintRatioSeed,
 18 |     |         uint256 penaltyRateSeed,
 19 |     |         uint256 minterFreezeTimeSeed
 20 |     |     ) public {
 21 | *r  |         require(!protocolSet);
 22 |     | 
 23 | *   |         if (baseEarnerRateSeed % 5 == 0) {
 24 | *   |             registrar.updateConfig(
 25 | *   |                 MAX_EARNER_RATE,
 26 | *   |                 fl.clamp(baseEarnerRateSeed, 0, ContinuousIndexingMath.BPS_SCALED_ONE, true)
 27 |     |             );
 28 | *   |             registrar.updateConfig(
 29 | *   |                 BASE_MINTER_RATE,
 30 | *   |                 fl.clamp(baseMinterRateSeed, 0, ContinuousIndexingMath.BPS_SCALED_ONE, true)
 31 |     |             );
 32 | *   |             registrar.updateConfig(TTGRegistrarReader.EARNER_RATE_MODEL, address(earnerRateModel));
 33 | *   |             registrar.updateConfig(TTGRegistrarReader.MINTER_RATE_MODEL, address(minterRateModel));
 34 | *   |             registrar.updateConfig(TTGRegistrarReader.UPDATE_COLLATERAL_VALIDATOR_THRESHOLD, 1);
 35 |     | 
 36 | *   |             registrar.updateConfig(TTGRegistrarReader.UPDATE_COLLATERAL_INTERVAL, updateCollateralIntervalSeed);
 37 | *   |             registrar.updateConfig(TTGRegistrarReader.MINT_DELAY, _mintDelay); //zeroes
 38 | *   |             registrar.updateConfig(TTGRegistrarReader.MINT_TTL, _mintTtl);
 39 | *   |             registrar.updateConfig(TTGRegistrarReader.MINT_RATIO, fl.clamp(mintRatioSeed, 0, 10_000, true));
 40 | *   |             registrar.updateConfig(TTGRegistrarReader.PENALTY_RATE, fl.clamp(penaltyRateSeed, 0, 10_000, true));
 41 | *   |             registrar.updateConfig(
 42 | *   |                 TTGRegistrarReader.MINTER_FREEZE_TIME,
 43 | *   |                 fl.clamp(minterFreezeTimeSeed, 0, 24 hours, true)
 44 |     |             );
 45 |     |         } else {
 46 |     |             // DEFAULT VALUES
 47 |     |             // uint32 internal _baseEarnerRate = ContinuousIndexingMath.BPS_SCALED_ONE / 10; // 10% APY
 48 |     |             // uint32 internal _baseMinterRate = ContinuousIndexingMath.BPS_SCALED_ONE / 10; // 10% APY
 49 |     |             // uint256 internal _updateInterval = 24 hours;
 50 |     |             // uint256 internal _mintDelay = 0;
 51 |     |             // uint256 internal _mintTtl = 0;
 52 |     |             // uint256 internal _mintRatio = 9_000; // 90%
 53 |     |             // uint32 internal _penaltyRate = 100; // 1%, bps
 54 |     |             // uint32 internal _minterFreezeTime = 24 hours;
 55 |     | 
 56 | *   |             registrar.updateConfig(MAX_EARNER_RATE, _baseEarnerRate);
 57 | *   |             registrar.updateConfig(BASE_MINTER_RATE, _baseMinterRate);
 58 | *   |             registrar.updateConfig(TTGRegistrarReader.EARNER_RATE_MODEL, address(earnerRateModel));
 59 | *   |             registrar.updateConfig(TTGRegistrarReader.MINTER_RATE_MODEL, address(minterRateModel));
 60 | *   |             registrar.updateConfig(TTGRegistrarReader.UPDATE_COLLATERAL_VALIDATOR_THRESHOLD, 1);
 61 | *   |             registrar.updateConfig(TTGRegistrarReader.UPDATE_COLLATERAL_INTERVAL, _updateInterval);
 62 | *   |             registrar.updateConfig(TTGRegistrarReader.MINT_DELAY, _mintDelay);
 63 | *   |             registrar.updateConfig(TTGRegistrarReader.MINT_TTL, _mintTtl);
 64 | *   |             registrar.updateConfig(TTGRegistrarReader.MINT_RATIO, _mintRatio);
 65 | *   |             registrar.updateConfig(TTGRegistrarReader.PENALTY_RATE, _penaltyRate);
 66 | *   |             registrar.updateConfig(TTGRegistrarReader.MINTER_FREEZE_TIME, _minterFreezeTime);
 67 |     |         }
 68 |     | 
 69 | *   |         protocolSet = true;
 70 |     |     }
 71 |     | }
 72 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/FuzzJMIExtension.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./helpers/preconditions/PreconditionsJMIExtension.sol";
   5 |     | import "./helpers/postconditions/PostconditionsJMIExtension.sol";
   6 |     | 
   7 |     | contract FuzzJMIExtension is PreconditionsJMIExtension, PostconditionsJMIExtension {
   8 |     |     // JMI-specific wrap with asset
   9 |     |     function fuzz_wrapAsset_JMI(uint256 seed) public setCurrentActor {
  10 |     |         WrapAssetParams memory params = wrapAssetPreconditions_JMI(seed);
  11 |     | 
  12 |     |         _before();
  13 |     | 
  14 |     |         (bool success, bytes memory returnData) = _wrapAssetCall(
  15 |     |             params.instance,
  16 |     |             params.asset,
  17 |     |             params.recipient,
  18 |     |             params.amount
  19 |     |         );
  20 |     | 
  21 |     |         wrapAssetPostconditions_JMI(success, returnData);
  22 |     |     }
  23 |     | 
  24 |     |     // Replace asset with M
  25 |     |     function fuzz_replaceAssetWithM_JMI(uint256 seed) public setCurrentActor {
  26 |     |         ReplaceAssetWithMParams memory params = replaceAssetWithMPreconditions_JMI(seed);
  27 |     | 
  28 |     |         _before();
  29 |     | 
  30 |     |         (bool success, bytes memory returnData) = _replaceAssetWithMCall(
  31 |     |             params.instance,
  32 |     |             params.asset,
  33 |     |             params.recipient,
  34 |     |             params.amount
  35 |     |         );
  36 |     | 
  37 |     |         replaceAssetWithMPostconditions_JMI(success, returnData);
  38 |     |     }
  39 |     | 
  40 |     |     // Set asset cap
  41 |     |     function fuzz_setAssetCap_JMI(uint256 seed) public setCurrentActor {
  42 |     |         SetAssetCapParams memory params = setAssetCapPreconditions_JMI(seed);
  43 |     | 
  44 |     |         _before();
  45 |     | 
  46 |     |         (bool success, bytes memory returnData) = _setAssetCapCall(
  47 |     |             params.instance,
  48 |     |             params.asset,
  49 |     |             params.cap
  50 |     |         );
  51 |     | 
  52 |     |         setAssetCapPostconditions_JMI(success, returnData);
  53 |     |     }
  54 |     | 
  55 |     |     // Pause
  56 |     |     function fuzz_pause_JMI(uint256 seed) public setCurrentActor {
  57 |     |         PauseParams memory params = pausePreconditions_JMI(seed);
  58 |     | 
  59 |     |         _before();
  60 |     | 
  61 |     |         (bool success, bytes memory returnData) = _pauseCall(params.instance);
  62 |     | 
  63 |     |         pausePostconditions_JMI(success, returnData);
  64 |     |     }
  65 |     | 
  66 |     |     // Unpause
  67 |     |     function fuzz_unpause_JMI(uint256 seed) public setCurrentActor {
  68 |     |         PauseParams memory params = unpausePreconditions_JMI(seed);
  69 |     | 
  70 |     |         _before();
  71 |     | 
  72 |     |         (bool success, bytes memory returnData) = _unpauseCall(params.instance);
  73 |     | 
  74 |     |         unpausePostconditions_JMI(success, returnData);
  75 |     |     }
  76 |     | 
  77 |     |     // Freeze
  78 |     |     function fuzz_freeze_JMI(uint256 seed) public setCurrentActor {
  79 |     |         FreezeParams memory params = freezePreconditions_JMI(seed);
  80 |     | 
  81 |     |         _before();
  82 |     | 
  83 |     |         (bool success, bytes memory returnData) = _freezeCall(params.instance, params.account);
  84 |     | 
  85 |     |         freezePostconditions_JMI(success, returnData);
  86 |     |     }
  87 |     | 
  88 |     |     // Unfreeze
  89 |     |     function fuzz_unfreeze_JMI(uint256 seed) public setCurrentActor {
  90 |     |         FreezeParams memory params = unfreezePreconditions_JMI(seed);
  91 |     | 
  92 |     |         _before();
  93 |     | 
  94 |     |         (bool success, bytes memory returnData) = _unfreezeCall(params.instance, params.account);
  95 |     | 
  96 |     |         unfreezePostconditions_JMI(success, returnData);
  97 |     |     }
  98 |     | 
  99 |     |     // Claim yield (JMI inherits from MYieldToOne)
 100 |     |     function fuzz_claimYield_JMI(uint256 seed) public setCurrentActor {
 101 |     |         ClaimYieldParams memory params = claimYieldPreconditions_JMI(seed);
 102 |     | 
 103 |     |         _before();
 104 |     | 
 105 |     |         (bool success, bytes memory returnData) = _claimYieldCall(params.instance);
 106 |     | 
 107 |     |         claimYieldPostconditions_JMI(success, returnData);
 108 |     |     }
 109 |     | 
 110 |     |     // Transfer (JMI is ERC20)
 111 |     |     function fuzz_transfer_JMI(uint256 seed) public setCurrentActor {
 112 |     |         TransferParams memory params = transferPreconditions_JMI(seed);
 113 |     | 
 114 |     |         _before();
 115 |     | 
 116 |     |         (bool success, bytes memory returnData) = _transferCall(params.instance, params.to, params.amount);
 117 |     | 
 118 |     |         transferPostconditions_JMI(success, returnData);
 119 |     |     }
 120 |     | 
 121 |     |     // Approve (JMI is ERC20)
 122 |     |     function fuzz_approve_JMI(uint256 seed) public setCurrentActor {
 123 |     |         ApproveParams memory params = approvePreconditions_JMI(seed);
 124 |     | 
 125 |     |         _before();
 126 |     | 
 127 |     |         (bool success, bytes memory returnData) = _approveCall(params.instance, params.spender, params.amount);
 128 |     | 
 129 |     |         approvePostconditions_JMI(success, returnData);
 130 |     |     }
 131 |     | }
 132 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/FuzzMEarnerManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./helpers/preconditions/PreconditionsMEarnerManager.sol";
  5 |     | import "./helpers/postconditions/PostconditionsMEarnerManager.sol";
  6 |     | 
  7 |     | contract FuzzMEarnerManager is PreconditionsMEarnerManager, PostconditionsMEarnerManager {
  8 | *   |     function fuzz_setAccountInfo_MEarnerManager(uint256 seed, bool statusSeed) public setCurrentActor {
  9 | *   |         SetAccountInfoParams memory params = setAccountInfoPreconditions(seed, statusSeed);
 10 |     | 
 11 | *   |         _before();
 12 |     | 
 13 | *   |         (bool success, bytes memory returnData) = _setAccountInfoCall(
 14 | *   |             params.instance,
 15 | *   |             params.account,
 16 | *   |             params.status,
 17 | *   |             params.feeRate
 18 |     |         );
 19 |     | 
 20 | *   |         setAccountInfoPostconditions(success, returnData);
 21 |     |     }
 22 |     | 
 23 | *   |     function fuzz_setFeeRecipient_MEarnerManager(uint256 seed) public setCurrentActor {
 24 | *   |         SetFeeRecipientParams memory params = setFeeRecipientPreconditions_MEarnerManager(seed);
 25 |     | 
 26 | *   |         _before();
 27 |     | 
 28 | *   |         (bool success, bytes memory returnData) = _setFeeRecipientCall(params.instance, params.feeRecipient);
 29 |     | 
 30 | *   |         setFeeRecipientPostconditions_MEarnerManager(success, returnData);
 31 |     |     }
 32 |     | 
 33 | *   |     function fuzz_claimFor_MEarnerManager(uint256 seed) public setCurrentActor {
 34 | *   |         ClaimForParams memory params = claimForPreconditions(seed);
 35 |     | 
 36 | *   |         _before();
 37 |     | 
 38 | *   |         (bool success, bytes memory returnData) = _claimForCall(params.instance, params.account);
 39 |     | 
 40 | *   |         claimForPostconditions(success, returnData);
 41 |     |     }
 42 |     | 
 43 | *   |     function fuzz_approve_MEarnerManager(uint256 seed) public setCurrentActor {
 44 | *   |         ApproveParams memory params = approvePreconditions_MEarnerManager(seed);
 45 |     | 
 46 | *   |         _before();
 47 |     | 
 48 | *   |         (bool success, bytes memory returnData) = _approveCall(params.instance, params.spender, params.amount);
 49 |     | 
 50 | *   |         approvePostconditions_MEarnerManager(success, returnData);
 51 |     |     }
 52 |     | 
 53 | *   |     function fuzz_transfer_MEarnerManager(uint256 seed) public setCurrentActor {
 54 | *   |         TransferParams memory params = transferPreconditions_MEarnerManager(seed);
 55 |     | 
 56 | *   |         _before();
 57 |     | 
 58 | *   |         (bool success, bytes memory returnData) = _transferCall(params.instance, params.to, params.amount);
 59 |     | 
 60 | *   |         transferPostconditions_MEarnerManager(success, returnData);
 61 |     |     }
 62 |     | 
 63 | *   |     function fuzz_transferFrom_MEarnerManager(uint256 seed) public setCurrentActor {
 64 | *   |         TransferFromParams memory params = transferFromPreconditions_MEarnerManager(seed);
 65 |     | 
 66 | *   |         _before();
 67 |     | 
 68 | *   |         (bool success, bytes memory returnData) = _transferFromCall(
 69 | *   |             params.instance,
 70 | *   |             params.from,
 71 | *   |             params.to,
 72 | *   |             params.amount
 73 |     |         );
 74 |     | 
 75 | *   |         transferFromPostconditions_MEarnerManager(success, returnData);
 76 |     |     }
 77 |     | 
 78 | *   |     function fuzz_enableEarning_MEarnerManager(uint256 seed) public setCurrentActor {
 79 | *   |         address instance = enableEarningPreconditions_MEarnerManager(seed);
 80 |     | 
 81 | *   |         _before();
 82 |     | 
 83 | *   |         (bool success, bytes memory returnData) = _enableEarningCall(instance);
 84 |     | 
 85 | *   |         enableEarningPostconditions_MEarnerManager(success, returnData);
 86 |     |     }
 87 |     | 
 88 | *   |     function fuzz_disableEarning_MEarnerManager(uint256 seed) public setCurrentActor {
 89 | *   |         address instance = disableEarningPreconditions_MEarnerManager(seed);
 90 |     | 
 91 | *   |         _before();
 92 |     | 
 93 | *   |         (bool success, bytes memory returnData) = _disableEarningCall(instance);
 94 |     | 
 95 | *   |         disableEarningPostconditions_MEarnerManager(success, returnData);
 96 |     |     }
 97 |     | }
 98 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/FuzzMToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./helpers/preconditions/PreconditionsMToken.sol";
  5 |     | import "./helpers/postconditions/PostconditionsMToken.sol";
  6 |     | 
  7 |     | contract FuzzMToken is PreconditionsMToken, PostconditionsMToken {
  8 | *   |     function fuzz_mint(uint256 seed) public setCurrentActor {
  9 | *   |         (address account, uint256 amount) = mintPreconditions(seed);
 10 |     | 
 11 | *   |         _before();
 12 |     | 
 13 | *   |         mintMToken(account, amount);
 14 |     | 
 15 | *   |         mintPostconditions(account, amount);
 16 |     |     }
 17 |     | 
 18 | *   |     function fuzz_warpDays(uint256 days_) public {
 19 | *   |         _before();
 20 | *   |         days_ = fl.clamp(days_, 1, 365);
 21 | *   |         vm.warp(block.timestamp + days_ * 1 days);
 22 | *   |         vm.roll(block.number + days_ * 1000);
 23 | *   |         warpDaysPostconditions();
 24 |     |     }
 25 |     | 
 26 | *   |     function fuzz_warpWeeks(uint256 weeks_) public {
 27 | *   |         _before();
 28 | *   |         weeks_ = fl.clamp(weeks_, 1, 10);
 29 | *   |         vm.warp(block.timestamp + weeks_ * 1 weeks);
 30 | *   |         vm.roll(block.number + weeks_ * 1000);
 31 | *   |         warpWeeksPostconditions(weeks_);
 32 |     |     }
 33 |     | }
 34 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/FuzzMYieldFee.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./helpers/preconditions/PreconditionsMYieldFee.sol";
   5 |     | import "./helpers/postconditions/PostconditionsMYieldFee.sol";
   6 |     | 
   7 |     | contract FuzzMYieldFee is PreconditionsMYieldFee, PostconditionsMYieldFee {
   8 | *   |     function fuzz_claimYieldFor_MYieldFee(uint256 seed) public setCurrentActor {
   9 | *   |         ClaimYieldForParams memory params = claimYieldForPreconditions(seed);
  10 |     | 
  11 | *   |         _before();
  12 |     | 
  13 | *   |         (bool success, bytes memory returnData) = _claimYieldForCall(params.instance, params.account);
  14 |     | 
  15 | *   |         claimYieldForPostconditions(success, returnData);
  16 |     |     }
  17 |     | 
  18 | *   |     function fuzz_claimFee_MYieldFee(uint256 seed) public setCurrentActor {
  19 | *   |         ClaimFeeParams memory params = claimFeePreconditions(seed);
  20 |     | 
  21 | *   |         _before();
  22 |     | 
  23 | *   |         (bool success, bytes memory returnData) = _claimFeeCall(params.instance);
  24 |     | 
  25 | *   |         claimFeePostconditions(success, returnData);
  26 |     |     }
  27 |     | 
  28 | *   |     function fuzz_updateIndex_MYieldFee(uint256 seed) public setCurrentActor {
  29 | *   |         UpdateIndexParams memory params = updateIndexPreconditions(seed);
  30 |     | 
  31 | *   |         _before();
  32 |     | 
  33 | *   |         (bool success, bytes memory returnData) = _updateIndexCall(params.instance);
  34 |     | 
  35 | *   |         updateIndexPostconditions(success, returnData);
  36 |     |     }
  37 |     | 
  38 | *   |     function fuzz_setFeeRate_MYieldFee(uint256 seed) public setCurrentActor {
  39 | *   |         SetFeeRateParams memory params = setFeeRatePreconditions(seed);
  40 |     | 
  41 | *   |         _before();
  42 |     | 
  43 | *   |         (bool success, bytes memory returnData) = _setFeeRateCall(params.instance, params.feeRate);
  44 |     | 
  45 | *   |         setFeeRatePostconditions(success, returnData);
  46 |     |     }
  47 |     | 
  48 | *   |     function fuzz_setFeeRecipient_MYieldFee(uint256 seed) public setCurrentActor {
  49 | *   |         SetFeeRecipientParams memory params = setFeeRecipientPreconditions(seed);
  50 |     | 
  51 | *   |         _before();
  52 |     | 
  53 | *   |         (bool success, bytes memory returnData) = _setFeeRecipientCall_MYieldFee(params.instance, params.feeRecipient);
  54 |     | 
  55 | *   |         setFeeRecipientPostconditions_MYieldFee(success, returnData);
  56 |     |     }
  57 |     | 
  58 | *   |     function fuzz_setClaimRecipient_MYieldFee(uint256 seed) public setCurrentActor {
  59 | *   |         SetClaimRecipientParams memory params = setClaimRecipientPreconditions(seed);
  60 |     | 
  61 | *   |         _before();
  62 |     | 
  63 | *   |         (bool success, bytes memory returnData) = _setClaimRecipientCall(
  64 | *   |             params.instance,
  65 | *   |             params.account,
  66 | *   |             params.claimRecipient
  67 |     |         );
  68 |     | 
  69 | *   |         setClaimRecipientPostconditions(success, returnData);
  70 |     |     }
  71 |     | 
  72 | *   |     function fuzz_enableEarning_MYieldFee(uint256 seed) public setCurrentActor {
  73 | *   |         address instance = enableEarningPreconditions_MYieldFee(seed);
  74 |     | 
  75 | *   |         _before();
  76 |     | 
  77 | *   |         (bool success, bytes memory returnData) = _enableEarningCall(instance);
  78 |     | 
  79 | *   |         enableEarningPostconditions_MYieldFee(success, returnData);
  80 |     |     }
  81 |     | 
  82 | *   |     function fuzz_disableEarning_MYieldFee(uint256 seed) public setCurrentActor {
  83 | *   |         address instance = disableEarningPreconditions_MYieldFee(seed);
  84 |     | 
  85 | *   |         _before();
  86 |     | 
  87 | *   |         (bool success, bytes memory returnData) = _disableEarningCall(instance);
  88 |     | 
  89 | *   |         disableEarningPostconditions_MYieldFee(success, returnData);
  90 |     |     }
  91 |     | 
  92 | *   |     function fuzz_approve_MYieldFee(uint256 seed) public setCurrentActor {
  93 | *   |         ApproveParams memory params = approvePreconditions_MYieldFee(seed);
  94 |     | 
  95 | *   |         _before();
  96 |     | 
  97 | *   |         (bool success, bytes memory returnData) = _approveCall(params.instance, params.spender, params.amount);
  98 |     | 
  99 | *   |         approvePostconditions_MYieldFee(success, returnData);
 100 |     |     }
 101 |     | 
 102 | *   |     function fuzz_transfer_MYieldFee(uint256 seed) public setCurrentActor {
 103 | *   |         TransferParams memory params = transferPreconditions_MYieldFee(seed);
 104 |     | 
 105 | *   |         _before();
 106 |     | 
 107 | *   |         (bool success, bytes memory returnData) = _transferCall(params.instance, params.to, params.amount);
 108 |     | 
 109 | *   |         transferPostconditions_MYieldFee(success, returnData);
 110 |     |     }
 111 |     | 
 112 | *   |     function fuzz_transferFrom_MYieldFee(uint256 seed) public setCurrentActor {
 113 | *   |         TransferFromParams memory params = transferFromPreconditions_MYieldFee(seed);
 114 |     | 
 115 | *   |         _before();
 116 |     | 
 117 | *   |         (bool success, bytes memory returnData) = _transferFromCall(
 118 | *   |             params.instance,
 119 | *   |             params.from,
 120 | *   |             params.to,
 121 | *   |             params.amount
 122 |     |         );
 123 |     | 
 124 | *   |         transferFromPostconditions_MYieldFee(success, returnData);
 125 |     |     }
 126 |     | }
 127 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/FuzzMYieldToOne.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./helpers/preconditions/PreconditionsMYieldToOne.sol";
  5 |     | import "./helpers/postconditions/PostconditionsMYieldToOne.sol";
  6 |     | 
  7 |     | contract FuzzMYieldToOne is PreconditionsMYieldToOne, PostconditionsMYieldToOne {
  8 | *   |     function fuzz_claimYield_MYieldToOne(uint256 seed) public setCurrentActor {
  9 | *   |         ClaimYieldParams memory params = claimYieldPreconditions(seed);
 10 |     | 
 11 | *   |         _before();
 12 |     | 
 13 | *   |         (bool success, bytes memory returnData) = _claimYieldCall(params.instance);
 14 |     | 
 15 | *   |         claimYieldPostconditions(success, returnData);
 16 |     |     }
 17 |     | 
 18 | *   |     function fuzz_setYieldRecipient_MYieldToOne(uint256 seed) public setCurrentActor {
 19 | *   |         SetYieldRecipientParams memory params = setYieldRecipientPreconditions_MYieldToOne(seed);
 20 |     | 
 21 | *   |         _before();
 22 |     | 
 23 | *   |         (bool success, bytes memory returnData) = _setYieldRecipientCall(params.instance, params.yieldRecipient);
 24 |     | 
 25 | *   |         setYieldRecipientPostconditions_MYieldToOne(success, returnData);
 26 |     |     }
 27 |     | 
 28 | *   |     function fuzz_enableEarning_MYieldToOne(uint256 seed) public setCurrentActor {
 29 | *   |         address instance = enableEarningPreconditions_MYieldToOne(seed);
 30 |     | 
 31 | *   |         _before();
 32 |     | 
 33 | *   |         (bool success, bytes memory returnData) = _enableEarningCall(instance);
 34 |     | 
 35 | *   |         enableEarningPostconditions_MYieldToOne(success, returnData);
 36 |     |     }
 37 |     | 
 38 | *   |     function fuzz_disableEarning_MYieldToOne(uint256 seed) public setCurrentActor {
 39 | *   |         address instance = disableEarningPreconditions_MYieldToOne(seed);
 40 |     | 
 41 | *   |         _before();
 42 |     | 
 43 | *   |         (bool success, bytes memory returnData) = _disableEarningCall(instance);
 44 |     | 
 45 | *   |         disableEarningPostconditions_MYieldToOne(success, returnData);
 46 |     |     }
 47 |     | 
 48 | *   |     function fuzz_approve_MYieldToOne(uint256 seed) public setCurrentActor {
 49 | *   |         ApproveParams memory params = approvePreconditions_MYieldToOne(seed);
 50 |     | 
 51 | *   |         _before();
 52 |     | 
 53 | *   |         (bool success, bytes memory returnData) = _approveCall(params.instance, params.spender, params.amount);
 54 |     | 
 55 | *   |         approvePostconditions_MYieldToOne(success, returnData);
 56 |     |     }
 57 |     | 
 58 | *   |     function fuzz_transfer_MYieldToOne(uint256 seed) public setCurrentActor {
 59 | *   |         TransferParams memory params = transferPreconditions_MYieldToOne(seed);
 60 |     | 
 61 | *   |         _before();
 62 |     | 
 63 | *   |         (bool success, bytes memory returnData) = _transferCall(params.instance, params.to, params.amount);
 64 |     | 
 65 | *   |         transferPostconditions_MYieldToOne(success, returnData);
 66 |     |     }
 67 |     | 
 68 | *   |     function fuzz_transferFrom_MYieldToOne(uint256 seed) public setCurrentActor {
 69 | *   |         TransferFromParams memory params = transferFromPreconditions_MYieldToOne(seed);
 70 |     | 
 71 | *   |         _before();
 72 |     | 
 73 | *   |         (bool success, bytes memory returnData) = _transferFromCall(
 74 | *   |             params.instance,
 75 | *   |             params.from,
 76 | *   |             params.to,
 77 | *   |             params.amount
 78 |     |         );
 79 |     | 
 80 | *   |         transferFromPostconditions_MYieldToOne(success, returnData);
 81 |     |     }
 82 |     | }
 83 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/FuzzSetup.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./utils/FunctionCalls.sol";
   5 |     | import { ERC1967Proxy } from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
   6 |     | import { IUniswapV3Factory } from "uniswapv3/v3-core/interfaces/IUniswapV3Factory.sol";
   7 |     | import { IUniswapV3Pool } from "uniswapv3/v3-core/interfaces/IUniswapV3Pool.sol";
   8 |     | import { TickMath } from "uniswapv3/v3-core/libraries/TickMath.sol";
   9 |     | import { INonfungiblePositionManager } from "uniswapv3/v3-periphery/interfaces/INonfungiblePositionManager.sol";
  10 |     | import { UniswapV3Pool } from "uniswapv3/v3-core/UniswapV3Pool.sol";
  11 |     | import { V3SwapRouter } from "uniswapv3/v3-periphery/V3SwapRouter.sol";
  12 |     | import { TTGRegistrarReader } from "src/libs/TTGRegistrarReader.sol";
  13 |     | 
  14 |     | contract FuzzSetup is FunctionCalls {
  15 |     |     uint256 public liquidityTokenId;
  16 |     | 
  17 | *   |     function fuzzSetup() internal {
  18 | *   |         deployMToken();
  19 | *   |         deployUniV3();
  20 | *   |         deployM0();
  21 | *   |         initializeM0();
  22 | *   |         deployPool();
  23 | *   |         setUsers();
  24 | *   |         labelAll();
  25 |     |     }
  26 |     | 
  27 | *   |     function deployMToken() internal {
  28 | *   |         registrar = new MockRegistrar(address(0x123));
  29 | *   |         console.log("minterGateway address", _getCreateAddress(address(this), 5));
  30 | *   |         mToken = new MToken(address(registrar), _getCreateAddress(address(this), 5));
  31 | *   |         console.log("mToken address", address(mToken));
  32 | *   |         minterGateway = new MinterGateway(address(registrar), address(mToken));
  33 | *   |         assert(address(minterGateway) == _getCreateAddress(address(this), 5));
  34 | *   |         wMToken = new WrappedMToken(address(mToken), admin);
  35 | *   |         weth = new WETH();
  36 | *   |         USDC = new MockERC20("USDC", "USDC", 6);
  37 | *   |         DAI = new MockERC20("DAI", "DAI", 18); // 18 decimals for JMI Extension testing
  38 | *   |         whitelistedTokens = [address(USDC), address(weth)];
  39 |     | 
  40 |     |         // Mint tokens for liquidity provision
  41 | *   |         USDC.mint(address(this), 2_000_000_000_000 * 1e6); // 2T USDC
  42 | *   |         DAI.mint(address(this), 2_000_000_000_000 * 1e18); // 2T DAI
  43 |     | 
  44 | *   |         minterGateway.activateMinter(address(this));
  45 |     |         // mintMToken(address(this), 2000000 * 1e6); // mintMToken(address(this), 2000000 * 1e6); // 2M MToken
  46 |     |     }
  47 |     | 
  48 | *   |     function deployUniV3() internal {
  49 | *   |         uniV3Factory = new UniswapV3Factory();
  50 | *   |         emit log_named_address("uniV3Factory", address(uniV3Factory));
  51 | *   |         bytes32 initCodeHash = keccak256(type(UniswapV3Pool).creationCode); //NOTE: for the pool init code changes
  52 | *   |         emit log_named_bytes32("initCodeHash", initCodeHash);
  53 | *   |         console.log("initCodeHash");
  54 | *   |         console.logBytes32(initCodeHash);
  55 |     | 
  56 | *   |         uniV3Factory.enableFeeAmount(100, 1);
  57 | *   |         positionManager = new NonfungiblePositionManager(address(uniV3Factory), address(weth), address(0x123)); // token descriptor
  58 | *   |         v3SwapRouter = new SwapRouter02(
  59 | *   |             address(uniV3Factory), // factoryV2 is not used
  60 | *   |             address(uniV3Factory),
  61 | *   |             address(positionManager),
  62 | *   |             address(weth)
  63 |     |         );
  64 |     |     }
  65 |     | 
  66 | *   |     function deployPool() internal {
  67 |     |         // Determine token order (token0 < token1)
  68 | *   |         address token0 = address(USDC) < address(wMToken) ? address(USDC) : address(wMToken);
  69 | *   |         address token1 = address(USDC) < address(wMToken) ? address(wMToken) : address(USDC);
  70 | *   |         require(token0 < token1, "token0 must be less than token1");
  71 |     |         // Create pool with 0.01% fee (100 basis points)
  72 |     | 
  73 | *   |         address poolAddress = uniV3Factory.createPool(token0, token1, UNISWAP_V3_FEE);
  74 |     | 
  75 |     |         // assert(poolAddress == address(v3SwapRouter.getPool(token0, token1, UNISWAP_V3_FEE)));
  76 |     | 
  77 | *   |         usdcMTokenPool = IUniswapV3Pool(poolAddress);
  78 |     | 
  79 |     |         // Initialize pool with 1:1 price ratio
  80 |     |         // For 1:1 ratio, sqrtPriceX96 = sqrt(1) * 2^96 = 2^96
  81 | *   |         uint160 sqrtPriceX96 = 79228162514264337593543950336; // 2^96
  82 | *   |         usdcMTokenPool.initialize(sqrtPriceX96);
  83 |     | 
  84 |     |         // Add liquidity using position manager
  85 | *   |         addLiquidity();
  86 |     |     }
  87 |     | 
  88 | *   |     function addLiquidity() internal {
  89 | *   |         mintMToken(address(this), 2_000_000_000_000 * 1e6); // minting unreasonably large amount of MToken
  90 | *   |         mToken.approve(address(wMToken), type(uint256).max);
  91 | *   |         wMToken.wrap(address(this), 2_000_000_000_000 * 1e6);
  92 |     | 
  93 |     |         // Approve tokens to position manager
  94 | *   |         USDC.approve(address(positionManager), type(uint256).max);
  95 | *   |         wMToken.approve(address(positionManager), type(uint256).max);
  96 |     | 
  97 |     |         // Get current tick and calculate tick range
  98 | *   |         (, int24 currentTick, , , , , ) = usdcMTokenPool.slot0();
  99 | *   |         int24 tickSpacing = usdcMTokenPool.tickSpacing();
 100 |     | 
 101 | *   |         int24 tickLower = 0;
 102 | *   |         int24 tickUpper = 1;
 103 |     | 
 104 |     |         // Mint liquidity position
 105 | *   |         INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({
 106 | *   |             token0: address(USDC) < address(wMToken) ? address(USDC) : address(wMToken),
 107 | *   |             token1: address(USDC) < address(wMToken) ? address(wMToken) : address(USDC),
 108 |     |             fee: UNISWAP_V3_FEE,
 109 | *   |             tickLower: tickLower,
 110 | *   |             tickUpper: tickUpper,
 111 | *   |             amount0Desired: 2_000_000_000_000 * 1e6, // 2T wMToken (6 decimals)
 112 | *   |             amount1Desired: 2_000_000_000_000 * 1e6, // 2T USDC (6 decimals)
 113 | *   |             amount0Min: 0,
 114 | *   |             amount1Min: 0,
 115 | *   |             recipient: address(this),
 116 | *   |             deadline: block.timestamp + 1 hours
 117 |     |         });
 118 |     | 
 119 | *   |         (liquidityTokenId, , , ) = positionManager.mint(params);
 120 |     | 
 121 | *   |         minter = new DirectPoolMinter(address(usdcMTokenPool));
 122 |     |     }
 123 |     | 
 124 | *   |     function deployM0() internal {
 125 | *   |         rateOracle = new MockRateOracle();
 126 |     | 
 127 | *   |         swapFacility = SwapFacility(
 128 | *   |             UnsafeUpgrades.deployUUPSProxy(
 129 | *   |                 address(new SwapFacility(address(mToken), address(registrar))),
 130 | *   |                 abi.encodeWithSelector(SwapFacility.initialize.selector, admin, pauser)
 131 |     |             )
 132 |     |         );
 133 |     | 
 134 | *   |         swapAdapter = new UniswapV3SwapAdapter(
 135 | *   |             address(wMToken),
 136 | *   |             address(swapFacility),
 137 | *   |             address(v3SwapRouter),
 138 | *   |             admin,
 139 | *   |             whitelistedTokens
 140 |     |         );
 141 |     | 
 142 | *   |         MYieldToOne mYieldToOne1Impl = new MYieldToOne(address(mToken), address(swapFacility));
 143 | *   |         ERC1967Proxy mYieldToOne1Proxy = new ERC1967Proxy(
 144 | *   |             address(mYieldToOne1Impl),
 145 | *   |             abi.encodeWithSelector(
 146 | *   |                 MYieldToOne.initialize.selector,
 147 |     |                 "NAME1",
 148 |     |                 "SYMBOL1",
 149 | *   |                 yieldRecipient,
 150 | *   |                 admin,
 151 | *   |                 freezeManager,
 152 | *   |                 yieldRecipientManager
 153 |     |             )
 154 |     |         );
 155 | *   |         mYieldToOne1 = MYieldToOne(address(mYieldToOne1Proxy));
 156 |     | 
 157 | *   |         MYieldToOne mYieldToOne2Impl = new MYieldToOne(address(mToken), address(swapFacility));
 158 | *   |         ERC1967Proxy mYieldToOne2Proxy = new ERC1967Proxy(
 159 | *   |             address(mYieldToOne2Impl),
 160 | *   |             abi.encodeWithSelector(
 161 | *   |                 MYieldToOne.initialize.selector,
 162 |     |                 "NAME2",
 163 |     |                 "SYMBOL2",
 164 | *   |                 yieldRecipient,
 165 | *   |                 admin,
 166 | *   |                 freezeManager,
 167 | *   |                 yieldRecipientManager
 168 |     |             )
 169 |     |         );
 170 | *   |         mYieldToOne2 = MYieldToOne(address(mYieldToOne2Proxy));
 171 |     | 
 172 | *   |         MYieldToOne mYieldToOne3Impl = new MYieldToOne(address(mToken), address(swapFacility));
 173 | *   |         ERC1967Proxy mYieldToOne3Proxy = new ERC1967Proxy(
 174 | *   |             address(mYieldToOne3Impl),
 175 | *   |             abi.encodeWithSelector(
 176 | *   |                 MYieldToOne.initialize.selector,
 177 |     |                 "NAME3",
 178 |     |                 "SYMBOL3",
 179 | *   |                 yieldRecipient,
 180 | *   |                 admin,
 181 | *   |                 freezeManager,
 182 | *   |                 yieldRecipientManager
 183 |     |             )
 184 |     |         );
 185 | *   |         mYieldToOne3 = MYieldToOne(address(mYieldToOne3Proxy));
 186 |     | 
 187 | *   |         MYieldFeeHarness mYieldFee1Impl = new MYieldFeeHarness(address(mToken), address(swapFacility));
 188 | *   |         ERC1967Proxy mYieldFee1Proxy = new ERC1967Proxy(
 189 | *   |             address(mYieldFee1Impl),
 190 | *   |             abi.encodeWithSelector(
 191 | *   |                 MYieldFeeHarness.initialize.selector,
 192 |     |                 "MYieldFee1",
 193 |     |                 "MYF1",
 194 |     |                 YIELD_FEE_RATE,
 195 | *   |                 feeRecipient,
 196 | *   |                 admin,
 197 | *   |                 yieldFeeManager,
 198 | *   |                 claimRecipientManager
 199 |     |             )
 200 |     |         );
 201 | *   |         mYieldFee1 = MYieldFeeHarness(address(mYieldFee1Proxy));
 202 |     | 
 203 | *   |         MYieldFeeHarness mYieldFee2Impl = new MYieldFeeHarness(address(mToken), address(swapFacility));
 204 | *   |         ERC1967Proxy mYieldFee2Proxy = new ERC1967Proxy(
 205 | *   |             address(mYieldFee2Impl),
 206 | *   |             abi.encodeWithSelector(
 207 | *   |                 MYieldFeeHarness.initialize.selector,
 208 |     |                 "MYieldFee2",
 209 |     |                 "MYF2",
 210 |     |                 YIELD_FEE_RATE,
 211 | *   |                 feeRecipient,
 212 | *   |                 admin,
 213 | *   |                 yieldFeeManager,
 214 | *   |                 claimRecipientManager
 215 |     |             )
 216 |     |         );
 217 | *   |         mYieldFee2 = MYieldFeeHarness(address(mYieldFee2Proxy));
 218 |     | 
 219 | *   |         MYieldFeeHarness mYieldFee3Impl = new MYieldFeeHarness(address(mToken), address(swapFacility));
 220 | *   |         ERC1967Proxy mYieldFee3Proxy = new ERC1967Proxy(
 221 | *   |             address(mYieldFee3Impl),
 222 | *   |             abi.encodeWithSelector(
 223 | *   |                 MYieldFeeHarness.initialize.selector,
 224 |     |                 "MYieldFee3",
 225 |     |                 "MYF3",
 226 |     |                 YIELD_FEE_RATE,
 227 | *   |                 feeRecipient,
 228 | *   |                 admin,
 229 | *   |                 yieldFeeManager,
 230 | *   |                 claimRecipientManager
 231 |     |             )
 232 |     |         );
 233 | *   |         mYieldFee3 = MYieldFeeHarness(address(mYieldFee3Proxy));
 234 |     | 
 235 | *   |         MEarnerManagerHarness mEarnerManager1Impl = new MEarnerManagerHarness(address(mToken), address(swapFacility));
 236 | *   |         ERC1967Proxy mEarnerManager1Proxy = new ERC1967Proxy(
 237 | *   |             address(mEarnerManager1Impl),
 238 | *   |             abi.encodeWithSelector(
 239 | *   |                 MEarnerManagerHarness.initialize.selector,
 240 |     |                 "MEarnerManager1",
 241 |     |                 "MEM1",
 242 | *   |                 address(mToken),
 243 | *   |                 address(swapFacility),
 244 | *   |                 admin,
 245 | *   |                 earnerManager,
 246 | *   |                 feeRecipient
 247 |     |             )
 248 |     |         );
 249 | *   |         mEarnerManager1 = MEarnerManagerHarness(address(mEarnerManager1Proxy));
 250 |     | 
 251 | *   |         MEarnerManagerHarness mEarnerManager2Impl = new MEarnerManagerHarness(address(mToken), address(swapFacility));
 252 | *   |         ERC1967Proxy mEarnerManager2Proxy = new ERC1967Proxy(
 253 | *   |             address(mEarnerManager2Impl),
 254 | *   |             abi.encodeWithSelector(
 255 | *   |                 MEarnerManagerHarness.initialize.selector,
 256 |     |                 "MEarnerManager2",
 257 |     |                 "MEM2",
 258 | *   |                 admin,
 259 | *   |                 earnerManager,
 260 | *   |                 feeRecipient
 261 |     |             )
 262 |     |         );
 263 | *   |         mEarnerManager2 = MEarnerManagerHarness(address(mEarnerManager2Proxy));
 264 |     | 
 265 | *   |         MEarnerManagerHarness mEarnerManager3Impl = new MEarnerManagerHarness(address(mToken), address(swapFacility));
 266 | *   |         ERC1967Proxy mEarnerManager3Proxy = new ERC1967Proxy(
 267 | *   |             address(mEarnerManager3Impl),
 268 | *   |             abi.encodeWithSelector(
 269 | *   |                 MEarnerManagerHarness.initialize.selector,
 270 |     |                 "MEarnerManager3",
 271 |     |                 "MEM3",
 272 | *   |                 admin,
 273 | *   |                 earnerManager,
 274 | *   |                 feeRecipient
 275 |     |             )
 276 |     |         );
 277 | *   |         mEarnerManager3 = MEarnerManagerHarness(address(mEarnerManager3Proxy));
 278 |     | 
 279 |     |         // Deploy JMI Extensions
 280 | *   |         JMIExtension jmiExtension1Impl = new JMIExtension(address(mToken), address(swapFacility));
 281 | *   |         ERC1967Proxy jmiExtension1Proxy = new ERC1967Proxy(
 282 | *   |             address(jmiExtension1Impl),
 283 | *   |             abi.encodeWithSelector(
 284 | *   |                 JMIExtension.initialize.selector,
 285 |     |                 "JMI1",
 286 |     |                 "JMI1",
 287 | *   |                 yieldRecipient,
 288 | *   |                 admin,
 289 | *   |                 assetCapManager,
 290 | *   |                 freezeManager,
 291 | *   |                 pauser,
 292 | *   |                 yieldRecipientManager
 293 |     |             )
 294 |     |         );
 295 | *   |         jmiExtension1 = JMIExtension(address(jmiExtension1Proxy));
 296 |     | 
 297 | *   |         JMIExtension jmiExtension2Impl = new JMIExtension(address(mToken), address(swapFacility));
 298 | *   |         ERC1967Proxy jmiExtension2Proxy = new ERC1967Proxy(
 299 | *   |             address(jmiExtension2Impl),
 300 | *   |             abi.encodeWithSelector(
 301 | *   |                 JMIExtension.initialize.selector,
 302 |     |                 "JMI2",
 303 |     |                 "JMI2",
 304 | *   |                 yieldRecipient,
 305 | *   |                 admin,
 306 | *   |                 assetCapManager,
 307 | *   |                 freezeManager,
 308 | *   |                 pauser,
 309 | *   |                 yieldRecipientManager
 310 |     |             )
 311 |     |         );
 312 | *   |         jmiExtension2 = JMIExtension(address(jmiExtension2Proxy));
 313 |     | 
 314 | *   |         JMIExtension jmiExtension3Impl = new JMIExtension(address(mToken), address(swapFacility));
 315 | *   |         ERC1967Proxy jmiExtension3Proxy = new ERC1967Proxy(
 316 | *   |             address(jmiExtension3Impl),
 317 | *   |             abi.encodeWithSelector(
 318 | *   |                 JMIExtension.initialize.selector,
 319 |     |                 "JMI3",
 320 |     |                 "JMI3",
 321 | *   |                 yieldRecipient,
 322 | *   |                 admin,
 323 | *   |                 assetCapManager,
 324 | *   |                 freezeManager,
 325 | *   |                 pauser,
 326 | *   |                 yieldRecipientManager
 327 |     |             )
 328 |     |         );
 329 | *   |         jmiExtension3 = JMIExtension(address(jmiExtension3Proxy));
 330 |     | 
 331 | *   |         mYieldToOneArray = [address(mYieldToOne1), address(mYieldToOne2), address(mYieldToOne3)];
 332 | *   |         mYieldFeeArray = [address(mYieldFee1), address(mYieldFee2), address(mYieldFee3)];
 333 | *   |         mEarnerManagerArray = [address(mEarnerManager1), address(mEarnerManager2), address(mEarnerManager3)];
 334 | *   |         jmiExtensionArray = [address(jmiExtension1), address(jmiExtension2), address(jmiExtension3)];
 335 | *   |         allExtensions = [
 336 | *   |             address(mYieldToOne1),
 337 | *   |             address(mYieldFee1),
 338 | *   |             address(mEarnerManager1),
 339 | *   |             address(mYieldToOne2),
 340 | *   |             address(mYieldFee2),
 341 | *   |             address(mEarnerManager2),
 342 | *   |             address(mYieldToOne3),
 343 | *   |             address(mYieldFee3),
 344 | *   |             address(mEarnerManager3),
 345 | *   |             address(jmiExtension1),
 346 | *   |             address(jmiExtension2),
 347 | *   |             address(jmiExtension3)
 348 |     |         ];
 349 |     | 
 350 | *   |         earnerRateModel = new EarnerRateModel(address(minterGateway), address(registrar), address(mToken));
 351 | *   |         minterRateModel = new MinterRateModel(address(registrar));
 352 |     |     }
 353 |     | 
 354 | *   |     function initializeM0() internal {
 355 | *   |         swapFacility.grantRole(M_SWAPPER_ROLE, USER1);
 356 | *   |         swapFacility.grantRole(M_SWAPPER_ROLE, USER2);
 357 | *   |         swapFacility.grantRole(M_SWAPPER_ROLE, USER3);
 358 |     | 
 359 | *   |         registrar.setEarner(address(mYieldToOne1), true);
 360 | *   |         registrar.setEarner(address(mYieldToOne2), true);
 361 | *   |         registrar.setEarner(address(mYieldToOne3), true);
 362 | *   |         registrar.setEarner(address(mEarnerManager1), true);
 363 | *   |         registrar.setEarner(address(mEarnerManager2), true);
 364 | *   |         registrar.setEarner(address(mEarnerManager3), true);
 365 | *   |         registrar.setEarner(address(mYieldFee1), true);
 366 | *   |         registrar.setEarner(address(mYieldFee2), true);
 367 | *   |         registrar.setEarner(address(mYieldFee3), true);
 368 | *   |         registrar.setEarner(address(jmiExtension1), true);
 369 | *   |         registrar.setEarner(address(jmiExtension2), true);
 370 | *   |         registrar.setEarner(address(jmiExtension3), true);
 371 |     | 
 372 | *   |         registrar.set(bytes32("minter_rate_model"), bytes32(uint256(uint160(address(minterRateModel)))));
 373 | *   |         registrar.set(bytes32("earner_rate_model"), bytes32(uint256(uint160(address(earnerRateModel)))));
 374 |     | 
 375 |     |         //randomizing configs in a separate handler
 376 |     |         // registrar.updateConfig(MAX_EARNER_RATE, _baseEarnerRate);
 377 |     |         // registrar.updateConfig(BASE_MINTER_RATE, _baseMinterRate);
 378 |     |         // registrar.updateConfig(TTGRegistrarReader.EARNER_RATE_MODEL, address(earnerRateModel));
 379 |     |         // registrar.updateConfig(TTGRegistrarReader.MINTER_RATE_MODEL, address(minterRateModel));
 380 |     |         // registrar.updateConfig(TTGRegistrarReader.UPDATE_COLLATERAL_VALIDATOR_THRESHOLD, 1);
 381 |     |         // registrar.updateConfig(TTGRegistrarReader.UPDATE_COLLATERAL_INTERVAL, _updateInterval);
 382 |     |         // registrar.updateConfig(TTGRegistrarReader.MINT_DELAY, _mintDelay);
 383 |     |         // registrar.updateConfig(TTGRegistrarReader.MINT_TTL, _mintTtl);
 384 |     |         // registrar.updateConfig(TTGRegistrarReader.MINT_RATIO, _mintRatio);
 385 |     |         // registrar.updateConfig(TTGRegistrarReader.PENALTY_RATE, _penaltyRate);
 386 |     |         // registrar.updateConfig(TTGRegistrarReader.MINTER_FREEZE_TIME, _minterFreezeTime);
 387 |     | 
 388 | *   |         mEarnerManager1.setAccountOf(address(swapFacility), 0, 0, true, 0);
 389 | *   |         mEarnerManager2.setAccountOf(address(swapFacility), 0, 0, true, 0);
 390 | *   |         mEarnerManager3.setAccountOf(address(swapFacility), 0, 0, true, 0);
 391 |     | 
 392 | *   |         mEarnerManager1.setAccountOf(address(swapAdapter), 0, 0, true, 0);
 393 | *   |         mEarnerManager2.setAccountOf(address(swapAdapter), 0, 0, true, 0);
 394 | *   |         mEarnerManager3.setAccountOf(address(swapAdapter), 0, 0, true, 0);
 395 |     | 
 396 | *   |         mYieldFee1.enableEarning();
 397 | *   |         mYieldFee2.enableEarning();
 398 | *   |         mYieldFee3.enableEarning();
 399 |     | 
 400 | *   |         mEarnerManager1.enableEarning();
 401 | *   |         mEarnerManager2.enableEarning();
 402 | *   |         mEarnerManager3.enableEarning();
 403 |     | 
 404 | *   |         mYieldToOne1.enableEarning();
 405 | *   |         mYieldToOne2.enableEarning();
 406 | *   |         mYieldToOne3.enableEarning();
 407 |     | 
 408 | *   |         jmiExtension1.enableEarning();
 409 | *   |         jmiExtension2.enableEarning();
 410 | *   |         jmiExtension3.enableEarning();
 411 |     | 
 412 |     |         // Set asset caps for DAI on JMI extensions (allowing 1T DAI each)
 413 | *   |         jmiExtension1.setAssetCap(address(DAI), 1_000_000_000_000 * 1e18);
 414 | *   |         jmiExtension2.setAssetCap(address(DAI), 1_000_000_000_000 * 1e18);
 415 | *   |         jmiExtension3.setAssetCap(address(DAI), 1_000_000_000_000 * 1e18);
 416 |     |     }
 417 |     | 
 418 | *   |     function setUsers() internal {
 419 | *   |         for (uint256 i = 0; i < USERS.length; i++) {
 420 | *   |             mintMToken(USERS[i], 1e9 * 1e6);
 421 |     | 
 422 | *   |             vm.prank(USERS[i]);
 423 | *   |             mToken.approve(address(wMToken), type(uint256).max);
 424 |     | 
 425 | *   |             vm.prank(USERS[i]);
 426 | *   |             wMToken.wrap(USERS[i], ((1e9 * 1e6) / 2));
 427 |     | 
 428 | *   |             USDC.mint(USERS[i], 1e9 * 1e6);
 429 | *   |             DAI.mint(USERS[i], 1e9 * 1e18); // Mint DAI for JMI Extension testing
 430 | *   |             vm.deal(USERS[i], 1e9 * 1e18);
 431 | *   |             vm.prank(USERS[i]);
 432 | *   |             weth.deposit{ value: 1e9 * 1e18 }();
 433 |     | 
 434 | *   |             vm.prank(USERS[i]);
 435 | *   |             mToken.approve(address(swapFacility), type(uint256).max);
 436 |     | 
 437 | *   |             vm.prank(USERS[i]);
 438 | *   |             DAI.approve(address(swapFacility), type(uint256).max);
 439 |     | 
 440 | *   |             vm.prank(USERS[i]);
 441 | *   |             wMToken.approve(address(swapFacility), type(uint256).max);
 442 |     | 
 443 | *   |             vm.prank(USERS[i]);
 444 | *   |             USDC.approve(address(swapFacility), type(uint256).max); //NOTE: USDC is the base token
 445 |     | 
 446 | *   |             vm.prank(USERS[i]);
 447 | *   |             weth.approve(address(swapFacility), type(uint256).max);
 448 |     | 
 449 | *   |             vm.prank(USERS[i]);
 450 | *   |             USDC.approve(address(v3SwapRouter), type(uint256).max);
 451 |     | 
 452 | *   |             vm.prank(USERS[i]);
 453 | *   |             weth.approve(address(v3SwapRouter), type(uint256).max);
 454 |     | 
 455 | *   |             vm.prank(USERS[i]);
 456 | *   |             USDC.approve(address(swapAdapter), type(uint256).max);
 457 |     | 
 458 | *   |             vm.prank(USERS[i]);
 459 | *   |             weth.approve(address(swapAdapter), type(uint256).max);
 460 |     | 
 461 | *   |             mEarnerManager1.setAccountOf(USERS[i], 0, 0, true, 1_000);
 462 | *   |             mEarnerManager2.setAccountOf(USERS[i], 0, 0, true, 2_000);
 463 | *   |             mEarnerManager3.setAccountOf(USERS[i], 0, 0, true, 3_000);
 464 |     | 
 465 | *   |             for (uint256 j = 0; j < allExtensions.length; j++) {
 466 | *   |                 vm.prank(USERS[i]);
 467 | *   |                 IERC20(allExtensions[j]).approve(address(swapFacility), type(uint256).max);
 468 | *   |                 vm.prank(USERS[i]);
 469 | *   |                 IERC20(allExtensions[j]).approve(address(swapAdapter), type(uint256).max);
 470 |     |             }
 471 |     |         }
 472 |     |     }
 473 |     | 
 474 |     |     //DO LABELING
 475 | *   |     function labelAll() internal {
 476 |     |         //CONTRACTS
 477 | *   |         vm.label(address(rateOracle), "RateOracle");
 478 | *   |         vm.label(address(registrar), "Registrar");
 479 | *   |         vm.label(address(swapFacility), "SwapFacility");
 480 |     | 
 481 | *   |         vm.label(address(mYieldToOne1), "MYieldToOne1");
 482 | *   |         vm.label(address(mYieldToOne2), "MYieldToOne2");
 483 | *   |         vm.label(address(mYieldToOne3), "MYieldToOne3");
 484 | *   |         vm.label(address(mYieldFee1), "MYieldFee1");
 485 | *   |         vm.label(address(mYieldFee2), "MYieldFee2");
 486 | *   |         vm.label(address(mYieldFee3), "MYieldFee3");
 487 | *   |         vm.label(address(mEarnerManager1), "MEarnerManager1");
 488 | *   |         vm.label(address(mEarnerManager2), "MEarnerManager2");
 489 | *   |         vm.label(address(mEarnerManager3), "MEarnerManager3");
 490 | *   |         vm.label(address(jmiExtension1), "JMIExtension1");
 491 | *   |         vm.label(address(jmiExtension2), "JMIExtension2");
 492 | *   |         vm.label(address(jmiExtension3), "JMIExtension3");
 493 |     | 
 494 |     |         //UNISWAP V3
 495 | *   |         vm.label(address(uniV3Factory), "UniV3Factory");
 496 | *   |         vm.label(address(v3SwapRouter), "V3SwapRouter");
 497 | *   |         vm.label(address(positionManager), "PositionManager");
 498 | *   |         vm.label(address(usdcMTokenPool), "USDC-MToken-Pool");
 499 |     | 
 500 |     |         //TOKENS
 501 | *   |         vm.label(address(USDC), "USDC");
 502 | *   |         vm.label(address(DAI), "DAI");
 503 | *   |         vm.label(address(weth), "WETH");
 504 | *   |         vm.label(address(mToken), "MToken");
 505 |     | 
 506 |     |         //USERS
 507 | *   |         vm.label(USER1, "USER1");
 508 | *   |         vm.label(USER2, "USER2");
 509 | *   |         vm.label(USER3, "USER3");
 510 |     |     }
 511 |     | 
 512 |     |     // calculates address of contract predeployment
 513 | *   |     function _getCreateAddress(address deployer, uint256 nonce) internal pure returns (address) {
 514 | *   |         if (nonce == 0) {
 515 |     |             return
 516 |     |                 address(
 517 |     |                     uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80)))))
 518 |     |                 );
 519 | *   |         } else if (nonce <= 0x7f) {
 520 | *   |             return
 521 |     |                 address(
 522 | *   |                     uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce)))))
 523 |     |                 );
 524 |     |         } else if (nonce <= 0xff) {
 525 |     |             return
 526 |     |                 address(
 527 |     |                     uint160(
 528 |     |                         uint256(
 529 |     |                             keccak256(
 530 |     |                                 abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))
 531 |     |                             )
 532 |     |                         )
 533 |     |                     )
 534 |     |                 );
 535 |     |         } else if (nonce <= 0xffff) {
 536 |     |             return
 537 |     |                 address(
 538 |     |                     uint160(
 539 |     |                         uint256(
 540 |     |                             keccak256(
 541 |     |                                 abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))
 542 |     |                             )
 543 |     |                         )
 544 |     |                     )
 545 |     |                 );
 546 |     |         } else {
 547 |     |             return
 548 |     |                 address(
 549 |     |                     uint160(
 550 |     |                         uint256(
 551 |     |                             keccak256(
 552 |     |                                 abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))
 553 |     |                             )
 554 |     |                         )
 555 |     |                     )
 556 |     |                 );
 557 |     |         }
 558 |     |     }
 559 |     | 
 560 | *   |     function mintMToken(address destination, uint256 amount) internal {
 561 | *   |         uint48 mintId = minterGateway.proposeMint(amount, destination);
 562 | *   |         minterGateway.mintM(mintId);
 563 |     |     }
 564 |     | }
 565 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/FuzzSwapFacility.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./helpers/preconditions/PreconditionsSwapFacility.sol";
  5 |     | import "./helpers/postconditions/PostconditionsSwapFacility.sol";
  6 |     | 
  7 |     | contract FuzzSwapFacility is PreconditionsSwapFacility, PostconditionsSwapFacility {
  8 | *   |     function fuzz_swap(uint256 seed) public setCurrentActor {
  9 | *   |         SwapParams memory params = swapPreconditions(seed);
 10 |     | 
 11 | *   |         _before();
 12 |     | 
 13 | *   |         (bool success, bytes memory returnData) = _swapCall(
 14 | *   |             params.instance,
 15 | *   |             params.extensionIn,
 16 | *   |             params.extensionOut,
 17 | *   |             params.amount,
 18 | *   |             params.recipient
 19 |     |         );
 20 |     | 
 21 | *   |         swapPostconditions(success, returnData, params);
 22 |     |     }
 23 |     | 
 24 | *   |     function fuzz_swapInM(uint256 seed) public setCurrentActor {
 25 | *   |         SwapInMParams memory params = swapInMPreconditions(seed);
 26 |     | 
 27 | *   |         _before();
 28 |     | 
 29 | *   |         (bool success, bytes memory returnData) = _swapInMCall(
 30 | *   |             params.instance,
 31 | *   |             params.extensionOut,
 32 | *   |             params.amount,
 33 | *   |             params.recipient
 34 |     |         );
 35 |     | 
 36 | *   |         swapInMPostconditions(success, returnData, params);
 37 |     |     }
 38 |     | 
 39 | *   |     function fuzz_swapOutM(uint256 seed) public setCurrentActor {
 40 | *   |         SwapOutMParams memory params = swapOutMPreconditions(seed);
 41 |     | 
 42 | *   |         _before();
 43 |     | 
 44 | *   |         (bool success, bytes memory returnData) = _swapOutMCall(
 45 | *   |             params.instance,
 46 | *   |             params.extensionIn,
 47 | *   |             params.amount,
 48 | *   |             params.recipient
 49 |     |         );
 50 |     | 
 51 | *   |         swapOutMPostconditions(success, returnData, params);
 52 |     |     }
 53 |     | 
 54 | *   |     function fuzz_swapInToken(uint256 seed) public setCurrentActor {
 55 | *   |         SwapInTokenParams memory params = swapInTokenPreconditions(seed);
 56 |     | 
 57 | *   |         _before();
 58 |     | 
 59 | *   |         (bool success, bytes memory returnData) = _swapInTokenCall(
 60 | *   |             params.instance,
 61 | *   |             params.tokenIn,
 62 | *   |             params.amountIn,
 63 | *   |             params.extensionOut,
 64 | *   |             params.minAmountOut,
 65 | *   |             params.recipient,
 66 | *   |             params.path
 67 |     |         );
 68 |     | 
 69 | *   |         swapInTokenPostconditions(success, returnData, params);
 70 |     |     }
 71 |     | 
 72 | *   |     function fuzz_swapOutToken(uint256 seed) public setCurrentActor {
 73 | *   |         SwapOutTokenParams memory params = swapOutTokenPreconditions(seed);
 74 |     | 
 75 | *   |         _before();
 76 |     | 
 77 | *   |         (bool success, bytes memory returnData) = _swapOutTokenCall(
 78 | *   |             params.instance,
 79 | *   |             params.extensionIn,
 80 | *   |             params.amountIn,
 81 | *   |             params.tokenOut,
 82 | *   |             params.minAmountOut,
 83 | *   |             params.recipient,
 84 | *   |             params.path
 85 |     |         );
 86 |     | 
 87 | *   |         swapOutTokenPostconditions(success, returnData, params);
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/FuzzUni.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./helpers/preconditions/PreconditionsUni.sol";
  5 |     | import "./helpers/postconditions/PostconditionsUni.sol";
  6 |     | 
  7 |     | contract FuzzUni is PreconditionsUni, PostconditionsUni {
  8 | *   |     function fuzz_allLiquidityUni(
  9 |     |         uint256 amount0Seed,
 10 |     |         uint256 amount1Seed,
 11 |     |         int24 tickLowerSeed,
 12 |     |         int24 tickUpperSeed,
 13 |     |         uint256 strategySeed
 14 |     |     ) public setCurrentActor {
 15 | *   |         (
 16 | *   |             uint256 amount0Desired,
 17 | *   |             uint256 amount1Desired,
 18 | *   |             int24 tickLower,
 19 | *   |             int24 tickUpper
 20 | *   |         ) = allLiquidityUniPreconditions(amount0Seed, amount1Seed, tickLowerSeed, tickUpperSeed, strategySeed);
 21 |     | 
 22 | *   |         address[] memory actorsToUpdate = new address[](1);
 23 | *   |         actorsToUpdate[0] = currentActor;
 24 | *   |         _before(actorsToUpdate);
 25 |     | 
 26 | *   |         add_liquidity_direct(
 27 | *   |             currentActor,
 28 | *   |             currentActor,
 29 | *   |             amount0Desired,
 30 | *   |             amount1Desired,
 31 | *   |             tickLower,
 32 | *   |             tickUpper,
 33 | *   |             address(usdcMTokenPool)
 34 |     |         );
 35 |     | 
 36 | *   |         allLiquidityUniPostconditions(
 37 | *   |             true, // Assuming success for direct liquidity addition
 38 | *   |             new bytes(0),
 39 | *   |             actorsToUpdate,
 40 | *   |             currentActor,
 41 | *   |             amount0Desired,
 42 | *   |             amount1Desired,
 43 | *   |             tickLower,
 44 | *   |             tickUpper
 45 |     |         );
 46 |     |     }
 47 |     | 
 48 | *   |     function fuzz_swapZeroToOne(uint256 amountInSeed) public setCurrentActor {
 49 | *   |         uint256 amountIn = swapZeroToOnePreconditions(amountInSeed);
 50 |     | 
 51 | *   |         address[] memory actorsToUpdate = new address[](1);
 52 | *   |         actorsToUpdate[0] = currentActor;
 53 | *   |         _before(actorsToUpdate);
 54 |     | 
 55 | *   |         uint256 amountOut = swap_t0_for_t1(currentActor, amountIn);
 56 |     | 
 57 |     |         swapZeroToOnePostconditions(
 58 |     |             true, // Direct call should succeed
 59 |     |             new bytes(0),
 60 |     |             actorsToUpdate,
 61 |     |             currentActor,
 62 |     |             amountIn,
 63 |     |             amountOut
 64 |     |         );
 65 |     |     }
 66 |     | 
 67 | *   |     function fuzz_swapOneToZero(uint256 amountInSeed) public setCurrentActor {
 68 | *   |         uint256 amountIn = swapOneToZeroPreconditions(amountInSeed);
 69 |     | 
 70 | *   |         address[] memory actorsToUpdate = new address[](1);
 71 | *   |         actorsToUpdate[0] = currentActor;
 72 | *   |         _before(actorsToUpdate);
 73 |     | 
 74 | *   |         uint256 amountOut = swap_t1_for_t0(currentActor, amountIn);
 75 |     | 
 76 |     |         swapOneToZeroPostconditions(
 77 |     |             true, // Direct call should succeed
 78 |     |             new bytes(0),
 79 |     |             actorsToUpdate,
 80 |     |             currentActor,
 81 |     |             amountIn,
 82 |     |             amountOut
 83 |     |         );
 84 |     |     }
 85 |     | }
 86 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/BeforeAfter.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity 0.8.26;
   3 |     | 
   4 |     | import "../FuzzSetup.sol";
   5 |     | import { IMYieldToOne } from "src/projects/yieldToOne/IMYieldToOne.sol";
   6 |     | import { IMYieldFee } from "src/projects/yieldToAllWithFee/interfaces/IMYieldFee.sol";
   7 |     | import { IMEarnerManager } from "src/projects/earnerManager/IMEarnerManager.sol";
   8 |     | import { IERC20 } from "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";
   9 |     | import { IMTokenLike } from "src/interfaces/IMTokenLike.sol";
  10 |     | 
  11 |     | contract BeforeAfter is FuzzSetup {
  12 |     |     // MYieldToOne parameter structs
  13 |     |     struct ClaimYieldParams {
  14 |     |         address instance;
  15 |     |     }
  16 |     | 
  17 |     |     struct SetYieldRecipientParams {
  18 |     |         address instance;
  19 |     |         address yieldRecipient;
  20 |     |     }
  21 |     | 
  22 |     |     struct ApproveParams {
  23 |     |         address instance;
  24 |     |         address spender;
  25 |     |         uint256 amount;
  26 |     |     }
  27 |     | 
  28 |     |     struct TransferParams {
  29 |     |         address instance;
  30 |     |         address to;
  31 |     |         uint256 amount;
  32 |     |     }
  33 |     | 
  34 |     |     struct TransferFromParams {
  35 |     |         address instance;
  36 |     |         address from;
  37 |     |         address to;
  38 |     |         uint256 amount;
  39 |     |     }
  40 |     | 
  41 |     |     struct WrapParams {
  42 |     |         address instance;
  43 |     |         address recipient;
  44 |     |         uint256 amount;
  45 |     |     }
  46 |     | 
  47 |     |     struct UnwrapParams {
  48 |     |         address instance;
  49 |     |         address recipient;
  50 |     |         uint256 amount;
  51 |     |     }
  52 |     | 
  53 |     |     // MEarnerManager parameter structs
  54 |     |     struct SetAccountInfoParams {
  55 |     |         address instance;
  56 |     |         address account;
  57 |     |         bool status;
  58 |     |         uint16 feeRate;
  59 |     |     }
  60 |     | 
  61 |     |     struct SetAccountInfoBatchParams {
  62 |     |         address instance;
  63 |     |         address[] accounts;
  64 |     |         bool[] statuses;
  65 |     |         uint16[] feeRates;
  66 |     |     }
  67 |     | 
  68 |     |     struct SetFeeRecipientParams {
  69 |     |         address instance;
  70 |     |         address feeRecipient;
  71 |     |     }
  72 |     | 
  73 |     |     struct ClaimForParams {
  74 |     |         address instance;
  75 |     |         address account;
  76 |     |     }
  77 |     | 
  78 |     |     // MYieldFee parameter structs
  79 |     |     struct ClaimYieldForParams {
  80 |     |         address instance;
  81 |     |         address account;
  82 |     |     }
  83 |     | 
  84 |     |     struct ClaimFeeParams {
  85 |     |         address instance;
  86 |     |     }
  87 |     | 
  88 |     |     struct UpdateIndexParams {
  89 |     |         address instance;
  90 |     |     }
  91 |     | 
  92 |     |     struct SetFeeRateParams {
  93 |     |         address instance;
  94 |     |         uint16 feeRate;
  95 |     |     }
  96 |     | 
  97 |     |     struct SetClaimRecipientParams {
  98 |     |         address instance;
  99 |     |         address account;
 100 |     |         address claimRecipient;
 101 |     |     }
 102 |     | 
 103 |     |     // SwapFacility parameter structs
 104 |     |     struct SwapParams {
 105 |     |         address instance;
 106 |     |         address extensionIn;
 107 |     |         address extensionOut;
 108 |     |         uint256 amount;
 109 |     |         address recipient;
 110 |     |         uint8 swapType;
 111 |     |     }
 112 |     | 
 113 |     |     struct SwapInMParams {
 114 |     |         address instance;
 115 |     |         address extensionOut;
 116 |     |         uint256 amount;
 117 |     |         address recipient;
 118 |     |     }
 119 |     | 
 120 |     |     struct SwapOutMParams {
 121 |     |         address instance;
 122 |     |         address extensionIn;
 123 |     |         uint256 amount;
 124 |     |         address recipient;
 125 |     |     }
 126 |     | 
 127 |     |     struct SwapInMWithPermitVRSParams {
 128 |     |         address instance;
 129 |     |         address extensionOut;
 130 |     |         uint256 amount;
 131 |     |         address recipient;
 132 |     |         uint256 deadline;
 133 |     |         uint8 v;
 134 |     |         bytes32 r;
 135 |     |         bytes32 s;
 136 |     |     }
 137 |     | 
 138 |     |     struct SwapInMWithPermitSignatureParams {
 139 |     |         address instance;
 140 |     |         address extensionOut;
 141 |     |         uint256 amount;
 142 |     |         address recipient;
 143 |     |         uint256 deadline;
 144 |     |         bytes signature;
 145 |     |     }
 146 |     | 
 147 |     |     struct SwapInTokenParams {
 148 |     |         address instance;
 149 |     |         address tokenIn;
 150 |     |         uint256 amountIn;
 151 |     |         address extensionOut;
 152 |     |         uint256 minAmountOut;
 153 |     |         address recipient;
 154 |     |         bytes path;
 155 |     |     }
 156 |     | 
 157 |     |     struct SwapOutTokenParams {
 158 |     |         address instance;
 159 |     |         address extensionIn;
 160 |     |         uint256 amountIn;
 161 |     |         address tokenOut;
 162 |     |         uint256 minAmountOut;
 163 |     |         address recipient;
 164 |     |         bytes path;
 165 |     |     }
 166 |     | 
 167 |     |     // JMI Extension parameter structs
 168 |     |     struct WrapAssetParams {
 169 |     |         address instance;
 170 |     |         address asset;
 171 |     |         address recipient;
 172 |     |         uint256 amount;
 173 |     |     }
 174 |     | 
 175 |     |     struct ReplaceAssetWithMParams {
 176 |     |         address instance;
 177 |     |         address asset;
 178 |     |         address recipient;
 179 |     |         uint256 amount;
 180 |     |     }
 181 |     | 
 182 |     |     struct SetAssetCapParams {
 183 |     |         address instance;
 184 |     |         address asset;
 185 |     |         uint256 cap;
 186 |     |     }
 187 |     | 
 188 |     |     struct PauseParams {
 189 |     |         address instance;
 190 |     |     }
 191 |     | 
 192 |     |     struct FreezeParams {
 193 |     |         address instance;
 194 |     |         address account;
 195 |     |     }
 196 |     | 
 197 |     |     enum SwapType {
 198 |     |         NA,
 199 |     |         YTO_TO_YTO,
 200 |     |         YTO_TO_YFEE,
 201 |     |         YFEE_TO_YTO,
 202 |     |         YFEE_TO_YFEE,
 203 |     |         MEARN_TO_YTO,
 204 |     |         YTO_TO_MEARN,
 205 |     |         MEARN_TO_YFEE,
 206 |     |         YFEE_TO_MEARN,
 207 |     |         MEARN_TO_MEARN
 208 |     |     }
 209 |     | 
 210 |     |     mapping(uint8 => State) states;
 211 |     | 
 212 |     |     struct mYieldToOneStruct {
 213 |     |         uint256 yield;
 214 |     |     }
 215 |     | 
 216 |     |     struct mYieldFeeStruct {
 217 |     |         uint256 totalAccruedYield;
 218 |     |         uint256 totalAccruedFee;
 219 |     |         uint256 balanceOfM0;
 220 |     |         uint256 principalBalanceOf;
 221 |     |         uint256 projectedTotalSupply;
 222 |     |         uint256 currentIndex;
 223 |     |         uint256 latestIndex;
 224 |     |         uint256 latestRate;
 225 |     |         uint256 feeRate;
 226 |     |     }
 227 |     | 
 228 |     |     struct mEarnerManagerStruct {
 229 |     |         uint256 mBalanceOf;
 230 |     |         uint256 totalSupply;
 231 |     |         uint256 yield;
 232 |     |         uint256 projectedTotalSupply;
 233 |     |         mapping(address => uint256) accruedYieldOf;
 234 |     |         mapping(address => uint256) accruedFeeOf;
 235 |     |         mapping(address => uint256) accruedYieldAndFeeOf;
 236 |     |     }
 237 |     | 
 238 |     |     struct State {
 239 |     |         mapping(address => ActorStates) actorStates;
 240 |     |         mapping(address => mYieldToOneStruct) mYieldToOne; // YTO
 241 |     |         mapping(address => mYieldFeeStruct) mYieldFee; // YFEE
 242 |     |         mapping(address => mEarnerManagerStruct) mEarnerManager; // MEARN
 243 |     |         uint256 swapFacilityBalanceOfM0;
 244 |     |     }
 245 |     | 
 246 |     |     struct ActorStates {
 247 |     |         uint256 mTokenBalance;
 248 |     |         uint256 allMEarnTokens;
 249 |     |         uint256 allYieldFeeTokens;
 250 |     |         uint256 allYieldToOneTokens;
 251 |     |         uint256 totalM0Balance;
 252 |     |         uint256 usdcBalance;
 253 |     |     }
 254 |     | 
 255 | *   |     function _before(address[] memory actors) internal {
 256 |     |         // Reset full state mapping
 257 |     |         // delete states[0]; //use only if needed
 258 |     |         // delete states[1]; //use only if needed
 259 | *   |         _setStates(0, USERS);
 260 |     |     }
 261 |     | 
 262 | *   |     function _before() internal {
 263 |     |         // Reset full state mapping
 264 |     |         // delete states[0]; //use only if needed
 265 |     |         // delete states[1]; //use only if needed
 266 | *   |         _setStates(0, USERS);
 267 |     |     }
 268 |     | 
 269 | *   |     function _after() internal {
 270 | *   |         _setStates(1, USERS);
 271 |     |     }
 272 |     | 
 273 | *   |     function _after(address[] memory actors) internal {
 274 | *   |         _setStates(1, USERS);
 275 |     |     }
 276 |     | 
 277 | *   |     function _setStates(uint8 callNum, address[] memory actors) internal {
 278 | *   |         _processActors(callNum, actors);
 279 | *   |         _updateCommonState(callNum);
 280 |     |     }
 281 |     | 
 282 | *   |     function _processActors(uint8 callNum, address[] memory actors) private {
 283 | *   |         for (uint256 i = 0; i < actors.length; i++) {
 284 | *   |             _setActorState(callNum, actors[i]);
 285 |     |         }
 286 |     |     }
 287 |     | 
 288 | *   |     function _updateCommonState(uint8 callNum) private {
 289 |     |         // For MYieldToOne, we use the yield()
 290 |     |         // For MYieldFee, we use totalAccruedYield()
 291 |     |         // For EarnerManager, we use mBalanceOf(ext) - totalSupply (edited)
 292 | *   |         _updateYieldToOneState(callNum);
 293 | *   |         _updateYieldFeeState(callNum);
 294 | *   |         _updateEarnerManagerState(callNum);
 295 | *   |         _updateSwapFacilityState(callNum);
 296 | *   |         _checkPoolState(callNum);
 297 |     |     }
 298 |     | 
 299 | *   |     function _updateYieldToOneState(uint8 callNum) private {
 300 | *   |         for (uint256 i = 0; i < mYieldToOneArray.length; i++) {
 301 | *   |             address extAddress = mYieldToOneArray[i];
 302 | *   |             states[callNum].mYieldToOne[extAddress].yield = IMYieldToOne(extAddress).yield();
 303 |     |         }
 304 |     |     }
 305 |     | 
 306 | *   |     function _updateYieldFeeState(uint8 callNum) private {
 307 | *   |         for (uint256 i = 0; i < mYieldFeeArray.length; i++) {
 308 | *   |             address extAddress = mYieldFeeArray[i];
 309 | *   |             states[callNum].mYieldFee[extAddress].balanceOfM0 = mToken.balanceOf(extAddress);
 310 | *   |             states[callNum].mYieldFee[extAddress].principalBalanceOf = mToken.principalBalanceOf(extAddress);
 311 | *   |             states[callNum].mYieldFee[extAddress].totalAccruedYield = IMYieldFee(extAddress).totalAccruedYield();
 312 | *   |             states[callNum].mYieldFee[extAddress].totalAccruedFee = IMYieldFee(extAddress).totalAccruedFee();
 313 | *   |             states[callNum].mYieldFee[extAddress].projectedTotalSupply = IMYieldFee(extAddress).projectedTotalSupply();
 314 |     |             // ==== logical coverage ====
 315 | *   |             states[callNum].mYieldFee[extAddress].currentIndex = MYieldFee(extAddress).currentIndex();
 316 | *   |             states[callNum].mYieldFee[extAddress].latestIndex = MYieldFee(extAddress).latestIndex();
 317 | *   |             states[callNum].mYieldFee[extAddress].latestRate = MYieldFee(extAddress).latestRate();
 318 | *   |             states[callNum].mYieldFee[extAddress].totalAccruedFee = MYieldFee(extAddress).totalAccruedFee();
 319 | *   |             states[callNum].mYieldFee[extAddress].feeRate = MYieldFee(extAddress).feeRate();
 320 |     |         }
 321 |     |     }
 322 |     | 
 323 | *   |     function _updateEarnerManagerState(uint8 callNum) private {
 324 | *   |         for (uint256 i = 0; i < mEarnerManagerArray.length; i++) {
 325 | *   |             address extAddress = mEarnerManagerArray[i];
 326 | *   |             uint256 mBalance = mToken.balanceOf(extAddress);
 327 | *   |             uint256 totalSupply = IERC20(extAddress).totalSupply();
 328 | *   |             states[callNum].mEarnerManager[extAddress].mBalanceOf = mBalance;
 329 | *   |             states[callNum].mEarnerManager[extAddress].totalSupply = totalSupply;
 330 | *   |             states[callNum].mEarnerManager[extAddress].yield = mBalance > totalSupply ? mBalance - totalSupply : 0;
 331 | *   |             states[callNum].mEarnerManager[extAddress].projectedTotalSupply = MEarnerManager(extAddress)
 332 |     |                 .projectedTotalSupply();
 333 |     |             // ==== logical coverage ====
 334 | *   |             for (uint256 j = 0; j < USERS.length; j++) {
 335 | *   |                 address user = USERS[j];
 336 | *   |                 uint256 accruedYield = MEarnerManager(extAddress).accruedYieldOf(user);
 337 | *   |                 uint256 accruedFee = MEarnerManager(extAddress).accruedFeeOf(user);
 338 | *   |                 (uint256 yieldWithFee, , ) = MEarnerManager(extAddress).accruedYieldAndFeeOf(user);
 339 | *   |                 states[callNum].mEarnerManager[extAddress].accruedYieldOf[user] = accruedYield;
 340 | *   |                 states[callNum].mEarnerManager[extAddress].accruedFeeOf[user] = accruedFee;
 341 | *   |                 states[callNum].mEarnerManager[extAddress].accruedYieldAndFeeOf[user] = yieldWithFee;
 342 |     |             }
 343 |     |         }
 344 |     |     }
 345 |     | 
 346 | *   |     function _updateSwapFacilityState(uint8 callNum) private {
 347 | *   |         states[callNum].swapFacilityBalanceOfM0 = mToken.balanceOf(address(swapFacility));
 348 |     |     }
 349 |     | 
 350 | *   |     function _checkPoolState(uint8 callNum) private {
 351 | *   |         (uint160 sqrtPriceX96, int24 tick, , , , , ) = usdcMTokenPool.slot0();
 352 | *   |         uint128 liquidity = usdcMTokenPool.liquidity();
 353 | *   |         console.log("sqrtPriceX96", sqrtPriceX96);
 354 | *   |         console.log("tick", tick);
 355 | *   |         console.log("pool liquidity", liquidity);
 356 |     |     }
 357 |     | 
 358 | *   |     function _setActorState(uint8 callNum, address actor) internal virtual {
 359 | *   |         delete states[callNum].actorStates[actor].mTokenBalance;
 360 | *   |         delete states[callNum].actorStates[actor].allMEarnTokens;
 361 | *   |         delete states[callNum].actorStates[actor].allYieldFeeTokens;
 362 | *   |         delete states[callNum].actorStates[actor].allYieldToOneTokens;
 363 | *   |         delete states[callNum].actorStates[actor].totalM0Balance;
 364 | *   |         delete states[callNum].actorStates[actor].usdcBalance;
 365 |     | 
 366 | *   |         states[callNum].actorStates[actor].mTokenBalance = mToken.balanceOf(actor);
 367 | *   |         states[callNum].actorStates[actor].usdcBalance = USDC.balanceOf(actor);
 368 | *   |         for (uint256 i = 0; i < mEarnerManagerArray.length; i++) {
 369 | *   |             address extAddress = mEarnerManagerArray[i];
 370 | *   |             states[callNum].actorStates[actor].allMEarnTokens += IMTokenLike(extAddress).balanceOf(actor);
 371 |     |         }
 372 | *   |         for (uint256 i = 0; i < mYieldFeeArray.length; i++) {
 373 | *   |             address extAddress = mYieldFeeArray[i];
 374 | *   |             states[callNum].actorStates[actor].allYieldFeeTokens += IMTokenLike(extAddress).balanceOf(actor);
 375 |     |         }
 376 | *   |         for (uint256 i = 0; i < mYieldToOneArray.length; i++) {
 377 | *   |             address extAddress = mYieldToOneArray[i];
 378 | *   |             states[callNum].actorStates[actor].allYieldToOneTokens += IMTokenLike(extAddress).balanceOf(actor);
 379 |     |         }
 380 | *   |         states[callNum].actorStates[actor].totalM0Balance =
 381 | *   |             states[callNum].actorStates[actor].mTokenBalance +
 382 | *   |             states[callNum].actorStates[actor].allMEarnTokens +
 383 | *   |             states[callNum].actorStates[actor].allYieldFeeTokens +
 384 | *   |             states[callNum].actorStates[actor].allYieldToOneTokens;
 385 |     |     }
 386 |     | 
 387 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
 388 |     |         return a < b ? a : b;
 389 |     |     }
 390 |     | }
 391 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/FuzzStorageVariables.sol
   1 |     | // SPDX-License-Identifier: UNTITLED
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../utils/FuzzActors.sol";
   5 |     | 
   6 |     | import { ContinuousIndexingMath } from "lib/common/src/libs/ContinuousIndexingMath.sol";
   7 |     | import { IndexingMath } from "lib/common/src/libs/IndexingMath.sol";
   8 |     | import { Upgrades, UnsafeUpgrades } from "lib/openzeppelin-foundry-upgrades/src/Upgrades.sol";
   9 |     | import { SwapFacility } from "src/swap/SwapFacility.sol";
  10 |     | import { MockRateOracle } from "test/utils/Mocks.sol";
  11 |     | import { MockRegistrar } from "test/fuzzing/mocks/MockRegistar.sol";
  12 |     | import { MToken } from "test/fuzzing/mocks/MToken.sol";
  13 |     | import { MockERC20 } from "test/fuzzing/mocks/MockERC20.sol";
  14 |     | import { Helpers } from "test/utils/Helpers.sol";
  15 |     | 
  16 |     | import { MYieldToOne } from "src/projects/yieldToOne/MYieldToOne.sol";
  17 |     | import { JMIExtension } from "src/projects/jmi/JMIExtension.sol";
  18 |     | import { MEarnerManagerHarness } from "test/harness/MEarnerManagerHarness.sol";
  19 |     | import { MYieldFeeHarness } from "test/harness/MYieldFeeHarness.sol";
  20 |     | 
  21 |     | import { WETH9 as WETH } from "uniswapv3/mocks/WETH.sol";
  22 |     | import { UniswapV3Factory } from "uniswapv3/v3-core/UniswapV3Factory.sol";
  23 |     | import { SwapRouter02 } from "uniswapv3/v3-periphery/SwapRouter02.sol";
  24 |     | import { NonfungiblePositionManager } from "uniswapv3/v3-periphery/NonfungiblePositionManager.sol";
  25 |     | import { UniswapV3SwapAdapter } from "src/swap/UniswapV3SwapAdapter.sol";
  26 |     | import { WrappedMToken } from "test/fuzzing/mocks/WrappedMToken.f.sol";
  27 |     | import { IUniswapV3Pool } from "uniswapv3/v3-core/interfaces/IUniswapV3Pool.sol";
  28 |     | 
  29 |     | import { EarnerRateModel } from "test/fuzzing/mocks/rateModels/EarnerRateModel.sol";
  30 |     | import { MinterRateModel } from "test/fuzzing/mocks/rateModels/MinterRateModel.sol";
  31 |     | import { MinterGateway } from "test/fuzzing/mocks/MinterGateway.f.sol";
  32 |     | import { DirectPoolMinter } from "test/fuzzing/mocks/DirectPoolMinter.sol";
  33 |     | 
  34 |     | contract FuzzStorageVariables is FuzzActors {
  35 |     |     // ==============================================================
  36 |     |     // FUZZING SUITE SETUP
  37 |     |     // ==============================================================
  38 |     | 
  39 |     |     address currentActor;
  40 | *   |     bool _setActor = true;
  41 |     | 
  42 | *   |     uint256 internal constant PRIME = 2147483647;
  43 | *   |     uint256 internal constant SEED = 22;
  44 | *   |     uint256 iteration = 1; // fuzzing iteration
  45 |     |     uint256 lastTimestamp;
  46 |     | 
  47 |     |     bool internal protocolSet;
  48 |     | 
  49 |     |     //==============================================================
  50 |     |     // REVERTS CONFIGURATION
  51 |     |     //==============================================================
  52 |     | 
  53 |     |     bool internal constant CATCH_REQUIRE_REVERT = true; // Set to false to ignore require()/revert()
  54 | *   |     bool internal constant CATCH_EMPTY_REVERTS = true; // Set to true to allow empty return data
  55 |     | 
  56 |     |     // ==============================================================
  57 |     |     // M0 CONFIGURATION
  58 |     |     // ==============================================================
  59 |     | 
  60 | *   |     uint16 public constant YIELD_FEE_RATE = 2000; // 20%
  61 |     | 
  62 |     |     bytes32 public constant EARNERS_LIST = "earners";
  63 |     |     uint32 public constant M_EARNER_RATE = ContinuousIndexingMath.BPS_SCALED_ONE / 10; // 10% APY
  64 |     | 
  65 |     |     uint56 public constant EXP_SCALED_ONE = 1e12;
  66 |     | 
  67 |     |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  68 |     |     bytes32 public constant BLACKLIST_MANAGER_ROLE = keccak256("BLACKLIST_MANAGER_ROLE");
  69 |     |     bytes32 public constant FREEZE_MANAGER_ROLE = keccak256("FREEZE_MANAGER_ROLE");
  70 |     |     bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
  71 |     |     bytes32 public constant FEE_MANAGER_ROLE = keccak256("FEE_MANAGER_ROLE");
  72 |     |     bytes32 public constant YIELD_RECIPIENT_MANAGER_ROLE = keccak256("YIELD_RECIPIENT_MANAGER_ROLE");
  73 |     |     bytes32 public constant EARNER_MANAGER_ROLE = keccak256("EARNER_MANAGER_ROLE");
  74 |     |     bytes32 public constant ASSET_CAP_MANAGER_ROLE = keccak256("ASSET_CAP_MANAGER_ROLE");
  75 | *   |     bytes32 public constant M_SWAPPER_ROLE = keccak256("M_SWAPPER_ROLE");
  76 |     | 
  77 |     |     uint16 public constant ONE_HUNDRED_PERCENT = 10_000;
  78 | *   |     uint24 public constant UNISWAP_V3_FEE = 100;
  79 |     | 
  80 |     |     // ==============================================================
  81 |     |     // M0 SETTINGS
  82 |     |     // ==============================================================
  83 |     |     bytes32 internal constant MAX_EARNER_RATE = "max_earner_rate";
  84 |     |     bytes32 internal constant BASE_MINTER_RATE = "base_minter_rate";
  85 |     | 
  86 | *   |     uint32 internal _baseEarnerRate = ContinuousIndexingMath.BPS_SCALED_ONE / 10; // 10% APY
  87 | *   |     uint32 internal _baseMinterRate = ContinuousIndexingMath.BPS_SCALED_ONE / 10; // 10% APY
  88 | *   |     uint256 internal _updateInterval = 24 hours;
  89 | *   |     uint256 internal _mintDelay = 0;
  90 | *   |     uint256 internal _mintTtl = 0;
  91 | *   |     uint256 internal _mintRatio = 9_000; // 90%
  92 | *   |     uint32 internal _penaltyRate = 100; // 1%, bps
  93 | *   |     uint32 internal _minterFreezeTime = 24 hours;
  94 |     | 
  95 | *   |     uint256 internal _start = block.timestamp;
  96 |     | 
  97 |     |     // ==============================================================
  98 |     |     // M0 CONTRACTS
  99 |     |     // ==============================================================
 100 |     | 
 101 |     |     WrappedMToken internal wMToken;
 102 |     |     MockERC20 internal USDC;
 103 |     |     WETH internal weth;
 104 |     | 
 105 |     |     IUniswapV3Pool internal usdcMTokenPool;
 106 |     |     DirectPoolMinter internal minter;
 107 |     | 
 108 |     |     address[] internal whitelistedTokens;
 109 |     |     UniswapV3Factory internal uniV3Factory;
 110 |     |     SwapRouter02 internal v3SwapRouter;
 111 |     |     NonfungiblePositionManager internal positionManager;
 112 |     | 
 113 |     |     MToken internal mToken;
 114 |     |     MockRateOracle internal rateOracle;
 115 |     |     MockRegistrar internal registrar;
 116 |     |     UniswapV3SwapAdapter internal swapAdapter;
 117 |     |     SwapFacility internal swapFacility;
 118 |     | 
 119 |     |     MYieldToOne internal mYieldToOne1;
 120 |     |     MYieldFeeHarness internal mYieldFee1;
 121 |     |     MEarnerManagerHarness internal mEarnerManager1;
 122 |     | 
 123 |     |     MYieldToOne internal mYieldToOne2;
 124 |     |     MYieldFeeHarness internal mYieldFee2;
 125 |     |     MEarnerManagerHarness internal mEarnerManager2;
 126 |     | 
 127 |     |     MYieldToOne internal mYieldToOne3;
 128 |     |     MYieldFeeHarness internal mYieldFee3;
 129 |     |     MEarnerManagerHarness internal mEarnerManager3;
 130 |     | 
 131 |     |     JMIExtension internal jmiExtension1;
 132 |     |     JMIExtension internal jmiExtension2;
 133 |     |     JMIExtension internal jmiExtension3;
 134 |     | 
 135 |     |     MockERC20 internal DAI; // Asset token for JMI Extension
 136 |     | 
 137 |     |     address[3] internal mYieldToOneArray;
 138 |     |     address[3] internal mYieldFeeArray;
 139 |     |     address[3] internal mEarnerManagerArray;
 140 |     |     address[3] internal jmiExtensionArray;
 141 |     |     address[12] internal allExtensions;
 142 |     | 
 143 |     |     EarnerRateModel internal earnerRateModel;
 144 |     |     MinterRateModel internal minterRateModel;
 145 |     | 
 146 |     |     MinterGateway internal minterGateway;
 147 |     | }
 148 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/postconditions/PostconditionsBase.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.25;
  3 |     | 
  4 |     | import "../../properties/Properties.sol";
  5 |     | 
  6 |     | contract PostconditionsBase is Properties {
  7 | *   |     function onSuccessInvariantsGeneral(bytes memory returnData) internal {
  8 | *   |         checkLogicalCoverage();
  9 |     | 
 10 | *   |         invariant_MYF_01();
 11 | *   |         invariant_MYF_02();
 12 | *   |         invariant_SWAP_02();
 13 | *   |         invariant_MEARN_01();
 14 |     |     }
 15 |     | 
 16 | *   |     function onFailInvariantsGeneral(bytes memory returnData) internal {
 17 | *   |         checkLogicalCoverage();
 18 | *   |         invariant_ERR(returnData);
 19 |     |     }
 20 |     | }
 21 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/postconditions/PostconditionsJMIExtension.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PostconditionsBase.sol";
  5 |     | 
  6 |     | contract PostconditionsJMIExtension is PostconditionsBase {
  7 |     |     function wrapAssetPostconditions_JMI(bool success, bytes memory returnData) internal {
  8 |     |         if (success) {
  9 |     |             _after();
 10 |     |             onSuccessInvariantsGeneral(returnData);
 11 |     |         } else {
 12 |     |             onFailInvariantsGeneral(returnData);
 13 |     |         }
 14 |     |     }
 15 |     | 
 16 |     |     function replaceAssetWithMPostconditions_JMI(bool success, bytes memory returnData) internal {
 17 |     |         if (success) {
 18 |     |             _after();
 19 |     |             onSuccessInvariantsGeneral(returnData);
 20 |     |         } else {
 21 |     |             onFailInvariantsGeneral(returnData);
 22 |     |         }
 23 |     |     }
 24 |     | 
 25 |     |     function setAssetCapPostconditions_JMI(bool success, bytes memory returnData) internal {
 26 |     |         if (success) {
 27 |     |             _after();
 28 |     |             onSuccessInvariantsGeneral(returnData);
 29 |     |         } else {
 30 |     |             onFailInvariantsGeneral(returnData);
 31 |     |         }
 32 |     |     }
 33 |     | 
 34 |     |     function pausePostconditions_JMI(bool success, bytes memory returnData) internal {
 35 |     |         if (success) {
 36 |     |             _after();
 37 |     |             onSuccessInvariantsGeneral(returnData);
 38 |     |         } else {
 39 |     |             onFailInvariantsGeneral(returnData);
 40 |     |         }
 41 |     |     }
 42 |     | 
 43 |     |     function unpausePostconditions_JMI(bool success, bytes memory returnData) internal {
 44 |     |         if (success) {
 45 |     |             _after();
 46 |     |             onSuccessInvariantsGeneral(returnData);
 47 |     |         } else {
 48 |     |             onFailInvariantsGeneral(returnData);
 49 |     |         }
 50 |     |     }
 51 |     | 
 52 |     |     function freezePostconditions_JMI(bool success, bytes memory returnData) internal {
 53 |     |         if (success) {
 54 |     |             _after();
 55 |     |             onSuccessInvariantsGeneral(returnData);
 56 |     |         } else {
 57 |     |             onFailInvariantsGeneral(returnData);
 58 |     |         }
 59 |     |     }
 60 |     | 
 61 |     |     function unfreezePostconditions_JMI(bool success, bytes memory returnData) internal {
 62 |     |         if (success) {
 63 |     |             _after();
 64 |     |             onSuccessInvariantsGeneral(returnData);
 65 |     |         } else {
 66 |     |             onFailInvariantsGeneral(returnData);
 67 |     |         }
 68 |     |     }
 69 |     | 
 70 |     |     function claimYieldPostconditions_JMI(bool success, bytes memory returnData) internal {
 71 |     |         if (success) {
 72 |     |             _after();
 73 |     |             onSuccessInvariantsGeneral(returnData);
 74 |     |         } else {
 75 |     |             onFailInvariantsGeneral(returnData);
 76 |     |         }
 77 |     |     }
 78 |     | 
 79 |     |     function transferPostconditions_JMI(bool success, bytes memory returnData) internal {
 80 |     |         if (success) {
 81 |     |             _after();
 82 |     |             onSuccessInvariantsGeneral(returnData);
 83 |     |         } else {
 84 |     |             onFailInvariantsGeneral(returnData);
 85 |     |         }
 86 |     |     }
 87 |     | 
 88 |     |     function approvePostconditions_JMI(bool success, bytes memory returnData) internal {
 89 |     |         if (success) {
 90 |     |             _after();
 91 |     |             onSuccessInvariantsGeneral(returnData);
 92 |     |         } else {
 93 |     |             onFailInvariantsGeneral(returnData);
 94 |     |         }
 95 |     |     }
 96 |     | }
 97 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/postconditions/PostconditionsMEarnerManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PostconditionsBase.sol";
  5 |     | 
  6 |     | contract PostconditionsMEarnerManager is PostconditionsBase {
  7 | *   |     function setAccountInfoPostconditions(bool success, bytes memory returnData) internal {
  8 | *   |         if (success) {
  9 | *   |             _after();
 10 | *   |             onSuccessInvariantsGeneral(returnData);
 11 |     |         } else {
 12 | *   |             onFailInvariantsGeneral(returnData);
 13 |     |         }
 14 |     |     }
 15 |     | 
 16 | *   |     function setFeeRecipientPostconditions_MEarnerManager(bool success, bytes memory returnData) internal {
 17 | *   |         if (success) {
 18 | *   |             _after();
 19 | *   |             onSuccessInvariantsGeneral(returnData);
 20 |     |         } else {
 21 | *   |             onFailInvariantsGeneral(returnData);
 22 |     |         }
 23 |     |     }
 24 |     | 
 25 | *   |     function claimForPostconditions(bool success, bytes memory returnData) internal {
 26 | *   |         if (success) {
 27 | *   |             _after();
 28 | *   |             onSuccessInvariantsGeneral(returnData);
 29 |     |         } else {
 30 |     |             onFailInvariantsGeneral(returnData);
 31 |     |         }
 32 |     |     }
 33 |     | 
 34 | *   |     function approvePostconditions_MEarnerManager(bool success, bytes memory returnData) internal {
 35 | *   |         if (success) {
 36 | *   |             _after();
 37 | *   |             onSuccessInvariantsGeneral(returnData);
 38 |     |         } else {
 39 | *   |             onFailInvariantsGeneral(returnData);
 40 |     |         }
 41 |     |     }
 42 |     | 
 43 | *   |     function transferPostconditions_MEarnerManager(bool success, bytes memory returnData) internal {
 44 | *   |         if (success) {
 45 | *   |             _after();
 46 | *   |             onSuccessInvariantsGeneral(returnData);
 47 |     |         } else {
 48 |     |             onFailInvariantsGeneral(returnData);
 49 |     |         }
 50 |     |     }
 51 |     | 
 52 | *   |     function transferFromPostconditions_MEarnerManager(bool success, bytes memory returnData) internal {
 53 | *   |         if (success) {
 54 | *   |             _after();
 55 | *   |             onSuccessInvariantsGeneral(returnData);
 56 |     |         } else {
 57 |     |             onFailInvariantsGeneral(returnData);
 58 |     |         }
 59 |     |     }
 60 |     | 
 61 | *   |     function enableEarningPostconditions_MEarnerManager(bool success, bytes memory returnData) internal {
 62 | *   |         if (success) {
 63 |     |             _after();
 64 |     |             onSuccessInvariantsGeneral(returnData);
 65 |     |         } else {
 66 | *   |             onFailInvariantsGeneral(returnData);
 67 |     |         }
 68 |     |     }
 69 |     | 
 70 | *   |     function disableEarningPostconditions_MEarnerManager(bool success, bytes memory returnData) internal {
 71 | *   |         if (success) {
 72 | *   |             _after();
 73 | *   |             onSuccessInvariantsGeneral(returnData);
 74 |     |         } else {
 75 | *   |             onFailInvariantsGeneral(returnData);
 76 |     |         }
 77 |     |     }
 78 |     | }
 79 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/postconditions/PostconditionsMToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PostconditionsBase.sol";
  5 |     | 
  6 |     | contract PostconditionsMToken is PostconditionsBase {
  7 | *   |     function mintPostconditions(address account, uint256 amount) internal {
  8 | *   |         _after();
  9 |     |     }
 10 |     | 
 11 |     |     function startEarningPostconditions(bool success, bytes memory returnData, address account) internal {
 12 |     |         if (success) {
 13 |     |             _after();
 14 |     |             onSuccessInvariantsGeneral(returnData);
 15 |     |         } else {
 16 |     |             onFailInvariantsGeneral(returnData);
 17 |     |         }
 18 |     |     }
 19 |     | 
 20 |     |     function stopEarningPostconditions(bool success, bytes memory returnData, address account) internal {
 21 |     |         if (success) {
 22 |     |             _after();
 23 |     |             onSuccessInvariantsGeneral(returnData);
 24 |     |         } else {
 25 |     |             onFailInvariantsGeneral(returnData);
 26 |     |         }
 27 |     |     }
 28 |     | 
 29 | *   |     function warpDaysPostconditions() internal {
 30 | *   |         _after();
 31 | *   |         onSuccessInvariantsGeneral(bytes(""));
 32 |     |     }
 33 |     | 
 34 | *   |     function warpWeeksPostconditions(uint256 weeks_) internal {
 35 | *   |         _after();
 36 | *   |         onSuccessInvariantsGeneral(bytes(""));
 37 |     |     }
 38 |     | }
 39 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/postconditions/PostconditionsMYieldFee.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./PostconditionsBase.sol";
   5 |     | 
   6 |     | contract PostconditionsMYieldFee is PostconditionsBase {
   7 | *   |     function claimYieldForPostconditions(bool success, bytes memory returnData) internal {
   8 | *   |         if (success) {
   9 | *   |             _after();
  10 | *   |             onSuccessInvariantsGeneral(returnData);
  11 |     |         } else {
  12 |     |             onFailInvariantsGeneral(returnData);
  13 |     |         }
  14 |     |     }
  15 |     | 
  16 | *   |     function claimFeePostconditions(bool success, bytes memory returnData) internal {
  17 | *   |         if (success) {
  18 | *   |             _after();
  19 | *   |             onSuccessInvariantsGeneral(returnData);
  20 |     |         } else {
  21 |     |             onFailInvariantsGeneral(returnData);
  22 |     |         }
  23 |     |     }
  24 |     | 
  25 | *   |     function updateIndexPostconditions(bool success, bytes memory returnData) internal {
  26 | *   |         if (success) {
  27 | *   |             _after();
  28 | *   |             onSuccessInvariantsGeneral(returnData);
  29 |     |         } else {
  30 |     |             onFailInvariantsGeneral(returnData);
  31 |     |         }
  32 |     |     }
  33 |     | 
  34 | *   |     function setFeeRatePostconditions(bool success, bytes memory returnData) internal {
  35 | *   |         if (success) {
  36 | *   |             _after();
  37 | *   |             onSuccessInvariantsGeneral(returnData);
  38 |     |         } else {
  39 |     |             onFailInvariantsGeneral(returnData);
  40 |     |         }
  41 |     |     }
  42 |     | 
  43 | *   |     function setFeeRecipientPostconditions_MYieldFee(bool success, bytes memory returnData) internal {
  44 | *   |         if (success) {
  45 | *   |             _after();
  46 | *   |             onSuccessInvariantsGeneral(returnData);
  47 |     |         } else {
  48 |     |             onFailInvariantsGeneral(returnData);
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 | *   |     function setClaimRecipientPostconditions(bool success, bytes memory returnData) internal {
  53 | *   |         if (success) {
  54 | *   |             _after();
  55 | *   |             onSuccessInvariantsGeneral(returnData);
  56 |     |         } else {
  57 |     |             onFailInvariantsGeneral(returnData);
  58 |     |         }
  59 |     |     }
  60 |     | 
  61 | *   |     function approvePostconditions_MYieldFee(bool success, bytes memory returnData) internal {
  62 | *   |         if (success) {
  63 | *   |             _after();
  64 | *   |             onSuccessInvariantsGeneral(returnData);
  65 |     |         } else {
  66 |     |             onFailInvariantsGeneral(returnData);
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 | *   |     function transferPostconditions_MYieldFee(bool success, bytes memory returnData) internal {
  71 | *   |         if (success) {
  72 | *   |             _after();
  73 | *   |             onSuccessInvariantsGeneral(returnData);
  74 |     |         } else {
  75 |     |             onFailInvariantsGeneral(returnData);
  76 |     |         }
  77 |     |     }
  78 |     | 
  79 | *   |     function transferFromPostconditions_MYieldFee(bool success, bytes memory returnData) internal {
  80 | *   |         if (success) {
  81 | *   |             _after();
  82 | *   |             onSuccessInvariantsGeneral(returnData);
  83 |     |         } else {
  84 |     |             onFailInvariantsGeneral(returnData);
  85 |     |         }
  86 |     |     }
  87 |     | 
  88 | *   |     function enableEarningPostconditions_MYieldFee(bool success, bytes memory returnData) internal {
  89 | *   |         if (success) {
  90 | *   |             _after();
  91 | *   |             onSuccessInvariantsGeneral(returnData);
  92 |     |         } else {
  93 | *   |             onFailInvariantsGeneral(returnData);
  94 |     |         }
  95 |     |     }
  96 |     | 
  97 | *   |     function disableEarningPostconditions_MYieldFee(bool success, bytes memory returnData) internal {
  98 | *   |         if (success) {
  99 | *   |             _after();
 100 | *   |             onSuccessInvariantsGeneral(returnData);
 101 |     |         } else {
 102 | *   |             onFailInvariantsGeneral(returnData);
 103 |     |         }
 104 |     |     }
 105 |     | }
 106 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/postconditions/PostconditionsMYieldToOne.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PostconditionsBase.sol";
  5 |     | 
  6 |     | contract PostconditionsMYieldToOne is PostconditionsBase {
  7 | *   |     function claimYieldPostconditions(bool success, bytes memory returnData) internal {
  8 | *   |         if (success) {
  9 | *   |             _after();
 10 | *   |             onSuccessInvariantsGeneral(returnData);
 11 |     |         } else {
 12 |     |             onFailInvariantsGeneral(returnData);
 13 |     |         }
 14 |     |     }
 15 |     | 
 16 | *   |     function setYieldRecipientPostconditions_MYieldToOne(bool success, bytes memory returnData) internal {
 17 | *   |         if (success) {
 18 | *   |             _after();
 19 | *   |             onSuccessInvariantsGeneral(returnData);
 20 |     |         } else {
 21 |     |             onFailInvariantsGeneral(returnData);
 22 |     |         }
 23 |     |     }
 24 |     | 
 25 | *   |     function enableEarningPostconditions_MYieldToOne(bool success, bytes memory returnData) internal {
 26 | *   |         if (success) {
 27 | *   |             _after();
 28 | *   |             onSuccessInvariantsGeneral(returnData);
 29 |     |         } else {
 30 | *   |             onFailInvariantsGeneral(returnData);
 31 |     |         }
 32 |     |     }
 33 |     | 
 34 | *   |     function disableEarningPostconditions_MYieldToOne(bool success, bytes memory returnData) internal {
 35 | *   |         if (success) {
 36 | *   |             _after();
 37 | *   |             onSuccessInvariantsGeneral(returnData);
 38 |     |         } else {
 39 | *   |             onFailInvariantsGeneral(returnData);
 40 |     |         }
 41 |     |     }
 42 |     | 
 43 | *   |     function approvePostconditions_MYieldToOne(bool success, bytes memory returnData) internal {
 44 | *   |         if (success) {
 45 | *   |             _after();
 46 | *   |             onSuccessInvariantsGeneral(returnData);
 47 |     |         } else {
 48 |     |             onFailInvariantsGeneral(returnData);
 49 |     |         }
 50 |     |     }
 51 |     | 
 52 | *   |     function transferPostconditions_MYieldToOne(bool success, bytes memory returnData) internal {
 53 | *   |         if (success) {
 54 | *   |             _after();
 55 | *   |             onSuccessInvariantsGeneral(returnData);
 56 |     |         } else {
 57 |     |             onFailInvariantsGeneral(returnData);
 58 |     |         }
 59 |     |     }
 60 |     | 
 61 | *   |     function transferFromPostconditions_MYieldToOne(bool success, bytes memory returnData) internal {
 62 | *   |         if (success) {
 63 | *   |             _after();
 64 | *   |             onSuccessInvariantsGeneral(returnData);
 65 |     |         } else {
 66 |     |             onFailInvariantsGeneral(returnData);
 67 |     |         }
 68 |     |     }
 69 |     | }
 70 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/postconditions/PostconditionsSwapFacility.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.26;
  3 |     | 
  4 |     | import "./PostconditionsBase.sol";
  5 |     | 
  6 |     | contract PostconditionsSwapFacility is PostconditionsBase {
  7 | *   |     function swapPostconditions(bool success, bytes memory returnData, SwapParams memory params) internal {
  8 | *   |         if (success) {
  9 |     |             _after();
 10 |     |             invariant_SWAP_01(params);
 11 |     |             invariant_SWAP_03();
 12 |     |             onSuccessInvariantsGeneral(returnData);
 13 |     |         } else {
 14 | *   |             onFailInvariantsGeneral(returnData);
 15 |     |         }
 16 |     |     }
 17 |     | 
 18 | *   |     function swapInMPostconditions(bool success, bytes memory returnData, SwapInMParams memory params) internal {
 19 | *   |         if (success) {
 20 | *   |             _after();
 21 | *   |             invariant_SWAP_03();
 22 |     | 
 23 | *   |             onSuccessInvariantsGeneral(returnData);
 24 |     |         } else {
 25 | *   |             onFailInvariantsGeneral(returnData);
 26 |     |         }
 27 |     |     }
 28 |     | 
 29 | *   |     function swapOutMPostconditions(bool success, bytes memory returnData, SwapOutMParams memory params) internal {
 30 | *   |         if (success) {
 31 |     |             _after();
 32 |     |             invariant_SWAP_03();
 33 |     | 
 34 |     |             onSuccessInvariantsGeneral(returnData);
 35 |     |         } else {
 36 | *   |             onFailInvariantsGeneral(returnData);
 37 |     |         }
 38 |     |     }
 39 |     | 
 40 | *   |     function swapInTokenPostconditions(
 41 |     |         bool success,
 42 |     |         bytes memory returnData,
 43 |     |         SwapInTokenParams memory params
 44 |     |     ) internal {
 45 | *   |         if (success) {
 46 |     |             _after();
 47 |     |             invariant_SWAP_04(params);
 48 |     |             onSuccessInvariantsGeneral(returnData);
 49 |     |         } else {
 50 | *   |             onFailInvariantsGeneral(returnData);
 51 |     |         }
 52 |     |     }
 53 |     | 
 54 | *   |     function swapOutTokenPostconditions(
 55 |     |         bool success,
 56 |     |         bytes memory returnData,
 57 |     |         SwapOutTokenParams memory params
 58 |     |     ) internal {
 59 | *   |         if (success) {
 60 |     |             _after();
 61 |     |             invariant_SWAP_05(params);
 62 |     |             onSuccessInvariantsGeneral(returnData);
 63 |     |         } else {
 64 | *   |             onFailInvariantsGeneral(returnData);
 65 |     |         }
 66 |     |     }
 67 |     | }
 68 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/postconditions/PostconditionsUni.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PostconditionsBase.sol";
  5 |     | 
  6 |     | contract PostconditionsUni is PostconditionsBase {
  7 | *   |     function allLiquidityUniPostconditions(
  8 |     |         bool success,
  9 |     |         bytes memory returnData,
 10 |     |         address[] memory actorsToUpdate,
 11 |     |         address user,
 12 |     |         uint256 amount0Desired,
 13 |     |         uint256 amount1Desired,
 14 |     |         int24 tickLower,
 15 |     |         int24 tickUpper
 16 |     |     ) internal {
 17 | *   |         if (success) {
 18 | *   |             _after(actorsToUpdate);
 19 |     | 
 20 |     |             // Verify liquidity was added
 21 | *   |             assertTrue(
 22 | *   |                 true, // In real impl, check that position exists
 23 |     |                 "UNI-01: Liquidity should be added to the pool"
 24 |     |             );
 25 |     | 
 26 |     |             // Verify tick range is valid
 27 |     |             assertTrue(tickLower < tickUpper, "UNI-02: Tick lower must be less than tick upper");
 28 |     | 
 29 |     |             console.log("Successfully added liquidity");
 30 |     |         } else {
 31 |     |             invariant_ERR(returnData);
 32 |     |         }
 33 |     |     }
 34 |     | 
 35 |     |     function swapZeroToOnePostconditions(
 36 |     |         bool success,
 37 |     |         bytes memory returnData,
 38 |     |         address[] memory actorsToUpdate,
 39 |     |         address user,
 40 |     |         uint256 amountIn,
 41 |     |         uint256 amountOut
 42 |     |     ) internal {
 43 |     |         if (success) {
 44 |     |             _after(actorsToUpdate);
 45 |     | 
 46 |     |             // Verify swap occurred
 47 |     |             assertTrue(amountOut > 0, "UNI-03: Swap should return non-zero output amount");
 48 |     | 
 49 |     |             console.log("Swap successful - USDC in:", amountIn, "WETH out:", amountOut);
 50 |     |         } else {
 51 |     |             invariant_ERR(returnData);
 52 |     |         }
 53 |     |     }
 54 |     | 
 55 |     |     function swapOneToZeroPostconditions(
 56 |     |         bool success,
 57 |     |         bytes memory returnData,
 58 |     |         address[] memory actorsToUpdate,
 59 |     |         address user,
 60 |     |         uint256 amountIn,
 61 |     |         uint256 amountOut
 62 |     |     ) internal {
 63 |     |         if (success) {
 64 |     |             _after(actorsToUpdate);
 65 |     | 
 66 |     |             // Verify swap occurred
 67 |     |             assertTrue(amountOut > 0, "UNI-04: Swap should return non-zero output amount");
 68 |     | 
 69 |     |             console.log("Swap successful - WETH in:", amountIn, "USDC out:", amountOut);
 70 |     |         } else {
 71 |     |             invariant_ERR(returnData);
 72 |     |         }
 73 |     |     }
 74 |     | }
 75 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/preconditions/PreconditionsBase.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../BeforeAfter.sol";
   5 |     | 
   6 |     | import { IV3SwapRouter } from "uniswapv3/v3-periphery/interfaces/IV3SwapRouter.sol";
   7 |     | 
   8 |     | contract PreconditionsBase is BeforeAfter {
   9 |     |     event LogAddress(address actor);
  10 |     | 
  11 |     |     modifier setCurrentActor() {
  12 | *r  |         require(protocolSet, "Protocol not set");
  13 |     | 
  14 | *   |         if (_setActor) {
  15 | *   |             uint256 fuzzNumber = generateFuzzNumber(iteration, SEED);
  16 | *   |             console.log("fuzz iteration", iteration);
  17 | *   |             currentActor = USERS[uint256(keccak256(abi.encodePacked(iteration * PRIME + SEED))) % (USERS.length)];
  18 |     | 
  19 | *   |             iteration += 1;
  20 |     | 
  21 |     |             // vm.startPrank(currentActor);
  22 | *   |             console.log("Pranking: ", toString(currentActor)); //echidna logs output
  23 | *   |             console.log("Block timestamp: ", block.timestamp);
  24 |     |             //check state and revert workaround
  25 | *   |             if (block.timestamp < lastTimestamp) {
  26 |     |                 vm.warp(lastTimestamp);
  27 |     |             } else {
  28 | *   |                 lastTimestamp = block.timestamp;
  29 |     |             }
  30 |     |         }
  31 | *   |         emit LogAddress(currentActor);
  32 |     |         _;
  33 |     |         // vm.stopPrank();
  34 |     |         // console.log("Stopped prank: ", toString(msg.sender));
  35 |     |     }
  36 |     | 
  37 |     |     function setActor(address targetUser) internal {
  38 |     |         address[] memory targetArray = USERS; //use several arrays
  39 |     |         require(targetArray.length > 0, "Target array is empty");
  40 |     | 
  41 |     |         // Find target user index
  42 |     |         uint256 targetIndex;
  43 |     |         bool found = false;
  44 |     |         for (uint256 i = 0; i < targetArray.length; i++) {
  45 |     |             if (targetArray[i] == targetUser) {
  46 |     |                 targetIndex = i;
  47 |     |                 console.log("Setting user", targetUser);
  48 |     |                 console.log("Index", i);
  49 |     | 
  50 |     |                 found = true;
  51 |     |                 break;
  52 |     |             }
  53 |     |         }
  54 |     | 
  55 |     |         require(found, "Target user not found in array");
  56 |     | 
  57 |     |         uint256 maxIterations = 100000; //  prevent infinite loops
  58 |     |         uint256 currentIteration = iteration;
  59 |     |         bool iterationFound = false;
  60 |     | 
  61 |     |         for (uint256 i = 0; i < maxIterations; i++) {
  62 |     |             uint256 hash = uint256(keccak256(abi.encodePacked(currentIteration * PRIME + SEED)));
  63 |     |             uint256 index = hash % targetArray.length;
  64 |     | 
  65 |     |             if (index == targetIndex) {
  66 |     |                 iteration = currentIteration;
  67 |     |                 iterationFound = true;
  68 |     |                 break;
  69 |     |             }
  70 |     | 
  71 |     |             currentIteration++;
  72 |     |         }
  73 |     | 
  74 |     |         require(iterationFound, "User index not found by setter");
  75 |     |     }
  76 |     | 
  77 | *   |     function generateFuzzNumber(uint256 iteration, uint256 seed) internal pure returns (uint256) {
  78 | *   |         return uint256(keccak256(abi.encodePacked(iteration * PRIME + seed)));
  79 |     |     }
  80 |     | 
  81 | *   |     function toString(address value) internal pure returns (string memory str) {
  82 | *   |         bytes memory s = new bytes(40);
  83 | *   |         for (uint256 i = 0; i < 20; i++) {
  84 | *   |             bytes1 b = bytes1(uint8(uint256(uint160(value)) / (2 ** (8 * (19 - i)))));
  85 | *   |             bytes1 hi = bytes1(uint8(b) / 16);
  86 | *   |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
  87 | *   |             s[2 * i] = char(hi);
  88 | *   |             s[2 * i + 1] = char(lo);
  89 |     |         }
  90 | *   |         return string(s);
  91 |     |     }
  92 |     | 
  93 | *   |     function char(bytes1 b) internal pure returns (bytes1 c) {
  94 | *   |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
  95 |     |         else return bytes1(uint8(b) + 0x57);
  96 |     |     }
  97 |     | 
  98 | *   |     function add_liquidity_direct(
  99 |     |         address user,
 100 |     |         address to,
 101 |     |         uint256 amount0Desired,
 102 |     |         uint256 amount1Desired,
 103 |     |         int24 tickLower,
 104 |     |         int24 tickUpper,
 105 |     |         address pool
 106 | *   |     ) public {
 107 | *   |         vm.startPrank(user);
 108 |     | 
 109 |     |         // Calculate liquidity
 110 | *   |         uint128 liquidity = minter.getLiquidityForAmounts(amount0Desired, amount1Desired, tickLower, tickUpper);
 111 | *   |         require(liquidity > 0, "Invalid liquidity");
 112 | *   |         console.log("liquidity check done", liquidity);
 113 |     |         // Approve tokens to the minter
 114 | *   |         USDC.approve(address(minter), amount0Desired);
 115 | *   |         wMToken.approve(address(minter), amount1Desired);
 116 |     | 
 117 |     |         // Mint liquidity
 118 | *r  |         (uint256 amount0, uint256 amount1) = minter.mintLiquidity(
 119 | *   |             to, // Recipient of the position
 120 | *   |             tickLower,
 121 | *   |             tickUpper,
 122 | *   |             liquidity,
 123 | *   |             amount0Desired, // Max USDC to spend
 124 | *   |             amount1Desired // Max wMToken to spend
 125 |     |         );
 126 |     | 
 127 |     |         // Log results
 128 | *   |         console.log("Liquidity minted:", uint256(liquidity));
 129 | *   |         console.log("USDC used:", uint256(amount0));
 130 | *   |         console.log("wMToken used:", uint256(amount1));
 131 |     | 
 132 |     |         // Verify position in the pool
 133 | *   |         bytes32 positionKey = bytes32(keccak256(abi.encodePacked(user, tickLower, tickUpper)));
 134 | *   |         IUniswapV3Pool(pool).positions(positionKey);
 135 |     | 
 136 | *   |         vm.stopPrank();
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @notice Swap token0 (USDC) to token1 (wMToken)
 141 |     |      * @param amountIn Amount of USDC to swap
 142 |     |      * @return amountOut Amount of wMToken received from the swap
 143 |     |      */
 144 | *   |     function swap_t0_for_t1(address actor, uint256 amountIn) internal returns (uint256 amountOut) {
 145 | *   |         console.log("Swapping token0 (USDC) for token1 (wMToken)");
 146 | *   |         vm.startPrank(actor);
 147 |     |         // Approve the router to spend token0 (USDC)
 148 | *   |         USDC.approve(address(v3SwapRouter), type(uint256).max);
 149 |     | 
 150 |     |         // Prepare exact input parameters (swapping exact amount of USDC for wMToken)
 151 | *   |         IV3SwapRouter.ExactInputSingleParams memory params = IV3SwapRouter.ExactInputSingleParams({
 152 | *   |             tokenIn: address(USDC),
 153 | *   |             tokenOut: address(wMToken),
 154 |     |             fee: UNISWAP_V3_FEE,
 155 | *   |             recipient: actor,
 156 | *   |             amountIn: amountIn,
 157 | *   |             amountOutMinimum: 0,
 158 | *   |             sqrtPriceLimitX96: 0 // No price limit (accept any price)
 159 |     |         });
 160 |     | 
 161 |     |         // Execute the swap
 162 | *r  |         amountOut = v3SwapRouter.exactInputSingle(params);
 163 |     | 
 164 |     |         // Log the results
 165 |     |         console.log("Swap completed:");
 166 |     |         console.log("USDC spent:", amountIn);
 167 |     |         console.log("wMToken received:", amountOut);
 168 |     |         vm.stopPrank();
 169 |     |         return amountOut;
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @notice Swap token1 (wMToken) to token0 (USDC)
 174 |     |      * @param amountIn Amount of wMToken to swap
 175 |     |      * @return amountOut Amount of USDC received from the swap
 176 |     |      */
 177 | *   |     function swap_t1_for_t0(address actor, uint256 amountIn) internal returns (uint256 amountOut) {
 178 | *   |         console.log("Swapping token1 (wMToken) for token0 (USDC)");
 179 | *   |         vm.startPrank(actor);
 180 |     |         // Approve the router to spend token1 (wMToken)
 181 | *   |         wMToken.approve(address(v3SwapRouter), type(uint256).max);
 182 |     | 
 183 |     |         // Prepare exact input parameters (swapping exact amount of wMToken for USDC)
 184 | *   |         IV3SwapRouter.ExactInputSingleParams memory params = IV3SwapRouter.ExactInputSingleParams({
 185 | *   |             tokenIn: address(wMToken),
 186 | *   |             tokenOut: address(USDC),
 187 |     |             fee: UNISWAP_V3_FEE,
 188 | *   |             recipient: actor,
 189 | *   |             amountIn: amountIn,
 190 | *   |             amountOutMinimum: 0,
 191 | *   |             sqrtPriceLimitX96: 0 // No price limit (accept any price)
 192 |     |         });
 193 |     | 
 194 |     |         // Execute the swap
 195 | *r  |         amountOut = v3SwapRouter.exactInputSingle(params);
 196 |     | 
 197 |     |         // Log the results
 198 |     |         console.log("Swap completed:");
 199 |     |         console.log("wMToken spent:", amountIn);
 200 |     |         console.log("USDC received:", amountOut);
 201 |     |         vm.stopPrank();
 202 |     |         return amountOut;
 203 |     |     }
 204 |     | }
 205 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/preconditions/PreconditionsJMIExtension.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PreconditionsBase.sol";
  5 |     | import { JMIExtension } from "src/projects/jmi/JMIExtension.sol";
  6 |     | 
  7 |     | contract PreconditionsJMIExtension is PreconditionsBase {
  8 |     |     function wrapAssetPreconditions_JMI(uint256 seed) internal returns (WrapAssetParams memory params) {
  9 |     |         params.instance = jmiExtensionArray[seed % jmiExtensionArray.length];
 10 |     |         params.asset = address(DAI);
 11 |     |         params.recipient = USERS[seed % USERS.length];
 12 |     |         params.amount = fl.clamp(seed, 1, DAI.balanceOf(currentActor));
 13 |     |     }
 14 |     | 
 15 |     |     function replaceAssetWithMPreconditions_JMI(uint256 seed) internal returns (ReplaceAssetWithMParams memory params) {
 16 |     |         params.instance = jmiExtensionArray[seed % jmiExtensionArray.length];
 17 |     |         params.asset = address(DAI);
 18 |     |         params.recipient = USERS[seed % USERS.length];
 19 |     |         // Amount must be <= asset balance held by the JMI extension
 20 |     |         uint256 assetBalance = JMIExtension(params.instance).assetBalanceOf(params.asset);
 21 |     |         params.amount = fl.clamp(seed, 1, assetBalance > 0 ? assetBalance : 1);
 22 |     |     }
 23 |     | 
 24 |     |     function setAssetCapPreconditions_JMI(uint256 seed) internal returns (SetAssetCapParams memory params) {
 25 |     |         params.instance = jmiExtensionArray[seed % jmiExtensionArray.length];
 26 |     |         params.asset = address(DAI);
 27 |     |         params.cap = seed; // Arbitrary cap value
 28 |     |     }
 29 |     | 
 30 |     |     function pausePreconditions_JMI(uint256 seed) internal returns (PauseParams memory params) {
 31 |     |         params.instance = jmiExtensionArray[seed % jmiExtensionArray.length];
 32 |     |     }
 33 |     | 
 34 |     |     function unpausePreconditions_JMI(uint256 seed) internal returns (PauseParams memory params) {
 35 |     |         params.instance = jmiExtensionArray[seed % jmiExtensionArray.length];
 36 |     |     }
 37 |     | 
 38 |     |     function freezePreconditions_JMI(uint256 seed) internal returns (FreezeParams memory params) {
 39 |     |         params.instance = jmiExtensionArray[seed % jmiExtensionArray.length];
 40 |     |         params.account = USERS[seed % USERS.length];
 41 |     |     }
 42 |     | 
 43 |     |     function unfreezePreconditions_JMI(uint256 seed) internal returns (FreezeParams memory params) {
 44 |     |         params.instance = jmiExtensionArray[seed % jmiExtensionArray.length];
 45 |     |         params.account = USERS[seed % USERS.length];
 46 |     |     }
 47 |     | 
 48 |     |     // JMI-specific claim yield preconditions
 49 |     |     function claimYieldPreconditions_JMI(uint256 seed) internal returns (ClaimYieldParams memory params) {
 50 |     |         params.instance = jmiExtensionArray[seed % jmiExtensionArray.length];
 51 |     |     }
 52 |     | 
 53 |     |     // JMI-specific transfer preconditions
 54 |     |     function transferPreconditions_JMI(uint256 seed) internal returns (TransferParams memory params) {
 55 |     |         params.instance = jmiExtensionArray[seed % jmiExtensionArray.length];
 56 |     |         params.to = USERS[seed % USERS.length];
 57 |     |         params.amount = fl.clamp(seed, 0, IERC20(params.instance).balanceOf(currentActor));
 58 |     |     }
 59 |     | 
 60 |     |     // JMI-specific approve preconditions
 61 |     |     function approvePreconditions_JMI(uint256 seed) internal returns (ApproveParams memory params) {
 62 |     |         params.instance = jmiExtensionArray[seed % jmiExtensionArray.length];
 63 |     |         params.spender = USERS[seed % USERS.length];
 64 |     |         params.amount = seed;
 65 |     |     }
 66 |     | }
 67 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/preconditions/PreconditionsMEarnerManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PreconditionsBase.sol";
  5 |     | 
  6 |     | contract PreconditionsMEarnerManager is PreconditionsBase {
  7 | *   |     function setAccountInfoPreconditions(
  8 |     |         uint256 seed,
  9 |     |         bool statusSeed
 10 | *   |     ) internal returns (SetAccountInfoParams memory params) {
 11 | *   |         if (seed % 2 == 0) {
 12 | *   |             params.instance = mEarnerManagerArray[seed % mEarnerManagerArray.length];
 13 | *   |             params.account = USERS[seed % USERS.length];
 14 | *   |             params.status = (seed % 2) == 1;
 15 |     |         } else {
 16 | *   |             params.instance = mEarnerManagerArray[seed % mEarnerManagerArray.length];
 17 | *   |             params.account = USERS[seed % USERS.length];
 18 | *   |             params.status = statusSeed;
 19 | *   |             params.feeRate = uint16(fl.clamp(seed, 0, type(uint16).max)); // 0 to 10000 bps (100%)
 20 |     |         }
 21 |     |     }
 22 |     | 
 23 | *   |     function setFeeRecipientPreconditions_MEarnerManager(
 24 |     |         uint256 seed
 25 | *   |     ) internal returns (SetFeeRecipientParams memory params) {
 26 | *   |         params.instance = mEarnerManagerArray[seed % mEarnerManagerArray.length];
 27 | *   |         params.feeRecipient = USERS[seed % USERS.length];
 28 |     |     }
 29 |     | 
 30 | *   |     function claimForPreconditions(uint256 seed) internal returns (ClaimForParams memory params) {
 31 | *   |         params.instance = mEarnerManagerArray[seed % mEarnerManagerArray.length];
 32 | *   |         params.account = USERS[seed % USERS.length];
 33 |     |     }
 34 |     | 
 35 | *   |     function approvePreconditions_MEarnerManager(uint256 seed) internal returns (ApproveParams memory params) {
 36 | *   |         params.instance = mEarnerManagerArray[seed % mEarnerManagerArray.length];
 37 | *   |         params.spender = USERS[seed % USERS.length];
 38 | *   |         params.amount = seed;
 39 |     |     }
 40 |     | 
 41 | *   |     function transferPreconditions_MEarnerManager(uint256 seed) internal returns (TransferParams memory params) {
 42 | *   |         params.instance = mEarnerManagerArray[seed % mEarnerManagerArray.length];
 43 | *   |         params.to = USERS[seed % USERS.length];
 44 | *   |         params.amount = fl.clamp(seed, 0, IERC20(params.instance).balanceOf(currentActor));
 45 |     |     }
 46 |     | 
 47 | *   |     function transferFromPreconditions_MEarnerManager(
 48 |     |         uint256 seed
 49 | *   |     ) internal returns (TransferFromParams memory params) {
 50 | *   |         params.instance = mEarnerManagerArray[seed % mEarnerManagerArray.length];
 51 | *   |         params.from = USERS[seed % USERS.length];
 52 | *   |         params.to = USERS[(seed + 1) % USERS.length];
 53 | *   |         params.amount = fl.clamp(seed, 0, IERC20(params.instance).balanceOf(currentActor));
 54 |     |     }
 55 |     | 
 56 | *   |     function enableEarningPreconditions_MEarnerManager(uint256 seed) internal returns (address) {
 57 | *   |         return mEarnerManagerArray[seed % mEarnerManagerArray.length];
 58 |     |     }
 59 |     | 
 60 | *   |     function disableEarningPreconditions_MEarnerManager(uint256 seed) internal returns (address) {
 61 | *   |         return mEarnerManagerArray[seed % mEarnerManagerArray.length];
 62 |     |     }
 63 |     | }
 64 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/preconditions/PreconditionsMToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PreconditionsBase.sol";
  5 |     | 
  6 |     | contract PreconditionsMToken is PreconditionsBase {
  7 | *   |     function mintPreconditions(uint256 seed) internal returns (address account, uint256 amount) {
  8 | *   |         amount = fl.clamp(seed, 1, 100_000_000 * 1e6); // 100M MToken
  9 | *   |         account = USERS[seed % USERS.length];
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/preconditions/PreconditionsMYieldFee.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PreconditionsBase.sol";
  5 |     | 
  6 |     | contract PreconditionsMYieldFee is PreconditionsBase {
  7 | *   |     function claimYieldForPreconditions(uint256 seed) internal returns (ClaimYieldForParams memory params) {
  8 | *   |         params.instance = mYieldFeeArray[seed % mYieldFeeArray.length];
  9 | *   |         params.account = USERS[seed % USERS.length];
 10 |     |     }
 11 |     | 
 12 | *   |     function claimFeePreconditions(uint256 seed) internal returns (ClaimFeeParams memory params) {
 13 | *   |         params.instance = mYieldFeeArray[seed % mYieldFeeArray.length];
 14 |     |     }
 15 |     | 
 16 | *   |     function updateIndexPreconditions(uint256 seed) internal returns (UpdateIndexParams memory params) {
 17 | *   |         params.instance = mYieldFeeArray[seed % mYieldFeeArray.length];
 18 |     |     }
 19 |     | 
 20 | *   |     function setFeeRatePreconditions(uint256 seed) internal returns (SetFeeRateParams memory params) {
 21 | *   |         params.instance = mYieldFeeArray[seed % mYieldFeeArray.length];
 22 | *   |         params.feeRate = uint16(fl.clamp(seed, 0, 10000)); // 0 to 10000 bps (100%)
 23 |     |     }
 24 |     | 
 25 | *   |     function setFeeRecipientPreconditions(uint256 seed) internal returns (SetFeeRecipientParams memory params) {
 26 | *   |         params.instance = mYieldFeeArray[seed % mYieldFeeArray.length];
 27 | *   |         params.feeRecipient = USERS[seed % USERS.length];
 28 |     |     }
 29 |     | 
 30 | *   |     function setClaimRecipientPreconditions(uint256 seed) internal returns (SetClaimRecipientParams memory params) {
 31 | *   |         params.instance = mYieldFeeArray[seed % mYieldFeeArray.length];
 32 | *   |         params.account = USERS[seed % USERS.length];
 33 | *   |         params.claimRecipient = USERS[(seed + 1) % USERS.length];
 34 |     |     }
 35 |     | 
 36 | *   |     function approvePreconditions_MYieldFee(uint256 seed) internal returns (ApproveParams memory params) {
 37 | *   |         params.instance = mYieldFeeArray[seed % mYieldFeeArray.length];
 38 | *   |         params.spender = USERS[seed % USERS.length];
 39 | *   |         params.amount = seed;
 40 |     |     }
 41 |     | 
 42 | *   |     function transferPreconditions_MYieldFee(uint256 seed) internal returns (TransferParams memory params) {
 43 | *   |         params.instance = mYieldFeeArray[seed % mYieldFeeArray.length];
 44 | *   |         params.to = USERS[seed % USERS.length];
 45 | *   |         params.amount = fl.clamp(seed, 0, IERC20(params.instance).balanceOf(currentActor));
 46 |     |     }
 47 |     | 
 48 | *   |     function transferFromPreconditions_MYieldFee(uint256 seed) internal returns (TransferFromParams memory params) {
 49 | *   |         params.instance = mYieldFeeArray[seed % mYieldFeeArray.length];
 50 | *   |         params.from = USERS[seed % USERS.length];
 51 | *   |         params.to = USERS[(seed + 1) % USERS.length];
 52 | *   |         params.amount = fl.clamp(seed, 0, IERC20(params.instance).balanceOf(currentActor));
 53 |     |     }
 54 |     | 
 55 | *   |     function enableEarningPreconditions_MYieldFee(uint256 seed) internal returns (address) {
 56 | *   |         return mYieldFeeArray[seed % mYieldFeeArray.length];
 57 |     |     }
 58 |     | 
 59 | *   |     function disableEarningPreconditions_MYieldFee(uint256 seed) internal returns (address) {
 60 | *   |         return mYieldFeeArray[seed % mYieldFeeArray.length];
 61 |     |     }
 62 |     | }
 63 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/preconditions/PreconditionsMYieldToOne.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PreconditionsBase.sol";
  5 |     | 
  6 |     | contract PreconditionsMYieldToOne is PreconditionsBase {
  7 | *   |     function claimYieldPreconditions(uint256 seed) internal returns (ClaimYieldParams memory params) {
  8 | *   |         params.instance = mYieldToOneArray[seed % mYieldToOneArray.length];
  9 |     |     }
 10 |     | 
 11 | *   |     function setYieldRecipientPreconditions_MYieldToOne(
 12 |     |         uint256 seed
 13 | *   |     ) internal returns (SetYieldRecipientParams memory params) {
 14 | *   |         params.instance = mYieldToOneArray[seed % mYieldToOneArray.length];
 15 | *   |         params.yieldRecipient = USERS[seed % USERS.length];
 16 |     |     }
 17 |     | 
 18 | *   |     function enableEarningPreconditions_MYieldToOne(uint256 seed) internal returns (address) {
 19 | *   |         return mYieldToOneArray[seed % mYieldToOneArray.length];
 20 |     |     }
 21 |     | 
 22 | *   |     function disableEarningPreconditions_MYieldToOne(uint256 seed) internal returns (address) {
 23 | *   |         return mYieldToOneArray[seed % mYieldToOneArray.length];
 24 |     |     }
 25 |     | 
 26 | *   |     function approvePreconditions_MYieldToOne(uint256 seed) internal returns (ApproveParams memory params) {
 27 | *   |         params.instance = mYieldToOneArray[seed % mYieldToOneArray.length];
 28 | *   |         params.spender = USERS[seed % USERS.length];
 29 | *   |         params.amount = seed;
 30 |     |     }
 31 |     | 
 32 | *   |     function transferPreconditions_MYieldToOne(uint256 seed) internal returns (TransferParams memory params) {
 33 | *   |         params.instance = mYieldToOneArray[seed % mYieldToOneArray.length];
 34 | *   |         params.to = USERS[seed % USERS.length];
 35 | *   |         params.amount = fl.clamp(seed, 0, IERC20(params.instance).balanceOf(currentActor));
 36 |     |     }
 37 |     | 
 38 | *   |     function transferFromPreconditions_MYieldToOne(uint256 seed) internal returns (TransferFromParams memory params) {
 39 | *   |         params.instance = mYieldToOneArray[seed % mYieldToOneArray.length];
 40 | *   |         params.from = USERS[seed % USERS.length];
 41 | *   |         params.to = USERS[(seed + 1) % USERS.length];
 42 | *   |         params.amount = fl.clamp(seed, 0, IERC20(params.instance).balanceOf(currentActor));
 43 |     |     }
 44 |     | }
 45 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/preconditions/PreconditionsSwapFacility.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.26;
  3 |     | 
  4 |     | import "./PreconditionsBase.sol";
  5 |     | 
  6 |     | contract PreconditionsSwapFacility is PreconditionsBase {
  7 | *   |     function swapPreconditions(uint256 seed) internal returns (SwapParams memory params) {
  8 | *   |         params.instance = address(swapFacility);
  9 | *   |         params.extensionIn = allExtensions[seed % allExtensions.length];
 10 | *   |         params.extensionOut = allExtensions[(seed / 2 + 1) % allExtensions.length];
 11 | *   |         params.amount = seed;
 12 | *   |         params.recipient = currentActor;
 13 | *   |         params.swapType = uint8(_getSwapType(params.extensionIn, params.extensionOut));
 14 |     |     }
 15 |     | 
 16 | *   |     function swapInMPreconditions(uint256 seed) internal returns (SwapInMParams memory params) {
 17 | *   |         params.instance = address(swapFacility);
 18 | *   |         params.extensionOut = allExtensions[seed % allExtensions.length];
 19 | *   |         params.amount = seed;
 20 | *   |         params.recipient = currentActor;
 21 |     |     }
 22 |     | 
 23 | *   |     function swapOutMPreconditions(uint256 seed) internal returns (SwapOutMParams memory params) {
 24 | *   |         params.instance = address(swapFacility);
 25 | *   |         params.extensionIn = allExtensions[seed % allExtensions.length];
 26 | *   |         params.amount = seed;
 27 | *   |         params.recipient = currentActor;
 28 |     |     }
 29 |     | 
 30 | *   |     function swapInTokenPreconditions(uint256 seed) internal returns (SwapInTokenParams memory params) {
 31 | *   |         params.instance = address(swapAdapter);
 32 | *   |         params.tokenIn = address(USDC);
 33 | *   |         params.amountIn = fl.clamp(seed, 0, USDC.balanceOf(currentActor));
 34 | *   |         params.extensionOut = allExtensions[seed % allExtensions.length];
 35 | *   |         params.minAmountOut = 0; // params.amountIn / 2; //NOTE: revise if needed
 36 | *   |         params.recipient = currentActor;
 37 | *   |         params.path = new bytes(0);
 38 |     |     }
 39 |     | 
 40 | *   |     function swapOutTokenPreconditions(uint256 seed) internal returns (SwapOutTokenParams memory params) {
 41 | *   |         params.instance = address(swapAdapter);
 42 | *   |         params.extensionIn = allExtensions[seed % allExtensions.length];
 43 | *   |         params.amountIn = fl.clamp(seed, 0, IMTokenLike(params.extensionIn).balanceOf(currentActor));
 44 | *   |         params.tokenOut = address(USDC);
 45 | *   |         params.minAmountOut = params.amountIn / 2;
 46 | *   |         params.recipient = currentActor;
 47 | *   |         params.path = new bytes(0);
 48 |     |     }
 49 |     | 
 50 | *   |     function _getSwapType(address extensionIn, address extensionOut) internal view returns (SwapType) {
 51 | *   |         uint8 typeIn = _getExtensionType(extensionIn);
 52 | *   |         uint8 typeOut = _getExtensionType(extensionOut);
 53 |     | 
 54 |     |         // YTO = 0, YFEE = 1, MEARN = 2
 55 | *   |         if (typeIn == 0 && typeOut == 0) return SwapType.YTO_TO_YTO;
 56 | *   |         if (typeIn == 0 && typeOut == 1) return SwapType.YTO_TO_YFEE;
 57 | *   |         if (typeIn == 0 && typeOut == 2) return SwapType.YTO_TO_MEARN;
 58 | *   |         if (typeIn == 1 && typeOut == 0) return SwapType.YFEE_TO_YTO;
 59 | *   |         if (typeIn == 1 && typeOut == 1) return SwapType.YFEE_TO_YFEE;
 60 | *   |         if (typeIn == 1 && typeOut == 2) return SwapType.YFEE_TO_MEARN;
 61 | *   |         if (typeIn == 2 && typeOut == 0) return SwapType.MEARN_TO_YTO;
 62 | *   |         if (typeIn == 2 && typeOut == 1) return SwapType.MEARN_TO_YFEE;
 63 | *   |         if (typeIn == 2 && typeOut == 2) return SwapType.MEARN_TO_MEARN;
 64 |     | 
 65 |     |         return SwapType.NA;
 66 |     |     }
 67 |     | 
 68 | *   |     function _getExtensionType(address extension) internal view returns (uint8) {
 69 |     |         // allExtensions array structure:
 70 |     |         // [0,3,6] = YTO (MYieldToOne), [1,4,7] = YFEE (MYieldFee), [2,5,8] = MEARN (MEarnerManager)
 71 | *   |         for (uint8 i = 0; i < allExtensions.length; i++) {
 72 | *   |             if (allExtensions[i] == extension) {
 73 | *   |                 return i % 3; // 0=YTO, 1=YFEE, 2=MEARN
 74 |     |             }
 75 |     |         }
 76 |     |         return 255; // Not found
 77 |     |     }
 78 |     | }
 79 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/helpers/preconditions/PreconditionsUni.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./PreconditionsBase.sol";
  5 |     | import { IUniswapV3Pool } from "uniswapv3/v3-core/interfaces/IUniswapV3Pool.sol";
  6 |     | 
  7 |     | contract PreconditionsUni is PreconditionsBase {
  8 | *   |     function allLiquidityUniPreconditions(
  9 |     |         uint256 amount0Seed,
 10 |     |         uint256 amount1Seed,
 11 |     |         int24 tickLowerSeed,
 12 |     |         int24 tickUpperSeed,
 13 |     |         uint256 strategySeed
 14 | *   |     ) internal returns (uint256 amount0Desired, uint256 amount1Desired, int24 tickLower, int24 tickUpper) {
 15 |     |         // Ensure amounts are reasonable
 16 | *   |         amount0Desired = fl.clamp(amount0Seed, 0.01e6, 1_000_000e6, true); // 1k to 1M USDC
 17 | *   |         amount1Desired = fl.clamp(amount1Seed, 0.01e6, 1_000_000e6, true);
 18 |     | 
 19 | *   |         int24 tickSpacing = 1; // fee tier 100 (0.01%) has tick spacing of 1
 20 |     | 
 21 |     |         // Use amount0Seed to determine liquidity provision strategy
 22 | *   |         uint256 strategy = fl.clamp(strategySeed, 0, 2, true);
 23 |     | 
 24 | *   |         if (strategy == 0) {
 25 |     |             // Add liquidity around current tick
 26 | *   |             (, int24 currentTick, , , , , ) = IUniswapV3Pool(address(usdcMTokenPool)).slot0();
 27 |     | 
 28 |     |             // Generate range around current tick
 29 | *   |             int24 rangeSize = int24(fl.clamp(int256(tickLowerSeed), 10, 500, true)) * tickSpacing;
 30 | *   |             tickLower = ((currentTick - rangeSize) / tickSpacing) * tickSpacing;
 31 | *   |             tickUpper = ((currentTick + rangeSize) / tickSpacing) * tickSpacing;
 32 |     | 
 33 | *   |             console.log("Strategy: Around current tick", int256(currentTick));
 34 | *   |         } else if (strategy == 1) {
 35 |     |             // Add liquidity on random range
 36 |     |             // Generate random ticks within valid bounds
 37 |     |             // Valid tick range is -887272 to 887272
 38 |     |             // Map seed to this range more clearly
 39 | *   |             int24 tick1 = int24(int256(tickLowerSeed % 1774545)) - 887272;
 40 | *   |             int24 tick2 = int24(int256(tickUpperSeed % 1774545)) - 887272;
 41 |     | 
 42 |     |             // Round to tick spacing
 43 | *   |             tick1 = (tick1 / tickSpacing) * tickSpacing;
 44 | *   |             tick2 = (tick2 / tickSpacing) * tickSpacing;
 45 |     | 
 46 |     |             // Ensure proper ordering
 47 | *   |             tickLower = tick1 < tick2 ? tick1 : tick2;
 48 | *   |             tickUpper = tick1 < tick2 ? tick2 : tick1;
 49 |     | 
 50 | *   |             console.log("Strategy: Random range");
 51 |     |         } else {
 52 |     |             // strategy == 2: Add liquidity on full range
 53 | *   |             tickLower = -887220; // Closest to min tick divisible by 10
 54 | *   |             tickUpper = 887220; // Closest to max tick divisible by 10
 55 |     | 
 56 | *   |             console.log("Strategy: Full range");
 57 |     |         }
 58 |     | 
 59 |     |         // Ensure minimum tick range for non-full range positions
 60 | *   |         if (strategy != 2 && tickUpper - tickLower < 10 * tickSpacing) {
 61 |     |             tickUpper = tickLower + 10 * tickSpacing;
 62 |     |         }
 63 |     | 
 64 |     |         // Ensure ticks are within Uniswap V3 bounds
 65 | *   |         if (tickLower < -887270) tickLower = -887270;
 66 | *   |         if (tickUpper > 887270) tickUpper = 887270;
 67 |     | 
 68 | *   |         (, int24 currentTick, , , , , ) = usdcMTokenPool.slot0();
 69 | *   |         console.log("currentTick:", currentTick);
 70 |     | 
 71 | *   |         console.log("Adding liquidity: USDC", amount0Desired);
 72 | *   |         console.log("Adding liquidity: WETH", amount1Desired);
 73 | *   |         console.log("Tick range lower:", int256(tickLower));
 74 | *   |         console.log("Tick range upper:", int256(tickUpper));
 75 |     |     }
 76 |     | 
 77 | *   |     function swapZeroToOnePreconditions(uint256 amountInSeed) internal returns (uint256 amountIn) {
 78 |     |         // Clamp swap amount to reasonable range
 79 | *   |         amountIn = fl.clamp(amountInSeed, 100e6, 100_000_000e6, true); // 100 to 100M USDC
 80 |     | 
 81 | *   |         (, int24 currentTick, , , , , ) = usdcMTokenPool.slot0();
 82 | *   |         console.log("swapZeroToOne currentTick:", currentTick);
 83 |     | 
 84 | *   |         console.log("Swapping USDC for WETH, amount:", amountIn);
 85 |     |     }
 86 |     | 
 87 | *   |     function swapOneToZeroPreconditions(uint256 amountInSeed) internal returns (uint256 amountIn) {
 88 |     |         // Clamp swap amount to reasonable range
 89 | *   |         amountIn = fl.clamp(amountInSeed, 0.01e6, 100_000_000e6, true);
 90 |     | 
 91 | *   |         (, int24 currentTick, , , , , ) = usdcMTokenPool.slot0();
 92 | *   |         console.log("swapOneToZero currentTick:", currentTick);
 93 |     | 
 94 | *   |         console.log("Swapping WETH for USDC, amount:", amountIn);
 95 |     |     }
 96 |     | }
 97 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/lifeSupport/IContinuousIndexing.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  Continuous Indexing Interface.
  7 |     |  * @author M^0 Labs
  8 |     |  */
  9 |     | interface IContinuousIndexing {
 10 |     |     /* ============ Events ============ */
 11 |     | 
 12 |     |     /**
 13 |     |      * @notice Emitted when the index is updated.
 14 |     |      * @param  index The new index.
 15 |     |      * @param  rate  The current rate.
 16 |     |      */
 17 |     |     event IndexUpdated(uint128 indexed index, uint32 indexed rate);
 18 |     | 
 19 |     |     /* ============ Interactive Functions ============ */
 20 |     | 
 21 |     |     /**
 22 |     |      * @notice Updates the latest index and latest accrual time in storage.
 23 |     |      * @return index The new stored index for computing present amounts from principal amounts.
 24 |     |      */
 25 |     |     function updateIndex() external returns (uint128);
 26 |     | 
 27 |     |     /* ============ View/Pure Functions ============ */
 28 |     | 
 29 |     |     /// @notice The current index that would be written to storage if `updateIndex` is called.
 30 |     |     function currentIndex() external view returns (uint128);
 31 |     | 
 32 |     |     /// @notice The latest updated index.
 33 |     |     function latestIndex() external view returns (uint128);
 34 |     | 
 35 |     |     /// @notice The latest timestamp when the index was updated.
 36 |     |     function latestUpdateTimestamp() external view returns (uint40);
 37 |     | }
 38 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/logicalCoverage/logicalBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./logicalMEarnerManager.sol";
  5 |     | import "./logicalMYieldFee.sol";
  6 |     | import "./logicalMYieldToOne.sol";
  7 |     | 
  8 |     | contract LogicalBase is LogicalMEarnerManager, LogicalMYieldFee, LogicalMYieldToOne {
  9 | *   |     function checkLogicalCoverage() internal {
 10 | *   |         logicalMEarnerManager();
 11 | *   |         logicalMYieldFee();
 12 | *   |         logicalMYieldToOne();
 13 |     |     }
 14 |     | }
 15 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/logicalCoverage/logicalMEarnerManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../helpers/BeforeAfter.sol";
   5 |     | 
   6 |     | contract LogicalMEarnerManager is BeforeAfter {
   7 | *   |     function logicalMEarnerManager() internal {
   8 | *   |         uint256 accuredYield_mEarnerManager0_USER1 = states[1].mEarnerManager[mEarnerManagerArray[0]].accruedYieldOf[
   9 | *   |             USERS[0]
  10 |     |         ];
  11 | *   |         if (accuredYield_mEarnerManager0_USER1 == 0) {
  12 | *   |             fl.log("accuredYield_mEarnerManager0_USER1 is 0");
  13 |     |         }
  14 | *   |         if (accuredYield_mEarnerManager0_USER1 > 0 && accuredYield_mEarnerManager0_USER1 <= 1e6) {
  15 |     |             fl.log("accuredYield_mEarnerManager0_USER1 is between 0 and 1e6");
  16 |     |         }
  17 | *   |         if (accuredYield_mEarnerManager0_USER1 > 1e6 && accuredYield_mEarnerManager0_USER1 <= 1e12) {
  18 |     |             fl.log("accuredYield_mEarnerManager0_USER1 is between 1e6 and 1e12");
  19 |     |         }
  20 | *   |         if (accuredYield_mEarnerManager0_USER1 > 1e12 && accuredYield_mEarnerManager0_USER1 <= 1e18) {
  21 |     |             fl.log("accuredYield_mEarnerManager0_USER1 is between 1e12 and 1e18");
  22 |     |         }
  23 | *   |         if (accuredYield_mEarnerManager0_USER1 > 1e18 && accuredYield_mEarnerManager0_USER1 <= 1e24) {
  24 |     |             fl.log("accuredYield_mEarnerManager0_USER1 is between 1e18 and 1e24");
  25 |     |         }
  26 | *   |         if (accuredYield_mEarnerManager0_USER1 > 1e24) {
  27 |     |             fl.log("accuredYield_mEarnerManager0_USER1 is greater than 1e24");
  28 |     |         }
  29 |     | 
  30 | *   |         uint256 accuredYield_mEarnerManager1_USER1 = states[1].mEarnerManager[mEarnerManagerArray[1]].accruedYieldOf[
  31 | *   |             USERS[0]
  32 |     |         ];
  33 | *   |         if (accuredYield_mEarnerManager1_USER1 == 0) {
  34 | *   |             fl.log("accuredYield_mEarnerManager1_USER1 is 0");
  35 |     |         }
  36 | *   |         if (accuredYield_mEarnerManager1_USER1 > 0 && accuredYield_mEarnerManager1_USER1 <= 1e6) {
  37 |     |             fl.log("accuredYield_mEarnerManager1_USER1 is between 0 and 1e6");
  38 |     |         }
  39 | *   |         if (accuredYield_mEarnerManager1_USER1 > 1e6 && accuredYield_mEarnerManager1_USER1 <= 1e12) {
  40 |     |             fl.log("accuredYield_mEarnerManager1_USER1 is between 1e6 and 1e12");
  41 |     |         }
  42 | *   |         if (accuredYield_mEarnerManager1_USER1 > 1e12 && accuredYield_mEarnerManager1_USER1 <= 1e18) {
  43 |     |             fl.log("accuredYield_mEarnerManager1_USER1 is between 1e12 and 1e18");
  44 |     |         }
  45 | *   |         if (accuredYield_mEarnerManager1_USER1 > 1e18 && accuredYield_mEarnerManager1_USER1 <= 1e24) {
  46 |     |             fl.log("accuredYield_mEarnerManager1_USER1 is between 1e18 and 1e24");
  47 |     |         }
  48 | *   |         if (accuredYield_mEarnerManager1_USER1 > 1e24) {
  49 |     |             fl.log("accuredYield_mEarnerManager1_USER1 is greater than 1e24");
  50 |     |         }
  51 |     | 
  52 | *   |         uint256 accuredYield_mEarnerManager2_USER1 = states[1].mEarnerManager[mEarnerManagerArray[2]].accruedYieldOf[
  53 | *   |             USERS[0]
  54 |     |         ];
  55 | *   |         if (accuredYield_mEarnerManager2_USER1 == 0) {
  56 | *   |             fl.log("accuredYield_mEarnerManager2_USER1 is 0");
  57 |     |         }
  58 | *   |         if (accuredYield_mEarnerManager2_USER1 > 0 && accuredYield_mEarnerManager2_USER1 <= 1e6) {
  59 |     |             fl.log("accuredYield_mEarnerManager2_USER1 is between 0 and 1e6");
  60 |     |         }
  61 | *   |         if (accuredYield_mEarnerManager2_USER1 > 1e6 && accuredYield_mEarnerManager2_USER1 <= 1e12) {
  62 |     |             fl.log("accuredYield_mEarnerManager2_USER1 is between 1e6 and 1e12");
  63 |     |         }
  64 | *   |         if (accuredYield_mEarnerManager2_USER1 > 1e12 && accuredYield_mEarnerManager2_USER1 <= 1e18) {
  65 |     |             fl.log("accuredYield_mEarnerManager2_USER1 is between 1e12 and 1e18");
  66 |     |         }
  67 | *   |         if (accuredYield_mEarnerManager2_USER1 > 1e18 && accuredYield_mEarnerManager2_USER1 <= 1e24) {
  68 |     |             fl.log("accuredYield_mEarnerManager2_USER1 is between 1e18 and 1e24");
  69 |     |         }
  70 | *   |         if (accuredYield_mEarnerManager2_USER1 > 1e24) {
  71 |     |             fl.log("accuredYield_mEarnerManager2_USER1 is greater than 1e24");
  72 |     |         }
  73 |     | 
  74 | *   |         uint256 accuredYield_mEarnerManager0_USER2 = states[1].mEarnerManager[mEarnerManagerArray[0]].accruedYieldOf[
  75 | *   |             USERS[1]
  76 |     |         ];
  77 | *   |         if (accuredYield_mEarnerManager0_USER2 == 0) {
  78 | *   |             fl.log("accuredYield_mEarnerManager0_USER2 is 0");
  79 |     |         }
  80 | *   |         if (accuredYield_mEarnerManager0_USER2 > 0 && accuredYield_mEarnerManager0_USER2 <= 1e6) {
  81 |     |             fl.log("accuredYield_mEarnerManager0_USER2 is between 0 and 1e6");
  82 |     |         }
  83 | *   |         if (accuredYield_mEarnerManager0_USER2 > 1e6 && accuredYield_mEarnerManager0_USER2 <= 1e12) {
  84 |     |             fl.log("accuredYield_mEarnerManager0_USER2 is between 1e6 and 1e12");
  85 |     |         }
  86 | *   |         if (accuredYield_mEarnerManager0_USER2 > 1e12 && accuredYield_mEarnerManager0_USER2 <= 1e18) {
  87 |     |             fl.log("accuredYield_mEarnerManager0_USER2 is between 1e12 and 1e18");
  88 |     |         }
  89 | *   |         if (accuredYield_mEarnerManager0_USER2 > 1e18 && accuredYield_mEarnerManager0_USER2 <= 1e24) {
  90 |     |             fl.log("accuredYield_mEarnerManager0_USER2 is between 1e18 and 1e24");
  91 |     |         }
  92 | *   |         if (accuredYield_mEarnerManager0_USER2 > 1e24) {
  93 |     |             fl.log("accuredYield_mEarnerManager0_USER2 is greater than 1e24");
  94 |     |         }
  95 |     | 
  96 | *   |         uint256 accuredYield_mEarnerManager1_USER2 = states[1].mEarnerManager[mEarnerManagerArray[1]].accruedYieldOf[
  97 | *   |             USERS[1]
  98 |     |         ];
  99 | *   |         if (accuredYield_mEarnerManager1_USER2 == 0) {
 100 | *   |             fl.log("accuredYield_mEarnerManager1_USER2 is 0");
 101 |     |         }
 102 | *   |         if (accuredYield_mEarnerManager1_USER2 > 0 && accuredYield_mEarnerManager1_USER2 <= 1e6) {
 103 | *   |             fl.log("accuredYield_mEarnerManager1_USER2 is between 0 and 1e6");
 104 |     |         }
 105 | *   |         if (accuredYield_mEarnerManager1_USER2 > 1e6 && accuredYield_mEarnerManager1_USER2 <= 1e12) {
 106 |     |             fl.log("accuredYield_mEarnerManager1_USER2 is between 1e6 and 1e12");
 107 |     |         }
 108 | *   |         if (accuredYield_mEarnerManager1_USER2 > 1e12 && accuredYield_mEarnerManager1_USER2 <= 1e18) {
 109 |     |             fl.log("accuredYield_mEarnerManager1_USER2 is between 1e12 and 1e18");
 110 |     |         }
 111 | *   |         if (accuredYield_mEarnerManager1_USER2 > 1e18 && accuredYield_mEarnerManager1_USER2 <= 1e24) {
 112 |     |             fl.log("accuredYield_mEarnerManager1_USER2 is between 1e18 and 1e24");
 113 |     |         }
 114 | *   |         if (accuredYield_mEarnerManager1_USER2 > 1e24) {
 115 |     |             fl.log("accuredYield_mEarnerManager1_USER2 is greater than 1e24");
 116 |     |         }
 117 |     | 
 118 | *   |         uint256 accuredYield_mEarnerManager2_USER2 = states[1].mEarnerManager[mEarnerManagerArray[2]].accruedYieldOf[
 119 | *   |             USERS[1]
 120 |     |         ];
 121 | *   |         if (accuredYield_mEarnerManager2_USER2 == 0) {
 122 | *   |             fl.log("accuredYield_mEarnerManager2_USER2 is 0");
 123 |     |         }
 124 | *   |         if (accuredYield_mEarnerManager2_USER2 > 0 && accuredYield_mEarnerManager2_USER2 <= 1e6) {
 125 |     |             fl.log("accuredYield_mEarnerManager2_USER2 is between 0 and 1e6");
 126 |     |         }
 127 | *   |         if (accuredYield_mEarnerManager2_USER2 > 1e6 && accuredYield_mEarnerManager2_USER2 <= 1e12) {
 128 |     |             fl.log("accuredYield_mEarnerManager2_USER2 is between 1e6 and 1e12");
 129 |     |         }
 130 | *   |         if (accuredYield_mEarnerManager2_USER2 > 1e12 && accuredYield_mEarnerManager2_USER2 <= 1e18) {
 131 |     |             fl.log("accuredYield_mEarnerManager2_USER2 is between 1e12 and 1e18");
 132 |     |         }
 133 | *   |         if (accuredYield_mEarnerManager2_USER2 > 1e18 && accuredYield_mEarnerManager2_USER2 <= 1e24) {
 134 |     |             fl.log("accuredYield_mEarnerManager2_USER2 is between 1e18 and 1e24");
 135 |     |         }
 136 | *   |         if (accuredYield_mEarnerManager2_USER2 > 1e24) {
 137 |     |             fl.log("accuredYield_mEarnerManager2_USER2 is greater than 1e24");
 138 |     |         }
 139 |     | 
 140 | *   |         uint256 accuredYield_mEarnerManager0_USER3 = states[1].mEarnerManager[mEarnerManagerArray[0]].accruedYieldOf[
 141 | *   |             USERS[2]
 142 |     |         ];
 143 | *   |         if (accuredYield_mEarnerManager0_USER3 == 0) {
 144 | *   |             fl.log("accuredYield_mEarnerManager0_USER3 is 0");
 145 |     |         }
 146 | *   |         if (accuredYield_mEarnerManager0_USER3 > 0 && accuredYield_mEarnerManager0_USER3 <= 1e6) {
 147 |     |             fl.log("accuredYield_mEarnerManager0_USER3 is between 0 and 1e6");
 148 |     |         }
 149 | *   |         if (accuredYield_mEarnerManager0_USER3 > 1e6 && accuredYield_mEarnerManager0_USER3 <= 1e12) {
 150 |     |             fl.log("accuredYield_mEarnerManager0_USER3 is between 1e6 and 1e12");
 151 |     |         }
 152 | *   |         if (accuredYield_mEarnerManager0_USER3 > 1e12 && accuredYield_mEarnerManager0_USER3 <= 1e18) {
 153 |     |             fl.log("accuredYield_mEarnerManager0_USER3 is between 1e12 and 1e18");
 154 |     |         }
 155 | *   |         if (accuredYield_mEarnerManager0_USER3 > 1e18 && accuredYield_mEarnerManager0_USER3 <= 1e24) {
 156 |     |             fl.log("accuredYield_mEarnerManager0_USER3 is between 1e18 and 1e24");
 157 |     |         }
 158 | *   |         if (accuredYield_mEarnerManager0_USER3 > 1e24) {
 159 |     |             fl.log("accuredYield_mEarnerManager0_USER3 is greater than 1e24");
 160 |     |         }
 161 |     | 
 162 | *   |         uint256 accuredYield_mEarnerManager1_USER3 = states[1].mEarnerManager[mEarnerManagerArray[1]].accruedYieldOf[
 163 | *   |             USERS[2]
 164 |     |         ];
 165 | *   |         if (accuredYield_mEarnerManager1_USER3 == 0) {
 166 | *   |             fl.log("accuredYield_mEarnerManager1_USER3 is 0");
 167 |     |         }
 168 | *   |         if (accuredYield_mEarnerManager1_USER3 > 0 && accuredYield_mEarnerManager1_USER3 <= 1e6) {
 169 | *   |             fl.log("accuredYield_mEarnerManager1_USER3 is between 0 and 1e6");
 170 |     |         }
 171 | *   |         if (accuredYield_mEarnerManager1_USER3 > 1e6 && accuredYield_mEarnerManager1_USER3 <= 1e12) {
 172 |     |             fl.log("accuredYield_mEarnerManager1_USER3 is between 1e6 and 1e12");
 173 |     |         }
 174 | *   |         if (accuredYield_mEarnerManager1_USER3 > 1e12 && accuredYield_mEarnerManager1_USER3 <= 1e18) {
 175 |     |             fl.log("accuredYield_mEarnerManager1_USER3 is between 1e12 and 1e18");
 176 |     |         }
 177 | *   |         if (accuredYield_mEarnerManager1_USER3 > 1e18 && accuredYield_mEarnerManager1_USER3 <= 1e24) {
 178 |     |             fl.log("accuredYield_mEarnerManager1_USER3 is between 1e18 and 1e24");
 179 |     |         }
 180 | *   |         if (accuredYield_mEarnerManager1_USER3 > 1e24) {
 181 |     |             fl.log("accuredYield_mEarnerManager1_USER3 is greater than 1e24");
 182 |     |         }
 183 |     | 
 184 | *   |         uint256 accuredYield_mEarnerManager2_USER3 = states[1].mEarnerManager[mEarnerManagerArray[2]].accruedYieldOf[
 185 | *   |             USERS[2]
 186 |     |         ];
 187 | *   |         if (accuredYield_mEarnerManager2_USER3 == 0) {
 188 | *   |             fl.log("accuredYield_mEarnerManager2_USER3 is 0");
 189 |     |         }
 190 | *   |         if (accuredYield_mEarnerManager2_USER3 > 0 && accuredYield_mEarnerManager2_USER3 <= 1e6) {
 191 |     |             fl.log("accuredYield_mEarnerManager2_USER3 is between 0 and 1e6");
 192 |     |         }
 193 | *   |         if (accuredYield_mEarnerManager2_USER3 > 1e6 && accuredYield_mEarnerManager2_USER3 <= 1e12) {
 194 |     |             fl.log("accuredYield_mEarnerManager2_USER3 is between 1e6 and 1e12");
 195 |     |         }
 196 | *   |         if (accuredYield_mEarnerManager2_USER3 > 1e12 && accuredYield_mEarnerManager2_USER3 <= 1e18) {
 197 |     |             fl.log("accuredYield_mEarnerManager2_USER3 is between 1e12 and 1e18");
 198 |     |         }
 199 | *   |         if (accuredYield_mEarnerManager2_USER3 > 1e18 && accuredYield_mEarnerManager2_USER3 <= 1e24) {
 200 |     |             fl.log("accuredYield_mEarnerManager2_USER3 is between 1e18 and 1e24");
 201 |     |         }
 202 | *   |         if (accuredYield_mEarnerManager2_USER3 > 1e24) {
 203 |     |             fl.log("accuredYield_mEarnerManager2_USER3 is greater than 1e24");
 204 |     |         }
 205 |     | 
 206 | *   |         uint256 accruedFeeOf_mEarnerManager0_USER1 = states[1].mEarnerManager[mEarnerManagerArray[0]].accruedFeeOf[
 207 | *   |             USERS[0]
 208 |     |         ];
 209 | *   |         if (accruedFeeOf_mEarnerManager0_USER1 == 0) {
 210 | *   |             fl.log("accruedFeeOf_mEarnerManager0_USER1 is 0");
 211 |     |         }
 212 | *   |         if (accruedFeeOf_mEarnerManager0_USER1 > 0 && accruedFeeOf_mEarnerManager0_USER1 <= 1e6) {
 213 |     |             fl.log("accruedFeeOf_mEarnerManager0_USER1 is between 0 and 1e6");
 214 |     |         }
 215 | *   |         if (accruedFeeOf_mEarnerManager0_USER1 > 1e6 && accruedFeeOf_mEarnerManager0_USER1 <= 1e12) {
 216 |     |             fl.log("accruedFeeOf_mEarnerManager0_USER1 is between 1e6 and 1e12");
 217 |     |         }
 218 | *   |         if (accruedFeeOf_mEarnerManager0_USER1 > 1e12 && accruedFeeOf_mEarnerManager0_USER1 <= 1e18) {
 219 |     |             fl.log("accruedFeeOf_mEarnerManager0_USER1 is between 1e12 and 1e18");
 220 |     |         }
 221 | *   |         if (accruedFeeOf_mEarnerManager0_USER1 > 1e18 && accruedFeeOf_mEarnerManager0_USER1 <= 1e24) {
 222 |     |             fl.log("accruedFeeOf_mEarnerManager0_USER1 is between 1e18 and 1e24");
 223 |     |         }
 224 | *   |         if (accruedFeeOf_mEarnerManager0_USER1 > 1e24) {
 225 |     |             fl.log("accruedFeeOf_mEarnerManager0_USER1 is greater than 1e24");
 226 |     |         }
 227 |     | 
 228 | *   |         uint256 accruedFeeOf_mEarnerManager1_USER1 = states[1].mEarnerManager[mEarnerManagerArray[1]].accruedFeeOf[
 229 | *   |             USERS[0]
 230 |     |         ];
 231 | *   |         if (accruedFeeOf_mEarnerManager1_USER1 == 0) {
 232 | *   |             fl.log("accruedFeeOf_mEarnerManager1_USER1 is 0");
 233 |     |         }
 234 | *   |         if (accruedFeeOf_mEarnerManager1_USER1 > 0 && accruedFeeOf_mEarnerManager1_USER1 <= 1e6) {
 235 |     |             fl.log("accruedFeeOf_mEarnerManager1_USER1 is between 0 and 1e6");
 236 |     |         }
 237 | *   |         if (accruedFeeOf_mEarnerManager1_USER1 > 1e6 && accruedFeeOf_mEarnerManager1_USER1 <= 1e12) {
 238 |     |             fl.log("accruedFeeOf_mEarnerManager1_USER1 is between 1e6 and 1e12");
 239 |     |         }
 240 | *   |         if (accruedFeeOf_mEarnerManager1_USER1 > 1e12 && accruedFeeOf_mEarnerManager1_USER1 <= 1e18) {
 241 |     |             fl.log("accruedFeeOf_mEarnerManager1_USER1 is between 1e12 and 1e18");
 242 |     |         }
 243 | *   |         if (accruedFeeOf_mEarnerManager1_USER1 > 1e18 && accruedFeeOf_mEarnerManager1_USER1 <= 1e24) {
 244 |     |             fl.log("accruedFeeOf_mEarnerManager1_USER1 is between 1e18 and 1e24");
 245 |     |         }
 246 | *   |         if (accruedFeeOf_mEarnerManager1_USER1 > 1e24) {
 247 |     |             fl.log("accruedFeeOf_mEarnerManager1_USER1 is greater than 1e24");
 248 |     |         }
 249 |     | 
 250 | *   |         uint256 accruedFeeOf_mEarnerManager2_USER1 = states[1].mEarnerManager[mEarnerManagerArray[2]].accruedFeeOf[
 251 | *   |             USERS[0]
 252 |     |         ];
 253 | *   |         if (accruedFeeOf_mEarnerManager2_USER1 == 0) {
 254 | *   |             fl.log("accruedFeeOf_mEarnerManager2_USER1 is 0");
 255 |     |         }
 256 | *   |         if (accruedFeeOf_mEarnerManager2_USER1 > 0 && accruedFeeOf_mEarnerManager2_USER1 <= 1e6) {
 257 |     |             fl.log("accruedFeeOf_mEarnerManager2_USER1 is between 0 and 1e6");
 258 |     |         }
 259 | *   |         if (accruedFeeOf_mEarnerManager2_USER1 > 1e6 && accruedFeeOf_mEarnerManager2_USER1 <= 1e12) {
 260 |     |             fl.log("accruedFeeOf_mEarnerManager2_USER1 is between 1e6 and 1e12");
 261 |     |         }
 262 | *   |         if (accruedFeeOf_mEarnerManager2_USER1 > 1e12 && accruedFeeOf_mEarnerManager2_USER1 <= 1e18) {
 263 |     |             fl.log("accruedFeeOf_mEarnerManager2_USER1 is between 1e12 and 1e18");
 264 |     |         }
 265 | *   |         if (accruedFeeOf_mEarnerManager2_USER1 > 1e18 && accruedFeeOf_mEarnerManager2_USER1 <= 1e24) {
 266 |     |             fl.log("accruedFeeOf_mEarnerManager2_USER1 is between 1e18 and 1e24");
 267 |     |         }
 268 | *   |         if (accruedFeeOf_mEarnerManager2_USER1 > 1e24) {
 269 |     |             fl.log("accruedFeeOf_mEarnerManager2_USER1 is greater than 1e24");
 270 |     |         }
 271 |     | 
 272 | *   |         uint256 accruedFeeOf_mEarnerManager0_USER2 = states[1].mEarnerManager[mEarnerManagerArray[0]].accruedFeeOf[
 273 | *   |             USERS[1]
 274 |     |         ];
 275 | *   |         if (accruedFeeOf_mEarnerManager0_USER2 == 0) {
 276 | *   |             fl.log("accruedFeeOf_mEarnerManager0_USER2 is 0");
 277 |     |         }
 278 | *   |         if (accruedFeeOf_mEarnerManager0_USER2 > 0 && accruedFeeOf_mEarnerManager0_USER2 <= 1e6) {
 279 |     |             fl.log("accruedFeeOf_mEarnerManager0_USER2 is between 0 and 1e6");
 280 |     |         }
 281 | *   |         if (accruedFeeOf_mEarnerManager0_USER2 > 1e6 && accruedFeeOf_mEarnerManager0_USER2 <= 1e12) {
 282 |     |             fl.log("accruedFeeOf_mEarnerManager0_USER2 is between 1e6 and 1e12");
 283 |     |         }
 284 | *   |         if (accruedFeeOf_mEarnerManager0_USER2 > 1e12 && accruedFeeOf_mEarnerManager0_USER2 <= 1e18) {
 285 |     |             fl.log("accruedFeeOf_mEarnerManager0_USER2 is between 1e12 and 1e18");
 286 |     |         }
 287 |     | 
 288 | *   |         uint256 accruedFeeOf_mEarnerManager1_USER2 = states[1].mEarnerManager[mEarnerManagerArray[1]].accruedFeeOf[
 289 | *   |             USERS[1]
 290 |     |         ];
 291 | *   |         if (accruedFeeOf_mEarnerManager1_USER2 == 0) {
 292 | *   |             fl.log("accruedFeeOf_mEarnerManager1_USER2 is 0");
 293 |     |         }
 294 | *   |         if (accruedFeeOf_mEarnerManager1_USER2 > 0 && accruedFeeOf_mEarnerManager1_USER2 <= 1e6) {
 295 |     |             fl.log("accruedFeeOf_mEarnerManager1_USER2 is between 0 and 1e6");
 296 |     |         }
 297 | *   |         if (accruedFeeOf_mEarnerManager1_USER2 > 1e6 && accruedFeeOf_mEarnerManager1_USER2 <= 1e12) {
 298 |     |             fl.log("accruedFeeOf_mEarnerManager1_USER2 is between 1e6 and 1e12");
 299 |     |         }
 300 | *   |         if (accruedFeeOf_mEarnerManager1_USER2 > 1e12 && accruedFeeOf_mEarnerManager1_USER2 <= 1e18) {
 301 |     |             fl.log("accruedFeeOf_mEarnerManager1_USER2 is between 1e12 and 1e18");
 302 |     |         }
 303 |     | 
 304 | *   |         uint256 accruedFeeOf_mEarnerManager2_USER2 = states[1].mEarnerManager[mEarnerManagerArray[2]].accruedFeeOf[
 305 | *   |             USERS[1]
 306 |     |         ];
 307 | *   |         if (accruedFeeOf_mEarnerManager2_USER2 == 0) {
 308 | *   |             fl.log("accruedFeeOf_mEarnerManager2_USER2 is 0");
 309 |     |         }
 310 | *   |         if (accruedFeeOf_mEarnerManager2_USER2 > 0 && accruedFeeOf_mEarnerManager2_USER2 <= 1e6) {
 311 |     |             fl.log("accruedFeeOf_mEarnerManager2_USER2 is between 0 and 1e6");
 312 |     |         }
 313 | *   |         if (accruedFeeOf_mEarnerManager2_USER2 > 1e6 && accruedFeeOf_mEarnerManager2_USER2 <= 1e12) {
 314 |     |             fl.log("accruedFeeOf_mEarnerManager2_USER2 is between 1e6 and 1e12");
 315 |     |         }
 316 | *   |         if (accruedFeeOf_mEarnerManager2_USER2 > 1e12 && accruedFeeOf_mEarnerManager2_USER2 <= 1e18) {
 317 |     |             fl.log("accruedFeeOf_mEarnerManager2_USER2 is between 1e12 and 1e18");
 318 |     |         }
 319 |     | 
 320 | *   |         uint256 accruedFeeOf_mEarnerManager0_USER3 = states[1].mEarnerManager[mEarnerManagerArray[0]].accruedFeeOf[
 321 | *   |             USERS[2]
 322 |     |         ];
 323 | *   |         if (accruedFeeOf_mEarnerManager0_USER3 == 0) {
 324 | *   |             fl.log("accruedFeeOf_mEarnerManager0_USER3 is 0");
 325 |     |         }
 326 | *   |         if (accruedFeeOf_mEarnerManager0_USER3 > 0 && accruedFeeOf_mEarnerManager0_USER3 <= 1e6) {
 327 |     |             fl.log("accruedFeeOf_mEarnerManager0_USER3 is between 0 and 1e6");
 328 |     |         }
 329 | *   |         if (accruedFeeOf_mEarnerManager0_USER3 > 1e6 && accruedFeeOf_mEarnerManager0_USER3 <= 1e12) {
 330 |     |             fl.log("accruedFeeOf_mEarnerManager0_USER3 is between 1e6 and 1e12");
 331 |     |         }
 332 | *   |         if (accruedFeeOf_mEarnerManager0_USER3 > 1e12 && accruedFeeOf_mEarnerManager0_USER3 <= 1e18) {
 333 |     |             fl.log("accruedFeeOf_mEarnerManager0_USER3 is between 1e12 and 1e18");
 334 |     |         }
 335 |     | 
 336 | *   |         uint256 accruedFeeOf_mEarnerManager1_USER3 = states[1].mEarnerManager[mEarnerManagerArray[1]].accruedFeeOf[
 337 | *   |             USERS[2]
 338 |     |         ];
 339 | *   |         if (accruedFeeOf_mEarnerManager1_USER3 == 0) {
 340 | *   |             fl.log("accruedFeeOf_mEarnerManager1_USER3 is 0");
 341 |     |         }
 342 | *   |         if (accruedFeeOf_mEarnerManager1_USER3 > 0 && accruedFeeOf_mEarnerManager1_USER3 <= 1e6) {
 343 |     |             fl.log("accruedFeeOf_mEarnerManager1_USER3 is between 0 and 1e6");
 344 |     |         }
 345 | *   |         if (accruedFeeOf_mEarnerManager1_USER3 > 1e6 && accruedFeeOf_mEarnerManager1_USER3 <= 1e12) {
 346 |     |             fl.log("accruedFeeOf_mEarnerManager1_USER3 is between 1e6 and 1e12");
 347 |     |         }
 348 | *   |         if (accruedFeeOf_mEarnerManager1_USER3 > 1e12 && accruedFeeOf_mEarnerManager1_USER3 <= 1e18) {
 349 |     |             fl.log("accruedFeeOf_mEarnerManager1_USER3 is between 1e12 and 1e18");
 350 |     |         }
 351 |     | 
 352 | *   |         uint256 accruedFeeOf_mEarnerManager2_USER3 = states[1].mEarnerManager[mEarnerManagerArray[2]].accruedFeeOf[
 353 | *   |             USERS[2]
 354 |     |         ];
 355 | *   |         if (accruedFeeOf_mEarnerManager2_USER3 == 0) {
 356 | *   |             fl.log("accruedFeeOf_mEarnerManager2_USER3 is 0");
 357 |     |         }
 358 | *   |         if (accruedFeeOf_mEarnerManager2_USER3 > 0 && accruedFeeOf_mEarnerManager2_USER3 <= 1e6) {
 359 |     |             fl.log("accruedFeeOf_mEarnerManager2_USER3 is between 0 and 1e6");
 360 |     |         }
 361 | *   |         if (accruedFeeOf_mEarnerManager2_USER3 > 1e6 && accruedFeeOf_mEarnerManager2_USER3 <= 1e12) {
 362 |     |             fl.log("accruedFeeOf_mEarnerManager2_USER3 is between 1e6 and 1e12");
 363 |     |         }
 364 | *   |         if (accruedFeeOf_mEarnerManager2_USER3 > 1e12 && accruedFeeOf_mEarnerManager2_USER3 <= 1e18) {
 365 |     |             fl.log("accruedFeeOf_mEarnerManager2_USER3 is between 1e12 and 1e18");
 366 |     |         }
 367 |     | 
 368 | *   |         uint256 accruedYieldAndFeeOf_mEarnerManager0_USER1 = states[1]
 369 | *   |             .mEarnerManager[mEarnerManagerArray[0]]
 370 | *   |             .accruedYieldAndFeeOf[USERS[0]];
 371 | *   |         if (accruedYieldAndFeeOf_mEarnerManager0_USER1 == 0) {
 372 | *   |             fl.log("accruedYieldAndFeeOf_mEarnerManager0_USER1 is 0");
 373 |     |         }
 374 | *   |         if (accruedYieldAndFeeOf_mEarnerManager0_USER1 > 0 && accruedYieldAndFeeOf_mEarnerManager0_USER1 <= 1e6) {
 375 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager0_USER1 is between 0 and 1e6");
 376 |     |         }
 377 | *   |         if (accruedYieldAndFeeOf_mEarnerManager0_USER1 > 1e6 && accruedYieldAndFeeOf_mEarnerManager0_USER1 <= 1e12) {
 378 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager0_USER1 is between 1e6 and 1e12");
 379 |     |         }
 380 | *   |         if (accruedYieldAndFeeOf_mEarnerManager0_USER1 > 1e12 && accruedYieldAndFeeOf_mEarnerManager0_USER1 <= 1e18) {
 381 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager0_USER1 is between 1e12 and 1e18");
 382 |     |         }
 383 |     | 
 384 | *   |         uint256 accruedYieldAndFeeOf_mEarnerManager1_USER1 = states[1]
 385 | *   |             .mEarnerManager[mEarnerManagerArray[1]]
 386 | *   |             .accruedYieldAndFeeOf[USERS[0]];
 387 | *   |         if (accruedYieldAndFeeOf_mEarnerManager1_USER1 == 0) {
 388 | *   |             fl.log("accruedYieldAndFeeOf_mEarnerManager1_USER1 is 0");
 389 |     |         }
 390 | *   |         if (accruedYieldAndFeeOf_mEarnerManager1_USER1 > 0 && accruedYieldAndFeeOf_mEarnerManager1_USER1 <= 1e6) {
 391 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager1_USER1 is between 0 and 1e6");
 392 |     |         }
 393 | *   |         if (accruedYieldAndFeeOf_mEarnerManager1_USER1 > 1e6 && accruedYieldAndFeeOf_mEarnerManager1_USER1 <= 1e12) {
 394 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager1_USER1 is between 1e6 and 1e12");
 395 |     |         }
 396 | *   |         if (accruedYieldAndFeeOf_mEarnerManager1_USER1 > 1e12 && accruedYieldAndFeeOf_mEarnerManager1_USER1 <= 1e18) {
 397 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager1_USER1 is between 1e12 and 1e18");
 398 |     |         }
 399 |     | 
 400 | *   |         uint256 accruedYieldAndFeeOf_mEarnerManager2_USER1 = states[1]
 401 | *   |             .mEarnerManager[mEarnerManagerArray[2]]
 402 | *   |             .accruedYieldAndFeeOf[USERS[0]];
 403 | *   |         if (accruedYieldAndFeeOf_mEarnerManager2_USER1 == 0) {
 404 | *   |             fl.log("accruedYieldAndFeeOf_mEarnerManager2_USER1 is 0");
 405 |     |         }
 406 | *   |         if (accruedYieldAndFeeOf_mEarnerManager2_USER1 > 0 && accruedYieldAndFeeOf_mEarnerManager2_USER1 <= 1e6) {
 407 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager2_USER1 is between 0 and 1e6");
 408 |     |         }
 409 | *   |         if (accruedYieldAndFeeOf_mEarnerManager2_USER1 > 1e6 && accruedYieldAndFeeOf_mEarnerManager2_USER1 <= 1e12) {
 410 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager2_USER1 is between 1e6 and 1e12");
 411 |     |         }
 412 | *   |         if (accruedYieldAndFeeOf_mEarnerManager2_USER1 > 1e12 && accruedYieldAndFeeOf_mEarnerManager2_USER1 <= 1e18) {
 413 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager2_USER1 is between 1e12 and 1e18");
 414 |     |         }
 415 |     | 
 416 | *   |         uint256 accruedYieldAndFeeOf_mEarnerManager0_USER2 = states[1]
 417 | *   |             .mEarnerManager[mEarnerManagerArray[0]]
 418 | *   |             .accruedYieldAndFeeOf[USERS[1]];
 419 | *   |         if (accruedYieldAndFeeOf_mEarnerManager0_USER2 == 0) {
 420 | *   |             fl.log("accruedYieldAndFeeOf_mEarnerManager0_USER2 is 0");
 421 |     |         }
 422 | *   |         if (accruedYieldAndFeeOf_mEarnerManager0_USER2 > 0 && accruedYieldAndFeeOf_mEarnerManager0_USER2 <= 1e6) {
 423 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager0_USER2 is between 0 and 1e6");
 424 |     |         }
 425 | *   |         if (accruedYieldAndFeeOf_mEarnerManager0_USER2 > 1e6 && accruedYieldAndFeeOf_mEarnerManager0_USER2 <= 1e12) {
 426 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager0_USER2 is between 1e6 and 1e12");
 427 |     |         }
 428 | *   |         if (accruedYieldAndFeeOf_mEarnerManager0_USER2 > 1e12 && accruedYieldAndFeeOf_mEarnerManager0_USER2 <= 1e18) {
 429 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager0_USER2 is between 1e12 and 1e18");
 430 |     |         }
 431 |     | 
 432 | *   |         uint256 accruedYieldAndFeeOf_mEarnerManager1_USER2 = states[1]
 433 | *   |             .mEarnerManager[mEarnerManagerArray[1]]
 434 | *   |             .accruedYieldAndFeeOf[USERS[1]];
 435 | *   |         if (accruedYieldAndFeeOf_mEarnerManager1_USER2 == 0) {
 436 | *   |             fl.log("accruedYieldAndFeeOf_mEarnerManager1_USER2 is 0");
 437 |     |         }
 438 | *   |         if (accruedYieldAndFeeOf_mEarnerManager1_USER2 > 0 && accruedYieldAndFeeOf_mEarnerManager1_USER2 <= 1e6) {
 439 | *   |             fl.log("accruedYieldAndFeeOf_mEarnerManager1_USER2 is between 0 and 1e6");
 440 |     |         }
 441 | *   |         if (accruedYieldAndFeeOf_mEarnerManager1_USER2 > 1e6 && accruedYieldAndFeeOf_mEarnerManager1_USER2 <= 1e12) {
 442 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager1_USER2 is between 1e6 and 1e12");
 443 |     |         }
 444 | *   |         if (accruedYieldAndFeeOf_mEarnerManager1_USER2 > 1e12 && accruedYieldAndFeeOf_mEarnerManager1_USER2 <= 1e18) {
 445 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager1_USER2 is between 1e12 and 1e18");
 446 |     |         }
 447 |     | 
 448 | *   |         uint256 accruedYieldAndFeeOf_mEarnerManager2_USER2 = states[1]
 449 | *   |             .mEarnerManager[mEarnerManagerArray[2]]
 450 | *   |             .accruedYieldAndFeeOf[USERS[1]];
 451 | *   |         if (accruedYieldAndFeeOf_mEarnerManager2_USER2 == 0) {
 452 | *   |             fl.log("accruedYieldAndFeeOf_mEarnerManager2_USER2 is 0");
 453 |     |         }
 454 | *   |         if (accruedYieldAndFeeOf_mEarnerManager2_USER2 > 0 && accruedYieldAndFeeOf_mEarnerManager2_USER2 <= 1e6) {
 455 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager2_USER2 is between 0 and 1e6");
 456 |     |         }
 457 | *   |         if (accruedYieldAndFeeOf_mEarnerManager2_USER2 > 1e6 && accruedYieldAndFeeOf_mEarnerManager2_USER2 <= 1e12) {
 458 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager2_USER2 is between 1e6 and 1e12");
 459 |     |         }
 460 | *   |         if (accruedYieldAndFeeOf_mEarnerManager2_USER2 > 1e12 && accruedYieldAndFeeOf_mEarnerManager2_USER2 <= 1e18) {
 461 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager2_USER2 is between 1e12 and 1e18");
 462 |     |         }
 463 |     | 
 464 | *   |         uint256 accruedYieldAndFeeOf_mEarnerManager0_USER3 = states[1]
 465 | *   |             .mEarnerManager[mEarnerManagerArray[0]]
 466 | *   |             .accruedYieldAndFeeOf[USERS[2]];
 467 | *   |         if (accruedYieldAndFeeOf_mEarnerManager0_USER3 == 0) {
 468 | *   |             fl.log("accruedYieldAndFeeOf_mEarnerManager0_USER3 is 0");
 469 |     |         }
 470 | *   |         if (accruedYieldAndFeeOf_mEarnerManager0_USER3 > 0 && accruedYieldAndFeeOf_mEarnerManager0_USER3 <= 1e6) {
 471 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager0_USER3 is between 0 and 1e6");
 472 |     |         }
 473 | *   |         if (accruedYieldAndFeeOf_mEarnerManager0_USER3 > 1e6 && accruedYieldAndFeeOf_mEarnerManager0_USER3 <= 1e12) {
 474 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager0_USER3 is between 1e6 and 1e12");
 475 |     |         }
 476 | *   |         if (accruedYieldAndFeeOf_mEarnerManager0_USER3 > 1e12 && accruedYieldAndFeeOf_mEarnerManager0_USER3 <= 1e18) {
 477 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager0_USER3 is between 1e12 and 1e18");
 478 |     |         }
 479 |     | 
 480 | *   |         uint256 accruedYieldAndFeeOf_mEarnerManager1_USER3 = states[1]
 481 | *   |             .mEarnerManager[mEarnerManagerArray[1]]
 482 | *   |             .accruedYieldAndFeeOf[USERS[2]];
 483 | *   |         if (accruedYieldAndFeeOf_mEarnerManager1_USER3 == 0) {
 484 | *   |             fl.log("accruedYieldAndFeeOf_mEarnerManager1_USER3 is 0");
 485 |     |         }
 486 | *   |         if (accruedYieldAndFeeOf_mEarnerManager1_USER3 > 0 && accruedYieldAndFeeOf_mEarnerManager1_USER3 <= 1e6) {
 487 | *   |             fl.log("accruedYieldAndFeeOf_mEarnerManager1_USER3 is between 0 and 1e6");
 488 |     |         }
 489 | *   |         if (accruedYieldAndFeeOf_mEarnerManager1_USER3 > 1e6 && accruedYieldAndFeeOf_mEarnerManager1_USER3 <= 1e12) {
 490 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager1_USER3 is between 1e6 and 1e12");
 491 |     |         }
 492 | *   |         if (accruedYieldAndFeeOf_mEarnerManager1_USER3 > 1e12 && accruedYieldAndFeeOf_mEarnerManager1_USER3 <= 1e18) {
 493 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager1_USER3 is between 1e12 and 1e18");
 494 |     |         }
 495 |     | 
 496 | *   |         uint256 accruedYieldAndFeeOf_mEarnerManager2_USER3 = states[1]
 497 | *   |             .mEarnerManager[mEarnerManagerArray[2]]
 498 | *   |             .accruedYieldAndFeeOf[USERS[2]];
 499 | *   |         if (accruedYieldAndFeeOf_mEarnerManager2_USER3 == 0) {
 500 | *   |             fl.log("accruedYieldAndFeeOf_mEarnerManager2_USER3 is 0");
 501 |     |         }
 502 | *   |         if (accruedYieldAndFeeOf_mEarnerManager2_USER3 > 0 && accruedYieldAndFeeOf_mEarnerManager2_USER3 <= 1e6) {
 503 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager2_USER3 is between 0 and 1e6");
 504 |     |         }
 505 | *   |         if (accruedYieldAndFeeOf_mEarnerManager2_USER3 > 1e6 && accruedYieldAndFeeOf_mEarnerManager2_USER3 <= 1e12) {
 506 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager2_USER3 is between 1e6 and 1e12");
 507 |     |         }
 508 | *   |         if (accruedYieldAndFeeOf_mEarnerManager2_USER3 > 1e12 && accruedYieldAndFeeOf_mEarnerManager2_USER3 <= 1e18) {
 509 |     |             fl.log("accruedYieldAndFeeOf_mEarnerManager2_USER3 is between 1e12 and 1e18");
 510 |     |         }
 511 |     |     }
 512 |     | }
 513 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/logicalCoverage/logicalMYieldFee.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../helpers/BeforeAfter.sol";
   5 |     | 
   6 |     | contract LogicalMYieldFee is BeforeAfter {
   7 | *   |     function logicalMYieldFee() internal {
   8 |     |         // currentIndex coverage for mYieldFeeArray[0]
   9 | *   |         uint256 currentIndex = states[1].mYieldFee[mYieldFeeArray[0]].currentIndex;
  10 |     | 
  11 | *   |         if (currentIndex > 1e6 && currentIndex <= 1e12) {
  12 | *   |             fl.log("MYieldFee[0] currentIndex is between 1e6 and 1e12");
  13 |     |         }
  14 | *   |         if (currentIndex > 1e12 && currentIndex <= 1e18) {
  15 | *   |             fl.log("MYieldFee[0] currentIndex is between 1e12 and 1e18");
  16 |     |         }
  17 | *   |         if (currentIndex > 1e18 && currentIndex <= 1e24) {
  18 |     |             fl.log("MYieldFee[0] currentIndex is between 1e18 and 1e24");
  19 |     |         }
  20 | *   |         if (currentIndex > 1e24) {
  21 |     |             fl.log("MYieldFee[0] currentIndex is greater than 1e24");
  22 |     |         }
  23 |     |         // currentIndex coverage for mYieldFeeArray[1]
  24 | *   |         currentIndex = states[1].mYieldFee[mYieldFeeArray[1]].currentIndex;
  25 |     | 
  26 | *   |         if (currentIndex > 1e6 && currentIndex <= 1e12) {
  27 | *   |             fl.log("MYieldFee[1] currentIndex is between 1e6 and 1e12");
  28 |     |         }
  29 | *   |         if (currentIndex > 1e12 && currentIndex <= 1e18) {
  30 | *   |             fl.log("MYieldFee[1] currentIndex is between 1e12 and 1e18");
  31 |     |         }
  32 |     | 
  33 |     |         // currentIndex coverage for mYieldFeeArray[2]
  34 | *   |         currentIndex = states[1].mYieldFee[mYieldFeeArray[2]].currentIndex;
  35 |     | 
  36 | *   |         if (currentIndex > 1e6 && currentIndex <= 1e12) {
  37 | *   |             fl.log("MYieldFee[2] currentIndex is between 1e6 and 1e12");
  38 |     |         }
  39 | *   |         if (currentIndex > 1e12 && currentIndex <= 1e18) {
  40 | *   |             fl.log("MYieldFee[2] currentIndex is between 1e12 and 1e18");
  41 |     |         }
  42 |     | 
  43 |     |         // latestIndex coverage for mYieldFeeArray[0]
  44 | *   |         uint256 latestIndex = states[1].mYieldFee[mYieldFeeArray[0]].latestIndex;
  45 | *   |         if (latestIndex == 0) {
  46 | *   |             fl.log("MYieldFee[0] latestIndex is 0");
  47 |     |         }
  48 | *   |         if (latestIndex > 0 && latestIndex <= 1e6) {
  49 |     |             fl.log("MYieldFee[0] latestIndex is between 0 and 1e6");
  50 |     |         }
  51 | *   |         if (latestIndex > 1e6 && latestIndex <= 1e12) {
  52 | *   |             fl.log("MYieldFee[0] latestIndex is between 1e6 and 1e12");
  53 |     |         }
  54 | *   |         if (latestIndex > 1e12 && latestIndex <= 1e18) {
  55 |     |             fl.log("MYieldFee[0] latestIndex is between 1e12 and 1e18");
  56 |     |         }
  57 |     | 
  58 |     |         // latestIndex coverage for mYieldFeeArray[1]
  59 | *   |         latestIndex = states[1].mYieldFee[mYieldFeeArray[1]].latestIndex;
  60 |     | 
  61 | *   |         if (latestIndex > 1e6 && latestIndex <= 1e12) {
  62 | *   |             fl.log("MYieldFee[1] latestIndex is between 1e6 and 1e12");
  63 |     |         }
  64 | *   |         if (latestIndex > 1e12 && latestIndex <= 1e18) {
  65 | *   |             fl.log("MYieldFee[1] latestIndex is between 1e12 and 1e18");
  66 |     |         }
  67 |     | 
  68 |     |         // latestIndex coverage for mYieldFeeArray[2]
  69 | *   |         latestIndex = states[1].mYieldFee[mYieldFeeArray[2]].latestIndex;
  70 |     | 
  71 | *   |         if (latestIndex > 1e6 && latestIndex <= 1e12) {
  72 | *   |             fl.log("MYieldFee[2] latestIndex is between 1e6 and 1e12");
  73 |     |         }
  74 | *   |         if (latestIndex > 1e12 && latestIndex <= 1e18) {
  75 |     |             fl.log("MYieldFee[2] latestIndex is between 1e12 and 1e18");
  76 |     |         }
  77 |     | 
  78 |     |         // totalAccruedFee coverage for mYieldFeeArray[0]
  79 | *   |         uint256 totalAccruedFee = states[1].mYieldFee[mYieldFeeArray[0]].totalAccruedFee;
  80 | *   |         if (totalAccruedFee == 0) {
  81 | *   |             fl.log("MYieldFee[0] totalAccruedFee is 0");
  82 |     |         }
  83 | *   |         if (totalAccruedFee > 0 && totalAccruedFee <= 1e6) {
  84 |     |             fl.log("MYieldFee[0] totalAccruedFee is between 0 and 1e6");
  85 |     |         }
  86 | *   |         if (totalAccruedFee > 1e6 && totalAccruedFee <= 1e12) {
  87 |     |             fl.log("MYieldFee[0] totalAccruedFee is between 1e6 and 1e12");
  88 |     |         }
  89 | *   |         if (totalAccruedFee > 1e12 && totalAccruedFee <= 1e18) {
  90 |     |             fl.log("MYieldFee[0] totalAccruedFee is between 1e12 and 1e18");
  91 |     |         }
  92 |     | 
  93 |     |         // totalAccruedFee coverage for mYieldFeeArray[1]
  94 | *   |         totalAccruedFee = states[1].mYieldFee[mYieldFeeArray[1]].totalAccruedFee;
  95 | *   |         if (totalAccruedFee == 0) {
  96 | *   |             fl.log("MYieldFee[1] totalAccruedFee is 0");
  97 |     |         }
  98 | *   |         if (totalAccruedFee > 0 && totalAccruedFee <= 1e6) {
  99 |     |             fl.log("MYieldFee[1] totalAccruedFee is between 0 and 1e6");
 100 |     |         }
 101 | *   |         if (totalAccruedFee > 1e6 && totalAccruedFee <= 1e12) {
 102 |     |             fl.log("MYieldFee[1] totalAccruedFee is between 1e6 and 1e12");
 103 |     |         }
 104 | *   |         if (totalAccruedFee > 1e12 && totalAccruedFee <= 1e18) {
 105 |     |             fl.log("MYieldFee[1] totalAccruedFee is between 1e12 and 1e18");
 106 |     |         }
 107 |     | 
 108 |     |         // totalAccruedFee coverage for mYieldFeeArray[2]
 109 | *   |         totalAccruedFee = states[1].mYieldFee[mYieldFeeArray[2]].totalAccruedFee;
 110 | *   |         if (totalAccruedFee == 0) {
 111 | *   |             fl.log("MYieldFee[2] totalAccruedFee is 0");
 112 |     |         }
 113 | *   |         if (totalAccruedFee > 0 && totalAccruedFee <= 1e6) {
 114 |     |             fl.log("MYieldFee[2] totalAccruedFee is between 0 and 1e6");
 115 |     |         }
 116 | *   |         if (totalAccruedFee > 1e6 && totalAccruedFee <= 1e12) {
 117 |     |             fl.log("MYieldFee[2] totalAccruedFee is between 1e6 and 1e12");
 118 |     |         }
 119 | *   |         if (totalAccruedFee > 1e12 && totalAccruedFee <= 1e18) {
 120 |     |             fl.log("MYieldFee[2] totalAccruedFee is between 1e12 and 1e18");
 121 |     |         }
 122 |     |     }
 123 |     | }
 124 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/logicalCoverage/logicalMYieldToOne.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../helpers/BeforeAfter.sol";
  5 |     | 
  6 |     | contract LogicalMYieldToOne is BeforeAfter {
  7 | *   |     function logicalMYieldToOne() internal {
  8 | *   |         uint256 yield = states[1].mYieldToOne[mYieldToOneArray[0]].yield;
  9 | *   |         if (yield == 0) {
 10 | *   |             fl.log("MYieldToOne[0] yield is 0");
 11 |     |         }
 12 | *   |         if (yield > 0 && yield <= 1e6) {
 13 |     |             fl.log("MYieldToOne[0] yield is between 0 and 1e6");
 14 |     |         }
 15 | *   |         if (yield > 1e6 && yield <= 1e12) {
 16 |     |             fl.log("MYieldToOne[0] yield is between 1e6 and 1e12");
 17 |     |         }
 18 | *   |         if (yield > 1e12 && yield <= 1e18) {
 19 |     |             fl.log("MYieldToOne[0] yield is between 1e12 and 1e18");
 20 |     |         }
 21 |     | 
 22 | *   |         yield = states[1].mYieldToOne[mYieldToOneArray[1]].yield;
 23 | *   |         if (yield == 0) {
 24 | *   |             fl.log("MYieldToOne[1] yield is 0");
 25 |     |         }
 26 | *   |         if (yield > 0 && yield <= 1e6) {
 27 |     |             fl.log("MYieldToOne[1] yield is between 0 and 1e6");
 28 |     |         }
 29 | *   |         if (yield > 1e6 && yield <= 1e12) {
 30 | *   |             fl.log("MYieldToOne[1] yield is between 1e6 and 1e12");
 31 |     |         }
 32 | *   |         if (yield > 1e12 && yield <= 1e18) {
 33 |     |             fl.log("MYieldToOne[1] yield is between 1e12 and 1e18");
 34 |     |         }
 35 |     | 
 36 | *   |         yield = states[1].mYieldToOne[mYieldToOneArray[2]].yield;
 37 | *   |         if (yield == 0) {
 38 | *   |             fl.log("MYieldToOne[0] yield is 0");
 39 |     |         }
 40 | *   |         if (yield > 0 && yield <= 1e6) {
 41 |     |             fl.log("MYieldToOne[2] yield is between 0 and 1e6");
 42 |     |         }
 43 | *   |         if (yield > 1e6 && yield <= 1e12) {
 44 |     |             fl.log("MYieldToOne[2] yield is between 1e6 and 1e12");
 45 |     |         }
 46 | *   |         if (yield > 1e12 && yield <= 1e18) {
 47 |     |             fl.log("MYieldToOne[2] yield is between 1e12 and 1e18");
 48 |     |         }
 49 |     |     }
 50 |     | }
 51 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/DirectPoolMinter.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import { IUniswapV3Pool } from "uniswapv3/v3-core/interfaces/IUniswapV3Pool.sol";
  5 |     | import { IERC20Minimal } from "uniswapv3/v3-core/interfaces/IERC20Minimal.sol";
  6 |     | 
  7 |     | import { IUniswapV3MintCallback } from "uniswapv3/v3-core/interfaces/callback/IUniswapV3MintCallback.sol";
  8 |     | 
  9 |     | import "uniswapv3/v3-periphery/libraries/LiquidityAmounts.sol";
 10 |     | import "uniswapv3/v3-core/libraries/TickMath.sol";
 11 |     | import { console } from "forge-std/console.sol";
 12 |     | 
 13 | *   | contract DirectPoolMinter is IUniswapV3MintCallback {
 14 |     |     using TickMath for int24;
 15 |     | 
 16 |     |     IUniswapV3Pool public pool;
 17 |     |     address public immutable token0;
 18 |     |     address public immutable token1;
 19 |     | 
 20 | *   |     constructor(address _pool) {
 21 | *   |         pool = IUniswapV3Pool(_pool);
 22 | *   |         token0 = pool.token0();
 23 | *   |         token1 = pool.token1();
 24 |     |     }
 25 |     | 
 26 |     |     // Callback function required by Uniswap V3 pool
 27 | *   |     function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external override {
 28 |     |         // Ensure the caller is the Uniswap V3 pool
 29 | *   |         require(msg.sender == address(pool), "Invalid caller");
 30 |     | 
 31 |     |         // Transfer tokens to the pool
 32 | *   |         if (amount0Owed > 0) {
 33 | *   |             IERC20Minimal(token0).transfer(address(pool), amount0Owed);
 34 |     |         }
 35 | *   |         if (amount1Owed > 0) {
 36 | *   |             IERC20Minimal(token1).transfer(address(pool), amount1Owed);
 37 |     |         }
 38 |     |     }
 39 |     | 
 40 |     |     // Function to mint liquidity directly in the pool
 41 | *   |     function mintLiquidity(
 42 |     |         address recipient,
 43 |     |         int24 tickLower,
 44 |     |         int24 tickUpper,
 45 |     |         uint128 liquidity,
 46 |     |         uint256 amount0Max,
 47 |     |         uint256 amount1Max
 48 | *   |     ) external returns (uint256 amount0, uint256 amount1) {
 49 |     |         // Approve tokens to the pool
 50 | *   |         IERC20Minimal(token0).approve(address(pool), amount0Max);
 51 | *   |         IERC20Minimal(token1).approve(address(pool), amount1Max);
 52 |     | 
 53 | *   |         IERC20Minimal(token0).transferFrom(msg.sender, address(this), amount0Max);
 54 | *   |         IERC20Minimal(token1).transferFrom(msg.sender, address(this), amount1Max);
 55 |     | 
 56 |     |         // Call the mint function on the pool
 57 | *   |         (amount0, amount1) = pool.mint(recipient, tickLower, tickUpper, liquidity, abi.encode(msg.sender));
 58 |     | 
 59 |     |         // Refund any excess tokens (optional)
 60 | *   |         if (amount0 < amount0Max) {
 61 |     |             IERC20Minimal(token0).approve(address(pool), 0);
 62 |     |             IERC20Minimal(token0).transfer(msg.sender, amount0Max - amount0);
 63 |     |         }
 64 | *   |         if (amount1 < amount1Max) {
 65 | *   |             IERC20Minimal(token1).approve(address(pool), 0);
 66 | *   |             IERC20Minimal(token1).transfer(msg.sender, amount1Max - amount1);
 67 |     |         }
 68 |     |     }
 69 |     | 
 70 |     |     // Helper function to calculate liquidity from token amounts
 71 | *   |     function getLiquidityForAmounts(
 72 |     |         uint256 amount0Desired,
 73 |     |         uint256 amount1Desired,
 74 |     |         int24 tickLower,
 75 |     |         int24 tickUpper
 76 | *   |     ) public returns (uint128 liquidity) {
 77 | *   |         (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
 78 | *   |         console.log("sqrtPriceX96", sqrtPriceX96);
 79 |     | 
 80 | *   |         uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);
 81 | *   |         console.log("sqrtRatioAX96", uint256(sqrtRatioAX96));
 82 | *   |         uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
 83 | *   |         console.log("sqrtRatioBX96", uint256(sqrtRatioBX96));
 84 |     | 
 85 | *   |         console.log("amount0Desired", amount0Desired);
 86 | *   |         console.log("amount1Desired", amount1Desired);
 87 |     | 
 88 | *   |         liquidity = LiquidityAmounts.getLiquidityForAmounts(
 89 | *   |             sqrtPriceX96,
 90 | *   |             sqrtRatioAX96,
 91 | *   |             sqrtRatioBX96,
 92 | *   |             amount0Desired,
 93 | *   |             amount1Desired
 94 |     |         );
 95 | *   |         console.log("liquidity", liquidity);
 96 |     |     }
 97 |     | }
 98 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/MToken.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import { ERC20Extended } from "lib/common/src/ERC20Extended.sol";
   6 |     | import { UIntMath } from "lib/common/src/libs/UIntMath.sol";
   7 |     | import { console } from "forge-std/console.sol";
   8 |     | 
   9 |     | import { IERC20 } from "lib/common/src/interfaces/IERC20.sol";
  10 |     | 
  11 |     | import { TTGRegistrarReader } from "src/libs/TTGRegistrarReader.sol";
  12 |     | 
  13 |     | import { IContinuousIndexing } from "./interfaces/IContinuousIndexing.sol";
  14 |     | import { IMToken } from "./interfaces/IMToken.sol";
  15 |     | import { IRateModel } from "./interfaces/IRateModel.sol";
  16 |     | 
  17 |     | import { ContinuousIndexing } from "./abstract/ContinuousIndexing.sol";
  18 |     | import { ContinuousIndexingMath } from "./libs/ContinuousIndexingMath.sol";
  19 |     | 
  20 |     | import { console } from "forge-std/console.sol";
  21 |     | /*
  22 |     | 
  23 |     |               
  24 |     |         
  25 |     |                  
  26 |     |                 
  27 |     |                
  28 |     |                      
  29 |     | 
  30 |     | -->> M is for Money. <<--
  31 |     | 
  32 |     | */
  33 |     | 
  34 |     | /**
  35 |     |  * @title  MToken
  36 |     |  * @author M^0 Labs
  37 |     |  * @notice ERC20 M Token.
  38 |     |  */
  39 | *   | contract MToken is IMToken, ContinuousIndexing, ERC20Extended {
  40 |     |     /* ============ Structs ============ */
  41 |     | 
  42 |     |     /**
  43 |     |      * @notice MToken balance struct.
  44 |     |      * @param  isEarning  True if the account is earning, false otherwise.
  45 |     |      * @param  rawBalance Balance (for a non earning account) or balance principal (for an earning account).
  46 |     |      */
  47 |     |     struct MBalance {
  48 |     |         bool isEarning;
  49 |     |         uint240 rawBalance;
  50 |     |     }
  51 |     | 
  52 |     |     /* ============ Variables ============ */
  53 |     | 
  54 |     |     /// @inheritdoc IMToken
  55 |     |     address public immutable minterGateway;
  56 |     | 
  57 |     |     /// @inheritdoc IMToken
  58 | *   |     address public immutable ttgRegistrar;
  59 |     | 
  60 |     |     /// @inheritdoc IMToken
  61 |     |     uint240 public totalNonEarningSupply;
  62 |     | 
  63 |     |     /// @inheritdoc IMToken
  64 |     |     uint112 public principalOfTotalEarningSupply;
  65 |     | 
  66 |     |     /// @notice The balance of M for non-earner or principal of earning M balance for earners.
  67 |     |     mapping(address account => MBalance balance) internal _balances;
  68 |     | 
  69 |     |     /* ============ Modifiers ============ */
  70 |     | 
  71 |     |     /// @dev Modifier to check if caller is Minter Gateway.
  72 |     |     modifier onlyMinterGateway() {
  73 | *   |         if (msg.sender != minterGateway) revert NotMinterGateway();
  74 |     | 
  75 |     |         _;
  76 |     |     }
  77 |     | 
  78 |     |     /* ============ Constructor ============ */
  79 |     | 
  80 |     |     /**
  81 |     |      * @notice Constructs the M Token contract.
  82 |     |      * @param  ttgRegistrar_ The address of the TTG Registrar contract.
  83 |     |      * @param  minterGateway_     The address of Minter Gateway.
  84 |     |      */
  85 | *   |     constructor(address ttgRegistrar_, address minterGateway_) ContinuousIndexing() ERC20Extended("M by M^0", "M", 6) {
  86 | *   |         if ((ttgRegistrar = ttgRegistrar_) == address(0)) revert ZeroTTGRegistrar();
  87 | *   |         if ((minterGateway = minterGateway_) == address(0)) revert ZeroMinterGateway();
  88 |     |     }
  89 |     | 
  90 |     |     /* ============ Interactive Functions ============ */
  91 |     | 
  92 |     |     /// @inheritdoc IMToken
  93 | *   |     function mint(address account_, uint256 amount_) external onlyMinterGateway {
  94 | *   |         _mint(account_, amount_);
  95 |     |     }
  96 |     | 
  97 |     |     /// @inheritdoc IMToken
  98 |     |     function burn(address account_, uint256 amount_) external onlyMinterGateway {
  99 |     |         _burn(account_, amount_);
 100 |     |     }
 101 |     | 
 102 |     |     /// @inheritdoc IMToken
 103 | *   |     function startEarning() external {
 104 |     |         //NOTE: removed by fuzzer
 105 |     |         // if (!_isApprovedEarner(msg.sender)) revert NotApprovedEarner();
 106 |     | 
 107 | *   |         _startEarning(msg.sender);
 108 |     |     }
 109 |     | 
 110 |     |     /// @inheritdoc IMToken
 111 |     |     function stopEarning() external {
 112 |     |         _stopEarning(msg.sender);
 113 |     |     }
 114 |     | 
 115 |     |     /// @inheritdoc IMToken
 116 | *   |     function stopEarning(address account_) external {
 117 |     |         //NOTE: removed by fuzzer
 118 |     |         // if (_isApprovedEarner(account_)) revert IsApprovedEarner();
 119 |     | 
 120 | *   |         _stopEarning(account_);
 121 |     |     }
 122 |     | 
 123 |     |     /* ============ View/Pure Functions ============ */
 124 |     | 
 125 |     |     /// @inheritdoc IMToken
 126 | *   |     function rateModel() public view returns (address rateModel_) {
 127 | *   |         return TTGRegistrarReader.getEarnerRateModel(ttgRegistrar);
 128 |     |     }
 129 |     | 
 130 |     |     /// @inheritdoc IMToken
 131 | *   |     function earnerRate() public view returns (uint32 earnerRate_) {
 132 | *   |         return _latestRate;
 133 |     |     }
 134 |     | 
 135 |     |     /// @inheritdoc IMToken
 136 | *   |     function totalEarningSupply() public view returns (uint240 totalEarningSupply_) {
 137 | *   |         return _getPresentAmount(principalOfTotalEarningSupply);
 138 |     |     }
 139 |     | 
 140 |     |     /// @inheritdoc IERC20
 141 | *   |     function totalSupply() external view returns (uint256 totalSupply_) {
 142 |     |         unchecked {
 143 | *   |             return totalNonEarningSupply + totalEarningSupply();
 144 |     |         }
 145 |     |     }
 146 |     | 
 147 |     |     /// @inheritdoc IMToken
 148 | *   |     function principalBalanceOf(address account_) external view returns (uint240 balance_) {
 149 | *   |         MBalance storage mBalance_ = _balances[account_];
 150 |     | 
 151 |     |         // Treat the raw balance as principal for earner.
 152 | *   |         return mBalance_.isEarning ? uint112(mBalance_.rawBalance) : 0;
 153 |     |     }
 154 |     | 
 155 |     |     /// @inheritdoc IERC20
 156 | *   |     function balanceOf(address account_) external view returns (uint256 balance_) {
 157 | *   |         MBalance storage mBalance_ = _balances[account_];
 158 |     | 
 159 | *   |         return
 160 | *   |             mBalance_.isEarning
 161 | *   |                 ? _getPresentAmount(uint112(mBalance_.rawBalance)) // Treat the raw balance as principal for earner.
 162 | *   |                 : mBalance_.rawBalance;
 163 |     |     }
 164 |     | 
 165 |     |     /// @inheritdoc IMToken
 166 | *   |     function isEarning(address account_) external view returns (bool isEarning_) {
 167 | *   |         return _balances[account_].isEarning;
 168 |     |     }
 169 |     | 
 170 |     |     /// @inheritdoc IContinuousIndexing
 171 | *   |     function currentIndex() public view override(ContinuousIndexing, IContinuousIndexing) returns (uint128) {
 172 |     |         // NOTE: Safe to use unchecked here, since `block.timestamp` is always greater than `latestUpdateTimestamp`.
 173 |     |         unchecked {
 174 | *   |             return
 175 |     |                 // NOTE: Cap the index to `type(uint128).max` to prevent overflow in present value math.
 176 | *   |                 UIntMath.bound128(
 177 | *   |                     ContinuousIndexingMath.multiplyIndicesDown(
 178 | *   |                         latestIndex,
 179 | *   |                         ContinuousIndexingMath.getContinuousIndex(
 180 | *   |                             ContinuousIndexingMath.convertFromBasisPoints(_latestRate),
 181 | *   |                             uint32(block.timestamp - latestUpdateTimestamp)
 182 |     |                         )
 183 |     |                     )
 184 |     |                 );
 185 |     |         }
 186 |     |     }
 187 |     | 
 188 |     |     /* ============ Internal Interactive Functions ============ */
 189 |     | 
 190 |     |     /**
 191 |     |      * @dev   Adds principal to `_balances` of an earning account.
 192 |     |      * @param account_         The account to add principal to.
 193 |     |      * @param principalAmount_ The principal amount to add.
 194 |     |      */
 195 | *   |     function _addEarningAmount(address account_, uint112 principalAmount_) internal {
 196 |     |         // NOTE: Safe to use unchecked here since overflow of the total supply is checked in `_mint`.
 197 |     |         unchecked {
 198 | *   |             _balances[account_].rawBalance += principalAmount_;
 199 | *   |             principalOfTotalEarningSupply += principalAmount_;
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     /**
 204 |     |      * @dev   Adds amount to `_balances` of a non-earning account.
 205 |     |      * @param account_ The account to add amount to.
 206 |     |      * @param amount_  The amount to add.
 207 |     |      */
 208 | *   |     function _addNonEarningAmount(address account_, uint240 amount_) internal {
 209 |     |         // NOTE: Safe to use unchecked here since overflow of the total supply is checked in `_mint`.
 210 |     |         unchecked {
 211 | *   |             _balances[account_].rawBalance += amount_;
 212 | *   |             totalNonEarningSupply += amount_;
 213 |     |         }
 214 |     |     }
 215 |     | 
 216 |     |     /**
 217 |     |      * @dev   Burns amount of earning or non-earning M from account.
 218 |     |      * @param account_ The account to burn from.
 219 |     |      * @param amount_  The present amount to burn.
 220 |     |      */
 221 |     |     function _burn(address account_, uint256 amount_) internal {
 222 |     |         _revertIfInsufficientAmount(amount_);
 223 |     | 
 224 |     |         emit Transfer(account_, address(0), amount_);
 225 |     | 
 226 |     |         if (_balances[account_].isEarning) {
 227 |     |             // NOTE: When burning a present amount, round the principal up in favor of the protocol.
 228 |     |             _subtractEarningAmount(account_, _getPrincipalAmountRoundedUp(UIntMath.safe240(amount_)));
 229 |     |             updateIndex();
 230 |     |         } else {
 231 |     |             _subtractNonEarningAmount(account_, UIntMath.safe240(amount_));
 232 |     |         }
 233 |     |     }
 234 |     | 
 235 |     |     /**
 236 |     |      * @dev   Mints amount of earning or non-earning M to account.
 237 |     |      * @param recipient_ The account to mint to.
 238 |     |      * @param amount_    The present amount to mint.
 239 |     |      */
 240 | *   |     function _mint(address recipient_, uint256 amount_) internal {
 241 | *   |         _revertIfInsufficientAmount(amount_);
 242 | *   |         _revertIfInvalidRecipient(recipient_);
 243 |     | 
 244 | *   |         emit Transfer(address(0), recipient_, amount_);
 245 |     | 
 246 | *   |         uint240 safeAmount_ = UIntMath.safe240(amount_);
 247 |     | 
 248 |     |         unchecked {
 249 |     |             // As an edge case precaution, prevent a mint that, if all tokens (earning and non-earning) were converted
 250 |     |             // to a principal earning amount, would overflow the `uint112 principalOfTotalEarningSupply`.
 251 | *   |             if (
 252 | *   |                 uint256(totalNonEarningSupply) + safeAmount_ > type(uint240).max ||
 253 |     |                 // NOTE: Round the principal up for worst case.
 254 | *   |                 uint256(principalOfTotalEarningSupply) +
 255 | *   |                     _getPrincipalAmountRoundedUp(totalNonEarningSupply + safeAmount_) >=
 256 | *   |                 type(uint112).max
 257 |     |             ) {
 258 |     |                 revert OverflowsPrincipalOfTotalSupply();
 259 |     |             }
 260 |     |         }
 261 |     | 
 262 | *   |         if (_balances[recipient_].isEarning) {
 263 |     |             // NOTE: When minting a present amount, round the principal down in favor of the protocol.
 264 |     |             _addEarningAmount(recipient_, _getPrincipalAmountRoundedDown(safeAmount_));
 265 |     |             updateIndex();
 266 |     |         } else {
 267 | *   |             _addNonEarningAmount(recipient_, safeAmount_);
 268 |     |         }
 269 |     |     }
 270 |     | 
 271 |     |     /**
 272 |     |      * @dev   Starts earning for account.
 273 |     |      * @param account_ The account to start earning for.
 274 |     |      */
 275 | *   |     function _startEarning(address account_) internal {
 276 | *   |         MBalance storage mBalance_ = _balances[account_];
 277 |     | 
 278 | *   |         if (mBalance_.isEarning) return;
 279 |     | 
 280 | *   |         emit StartedEarning(account_);
 281 |     | 
 282 | *   |         mBalance_.isEarning = true;
 283 |     | 
 284 |     |         // Treat the raw balance as present amount for non earner.
 285 | *   |         uint240 amount_ = mBalance_.rawBalance;
 286 |     | 
 287 | *   |         if (amount_ == 0) return;
 288 |     | 
 289 |     |         // NOTE: When converting a non-earning balance into an earning balance,
 290 |     |         // round the principal down in favor of the protocol.
 291 |     |         uint112 principalAmount_ = _getPrincipalAmountRoundedDown(amount_);
 292 |     | 
 293 |     |         _balances[account_].rawBalance = principalAmount_;
 294 |     | 
 295 |     |         unchecked {
 296 |     |             principalOfTotalEarningSupply += principalAmount_;
 297 |     |             totalNonEarningSupply -= amount_;
 298 |     |         }
 299 |     | 
 300 |     |         updateIndex();
 301 |     |     }
 302 |     | 
 303 |     |     /**
 304 |     |      * @dev   Stops earning for account.
 305 |     |      * @param account_ The account to stop earning for.
 306 |     |      */
 307 | *   |     function _stopEarning(address account_) internal {
 308 | *   |         MBalance storage mBalance_ = _balances[account_];
 309 |     | 
 310 | *   |         if (!mBalance_.isEarning) return;
 311 |     | 
 312 | *   |         emit StoppedEarning(account_);
 313 |     | 
 314 | *   |         mBalance_.isEarning = false;
 315 |     | 
 316 |     |         // Treat the raw balance as principal for earner.
 317 | *   |         uint112 principalAmount_ = uint112(_balances[account_].rawBalance);
 318 |     | 
 319 | *   |         if (principalAmount_ == 0) return;
 320 |     | 
 321 |     |         uint240 amount_ = _getPresentAmount(principalAmount_);
 322 |     | 
 323 |     |         _balances[account_].rawBalance = amount_;
 324 |     | 
 325 |     |         unchecked {
 326 |     |             totalNonEarningSupply += amount_;
 327 |     |             principalOfTotalEarningSupply -= principalAmount_;
 328 |     |         }
 329 |     | 
 330 |     |         updateIndex();
 331 |     |     }
 332 |     | 
 333 |     |     /**
 334 |     |      * @dev   Subtracts principal from `_balances` of an earning account.
 335 |     |      * @param account_         The account to subtract principal from.
 336 |     |      * @param principalAmount_ The principal amount to subtract.
 337 |     |      */
 338 | *   |     function _subtractEarningAmount(address account_, uint112 principalAmount_) internal {
 339 | *   |         uint256 rawBalance_ = _balances[account_].rawBalance;
 340 |     | 
 341 | *   |         if (rawBalance_ < principalAmount_) revert InsufficientBalance(account_, rawBalance_, principalAmount_);
 342 |     | 
 343 |     |         unchecked {
 344 |     |             // Overflow not possible given the above check.
 345 | *   |             _balances[account_].rawBalance -= principalAmount_;
 346 | *   |             principalOfTotalEarningSupply -= principalAmount_;
 347 |     |         }
 348 |     |     }
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev   Subtracts amount from `_balances` of a non-earning account.
 352 |     |      * @param account_ The account to subtract amount from.
 353 |     |      * @param amount_  The amount to subtract.
 354 |     |      */
 355 | *   |     function _subtractNonEarningAmount(address account_, uint240 amount_) internal {
 356 | *   |         uint256 rawBalance_ = _balances[account_].rawBalance;
 357 |     | 
 358 | *   |         if (rawBalance_ < amount_) revert InsufficientBalance(account_, rawBalance_, amount_);
 359 |     | 
 360 |     |         unchecked {
 361 |     |             // Overflow not possible given the above check.
 362 | *   |             _balances[account_].rawBalance -= amount_;
 363 | *   |             totalNonEarningSupply -= amount_;
 364 |     |         }
 365 |     |     }
 366 |     | 
 367 |     |     /**
 368 |     |      * @dev   Transfer M between both earning and non-earning accounts.
 369 |     |      * @param sender_    The account to transfer from. It can be either earning or non-earning account.
 370 |     |      * @param recipient_ The account to transfer to. It can be either earning or non-earning account.
 371 |     |      * @param amount_    The present amount to transfer.
 372 |     |      */
 373 | *   |     function _transfer(address sender_, address recipient_, uint256 amount_) internal override {
 374 | *   |         _revertIfInvalidRecipient(recipient_);
 375 |     | 
 376 | *   |         emit Transfer(sender_, recipient_, amount_);
 377 |     | 
 378 | *   |         uint240 safeAmount_ = UIntMath.safe240(amount_);
 379 |     | 
 380 | *   |         bool senderIsEarning_ = _balances[sender_].isEarning; // Only using the sender's earning status more than once.
 381 |     | 
 382 |     |         // If this is an in-kind transfer, then...
 383 | *   |         if (senderIsEarning_ == _balances[recipient_].isEarning) {
 384 |     |             // NOTE: When subtracting a present amount from an earner, round the principal up in favor of the protocol.
 385 | *   |             return
 386 | *   |                 _transferAmountInKind( // perform an in-kind transfer with...
 387 | *   |                     sender_,
 388 | *   |                     recipient_,
 389 | *   |                     senderIsEarning_ ? _getPrincipalAmountRoundedUp(safeAmount_) : safeAmount_ // the appropriate amount
 390 |     |                 );
 391 |     |         }
 392 |     | 
 393 |     |         // If this is not an in-kind transfer, then...
 394 | *   |         if (senderIsEarning_) {
 395 |     |             // either the sender is earning and the recipient is not, or...
 396 |     |             // NOTE: When subtracting a present amount from an earner, round the principal up in favor of the protocol.
 397 | *   |             _subtractEarningAmount(sender_, _getPrincipalAmountRoundedUp(safeAmount_));
 398 | *   |             _addNonEarningAmount(recipient_, safeAmount_);
 399 |     |         } else {
 400 |     |             // the sender is not earning and the recipient is.
 401 |     |             // NOTE: When adding a present amount to an earner, round the principal down in favor of the protocol.
 402 | *   |             _subtractNonEarningAmount(sender_, safeAmount_);
 403 | *   |             _addEarningAmount(recipient_, _getPrincipalAmountRoundedDown(safeAmount_));
 404 |     |         }
 405 |     | 
 406 | *   |         updateIndex();
 407 |     |     }
 408 |     | 
 409 |     |     /**
 410 |     |      * @dev   Transfer M between same earning status accounts.
 411 |     |      * @param sender_    The account to transfer from.
 412 |     |      * @param recipient_ The account to transfer to.
 413 |     |      * @param amount_    The amount (present or principal) to transfer.
 414 |     |      */
 415 | *   |     function _transferAmountInKind(address sender_, address recipient_, uint240 amount_) internal {
 416 | *   |         uint256 rawBalance_ = _balances[sender_].rawBalance;
 417 |     | 
 418 | *   |         if (rawBalance_ < amount_) revert InsufficientBalance(sender_, rawBalance_, amount_);
 419 |     | 
 420 |     |         // NOTE: When transferring an amount in kind, the `rawBalance` can't overflow
 421 |     |         //       since the total supply would have overflowed first when minting.
 422 |     |         unchecked {
 423 | *   |             _balances[sender_].rawBalance -= amount_;
 424 | *   |             _balances[recipient_].rawBalance += amount_;
 425 |     |         }
 426 |     |     }
 427 |     | 
 428 |     |     /* ============ Internal View/Pure Functions ============ */
 429 |     | 
 430 |     |     /**
 431 |     |      * @dev    Returns the present amount (rounded down) given the principal amount, using the current index.
 432 |     |      *         All present amounts are rounded down in favor of the protocol.
 433 |     |      * @param  principalAmount_ The principal amount.
 434 |     |      * @return The present amount.
 435 |     |      */
 436 | *   |     function _getPresentAmount(uint112 principalAmount_) internal view returns (uint240) {
 437 | *   |         return _getPresentAmount(principalAmount_, currentIndex());
 438 |     |     }
 439 |     | 
 440 |     |     /**
 441 |     |      * @dev    Returns the present amount (rounded down) given the principal amount and an index.
 442 |     |      *         All present amounts are rounded down in favor of the protocol, since they are assets.
 443 |     |      * @param  principalAmount_ The principal amount.
 444 |     |      * @param  index_           An index
 445 |     |      * @return The present amount.
 446 |     |      */
 447 | *   |     function _getPresentAmount(uint112 principalAmount_, uint128 index_) internal pure returns (uint240) {
 448 | *   |         return _getPresentAmountRoundedDown(principalAmount_, index_);
 449 |     |     }
 450 |     | 
 451 |     |     /**
 452 |     |      * @dev    Checks if earner was approved by TTG.
 453 |     |      * @param  account_    The account to check.
 454 |     |      * @return True if approved, false otherwise.
 455 |     |      */
 456 |     |     function _isApprovedEarner(address account_) internal view returns (bool) {
 457 |     |         return
 458 |     |             TTGRegistrarReader.isEarnersListIgnored(ttgRegistrar) ||
 459 |     |             TTGRegistrarReader.isApprovedEarner(ttgRegistrar, account_);
 460 |     |     }
 461 |     | 
 462 |     |     /**
 463 |     |      * @dev    Gets the current earner rate from TTG approved rate model contract.
 464 |     |      * @return rate_ The current earner rate.
 465 |     |      */
 466 | *   |     function _rate() internal view override returns (uint32 rate_) {
 467 | *   |         (bool success_, bytes memory returnData_) = rateModel().staticcall(
 468 | *   |             abi.encodeWithSelector(IRateModel.rate.selector)
 469 |     |         );
 470 |     | 
 471 | *   |         rate_ = (success_ && returnData_.length >= 32) ? UIntMath.bound32(abi.decode(returnData_, (uint256))) : 0;
 472 |     |     }
 473 |     | 
 474 |     |     /**
 475 |     |      * @dev   Reverts if the amount of a `mint` or `burn` is equal to 0.
 476 |     |      * @param amount_ Amount to check.
 477 |     |      */
 478 | *   |     function _revertIfInsufficientAmount(uint256 amount_) internal pure {
 479 | *   |         if (amount_ == 0) revert InsufficientAmount(amount_);
 480 |     |     }
 481 |     | 
 482 |     |     /**
 483 |     |      * @dev   Reverts if the recipient of a `mint` or `transfer` is address(0).
 484 |     |      * @param recipient_ Address of the recipient to check.
 485 |     |      */
 486 | *   |     function _revertIfInvalidRecipient(address recipient_) internal pure {
 487 | *   |         if (recipient_ == address(0)) revert InvalidRecipient(recipient_);
 488 |     |     }
 489 |     | }
 490 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/MinterGateway.f.sol
    1 |     | // SPDX-License-Identifier: GPL-3.0
    2 |     | pragma solidity ^0.8.0;
    3 |     | 
    4 |     | // lib/common/src/libs/Bytes32String.sol
    5 |     | 
    6 |     | /**
    7 |     |  * @title  A library to convert between string and bytes32 (assuming 32 characters or less).
    8 |     |  * @author M^0 Labs
    9 |     |  */
   10 |     | library Bytes32String {
   11 | *   |     function toBytes32(string memory input) internal pure returns (bytes32) {
   12 | *   |         return bytes32(abi.encodePacked(input));
   13 |     |     }
   14 |     | 
   15 | *   |     function toString(bytes32 input) internal pure returns (string memory) {
   16 | *   |         uint256 length;
   17 |     | 
   18 | *   |         while (length < 32 && uint8(input[length]) != 0) {
   19 | *   |             ++length;
   20 |     |         }
   21 |     | 
   22 | *   |         bytes memory name = new bytes(length);
   23 |     | 
   24 | *   |         for (uint256 index; index < length; ++index) {
   25 | *   |             name[index] = input[index];
   26 |     |         }
   27 |     | 
   28 | *   |         return string(name);
   29 |     |     }
   30 |     | }
   31 |     | 
   32 |     | // src/interfaces/IContinuousIndexing.sol
   33 |     | 
   34 |     | /**
   35 |     |  * @title  Continuous Indexing Interface.
   36 |     |  * @author M^0 Labs
   37 |     |  */
   38 |     | interface IContinuousIndexing {
   39 |     |     /* ============ Events ============ */
   40 |     | 
   41 |     |     /**
   42 |     |      * @notice Emitted when the index is updated.
   43 |     |      * @param  index The new index.
   44 |     |      * @param  rate  The current rate.
   45 |     |      */
   46 |     |     event IndexUpdated(uint128 indexed index, uint32 indexed rate);
   47 |     | 
   48 |     |     /* ============ Interactive Functions ============ */
   49 |     | 
   50 |     |     /**
   51 |     |      * @notice Updates the latest index and latest accrual time in storage.
   52 |     |      * @return index The new stored index for computing present amounts from principal amounts.
   53 |     |      */
   54 |     |     function updateIndex() external returns (uint128);
   55 |     | 
   56 |     |     /* ============ View/Pure Functions ============ */
   57 |     | 
   58 |     |     /// @notice The current index that would be written to storage if `updateIndex` is called.
   59 |     |     function currentIndex() external view returns (uint128);
   60 |     | 
   61 |     |     /// @notice The latest updated index.
   62 |     |     function latestIndex() external view returns (uint128);
   63 |     | 
   64 |     |     /// @notice The latest timestamp when the index was updated.
   65 |     |     function latestUpdateTimestamp() external view returns (uint40);
   66 |     | }
   67 |     | 
   68 |     | // lib/common/src/interfaces/IERC1271.sol
   69 |     | 
   70 |     | /**
   71 |     |  * @title  Standard Signature Validation Method for Contracts via EIP-1271.
   72 |     |  * @author M^0 Labs
   73 |     |  * @dev    The interface as defined by EIP-1271: https://eips.ethereum.org/EIPS/eip-1271
   74 |     |  */
   75 |     | interface IERC1271 {
   76 |     |     /**
   77 |     |      * @dev    Returns a specific magic value if the provided signature is valid for the provided digest.
   78 |     |      * @param  digest     Hash of the data purported to have been signed.
   79 |     |      * @param  signature  Signature byte array associated with the digest.
   80 |     |      * @return magicValue Magic value 0x1626ba7e if the signature is valid.
   81 |     |      */
   82 |     |     function isValidSignature(bytes32 digest, bytes memory signature) external view returns (bytes4 magicValue);
   83 |     | }
   84 |     | 
   85 |     | // lib/common/src/interfaces/IERC20.sol
   86 |     | 
   87 |     | /**
   88 |     |  * @title  ERC20 Token Standard.
   89 |     |  * @author M^0 Labs
   90 |     |  * @dev    The interface as defined by EIP-20: https://eips.ethereum.org/EIPS/eip-20
   91 |     |  */
   92 |     | interface IERC20 {
   93 |     |     /* ============ Events ============ */
   94 |     | 
   95 |     |     /**
   96 |     |      * @notice Emitted when `spender` has been approved for `amount` of the token balance of `account`.
   97 |     |      * @param  account The address of the account.
   98 |     |      * @param  spender The address of the spender being approved for the allowance.
   99 |     |      * @param  amount  The amount of the allowance being approved.
  100 |     |      */
  101 |     |     event Approval(address indexed account, address indexed spender, uint256 amount);
  102 |     | 
  103 |     |     /**
  104 |     |      * @notice Emitted when `amount` tokens is transferred from `sender` to `recipient`.
  105 |     |      * @param  sender    The address of the sender who's token balance is decremented.
  106 |     |      * @param  recipient The address of the recipient who's token balance is incremented.
  107 |     |      * @param  amount    The amount of tokens being transferred.
  108 |     |      */
  109 |     |     event Transfer(address indexed sender, address indexed recipient, uint256 amount);
  110 |     | 
  111 |     |     /* ============ Interactive Functions ============ */
  112 |     | 
  113 |     |     /**
  114 |     |      * @notice Allows a calling account to approve `spender` to spend up to `amount` of its token balance.
  115 |     |      * @dev    MUST emit an `Approval` event.
  116 |     |      * @param  spender The address of the account being allowed to spend up to the allowed amount.
  117 |     |      * @param  amount  The amount of the allowance being approved.
  118 |     |      * @return Whether or not the approval was successful.
  119 |     |      */
  120 |     |     function approve(address spender, uint256 amount) external returns (bool);
  121 |     | 
  122 |     |     /**
  123 |     |      * @notice Allows a calling account to transfer `amount` tokens to `recipient`.
  124 |     |      * @param  recipient The address of the recipient who's token balance will be incremented.
  125 |     |      * @param  amount    The amount of tokens being transferred.
  126 |     |      * @return Whether or not the transfer was successful.
  127 |     |      */
  128 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
  129 |     | 
  130 |     |     /**
  131 |     |      * @notice Allows a calling account to transfer `amount` tokens from `sender`, with allowance, to a `recipient`.
  132 |     |      * @param  sender    The address of the sender who's token balance will be decremented.
  133 |     |      * @param  recipient The address of the recipient who's token balance will be incremented.
  134 |     |      * @param  amount    The amount of tokens being transferred.
  135 |     |      * @return Whether or not the transfer was successful.
  136 |     |      */
  137 |     |     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
  138 |     | 
  139 |     |     /* ============ View/Pure Functions ============ */
  140 |     | 
  141 |     |     /**
  142 |     |      * @notice Returns the allowance `spender` is allowed to spend on behalf of `account`.
  143 |     |      * @param  account The address of the account who's token balance `spender` is allowed to spend.
  144 |     |      * @param  spender The address of an account allowed to spend on behalf of `account`.
  145 |     |      * @return The amount `spender` can spend on behalf of `account`.
  146 |     |      */
  147 |     |     function allowance(address account, address spender) external view returns (uint256);
  148 |     | 
  149 |     |     /**
  150 |     |      * @notice Returns the token balance of `account`.
  151 |     |      * @param  account The address of some account.
  152 |     |      * @return The token balance of `account`.
  153 |     |      */
  154 |     |     function balanceOf(address account) external view returns (uint256);
  155 |     | 
  156 |     |     /// @notice Returns the number of decimals UIs should assume all amounts have.
  157 |     |     function decimals() external view returns (uint8);
  158 |     | 
  159 |     |     /// @notice Returns the name of the contract/token.
  160 |     |     function name() external view returns (string memory);
  161 |     | 
  162 |     |     /// @notice Returns the symbol of the token.
  163 |     |     function symbol() external view returns (string memory);
  164 |     | 
  165 |     |     /// @notice Returns the current total supply of the token.
  166 |     |     function totalSupply() external view returns (uint256);
  167 |     | }
  168 |     | 
  169 |     | // lib/common/src/interfaces/IERC712.sol
  170 |     | 
  171 |     | /**
  172 |     |  * @title  Typed structured data hashing and signing via EIP-712.
  173 |     |  * @author M^0 Labs
  174 |     |  * @dev    The interface as defined by EIP-712: https://eips.ethereum.org/EIPS/eip-712
  175 |     |  */
  176 |     | interface IERC712 {
  177 |     |     /* ============ Custom Errors ============ */
  178 |     | 
  179 |     |     /// @notice Revert message when an invalid signature is detected.
  180 |     |     error InvalidSignature();
  181 |     | 
  182 |     |     /// @notice Revert message when a signature with invalid length is detected.
  183 |     |     error InvalidSignatureLength();
  184 |     | 
  185 |     |     /// @notice Revert message when the S portion of a signature is invalid.
  186 |     |     error InvalidSignatureS();
  187 |     | 
  188 |     |     /// @notice Revert message when the V portion of a signature is invalid.
  189 |     |     error InvalidSignatureV();
  190 |     | 
  191 |     |     /**
  192 |     |      * @notice Revert message when a signature is being used beyond its deadline (i.e. expiry).
  193 |     |      * @param  deadline  The last timestamp where the signature is still valid.
  194 |     |      * @param  timestamp The current timestamp.
  195 |     |      */
  196 |     |     error SignatureExpired(uint256 deadline, uint256 timestamp);
  197 |     | 
  198 |     |     /// @notice Revert message when a recovered signer does not match the account being purported to have signed.
  199 |     |     error SignerMismatch();
  200 |     | 
  201 |     |     /* ============ View/Pure Functions ============ */
  202 |     | 
  203 |     |     /// @notice Returns the EIP712 domain separator used in the encoding of a signed digest.
  204 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
  205 |     | }
  206 |     | 
  207 |     | // src/interfaces/IRateModel.sol
  208 |     | 
  209 |     | /**
  210 |     |  * @title  Rate Model Interface.
  211 |     |  * @author M^0 Labs
  212 |     |  */
  213 |     | interface IRateModel {
  214 |     |     /**
  215 |     |      * @notice Returns the current yearly rate in BPS.
  216 |     |      *         This value does not account for the compounding interest.
  217 |     |      */
  218 |     |     function rate() external view returns (uint256);
  219 |     | }
  220 |     | 
  221 |     | // src/interfaces/ITTGRegistrar.sol
  222 |     | 
  223 |     | /**
  224 |     |  * @title  TTG (Two Token Governance) Registrar interface.
  225 |     |  * @author M^0 Labs
  226 |     |  */
  227 |     | interface ITTGRegistrar {
  228 |     |     /**
  229 |     |      * @notice Key value pair getter.
  230 |     |      * @param  key The key to get the value of.
  231 |     |      * @return value The value of the key.
  232 |     |      */
  233 |     |     function get(bytes32 key) external view returns (bytes32 value);
  234 |     | 
  235 |     |     /**
  236 |     |      * @notice Checks if the list contains the account.
  237 |     |      * @param  list The list to check.
  238 |     |      * @param  account The account to check.
  239 |     |      * @return True if the list contains the account, false otherwise.
  240 |     |      */
  241 |     |     function listContains(bytes32 list, address account) external view returns (bool);
  242 |     | 
  243 |     |     /// @notice Returns the vault contract address.
  244 |     |     function vault() external view returns (address);
  245 |     | }
  246 |     | 
  247 |     | // lib/common/src/libs/UIntMath.sol
  248 |     | 
  249 |     | /**
  250 |     |  * @title  Library to perform safe math operations on uint types
  251 |     |  * @author M^0 Labs
  252 |     |  */
  253 |     | library UIntMath {
  254 |     |     /* ============ Custom Errors ============ */
  255 |     | 
  256 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint16.
  257 |     |     error InvalidUInt16();
  258 |     | 
  259 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint32.
  260 |     |     error InvalidUInt32();
  261 |     | 
  262 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint40.
  263 |     |     error InvalidUInt40();
  264 |     | 
  265 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint48.
  266 |     |     error InvalidUInt48();
  267 |     | 
  268 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint112.
  269 |     |     error InvalidUInt112();
  270 |     | 
  271 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint128.
  272 |     |     error InvalidUInt128();
  273 |     | 
  274 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint240.
  275 |     |     error InvalidUInt240();
  276 |     | 
  277 |     |     /* ============ Internal View/Pure Functions ============ */
  278 |     | 
  279 |     |     /**
  280 |     |      * @notice Casts a uint256 value to a uint16, ensuring that it is less than or equal to the maximum uint16 value.
  281 |     |      * @param  n The value to cast.
  282 |     |      * @return The value casted to uint16.
  283 |     |      */
  284 |     |     function safe16(uint256 n) internal pure returns (uint16) {
  285 |     |         if (n > type(uint16).max) revert InvalidUInt16();
  286 |     |         return uint16(n);
  287 |     |     }
  288 |     | 
  289 |     |     /**
  290 |     |      * @notice Casts a uint256 value to a uint32, ensuring that it is less than or equal to the maximum uint32 value.
  291 |     |      * @param  n The value to cast.
  292 |     |      * @return The value casted to uint32.
  293 |     |      */
  294 |     |     function safe32(uint256 n) internal pure returns (uint32) {
  295 |     |         if (n > type(uint32).max) revert InvalidUInt32();
  296 |     |         return uint32(n);
  297 |     |     }
  298 |     | 
  299 |     |     /**
  300 |     |      * @notice Casts a uint256 value to a uint40, ensuring that it is less than or equal to the maximum uint40 value.
  301 |     |      * @param  n The value to cast.
  302 |     |      * @return The value casted to uint40.
  303 |     |      */
  304 |     |     function safe40(uint256 n) internal pure returns (uint40) {
  305 |     |         if (n > type(uint40).max) revert InvalidUInt40();
  306 |     |         return uint40(n);
  307 |     |     }
  308 |     | 
  309 |     |     /**
  310 |     |      * @notice Casts a uint256 value to a uint48, ensuring that it is less than or equal to the maximum uint48 value.
  311 |     |      * @param  n The value to cast.
  312 |     |      * @return The value casted to uint48.
  313 |     |      */
  314 |     |     function safe48(uint256 n) internal pure returns (uint48) {
  315 |     |         if (n > type(uint48).max) revert InvalidUInt48();
  316 |     |         return uint48(n);
  317 |     |     }
  318 |     | 
  319 |     |     /**
  320 |     |      * @notice Casts a uint256 value to a uint112, ensuring that it is less than or equal to the maximum uint112 value.
  321 |     |      * @param  n The value to cast.
  322 |     |      * @return The value casted to uint112.
  323 |     |      */
  324 | *   |     function safe112(uint256 n) internal pure returns (uint112) {
  325 | *   |         if (n > type(uint112).max) revert InvalidUInt112();
  326 | *   |         return uint112(n);
  327 |     |     }
  328 |     | 
  329 |     |     /**
  330 |     |      * @notice Casts a uint256 value to a uint128, ensuring that it is less than or equal to the maximum uint128 value.
  331 |     |      * @param  n The value to cast.
  332 |     |      * @return The value casted to uint128.
  333 |     |      */
  334 |     |     function safe128(uint256 n) internal pure returns (uint128) {
  335 |     |         if (n > type(uint128).max) revert InvalidUInt128();
  336 |     |         return uint128(n);
  337 |     |     }
  338 |     | 
  339 |     |     /**
  340 |     |      * @notice Casts a uint256 value to a uint240, ensuring that it is less than or equal to the maximum uint240 value.
  341 |     |      * @param  n The value to cast.
  342 |     |      * @return The value casted to uint240.
  343 |     |      */
  344 | *   |     function safe240(uint256 n) internal pure returns (uint240) {
  345 | *   |         if (n > type(uint240).max) revert InvalidUInt240();
  346 | *   |         return uint240(n);
  347 |     |     }
  348 |     | 
  349 |     |     /**
  350 |     |      * @notice Limits a uint256 value to the maximum uint32 value.
  351 |     |      * @param  n The value to bound.
  352 |     |      * @return The value limited to within uint32 bounds.
  353 |     |      */
  354 | *   |     function bound32(uint256 n) internal pure returns (uint32) {
  355 | *   |         return uint32(min256(n, uint256(type(uint32).max)));
  356 |     |     }
  357 |     | 
  358 |     |     /**
  359 |     |      * @notice Limits a uint256 value to the maximum uint112 value.
  360 |     |      * @param  n The value to bound.
  361 |     |      * @return The value limited to within uint112 bounds.
  362 |     |      */
  363 |     |     function bound112(uint256 n) internal pure returns (uint112) {
  364 |     |         return uint112(min256(n, uint256(type(uint112).max)));
  365 |     |     }
  366 |     | 
  367 |     |     /**
  368 |     |      * @notice Limits a uint256 value to the maximum uint128 value.
  369 |     |      * @param  n The value to bound.
  370 |     |      * @return The value limited to within uint128 bounds.
  371 |     |      */
  372 | *   |     function bound128(uint256 n) internal pure returns (uint128) {
  373 | *   |         return uint128(min256(n, uint256(type(uint128).max)));
  374 |     |     }
  375 |     | 
  376 |     |     /**
  377 |     |      * @notice Limits a uint256 value to the maximum uint240 value.
  378 |     |      * @param  n The value to bound.
  379 |     |      * @return The value limited to within uint240 bounds.
  380 |     |      */
  381 |     |     function bound240(uint256 n) internal pure returns (uint240) {
  382 |     |         return uint240(min256(n, uint256(type(uint240).max)));
  383 |     |     }
  384 |     | 
  385 |     |     /**
  386 |     |      * @notice Compares two uint32 values and returns the larger one.
  387 |     |      * @param  a Value to compare.
  388 |     |      * @param  b Value to compare.
  389 |     |      * @return The larger value.
  390 |     |      */
  391 | *   |     function max32(uint32 a, uint32 b) internal pure returns (uint32) {
  392 | *   |         return a > b ? a : b;
  393 |     |     }
  394 |     | 
  395 |     |     /**
  396 |     |      * @notice Compares two uint40 values and returns the larger one.
  397 |     |      * @param  a Value to compare.
  398 |     |      * @param  b Value to compare.
  399 |     |      * @return The larger value.
  400 |     |      */
  401 |     |     function max40(uint40 a, uint40 b) internal pure returns (uint40) {
  402 |     |         return a > b ? a : b;
  403 |     |     }
  404 |     | 
  405 |     |     /**
  406 |     |      * @notice Compares two uint128 values and returns the larger one.
  407 |     |      * @param  a Value to compare.
  408 |     |      * @param  b Value to compare.
  409 |     |      * @return The larger value.
  410 |     |      */
  411 |     |     function max128(uint128 a, uint128 b) internal pure returns (uint128) {
  412 |     |         return a > b ? a : b;
  413 |     |     }
  414 |     | 
  415 |     |     /**
  416 |     |      * @notice Compares two uint240 values and returns the larger one.
  417 |     |      * @param  a Value to compare.
  418 |     |      * @param  b Value to compare.
  419 |     |      * @return The larger value.
  420 |     |      */
  421 |     |     function max240(uint240 a, uint240 b) internal pure returns (uint240) {
  422 |     |         return a > b ? a : b;
  423 |     |     }
  424 |     | 
  425 |     |     /**
  426 |     |      * @notice Compares two uint32 values and returns the lesser one.
  427 |     |      * @param  a Value to compare.
  428 |     |      * @param  b Value to compare.
  429 |     |      * @return The lesser value.
  430 |     |      */
  431 | *   |     function min32(uint32 a, uint32 b) internal pure returns (uint32) {
  432 | *   |         return a < b ? a : b;
  433 |     |     }
  434 |     | 
  435 |     |     /**
  436 |     |      * @notice Compares two uint40 values and returns the lesser one.
  437 |     |      * @param  a Value to compare.
  438 |     |      * @param  b Value to compare.
  439 |     |      * @return The lesser value.
  440 |     |      */
  441 |     |     function min40(uint40 a, uint40 b) internal pure returns (uint40) {
  442 |     |         return a < b ? a : b;
  443 |     |     }
  444 |     | 
  445 |     |     /**
  446 |     |      * @notice Compares two uint240 values and returns the lesser one.
  447 |     |      * @param  a Value to compare.
  448 |     |      * @param  b Value to compare.
  449 |     |      * @return The lesser value.
  450 |     |      */
  451 |     |     function min240(uint240 a, uint240 b) internal pure returns (uint240) {
  452 |     |         return a < b ? a : b;
  453 |     |     }
  454 |     | 
  455 |     |     /**
  456 |     |      * @notice Compares two uint112 values and returns the lesser one.
  457 |     |      * @param  a Value to compare.
  458 |     |      * @param  b Value to compare.
  459 |     |      * @return The lesser value.
  460 |     |      */
  461 |     |     function min112(uint112 a, uint112 b) internal pure returns (uint112) {
  462 |     |         return a < b ? a : b;
  463 |     |     }
  464 |     | 
  465 |     |     /**
  466 |     |      * @notice Compares two uint256 values and returns the lesser one.
  467 |     |      * @param  a Value to compare.
  468 |     |      * @param  b Value to compare.
  469 |     |      * @return The lesser value.
  470 |     |      */
  471 | *   |     function min256(uint256 a, uint256 b) internal pure returns (uint256) {
  472 | *   |         return a < b ? a : b;
  473 |     |     }
  474 |     | }
  475 |     | 
  476 |     | // src/libs/ContinuousIndexingMath.sol
  477 |     | 
  478 |     | /**
  479 |     |  * @title  Arithmetic library with operations for calculating continuous indexing.
  480 |     |  * @author M^0 Labs
  481 |     |  */
  482 |     | library ContinuousIndexingMath {
  483 |     |     /* ============ Variables ============ */
  484 |     | 
  485 |     |     /// @notice The number of seconds in a year.
  486 | *   |     uint32 internal constant SECONDS_PER_YEAR = 31_536_000;
  487 |     | 
  488 |     |     /// @notice 100% in basis points.
  489 | *   |     uint16 internal constant BPS_SCALED_ONE = 1e4;
  490 |     | 
  491 |     |     /// @notice The scaling of rates in for exponent math.
  492 | *   |     uint56 internal constant EXP_SCALED_ONE = 1e12;
  493 |     | 
  494 |     |     /* ============ Custom Errors ============ */
  495 |     | 
  496 |     |     /// @notice Emitted when a division by zero occurs.
  497 |     |     error DivisionByZero();
  498 |     | 
  499 |     |     /* ============ Internal View/Pure Functions ============ */
  500 |     | 
  501 |     |     /**
  502 |     |      * @notice Helper function to calculate `(x * EXP_SCALED_ONE) / index`, rounded down.
  503 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  504 |     |      */
  505 |     |     function divideDown(uint240 x, uint128 index) internal pure returns (uint112 z) {
  506 |     |         if (index == 0) revert DivisionByZero();
  507 |     | 
  508 |     |         unchecked {
  509 |     |             // NOTE: While `uint256(x) * EXP_SCALED_ONE` can technically overflow, these divide/multiply functions are
  510 |     |             //       only used for the purpose of principal/present amount calculations for continuous indexing, and
  511 |     |             //       so for an `x` to be large enough to overflow this, it would have to be a possible result of
  512 |     |             //       `multiplyDown` or `multiplyUp`, which would already satisfy
  513 |     |             //       `uint256(x) * EXP_SCALED_ONE < type(uint240).max`.
  514 |     |             return UIntMath.safe112((uint256(x) * EXP_SCALED_ONE) / index);
  515 |     |         }
  516 |     |     }
  517 |     | 
  518 |     |     /**
  519 |     |      * @notice Helper function to calculate `(x * EXP_SCALED_ONE) / index`, rounded up.
  520 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  521 |     |      */
  522 | *   |     function divideUp(uint240 x, uint128 index) internal pure returns (uint112 z) {
  523 | *   |         if (index == 0) revert DivisionByZero();
  524 |     | 
  525 |     |         unchecked {
  526 |     |             // NOTE: While `uint256(x) * EXP_SCALED_ONE` can technically overflow, these divide/multiply functions are
  527 |     |             //       only used for the purpose of principal/present amount calculations for continuous indexing, and
  528 |     |             //       so for an `x` to be large enough to overflow this, it would have to be a possible result of
  529 |     |             //       `multiplyDown` or `multiplyUp`, which would already satisfy
  530 |     |             //       `uint256(x) * EXP_SCALED_ONE < type(uint240).max`.
  531 | *   |             return UIntMath.safe112(((uint256(x) * EXP_SCALED_ONE) + index - 1) / index);
  532 |     |         }
  533 |     |     }
  534 |     | 
  535 |     |     /**
  536 |     |      * @notice Helper function to calculate `(x * index) / EXP_SCALED_ONE`, rounded down.
  537 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  538 |     |      */
  539 | *   |     function multiplyDown(uint112 x, uint128 index) internal pure returns (uint240 z) {
  540 |     |         unchecked {
  541 | *   |             return uint240((uint256(x) * index) / EXP_SCALED_ONE);
  542 |     |         }
  543 |     |     }
  544 |     | 
  545 |     |     /**
  546 |     |      * @notice Helper function to calculate `(x * index) / EXP_SCALED_ONE`, rounded up.
  547 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  548 |     |      */
  549 | *   |     function multiplyUp(uint112 x, uint128 index) internal pure returns (uint240 z) {
  550 |     |         unchecked {
  551 | *   |             return uint240(((uint256(x) * index) + (EXP_SCALED_ONE - 1)) / EXP_SCALED_ONE);
  552 |     |         }
  553 |     |     }
  554 |     | 
  555 |     |     /**
  556 |     |      * @notice Helper function to calculate `(index * deltaIndex) / EXP_SCALED_ONE`, rounded down.
  557 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  558 |     |      */
  559 |     |     function multiplyIndicesDown(uint128 index, uint48 deltaIndex) internal pure returns (uint144 z) {
  560 |     |         unchecked {
  561 |     |             return uint144((uint256(index) * deltaIndex) / EXP_SCALED_ONE);
  562 |     |         }
  563 |     |     }
  564 |     | 
  565 |     |     /**
  566 |     |      * @notice Helper function to calculate `(index * deltaIndex) / EXP_SCALED_ONE`, rounded up.
  567 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  568 |     |      */
  569 | *   |     function multiplyIndicesUp(uint128 index, uint48 deltaIndex) internal pure returns (uint144 z) {
  570 |     |         unchecked {
  571 | *   |             return uint144((uint256(index) * deltaIndex + (EXP_SCALED_ONE - 1)) / EXP_SCALED_ONE);
  572 |     |         }
  573 |     |     }
  574 |     | 
  575 |     |     /**
  576 |     |      * @notice Helper function to calculate e^rt (continuous compounding formula).
  577 |     |      * @dev    `uint64 yearlyRate` can accommodate 1000% interest per year.
  578 |     |      * @dev    `uint32 time` can accommodate 100 years.
  579 |     |      * @dev    `type(uint64).max * type(uint32).max / SECONDS_PER_YEAR` fits in a `uint72`.
  580 |     |      */
  581 | *   |     function getContinuousIndex(uint64 yearlyRate, uint32 time) internal pure returns (uint48 index) {
  582 |     |         unchecked {
  583 |     |             // NOTE: Casting `uint256(yearlyRate) * time` to a `uint72` is safe because the largest value is
  584 |     |             //      `type(uint64).max * type(uint32).max / SECONDS_PER_YEAR`, which is less than `type(uint72).max`.
  585 | *   |             return exponent(uint72((uint256(yearlyRate) * time) / SECONDS_PER_YEAR));
  586 |     |         }
  587 |     |     }
  588 |     | 
  589 |     |     /**
  590 |     |      * @notice Helper function to calculate y = e^x using R(4,4) Pad approximation:
  591 |     |      *           e(x) = (1 + x/2 + 3(x^2)/28 + x^3/84 + x^4/1680) / (1 - x/2 + 3(x^2)/28 - x^3/84 + x^4/1680)
  592 |     |      *           See: https://en.wikipedia.org/wiki/Pad%C3%A9_table
  593 |     |      *           See: https://www.wolframalpha.com/input?i=PadeApproximant%5Bexp%5Bx%5D%2C%7Bx%2C0%2C%7B4%2C+4%7D%7D%5D
  594 |     |      *         Despite itself being a whole number, `x` represents a real number scaled by `EXP_SCALED_ONE`, thus
  595 |     |      *         allowing for y = e^x where x is a real number.
  596 |     |      * @dev    Output `y` for a `uint72` input `x` will fit in `uint48`
  597 |     |      */
  598 | *   |     function exponent(uint72 x) internal pure returns (uint48 y) {
  599 |     |         // NOTE: This can be done unchecked even for `x = type(uint72).max`.
  600 |     |         //       Verify by removing `unchecked` and running `test_exponent()`.
  601 |     |         unchecked {
  602 | *   |             uint256 x2 = uint256(x) * x;
  603 |     | 
  604 |     |             // `additiveTerms` is `(1 + 3(x^2)/28 + x^4/1680)`, and scaled by `84e27`.
  605 |     |             // NOTE: `84e27` the cleanest and largest scalar, given the various intermediate overflow possibilities.
  606 |     |             // NOTE: The resulting `(x2 * x2) / 20e21` term has been split up in order to avoid overflow of `x2 * x2`.
  607 | *   |             uint256 additiveTerms = 84e27 + (9e3 * x2) + ((x2 / 2e11) * (x2 / 1e11));
  608 |     | 
  609 |     |             // `differentTerms` is `(- x/2 - x^3/84)`, but positive (will be subtracted later), and scaled by `84e27`.
  610 | *   |             uint256 differentTerms = uint256(x) * (42e15 + (x2 / 1e9));
  611 |     | 
  612 |     |             // Result needs to be scaled by `1e12`.
  613 |     |             // NOTE: Can cast to `uint48` because contents can never be larger than `type(uint48).max` for any `x`.
  614 |     |             //       Max `y` is ~200e12, before falling off. See links above for reference.
  615 | *   |             return uint48(((additiveTerms + differentTerms) * 1e12) / (additiveTerms - differentTerms));
  616 |     |         }
  617 |     |     }
  618 |     | 
  619 |     |     /**
  620 |     |      * @notice Helper function to convert 12-decimal representation to basis points.
  621 |     |      * @param  input The input in 12-decimal representation.
  622 |     |      * @return The output in basis points.
  623 |     |      */
  624 |     |     function convertToBasisPoints(uint64 input) internal pure returns (uint40) {
  625 |     |         unchecked {
  626 |     |             return uint40((uint256(input) * BPS_SCALED_ONE) / EXP_SCALED_ONE);
  627 |     |         }
  628 |     |     }
  629 |     | 
  630 |     |     /**
  631 |     |      * @notice Helper function to convert basis points to 12-decimal representation.
  632 |     |      * @param  input The input in basis points.
  633 |     |      * @return The output in 12-decimal representation.
  634 |     |      */
  635 | *   |     function convertFromBasisPoints(uint32 input) internal pure returns (uint64) {
  636 |     |         unchecked {
  637 | *   |             return uint64((uint256(input) * EXP_SCALED_ONE) / BPS_SCALED_ONE);
  638 |     |         }
  639 |     |     }
  640 |     | }
  641 |     | 
  642 |     | // lib/common/src/interfaces/IERC712Extended.sol
  643 |     | 
  644 |     | /**
  645 |     |  * @title  EIP-712 extended by EIP-5267.
  646 |     |  * @author M^0 Labs
  647 |     |  * @dev    The additional interface as defined by EIP-5267: https://eips.ethereum.org/EIPS/eip-5267
  648 |     |  */
  649 |     | interface IERC712Extended is IERC712 {
  650 |     |     /* ============ Events ============ */
  651 |     | 
  652 |     |     /// @notice MAY be emitted to signal that the domain could have changed.
  653 |     |     event EIP712DomainChanged();
  654 |     | 
  655 |     |     /* ============ View/Pure Functions ============ */
  656 |     | 
  657 |     |     /// @notice Returns the fields and values that describe the domain separator used by this contract for EIP-712.
  658 |     |     function eip712Domain()
  659 |     |         external
  660 |     |         view
  661 |     |         returns (
  662 |     |             bytes1 fields,
  663 |     |             string memory name,
  664 |     |             string memory version,
  665 |     |             uint256 chainId,
  666 |     |             address verifyingContract,
  667 |     |             bytes32 salt,
  668 |     |             uint256[] memory extensions
  669 |     |         );
  670 |     | }
  671 |     | 
  672 |     | // lib/common/src/libs/SignatureChecker.sol
  673 |     | 
  674 |     | /**
  675 |     |  * @title  A library to handle ECDSA/secp256k1 and ERC1271 signatures, individually or in arbitrarily in combination.
  676 |     |  * @author M^0 Labs
  677 |     |  */
  678 |     | library SignatureChecker {
  679 |     |     /* ============ Enums ============ */
  680 |     | 
  681 |     |     /**
  682 |     |      * @notice An enum representing the possible errors that can be emitted during signature validation.
  683 |     |      * @param  NoError                No error occurred during signature validation.
  684 |     |      * @param  InvalidSignature       The signature is invalid.
  685 |     |      * @param  InvalidSignatureLength The signature length is invalid.
  686 |     |      * @param  InvalidSignatureS      The signature parameter S is invalid.
  687 |     |      * @param  InvalidSignatureV      The signature parameter V is invalid.
  688 |     |      * @param  SignerMismatch         The signer does not match the recovered signer.
  689 |     |      */
  690 |     |     enum Error {
  691 |     |         NoError,
  692 |     |         InvalidSignature,
  693 |     |         InvalidSignatureLength,
  694 |     |         InvalidSignatureS,
  695 |     |         InvalidSignatureV,
  696 |     |         SignerMismatch
  697 |     |     }
  698 |     | 
  699 |     |     /* ============ Internal View/Pure Functions ============ */
  700 |     | 
  701 |     |     /**
  702 |     |      * @dev    Returns whether a signature is valid (ECDSA/secp256k1 or ERC1271) for a signer and digest.
  703 |     |      * @dev    Signatures must not be used as unique identifiers since the `ecrecover` EVM opcode
  704 |     |      *         allows for malleable (non-unique) signatures.
  705 |     |      *         See https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h
  706 |     |      * @param  signer    The address of the account purported to have signed.
  707 |     |      * @param  digest    The hash of the data that was signed.
  708 |     |      * @param  signature A byte array signature.
  709 |     |      * @return           Whether the signature is valid or not.
  710 |     |      */
  711 |     |     function isValidSignature(address signer, bytes32 digest, bytes memory signature) internal view returns (bool) {
  712 |     |         return isValidECDSASignature(signer, digest, signature) || isValidERC1271Signature(signer, digest, signature);
  713 |     |     }
  714 |     | 
  715 |     |     /**
  716 |     |      * @dev    Returns whether an ERC1271 signature is valid for a signer and digest.
  717 |     |      * @param  signer    The address of the account purported to have signed.
  718 |     |      * @param  digest    The hash of the data that was signed.
  719 |     |      * @param  signature A byte array ERC1271 signature.
  720 |     |      * @return           Whether the signature is valid or not.
  721 |     |      */
  722 |     |     function isValidERC1271Signature(
  723 |     |         address signer,
  724 |     |         bytes32 digest,
  725 |     |         bytes memory signature
  726 |     |     ) internal view returns (bool) {
  727 |     |         (bool success_, bytes memory result_) = signer.staticcall(
  728 |     |             abi.encodeCall(IERC1271.isValidSignature, (digest, signature))
  729 |     |         );
  730 |     | 
  731 |     |         return
  732 |     |             success_ &&
  733 |     |             result_.length >= 32 &&
  734 |     |             abi.decode(result_, (bytes32)) == bytes32(IERC1271.isValidSignature.selector);
  735 |     |     }
  736 |     | 
  737 |     |     /**
  738 |     |      * @dev    Decodes an ECDSA/secp256k1 signature from a byte array to standard v, r, and s parameters.
  739 |     |      * @param  signature A byte array ECDSA/secp256k1 signature.
  740 |     |      * @return v         An ECDSA/secp256k1 signature parameter.
  741 |     |      * @return r         An ECDSA/secp256k1 signature parameter.
  742 |     |      * @return s         An ECDSA/secp256k1 signature parameter.
  743 |     |      */
  744 |     |     function decodeECDSASignature(bytes memory signature) internal pure returns (uint8 v, bytes32 r, bytes32 s) {
  745 |     |         // ecrecover takes the signature parameters, and they can be decoded using assembly.
  746 |     |         /// @solidity memory-safe-assembly
  747 |     |         assembly {
  748 |     |             r := mload(add(signature, 0x20))
  749 |     |             s := mload(add(signature, 0x40))
  750 |     |             v := byte(0, mload(add(signature, 0x60)))
  751 |     |         }
  752 |     |     }
  753 |     | 
  754 |     |     /**
  755 |     |      * @dev    Decodes an ECDSA/secp256k1 short signature as defined by EIP2098
  756 |     |      *         from a byte array to standard v, r, and s parameters.
  757 |     |      * @param  signature A byte array ECDSA/secp256k1 short signature.
  758 |     |      * @return r         An ECDSA/secp256k1 signature parameter.
  759 |     |      * @return vs        An ECDSA/secp256k1 short signature parameter.
  760 |     |      */
  761 |     |     function decodeShortECDSASignature(bytes memory signature) internal pure returns (bytes32 r, bytes32 vs) {
  762 |     |         // ecrecover takes the signature parameters, and they can be decoded using assembly.
  763 |     |         /// @solidity memory-safe-assembly
  764 |     |         assembly {
  765 |     |             r := mload(add(signature, 0x20))
  766 |     |             vs := mload(add(signature, 0x40))
  767 |     |         }
  768 |     |     }
  769 |     | 
  770 |     |     /**
  771 |     |      * @dev    Returns whether an ECDSA/secp256k1 signature is valid for a signer and digest.
  772 |     |      * @param  signer    The address of the account purported to have signed.
  773 |     |      * @param  digest    The hash of the data that was signed.
  774 |     |      * @param  signature A byte array ECDSA/secp256k1 signature (encoded r, s, v).
  775 |     |      * @return           Whether the signature is valid or not.
  776 |     |      */
  777 |     |     function isValidECDSASignature(
  778 |     |         address signer,
  779 |     |         bytes32 digest,
  780 |     |         bytes memory signature
  781 |     |     ) internal pure returns (bool) {
  782 |     |         if (signature.length == 64) {
  783 |     |             (bytes32 r, bytes32 vs) = decodeShortECDSASignature(signature);
  784 |     |             return isValidECDSASignature(signer, digest, r, vs);
  785 |     |         }
  786 |     | 
  787 |     |         return validateECDSASignature(signer, digest, signature) == Error.NoError;
  788 |     |     }
  789 |     | 
  790 |     |     /**
  791 |     |      * @dev    Returns whether an ECDSA/secp256k1 short signature is valid for a signer and digest.
  792 |     |      * @param  signer The address of the account purported to have signed.
  793 |     |      * @param  digest The hash of the data that was signed.
  794 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
  795 |     |      * @param  vs     An ECDSA/secp256k1 short signature parameter.
  796 |     |      * @return        Whether the signature is valid or not.
  797 |     |      */
  798 |     |     function isValidECDSASignature(address signer, bytes32 digest, bytes32 r, bytes32 vs) internal pure returns (bool) {
  799 |     |         return validateECDSASignature(signer, digest, r, vs) == Error.NoError;
  800 |     |     }
  801 |     | 
  802 |     |     /**
  803 |     |      * @dev    Returns the signer of an ECDSA/secp256k1 signature for some digest.
  804 |     |      * @param  digest    The hash of the data that was signed.
  805 |     |      * @param  signature A byte array ECDSA/secp256k1 signature.
  806 |     |      * @return           An error, if any, that occurred during the signer recovery.
  807 |     |      * @return           The address of the account recovered form the signature (0 if error).
  808 |     |      */
  809 |     |     function recoverECDSASigner(bytes32 digest, bytes memory signature) internal pure returns (Error, address) {
  810 |     |         if (signature.length != 65) return (Error.InvalidSignatureLength, address(0));
  811 |     | 
  812 |     |         (uint8 v, bytes32 r, bytes32 s) = decodeECDSASignature(signature);
  813 |     | 
  814 |     |         return recoverECDSASigner(digest, v, r, s);
  815 |     |     }
  816 |     | 
  817 |     |     /**
  818 |     |      * @dev    Returns the signer of an ECDSA/secp256k1 short signature for some digest.
  819 |     |      * @dev    See https://eips.ethereum.org/EIPS/eip-2098
  820 |     |      * @param  digest The hash of the data that was signed.
  821 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
  822 |     |      * @param  vs     An ECDSA/secp256k1 short signature parameter.
  823 |     |      * @return        An error, if any, that occurred during the signer recovery.
  824 |     |      * @return        The address of the account recovered form the signature (0 if error).
  825 |     |      */
  826 |     |     function recoverECDSASigner(bytes32 digest, bytes32 r, bytes32 vs) internal pure returns (Error, address) {
  827 |     |         unchecked {
  828 |     |             // We do not check for an overflow here since the shift operation results in 0 or 1.
  829 |     |             uint8 v = uint8((uint256(vs) >> 255) + 27);
  830 |     |             bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  831 |     |             return recoverECDSASigner(digest, v, r, s);
  832 |     |         }
  833 |     |     }
  834 |     | 
  835 |     |     /**
  836 |     |      * @dev    Returns the signer of an ECDSA/secp256k1 signature for some digest.
  837 |     |      * @param  digest The hash of the data that was signed.
  838 |     |      * @param  v      An ECDSA/secp256k1 signature parameter.
  839 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
  840 |     |      * @param  s      An ECDSA/secp256k1 signature parameter.
  841 |     |      * @return        An error, if any, that occurred during the signer recovery.
  842 |     |      * @return signer The address of the account recovered form the signature (0 if error).
  843 |     |      */
  844 |     |     function recoverECDSASigner(
  845 |     |         bytes32 digest,
  846 |     |         uint8 v,
  847 |     |         bytes32 r,
  848 |     |         bytes32 s
  849 |     |     ) internal pure returns (Error, address signer) {
  850 |     |         // Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
  851 |     |         // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}.
  852 |     |         if (uint256(s) > uint256(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0))
  853 |     |             return (Error.InvalidSignatureS, address(0));
  854 |     | 
  855 |     |         if (v != 27 && v != 28) return (Error.InvalidSignatureV, address(0));
  856 |     | 
  857 |     |         signer = ecrecover(digest, v, r, s);
  858 |     | 
  859 |     |         return (signer == address(0)) ? (Error.InvalidSignature, address(0)) : (Error.NoError, signer);
  860 |     |     }
  861 |     | 
  862 |     |     /**
  863 |     |      * @dev    Returns an error, if any, in validating an ECDSA/secp256k1 signature for a signer and digest.
  864 |     |      * @param  signer    The address of the account purported to have signed.
  865 |     |      * @param  digest    The hash of the data that was signed.
  866 |     |      * @param  signature A byte array ERC1271 signature.
  867 |     |      * @return           An error, if any, that occurred during the signer recovery.
  868 |     |      */
  869 |     |     function validateECDSASignature(
  870 |     |         address signer,
  871 |     |         bytes32 digest,
  872 |     |         bytes memory signature
  873 |     |     ) internal pure returns (Error) {
  874 |     |         (Error recoverError, address recoveredSigner) = recoverECDSASigner(digest, signature);
  875 |     | 
  876 |     |         return (recoverError == Error.NoError) ? validateRecoveredSigner(signer, recoveredSigner) : recoverError;
  877 |     |     }
  878 |     | 
  879 |     |     /**
  880 |     |      * @dev    Returns an error, if any, in validating an ECDSA/secp256k1 short signature for a signer and digest.
  881 |     |      * @param  signer The address of the account purported to have signed.
  882 |     |      * @param  digest The hash of the data that was signed.
  883 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
  884 |     |      * @param  vs     An ECDSA/secp256k1 short signature parameter.
  885 |     |      * @return        An error, if any, that occurred during the signer recovery.
  886 |     |      */
  887 |     |     function validateECDSASignature(
  888 |     |         address signer,
  889 |     |         bytes32 digest,
  890 |     |         bytes32 r,
  891 |     |         bytes32 vs
  892 |     |     ) internal pure returns (Error) {
  893 |     |         (Error recoverError, address recoveredSigner) = recoverECDSASigner(digest, r, vs);
  894 |     | 
  895 |     |         return (recoverError == Error.NoError) ? validateRecoveredSigner(signer, recoveredSigner) : recoverError;
  896 |     |     }
  897 |     | 
  898 |     |     /**
  899 |     |      * @dev    Returns an error, if any, in validating an ECDSA/secp256k1 signature for a signer and digest.
  900 |     |      * @param  signer The address of the account purported to have signed.
  901 |     |      * @param  digest The hash of the data that was signed.
  902 |     |      * @param  v      An ECDSA/secp256k1 signature parameter.
  903 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
  904 |     |      * @param  s      An ECDSA/secp256k1 signature parameter.
  905 |     |      * @return        An error, if any, that occurred during the signer recovery.
  906 |     |      */
  907 |     |     function validateECDSASignature(
  908 |     |         address signer,
  909 |     |         bytes32 digest,
  910 |     |         uint8 v,
  911 |     |         bytes32 r,
  912 |     |         bytes32 s
  913 |     |     ) internal pure returns (Error) {
  914 |     |         (Error recoverError, address recoveredSigner) = recoverECDSASigner(digest, v, r, s);
  915 |     | 
  916 |     |         return (recoverError == Error.NoError) ? validateRecoveredSigner(signer, recoveredSigner) : recoverError;
  917 |     |     }
  918 |     | 
  919 |     |     /**
  920 |     |      * @dev    Returns an error if `signer` is not `recoveredSigner`.
  921 |     |      * @param  signer          The address of the some signer.
  922 |     |      * @param  recoveredSigner The address of the some recoveredSigner.
  923 |     |      * @return                 An error if `signer` is not `recoveredSigner`.
  924 |     |      */
  925 |     |     function validateRecoveredSigner(address signer, address recoveredSigner) internal pure returns (Error) {
  926 |     |         return (signer == recoveredSigner) ? Error.NoError : Error.SignerMismatch;
  927 |     |     }
  928 |     | }
  929 |     | 
  930 |     | // src/libs/TTGRegistrarReader.sol
  931 |     | 
  932 |     | /**
  933 |     |  * @title  Library to read TTG (Two Token Governance) Registrar contract parameters.
  934 |     |  * @author M^0 Labs
  935 |     |  */
  936 |     | library TTGRegistrarReader {
  937 |     |     /* ============ Variables ============ */
  938 |     | 
  939 |     |     /// @notice The name of parameter in TTG that defines the earner rate model contract.
  940 |     |     bytes32 internal constant EARNER_RATE_MODEL = "earner_rate_model";
  941 |     | 
  942 |     |     /// @notice The parameter name in TTG that defines the earners list.
  943 |     |     bytes32 internal constant EARNERS_LIST = "earners";
  944 |     | 
  945 |     |     /// @notice The parameter name in TTG that defines whether to ignore the earners list or not.
  946 |     |     bytes32 internal constant EARNERS_LIST_IGNORED = "earners_list_ignored";
  947 |     | 
  948 |     |     /// @notice The parameter name in TTG that defines the time to wait for mint request to be processed.
  949 |     |     bytes32 internal constant MINT_DELAY = "mint_delay";
  950 |     | 
  951 |     |     /// @notice The parameter name in TTG that defines the mint ratio.
  952 |     |     bytes32 internal constant MINT_RATIO = "mint_ratio"; // bps
  953 |     | 
  954 |     |     /// @notice The parameter name in TTG that defines the time while mint request can still be processed.
  955 |     |     bytes32 internal constant MINT_TTL = "mint_ttl";
  956 |     | 
  957 |     |     /// @notice The parameter name in TTG that defines the time to freeze minter.
  958 |     |     bytes32 internal constant MINTER_FREEZE_TIME = "minter_freeze_time";
  959 |     | 
  960 |     |     /// @notice The parameter name in TTG that defines the minter rate model contract.
  961 |     |     bytes32 internal constant MINTER_RATE_MODEL = "minter_rate_model";
  962 |     | 
  963 |     |     /// @notice The parameter name in TTG that defines the minters list.
  964 |     |     bytes32 internal constant MINTERS_LIST = "minters";
  965 |     | 
  966 |     |     /// @notice The parameter name in TTG that defines the penalty rate.
  967 |     |     bytes32 internal constant PENALTY_RATE = "penalty_rate"; // bps
  968 |     | 
  969 |     |     /// @notice The parameter name in TTG that defines the required interval to update collateral.
  970 |     |     bytes32 internal constant UPDATE_COLLATERAL_INTERVAL = "update_collateral_interval";
  971 |     | 
  972 |     |     /// @notice The parameter name that defines number of signatures required for successful collateral update.
  973 |     |     bytes32 internal constant UPDATE_COLLATERAL_VALIDATOR_THRESHOLD = "update_collateral_threshold";
  974 |     | 
  975 |     |     /// @notice The parameter name in TTG that defines the validators list.
  976 |     |     bytes32 internal constant VALIDATORS_LIST = "validators";
  977 |     | 
  978 |     |     /* ============ Internal View/Pure Functions ============ */
  979 |     | 
  980 |     |     /// @notice Gets the earner rate model contract address.
  981 |     |     function getEarnerRateModel(address registrar_) internal view returns (address) {
  982 |     |         return toAddress(_get(registrar_, EARNER_RATE_MODEL));
  983 |     |     }
  984 |     | 
  985 |     |     /// @notice Gets the mint delay.
  986 | *   |     function getMintDelay(address registrar_) internal view returns (uint256) {
  987 | *   |         return uint256(_get(registrar_, MINT_DELAY));
  988 |     |     }
  989 |     | 
  990 |     |     /// @notice Gets the minter freeze time.
  991 |     |     function getMinterFreezeTime(address registrar_) internal view returns (uint256) {
  992 |     |         return uint256(_get(registrar_, MINTER_FREEZE_TIME));
  993 |     |     }
  994 |     | 
  995 |     |     /// @notice Gets the minter rate model contract address.
  996 | *   |     function getMinterRateModel(address registrar_) internal view returns (address) {
  997 | *   |         return toAddress(_get(registrar_, MINTER_RATE_MODEL));
  998 |     |     }
  999 |     | 
 1000 |     |     /// @notice Gets the mint TTL.
 1001 | *   |     function getMintTTL(address registrar_) internal view returns (uint256) {
 1002 | *   |         return uint256(_get(registrar_, MINT_TTL));
 1003 |     |     }
 1004 |     | 
 1005 |     |     /// @notice Gets the mint ratio.
 1006 | *   |     function getMintRatio(address registrar_) internal view returns (uint256) {
 1007 | *   |         return uint256(_get(registrar_, MINT_RATIO));
 1008 |     |     }
 1009 |     | 
 1010 |     |     /// @notice Gets the update collateral interval.
 1011 | *   |     function getUpdateCollateralInterval(address registrar_) internal view returns (uint256) {
 1012 | *   |         return uint256(_get(registrar_, UPDATE_COLLATERAL_INTERVAL));
 1013 |     |     }
 1014 |     | 
 1015 |     |     /// @notice Gets the update collateral validator threshold.
 1016 |     |     function getUpdateCollateralValidatorThreshold(address registrar_) internal view returns (uint256) {
 1017 |     |         return uint256(_get(registrar_, UPDATE_COLLATERAL_VALIDATOR_THRESHOLD));
 1018 |     |     }
 1019 |     | 
 1020 |     |     /// @notice Checks if the given earner is approved.
 1021 |     |     function isApprovedEarner(address registrar_, address earner_) internal view returns (bool) {
 1022 |     |         return _contains(registrar_, EARNERS_LIST, earner_);
 1023 |     |     }
 1024 |     | 
 1025 |     |     /// @notice Checks if the `earners_list_ignored` exists.
 1026 |     |     function isEarnersListIgnored(address registrar_) internal view returns (bool) {
 1027 |     |         return _get(registrar_, EARNERS_LIST_IGNORED) != bytes32(0);
 1028 |     |     }
 1029 |     | 
 1030 |     |     /// @notice Checks if the given minter is approved.
 1031 | *   |     function isApprovedMinter(address registrar_, address minter_) internal view returns (bool) {
 1032 | *   |         return _contains(registrar_, MINTERS_LIST, minter_);
 1033 |     |     }
 1034 |     | 
 1035 |     |     /// @notice Checks if the given validator is approved.
 1036 |     |     function isApprovedValidator(address registrar_, address validator_) internal view returns (bool) {
 1037 |     |         return _contains(registrar_, VALIDATORS_LIST, validator_);
 1038 |     |     }
 1039 |     | 
 1040 |     |     /// @notice Gets the penalty rate.
 1041 |     |     function getPenaltyRate(address registrar_) internal view returns (uint256) {
 1042 |     |         return uint256(_get(registrar_, PENALTY_RATE));
 1043 |     |     }
 1044 |     | 
 1045 |     |     /// @notice Gets the vault contract address.
 1046 | *   |     function getVault(address registrar_) internal view returns (address) {
 1047 | *   |         return ITTGRegistrar(registrar_).vault();
 1048 |     |     }
 1049 |     | 
 1050 |     |     /// @notice Converts given bytes32 to address.
 1051 | *   |     function toAddress(bytes32 input_) internal pure returns (address) {
 1052 | *   |         return address(uint160(uint256(input_)));
 1053 |     |     }
 1054 |     | 
 1055 |     |     /// @notice Checks if the given list contains the given account.
 1056 | *   |     function _contains(address registrar_, bytes32 listName_, address account_) private view returns (bool) {
 1057 | *   |         return ITTGRegistrar(registrar_).listContains(listName_, account_);
 1058 |     |     }
 1059 |     | 
 1060 |     |     /// @notice Gets the value of the given key.
 1061 | *   |     function _get(address registrar_, bytes32 key_) private view returns (bytes32) {
 1062 | *   |         return ITTGRegistrar(registrar_).get(key_);
 1063 |     |     }
 1064 |     | }
 1065 |     | 
 1066 |     | // src/interfaces/IMinterGateway.sol
 1067 |     | 
 1068 |     | /**
 1069 |     |  * @title  Minter Gateway Interface.
 1070 |     |  * @author M^0 Labs
 1071 |     |  */
 1072 |     | interface IMinterGateway is IContinuousIndexing, IERC712 {
 1073 |     |     /* ============ Events ============ */
 1074 |     | 
 1075 |     |     /**
 1076 |     |      * @notice Emitted when M tokens are burned and an inactive minter's owed M balance decreased.
 1077 |     |      * @param  minter The address of the minter.
 1078 |     |      * @param  amount The amount of M tokens burned.
 1079 |     |      * @param  payer  The address of the payer.
 1080 |     |      */
 1081 |     |     event BurnExecuted(address indexed minter, uint240 amount, address indexed payer);
 1082 |     | 
 1083 |     |     /**
 1084 |     |      * @notice Emitted when M tokens are burned and an active minter's owed M balance decreased.
 1085 |     |      * @param  minter          The address of the minter.
 1086 |     |      * @param  principalAmount The principal amount of M tokens burned.
 1087 |     |      * @param  amount          The amount of M tokens burned.
 1088 |     |      * @param  payer           The address of the payer.
 1089 |     |      */
 1090 |     |     event BurnExecuted(address indexed minter, uint112 principalAmount, uint240 amount, address indexed payer);
 1091 |     | 
 1092 |     |     /**
 1093 |     |      * @notice Emitted when a minter's collateral is updated.
 1094 |     |      * @param  minter                           Address of the minter
 1095 |     |      * @param  collateral                       The latest amount of collateral
 1096 |     |      * @param  totalResolvedCollateralRetrieval The total collateral amount of outstanding retrievals resolved.
 1097 |     |      * @param  metadataHash                     The hash of some metadata reserved for future informational use.
 1098 |     |      * @param  timestamp                        The timestamp of the collateral update,
 1099 |     |      *                                          minimum of given validators' signatures.
 1100 |     |      */
 1101 |     |     event CollateralUpdated(
 1102 |     |         address indexed minter,
 1103 |     |         uint240 collateral,
 1104 |     |         uint240 totalResolvedCollateralRetrieval,
 1105 |     |         bytes32 indexed metadataHash,
 1106 |     |         uint40 timestamp
 1107 |     |     );
 1108 |     | 
 1109 |     |     /**
 1110 |     |      * @notice Emitted when a minter is activated.
 1111 |     |      * @param  minter Address of the minter that was activated
 1112 |     |      * @param  caller Address who called the function
 1113 |     |      */
 1114 |     |     event MinterActivated(address indexed minter, address indexed caller);
 1115 |     | 
 1116 |     |     /**
 1117 |     |      * @notice Emitted when a minter is deactivated.
 1118 |     |      * @param  minter        Address of the minter that was deactivated.
 1119 |     |      * @param  inactiveOwedM Amount of M tokens owed by the minter (in an inactive state).
 1120 |     |      * @param  caller        Address who called the function.
 1121 |     |      */
 1122 |     |     event MinterDeactivated(address indexed minter, uint240 inactiveOwedM, address indexed caller);
 1123 |     | 
 1124 |     |     /**
 1125 |     |      * @notice Emitted when a minter is frozen.
 1126 |     |      * @param  minter      Address of the minter that was frozen
 1127 |     |      * @param  frozenUntil Timestamp until the minter is frozen
 1128 |     |      */
 1129 |     |     event MinterFrozen(address indexed minter, uint40 frozenUntil);
 1130 |     | 
 1131 |     |     /**
 1132 |     |      * @notice Emitted when a mint proposal is canceled.
 1133 |     |      * @param  mintId    The id of the canceled mint proposal.
 1134 |     |      * @param  minter    The address of the minter for which the mint was canceled.
 1135 |     |      * @param  canceller The address of the validator who canceled the mint proposal.
 1136 |     |      */
 1137 |     |     event MintCanceled(uint48 indexed mintId, address indexed minter, address indexed canceller);
 1138 |     | 
 1139 |     |     /**
 1140 |     |      * @notice Emitted when a mint proposal is executed.
 1141 |     |      * @param  mintId          The id of the executed mint proposal.
 1142 |     |      * @param  minter          The address of the minter that executed the mint.
 1143 |     |      * @param  principalAmount The principal amount of M tokens minted.
 1144 |     |      * @param  amount          The amount of M tokens minted.
 1145 |     |      */
 1146 |     |     event MintExecuted(uint48 indexed mintId, address indexed minter, uint112 principalAmount, uint240 amount);
 1147 |     | 
 1148 |     |     /**
 1149 |     |      * @notice Emitted when a mint proposal is created.
 1150 |     |      * @param  mintId      The id of mint proposal.
 1151 |     |      * @param  minter      The address of the minter that proposed the mint.
 1152 |     |      * @param  amount      The amount of M tokens to mint.
 1153 |     |      * @param  destination The address to mint to.
 1154 |     |      */
 1155 |     |     event MintProposed(uint48 indexed mintId, address indexed minter, uint240 amount, address indexed destination);
 1156 |     | 
 1157 |     |     /**
 1158 |     |      * @notice Emitted when a penalty is imposed on `minter` for missed update collateral intervals.
 1159 |     |      * @param  minter          The address of the minter.
 1160 |     |      * @param  missedIntervals The number of update intervals missed.
 1161 |     |      * @param  penaltyAmount   The present amount of penalty charge.
 1162 |     |      */
 1163 |     |     event MissedIntervalsPenaltyImposed(address indexed minter, uint40 missedIntervals, uint240 penaltyAmount);
 1164 |     | 
 1165 |     |     /**
 1166 |     |      * @notice Emitted when a penalty is imposed on `minter` for undercollateralization.
 1167 |     |      * @param  minter        The address of the minter.
 1168 |     |      * @param  excessOwedM   The present amount of owed M in excess of allowed owed M.
 1169 |     |      * @param  timeSpan      The span of time over which the undercollateralization penalty was applied.
 1170 |     |      * @param  penaltyAmount The present amount of penalty charge.
 1171 |     |      */
 1172 |     |     event UndercollateralizedPenaltyImposed(
 1173 |     |         address indexed minter,
 1174 |     |         uint240 excessOwedM,
 1175 |     |         uint40 timeSpan,
 1176 |     |         uint240 penaltyAmount
 1177 |     |     );
 1178 |     | 
 1179 |     |     /**
 1180 |     |      * @notice Emitted when a collateral retrieval proposal is created.
 1181 |     |      * @param  retrievalId The id of retrieval proposal.
 1182 |     |      * @param  minter      The address of the minter.
 1183 |     |      * @param  amount      The amount of collateral to retrieve.
 1184 |     |      */
 1185 |     |     event RetrievalCreated(uint48 indexed retrievalId, address indexed minter, uint240 amount);
 1186 |     | 
 1187 |     |     /**
 1188 |     |      * @notice Emitted when a collateral retrieval proposal is resolved.
 1189 |     |      * @param  retrievalId The id of retrieval proposal.
 1190 |     |      * @param  minter      The address of the minter.
 1191 |     |      */
 1192 |     |     event RetrievalResolved(uint48 indexed retrievalId, address indexed minter);
 1193 |     | 
 1194 |     |     /* ============ Custom Errors ============ */
 1195 |     | 
 1196 |     |     /// @notice Emitted when calling `activateMinter` with a minter who was previously deactivated.
 1197 |     |     error DeactivatedMinter();
 1198 |     | 
 1199 |     |     /// @notice Emitted when repay will burn more M than the repay specified.
 1200 |     |     error ExceedsMaxRepayAmount(uint240 amount, uint240 maxAmount);
 1201 |     | 
 1202 |     |     /// @notice Emitted when calling `mintM` with a proposal that was created more than `mintDelay + mintTTL` time ago.
 1203 |     |     error ExpiredMintProposal(uint40 deadline);
 1204 |     | 
 1205 |     |     /// @notice Emitted when calling `mintM` or `proposeMint` by a minter who was frozen by validator.
 1206 |     |     error FrozenMinter();
 1207 |     | 
 1208 |     |     /// @notice Emitted when calling `updateCollateral` with any validator timestamp in the future.
 1209 |     |     error FutureTimestamp();
 1210 |     | 
 1211 |     |     /// @notice Emitted when calling a function only allowed for active minters.
 1212 |     |     error InactiveMinter();
 1213 |     | 
 1214 |     |     /// @notice Emitted when calling `cancelMint` or `mintM` with invalid `mintId`.
 1215 |     |     error InvalidMintProposal();
 1216 |     | 
 1217 |     |     /// @notice Emitted when calling `updateCollateral` if `validators` addresses are not ordered in ascending order.
 1218 |     |     error InvalidSignatureOrder();
 1219 |     | 
 1220 |     |     /// @notice Emitted when calling `activateMinter` if minter was not approved by TTG.
 1221 |     |     error NotApprovedMinter();
 1222 |     | 
 1223 |     |     /// @notice Emitted when calling `cancelMint` or `freezeMinter` if `validator` was not approved by TTG.
 1224 |     |     error NotApprovedValidator(address validator);
 1225 |     | 
 1226 |     |     /// @notice Emitted when calling `updateCollateral` if `validatorThreshold` of signatures was not reached.
 1227 |     |     error NotEnoughValidSignatures(uint256 validSignatures, uint256 requiredThreshold);
 1228 |     | 
 1229 |     |     /// @notice Emitted when principal of total owed M (active and inactive) will overflow a `type(uint112).max`.
 1230 |     |     error OverflowsPrincipalOfTotalOwedM();
 1231 |     | 
 1232 |     |     /// @notice Emitted when calling `mintM` if `mintDelay` time has not passed yet.
 1233 |     |     error PendingMintProposal(uint40 activeTimestamp);
 1234 |     | 
 1235 |     |     /// @notice Emitted when calling `proposeRetrieval` if sum of all outstanding retrievals
 1236 |     |     ///         Plus new proposed retrieval amount is greater than collateral.
 1237 |     |     error RetrievalsExceedCollateral(uint240 totalPendingRetrievals, uint240 collateral);
 1238 |     | 
 1239 |     |     /// @notice Emitted when calling `updateCollateral`
 1240 |     |     ///         If `validators`, `signatures`, `timestamps` lengths do not match.
 1241 |     |     error SignatureArrayLengthsMismatch();
 1242 |     | 
 1243 |     |     /// @notice Emitted when updating collateral with a timestamp earlier than allowed.
 1244 |     |     error StaleCollateralUpdate(uint40 newTimestamp, uint40 earliestAllowedTimestamp);
 1245 |     | 
 1246 |     |     /// @notice Emitted when calling `updateCollateral` with any validator timestamp older than the last signature
 1247 |     |     ///         timestamp for that minter and validator.
 1248 |     |     error OutdatedValidatorTimestamp(address validator, uint256 timestamp, uint256 lastSignatureTimestamp);
 1249 |     | 
 1250 |     |     /// @notice Emitted when calling `deactivateMinter` with a minter still approved in TTG Registrar.
 1251 |     |     error StillApprovedMinter();
 1252 |     | 
 1253 |     |     /**
 1254 |     |      * @notice Emitted when calling `proposeMint`, `mintM`, `proposeRetrieval`
 1255 |     |      *         If minter position becomes undercollateralized.
 1256 |     |      * @dev    `activeOwedM` is a `uint256` because it may represent some resulting owed M from computations.
 1257 |     |      */
 1258 |     |     error Undercollateralized(uint256 activeOwedM, uint256 maxAllowedOwedM);
 1259 |     | 
 1260 |     |     /// @notice Emitted when calling `burnM` if amount is 0.
 1261 |     |     error ZeroBurnAmount();
 1262 |     | 
 1263 |     |     /// @notice Emitted in constructor if M Token is 0x0.
 1264 |     |     error ZeroMToken();
 1265 |     | 
 1266 |     |     /// @notice Emitted when calling `proposeMint` if amount is 0.
 1267 |     |     error ZeroMintAmount();
 1268 |     | 
 1269 |     |     /// @notice Emitted when calling `proposeMint` if destination is 0x0.
 1270 |     |     error ZeroMintDestination();
 1271 |     | 
 1272 |     |     /// @notice Emitted when calling `proposeRetrieval` if collateral is 0.
 1273 |     |     error ZeroRetrievalAmount();
 1274 |     | 
 1275 |     |     /// @notice Emitted in constructor if TTG Registrar is 0x0.
 1276 |     |     error ZeroTTGRegistrar();
 1277 |     | 
 1278 |     |     /// @notice Emitted in constructor if TTG Distribution Vault is set to 0x0 in TTG Registrar.
 1279 |     |     error ZeroTTGVault();
 1280 |     | 
 1281 |     |     /// @notice Emitted when calling `updateCollateral` with any validator timestamp of 0.
 1282 |     |     error ZeroTimestamp();
 1283 |     | 
 1284 |     |     /* ============ Interactive Functions ============ */
 1285 |     | 
 1286 |     |     /**
 1287 |     |      * @notice Updates collateral for minters
 1288 |     |      * @param  collateral   The amount of collateral
 1289 |     |      * @param  retrievalIds The list of active proposeRetrieval requests to close
 1290 |     |      * @param  metadataHash The hash of metadata of the collateral update, reserved for future informational use
 1291 |     |      * @param  validators   The list of validators
 1292 |     |      * @param  timestamps   The list of timestamps of validators' signatures
 1293 |     |      * @param  signatures   The list of signatures
 1294 |     |      * @return minTimestamp The minimum timestamp of all validators' signatures
 1295 |     |      */
 1296 |     |     function updateCollateral(
 1297 |     |         uint256 collateral,
 1298 |     |         uint256[] calldata retrievalIds,
 1299 |     |         bytes32 metadataHash,
 1300 |     |         address[] calldata validators,
 1301 |     |         uint256[] calldata timestamps,
 1302 |     |         bytes[] calldata signatures
 1303 |     |     ) external returns (uint40 minTimestamp);
 1304 |     | 
 1305 |     |     /**
 1306 |     |      * @notice Proposes retrieval of minter's off-chain collateral
 1307 |     |      * @param  collateral  The amount of collateral to retrieve
 1308 |     |      * @return retrievalId The unique id of created retrieval proposal
 1309 |     |      */
 1310 |     |     function proposeRetrieval(uint256 collateral) external returns (uint48 retrievalId);
 1311 |     | 
 1312 |     |     /**
 1313 |     |      * @notice Proposes minting of M tokens
 1314 |     |      * @param  amount      The amount of M tokens to mint
 1315 |     |      * @param  destination The address to mint to
 1316 |     |      * @return mintId      The unique id of created mint proposal
 1317 |     |      */
 1318 |     |     function proposeMint(uint256 amount, address destination) external returns (uint48 mintId);
 1319 |     | 
 1320 |     |     /**
 1321 |     |      * @notice Executes minting of M tokens
 1322 |     |      * @param  mintId          The id of outstanding mint proposal for minter
 1323 |     |      * @return principalAmount The amount of principal of owed M minted.
 1324 |     |      * @return amount          The amount of M tokens minted.
 1325 |     |      */
 1326 |     |     function mintM(uint256 mintId) external returns (uint112 principalAmount, uint240 amount);
 1327 |     | 
 1328 |     |     /**
 1329 |     |      * @notice Burns M tokens
 1330 |     |      * @dev    If amount to burn is greater than minter's owedM including penalties, burn all up to owedM.
 1331 |     |      * @param  minter          The address of the minter to burn M tokens for.
 1332 |     |      * @param  maxAmount       The max amount of M tokens to burn.
 1333 |     |      * @return principalAmount The amount of principal of owed M burned.
 1334 |     |      * @return amount          The amount of M tokens burned.
 1335 |     |      */
 1336 |     |     function burnM(address minter, uint256 maxAmount) external returns (uint112 principalAmount, uint240 amount);
 1337 |     | 
 1338 |     |     /**
 1339 |     |      * @notice Burns M tokens
 1340 |     |      * @dev    If amount to burn is greater than minter's owedM including penalties, burn all up to owedM.
 1341 |     |      * @param  minter             The address of the minter to burn M tokens for.
 1342 |     |      * @param  maxPrincipalAmount The max amount of principal of owed M to burn.
 1343 |     |      * @param  maxAmount          The max amount of M tokens to burn.
 1344 |     |      * @return principalAmount    The amount of principal of owed M burned.
 1345 |     |      * @return amount             The amount of M tokens burned.
 1346 |     |      */
 1347 |     |     function burnM(
 1348 |     |         address minter,
 1349 |     |         uint256 maxPrincipalAmount,
 1350 |     |         uint256 maxAmount
 1351 |     |     ) external returns (uint112 principalAmount, uint240 amount);
 1352 |     | 
 1353 |     |     /**
 1354 |     |      * @notice Cancels minting request for selected minter by validator
 1355 |     |      * @param  minter The address of the minter to cancelMint minting request for
 1356 |     |      * @param  mintId The id of outstanding mint request
 1357 |     |      */
 1358 |     |     function cancelMint(address minter, uint256 mintId) external;
 1359 |     | 
 1360 |     |     /**
 1361 |     |      * @notice Freezes minter
 1362 |     |      * @param  minter      The address of the minter to freeze
 1363 |     |      * @return frozenUntil The timestamp until which minter is frozen
 1364 |     |      */
 1365 |     |     function freezeMinter(address minter) external returns (uint40 frozenUntil);
 1366 |     | 
 1367 |     |     /**
 1368 |     |      * @notice Activate an approved minter.
 1369 |     |      * @dev    MUST revert if `minter` is not recorded as an approved minter in TTG Registrar.
 1370 |     |      * @dev    MUST revert if `minter` has been deactivated.
 1371 |     |      * @param  minter The address of the minter to activate
 1372 |     |      */
 1373 |     |     function activateMinter(address minter) external;
 1374 |     | 
 1375 |     |     /**
 1376 |     |      * @notice Deactivates an active minter.
 1377 |     |      * @dev    MUST revert if the minter is still approved.
 1378 |     |      * @dev    MUST revert if the minter is not active.
 1379 |     |      * @param  minter        The address of the minter to deactivate.
 1380 |     |      * @return inactiveOwedM The inactive owed M for the deactivated minter.
 1381 |     |      */
 1382 |     |     function deactivateMinter(address minter) external returns (uint240 inactiveOwedM);
 1383 |     | 
 1384 |     |     /* ============ View/Pure Functions ============ */
 1385 |     | 
 1386 |     |     /// @notice The address of M token
 1387 |     |     function mToken() external view returns (address);
 1388 |     | 
 1389 |     |     /// @notice The address of TTG Registrar contract.
 1390 |     |     function ttgRegistrar() external view returns (address);
 1391 |     | 
 1392 |     |     /// @notice The address of TTG Vault contract.
 1393 |     |     function ttgVault() external view returns (address);
 1394 |     | 
 1395 |     |     /// @notice The last saved value of Minter rate.
 1396 |     |     function minterRate() external view returns (uint32);
 1397 |     | 
 1398 |     |     /// @notice The principal of total owed M for all active minters.
 1399 |     |     function principalOfTotalActiveOwedM() external view returns (uint112);
 1400 |     | 
 1401 |     |     /// @notice The total owed M for all active minters.
 1402 |     |     function totalActiveOwedM() external view returns (uint240);
 1403 |     | 
 1404 |     |     /// @notice The total owed M for all inactive minters.
 1405 |     |     function totalInactiveOwedM() external view returns (uint240);
 1406 |     | 
 1407 |     |     /// @notice The total owed M for all minters.
 1408 |     |     function totalOwedM() external view returns (uint240);
 1409 |     | 
 1410 |     |     /// @notice The difference between total owed M and M token total supply.
 1411 |     |     function excessOwedM() external view returns (uint240);
 1412 |     | 
 1413 |     |     /// @notice The principal of active owed M of minter.
 1414 |     |     function principalOfActiveOwedMOf(address minter_) external view returns (uint112);
 1415 |     | 
 1416 |     |     /// @notice The active owed M of minter.
 1417 |     |     function activeOwedMOf(address minter) external view returns (uint240);
 1418 |     | 
 1419 |     |     /**
 1420 |     |      * @notice The max allowed active owed M of minter taking into account collateral amount and retrieval proposals.
 1421 |     |      * @dev    This is the only present value that requires a `uint256` since it is the result of a multiplication
 1422 |     |      *         between a `uint240` and a value that has a max of `65,000` (the mint ratio).
 1423 |     |      */
 1424 |     |     function maxAllowedActiveOwedMOf(address minter) external view returns (uint256);
 1425 |     | 
 1426 |     |     /// @notice The inactive owed M of deactivated minter.
 1427 |     |     function inactiveOwedMOf(address minter) external view returns (uint240);
 1428 |     | 
 1429 |     |     /// @notice The collateral of a given minter.
 1430 |     |     function collateralOf(address minter) external view returns (uint240);
 1431 |     | 
 1432 |     |     /// @notice The timestamp of the last collateral update of minter.
 1433 |     |     function collateralUpdateTimestampOf(address minter) external view returns (uint40);
 1434 |     | 
 1435 |     |     /// @notice The timestamp after which an additional penalty for a missed update interval will be charged.
 1436 |     |     function collateralPenaltyDeadlineOf(address minter) external view returns (uint40);
 1437 |     | 
 1438 |     |     /// @notice The timestamp after which the minter's collateral is assumed to be 0 due to a missed update.
 1439 |     |     function collateralExpiryTimestampOf(address minter) external view returns (uint40);
 1440 |     | 
 1441 |     |     /// @notice The timestamp until which minter is already penalized for missed collateral updates.
 1442 |     |     function penalizedUntilOf(address minter) external view returns (uint40);
 1443 |     | 
 1444 |     |     /// @notice The timestamp when `minter` created their latest retrieval proposal.
 1445 |     |     function latestProposedRetrievalTimestampOf(address minter) external view returns (uint40);
 1446 |     | 
 1447 |     |     /**
 1448 |     |      * @notice Returns the last signature timestamp used by `validator` to update collateral for `minter`.
 1449 |     |      * @param  minter    The address of the minter.
 1450 |     |      * @param  validator The address of the validator.
 1451 |     |      * @return The last signature timestamp used.
 1452 |     |      */
 1453 |     |     function getLastSignatureTimestamp(address minter, address validator) external view returns (uint256);
 1454 |     | 
 1455 |     |     /**
 1456 |     |      * @notice Returns the EIP-712 digest for updateCollateral method.
 1457 |     |      * @param  minter       The address of the minter.
 1458 |     |      * @param  collateral   The amount of collateral.
 1459 |     |      * @param  retrievalIds The list of outstanding collateral retrieval IDs to resolve.
 1460 |     |      * @param  metadataHash The hash of metadata of the collateral update, reserved for future informational use.
 1461 |     |      * @param  timestamp    The timestamp of the collateral update.
 1462 |     |      */
 1463 |     |     function getUpdateCollateralDigest(
 1464 |     |         address minter,
 1465 |     |         uint256 collateral,
 1466 |     |         uint256[] calldata retrievalIds,
 1467 |     |         bytes32 metadataHash,
 1468 |     |         uint256 timestamp
 1469 |     |     ) external view returns (bytes32);
 1470 |     | 
 1471 |     |     /// @notice The mint proposal of minters, only 1 active proposal per minter
 1472 |     |     function mintProposalOf(
 1473 |     |         address minter
 1474 |     |     ) external view returns (uint48 mintId, uint40 createdAt, address destination, uint240 amount);
 1475 |     | 
 1476 |     |     /// @notice The amount of a pending retrieval request for an active minter.
 1477 |     |     function pendingCollateralRetrievalOf(address minter, uint256 retrievalId) external view returns (uint240);
 1478 |     | 
 1479 |     |     /// @notice The total amount of pending retrieval requests for an active minter.
 1480 |     |     function totalPendingCollateralRetrievalOf(address minter) external view returns (uint240);
 1481 |     | 
 1482 |     |     /// @notice The timestamp when minter becomes unfrozen after being frozen by validator.
 1483 |     |     function frozenUntilOf(address minter) external view returns (uint40);
 1484 |     | 
 1485 |     |     /// @notice Checks if minter was activated after approval by TTG
 1486 |     |     function isActiveMinter(address minter) external view returns (bool);
 1487 |     | 
 1488 |     |     /// @notice Checks if minter was deactivated after removal by TTG
 1489 |     |     function isDeactivatedMinter(address minter) external view returns (bool);
 1490 |     | 
 1491 |     |     /// @notice Checks if minter was frozen by validator
 1492 |     |     function isFrozenMinter(address minter) external view returns (bool);
 1493 |     | 
 1494 |     |     /// @notice Checks if minter was approved by TTG
 1495 |     |     function isMinterApproved(address minter) external view returns (bool);
 1496 |     | 
 1497 |     |     /// @notice Checks if validator was approved by TTG
 1498 |     |     function isValidatorApproved(address validator) external view returns (bool);
 1499 |     | 
 1500 |     |     /// @notice The delay between mint proposal creation and its earliest execution.
 1501 |     |     function mintDelay() external view returns (uint32);
 1502 |     | 
 1503 |     |     /// @notice The time while mint request can still be processed before it is considered expired.
 1504 |     |     function mintTTL() external view returns (uint32);
 1505 |     | 
 1506 |     |     /// @notice The freeze time for minter.
 1507 |     |     function minterFreezeTime() external view returns (uint32);
 1508 |     | 
 1509 |     |     /// @notice The allowed activeOwedM to collateral ratio.
 1510 |     |     function mintRatio() external view returns (uint32);
 1511 |     | 
 1512 |     |     /// @notice The % that defines penalty amount for missed collateral updates or excessive owedM value
 1513 |     |     function penaltyRate() external view returns (uint32);
 1514 |     | 
 1515 |     |     /// @notice The smart contract that defines the minter rate.
 1516 |     |     function rateModel() external view returns (address);
 1517 |     | 
 1518 |     |     /// @notice The interval that defines the required frequency of collateral updates.
 1519 |     |     function updateCollateralInterval() external view returns (uint32);
 1520 |     | 
 1521 |     |     /// @notice The number of signatures required for successful collateral update.
 1522 |     |     function updateCollateralValidatorThreshold() external view returns (uint256);
 1523 |     | 
 1524 |     |     /// @notice Descaler for variables in basis points. Effectively, 100% in basis points.
 1525 |     |     function ONE() external pure returns (uint16);
 1526 |     | 
 1527 |     |     /// @notice Mint ratio cap. 650% in basis points.
 1528 |     |     function MAX_MINT_RATIO() external pure returns (uint32);
 1529 |     | 
 1530 |     |     /// @notice Update collateral interval lower cap in seconds.
 1531 |     |     function MIN_UPDATE_COLLATERAL_INTERVAL() external pure returns (uint32);
 1532 |     | 
 1533 |     |     /// @notice The EIP-712 typehash for the `updateCollateral` method.
 1534 |     |     function UPDATE_COLLATERAL_TYPEHASH() external pure returns (bytes32);
 1535 |     | }
 1536 |     | 
 1537 |     | // lib/common/src/interfaces/IStatefulERC712.sol
 1538 |     | 
 1539 |     | /**
 1540 |     |  * @title  Stateful Extension for EIP-712 typed structured data hashing and signing with nonces.
 1541 |     |  * @author M^0 Labs
 1542 |     |  */
 1543 |     | interface IStatefulERC712 is IERC712Extended {
 1544 |     |     /* ============ Custom Errors ============ */
 1545 |     | 
 1546 |     |     /**
 1547 |     |      * @notice Revert message when a signing account's nonce is not the expected current nonce.
 1548 |     |      * @param  nonce         The nonce used in the signature.
 1549 |     |      * @param  expectedNonce The expected nonce to be used in a signature by the signing account.
 1550 |     |      */
 1551 |     |     error InvalidAccountNonce(uint256 nonce, uint256 expectedNonce);
 1552 |     | 
 1553 |     |     /* ============ View/Pure Functions ============ */
 1554 |     | 
 1555 |     |     /**
 1556 |     |      * @notice Returns the next nonce to be used in a signature by `account`.
 1557 |     |      * @param  account The address of some account.
 1558 |     |      * @return nonce   The next nonce to be used in a signature by `account`.
 1559 |     |      */
 1560 |     |     function nonces(address account) external view returns (uint256 nonce);
 1561 |     | }
 1562 |     | 
 1563 |     | // src/abstract/ContinuousIndexing.sol
 1564 |     | 
 1565 |     | /**
 1566 |     |  * @title Abstract Continuous Indexing Contract to handle rate/index updates in inheriting contracts.
 1567 |     |  * @author M^0 Labs
 1568 |     |  */
 1569 |     | abstract contract ContinuousIndexing is IContinuousIndexing {
 1570 |     |     /* ============ Variables ============ */
 1571 |     | 
 1572 |     |     /// @inheritdoc IContinuousIndexing
 1573 |     |     uint128 public latestIndex;
 1574 |     | 
 1575 |     |     /// @dev The latest updated rate.
 1576 |     |     uint32 internal _latestRate;
 1577 |     | 
 1578 |     |     /// @inheritdoc IContinuousIndexing
 1579 |     |     uint40 public latestUpdateTimestamp;
 1580 |     | 
 1581 |     |     /* ============ Constructor ============ */
 1582 |     | 
 1583 |     |     /// @notice Constructs the ContinuousIndexing contract.
 1584 |     |     constructor() {
 1585 | *   |         latestIndex = ContinuousIndexingMath.EXP_SCALED_ONE;
 1586 | *   |         latestUpdateTimestamp = uint40(block.timestamp);
 1587 |     |     }
 1588 |     | 
 1589 |     |     /* ============ Interactive Functions ============ */
 1590 |     | 
 1591 |     |     /// @inheritdoc IContinuousIndexing
 1592 | *   |     function updateIndex() public virtual returns (uint128 currentIndex_) {
 1593 |     |         // NOTE: `_rate()` can depend indirectly on `latestIndex` and `latestUpdateTimestamp`, if the RateModel
 1594 |     |         //       depends on earning balances/supply, which depends on `currentIndex()`, so only update them after this.
 1595 | *   |         uint32 rate_ = _rate();
 1596 |     | 
 1597 | *   |         if (latestUpdateTimestamp == block.timestamp && _latestRate == rate_) return latestIndex;
 1598 |     | 
 1599 |     |         // NOTE: `currentIndex()` depends on `_latestRate`, so only update it after this.
 1600 | *   |         latestIndex = currentIndex_ = currentIndex();
 1601 | *   |         _latestRate = rate_;
 1602 | *   |         latestUpdateTimestamp = uint40(block.timestamp);
 1603 |     | 
 1604 | *   |         emit IndexUpdated(currentIndex_, rate_);
 1605 |     |     }
 1606 |     | 
 1607 |     |     /* ============ View/Pure Functions ============ */
 1608 |     | 
 1609 |     |     /// @inheritdoc IContinuousIndexing
 1610 |     |     function currentIndex() public view virtual returns (uint128);
 1611 |     | 
 1612 |     |     /* ============ Internal View/Pure Functions ============ */
 1613 |     | 
 1614 |     |     /**
 1615 |     |      * @dev    Returns the principal amount (rounded down) given the present amount, using the current index.
 1616 |     |      * @param  presentAmount_ The present amount.
 1617 |     |      * @return The principal amount rounded down.
 1618 |     |      */
 1619 |     |     function _getPrincipalAmountRoundedDown(uint240 presentAmount_) internal view returns (uint112) {
 1620 |     |         return _getPrincipalAmountRoundedDown(presentAmount_, currentIndex());
 1621 |     |     }
 1622 |     | 
 1623 |     |     /**
 1624 |     |      * @dev    Returns the principal amount (rounded up) given the present amount and an index.
 1625 |     |      * @param  presentAmount_ The present amount.
 1626 |     |      * @return The principal amount rounded up.
 1627 |     |      */
 1628 | *   |     function _getPrincipalAmountRoundedUp(uint240 presentAmount_) internal view returns (uint112) {
 1629 | *   |         return _getPrincipalAmountRoundedUp(presentAmount_, currentIndex());
 1630 |     |     }
 1631 |     | 
 1632 |     |     /**
 1633 |     |      * @dev    Returns the present amount (rounded down) given the principal amount and an index.
 1634 |     |      * @param  principalAmount_ The principal amount.
 1635 |     |      * @param  index_           An index.
 1636 |     |      * @return The present amount rounded down.
 1637 |     |      */
 1638 | *   |     function _getPresentAmountRoundedDown(uint112 principalAmount_, uint128 index_) internal pure returns (uint240) {
 1639 | *   |         return ContinuousIndexingMath.multiplyDown(principalAmount_, index_);
 1640 |     |     }
 1641 |     | 
 1642 |     |     /**
 1643 |     |      * @dev    Returns the present amount (rounded up) given the principal amount and an index.
 1644 |     |      * @param  principalAmount_ The principal amount.
 1645 |     |      * @param  index_           An index.
 1646 |     |      * @return The present amount rounded up.
 1647 |     |      */
 1648 | *   |     function _getPresentAmountRoundedUp(uint112 principalAmount_, uint128 index_) internal pure returns (uint240) {
 1649 | *   |         return ContinuousIndexingMath.multiplyUp(principalAmount_, index_);
 1650 |     |     }
 1651 |     | 
 1652 |     |     /**
 1653 |     |      * @dev    Returns the principal amount given the present amount, using the current index.
 1654 |     |      * @param  presentAmount_ The present amount.
 1655 |     |      * @param  index_         An index.
 1656 |     |      * @return The principal amount rounded down.
 1657 |     |      */
 1658 |     |     function _getPrincipalAmountRoundedDown(uint240 presentAmount_, uint128 index_) internal pure returns (uint112) {
 1659 |     |         return ContinuousIndexingMath.divideDown(presentAmount_, index_);
 1660 |     |     }
 1661 |     | 
 1662 |     |     /**
 1663 |     |      * @dev    Returns the principal amount given the present amount, using the current index.
 1664 |     |      * @param  presentAmount_ The present amount.
 1665 |     |      * @param  index_         An index.
 1666 |     |      * @return The principal amount rounded up.
 1667 |     |      */
 1668 | *   |     function _getPrincipalAmountRoundedUp(uint240 presentAmount_, uint128 index_) internal pure returns (uint112) {
 1669 | *   |         return ContinuousIndexingMath.divideUp(presentAmount_, index_);
 1670 |     |     }
 1671 |     | 
 1672 |     |     /// @dev To be overridden by the inheriting contract to return the current rate.
 1673 |     |     function _rate() internal view virtual returns (uint32);
 1674 |     | }
 1675 |     | 
 1676 |     | // lib/common/src/interfaces/IERC3009.sol
 1677 |     | 
 1678 |     | /**
 1679 |     |  * @title  Transfer via signed authorization following EIP-3009 standard.
 1680 |     |  * @author M^0 Labs
 1681 |     |  * @dev    The interface as defined by EIP-3009: https://eips.ethereum.org/EIPS/eip-3009
 1682 |     |  */
 1683 |     | interface IERC3009 is IStatefulERC712 {
 1684 |     |     /* ============ Events ============ */
 1685 |     | 
 1686 |     |     /**
 1687 |     |      * @notice Emitted when an authorization has been canceled.
 1688 |     |      * @param  authorizer Authorizer's address.
 1689 |     |      * @param  nonce      Nonce of the canceled authorization.
 1690 |     |      */
 1691 |     |     event AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);
 1692 |     | 
 1693 |     |     /**
 1694 |     |      * @notice Emitted when an authorization has been used.
 1695 |     |      * @param  authorizer Authorizer's address.
 1696 |     |      * @param  nonce      Nonce of the used authorization.
 1697 |     |      */
 1698 |     |     event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);
 1699 |     | 
 1700 |     |     /* ============ Custom Errors ============ */
 1701 |     | 
 1702 |     |     /**
 1703 |     |      * @notice Emitted when an authorization has already been used.
 1704 |     |      * @param  authorizer Authorizer's address.
 1705 |     |      * @param  nonce      Nonce of the used authorization.
 1706 |     |      */
 1707 |     |     error AuthorizationAlreadyUsed(address authorizer, bytes32 nonce);
 1708 |     | 
 1709 |     |     /**
 1710 |     |      * @notice Emitted when an authorization is expired.
 1711 |     |      * @param  timestamp   Timestamp at which the transaction was submitted.
 1712 |     |      * @param  validBefore Timestamp before which the authorization would have been valid.
 1713 |     |      */
 1714 |     |     error AuthorizationExpired(uint256 timestamp, uint256 validBefore);
 1715 |     | 
 1716 |     |     /**
 1717 |     |      * @notice Emitted when an authorization is not yet valid.
 1718 |     |      * @param  timestamp  Timestamp at which the transaction was submitted.
 1719 |     |      * @param  validAfter Timestamp after which the authorization will be valid.
 1720 |     |      */
 1721 |     |     error AuthorizationNotYetValid(uint256 timestamp, uint256 validAfter);
 1722 |     | 
 1723 |     |     /**
 1724 |     |      * @notice Emitted when the caller of `receiveWithAuthorization` is not the payee.
 1725 |     |      * @param  caller Caller's address.
 1726 |     |      * @param  payee  Payee's address.
 1727 |     |      */
 1728 |     |     error CallerMustBePayee(address caller, address payee);
 1729 |     | 
 1730 |     |     /* ============ Interactive Functions ============ */
 1731 |     | 
 1732 |     |     /**
 1733 |     |      * @notice Execute a transfer with a signed authorization.
 1734 |     |      * @param  from        Payer's address (Authorizer).
 1735 |     |      * @param  to          Payee's address.
 1736 |     |      * @param  value       Amount to be transferred.
 1737 |     |      * @param  validAfter  The time after which this is valid (unix time).
 1738 |     |      * @param  validBefore The time before which this is valid (unix time).
 1739 |     |      * @param  nonce       Unique nonce.
 1740 |     |      * @param  signature   A byte array ECDSA/secp256k1 signature (encoded r, s, v).
 1741 |     |      */
 1742 |     |     function transferWithAuthorization(
 1743 |     |         address from,
 1744 |     |         address to,
 1745 |     |         uint256 value,
 1746 |     |         uint256 validAfter,
 1747 |     |         uint256 validBefore,
 1748 |     |         bytes32 nonce,
 1749 |     |         bytes memory signature
 1750 |     |     ) external;
 1751 |     | 
 1752 |     |     /**
 1753 |     |      * @notice Execute a transfer with a signed authorization.
 1754 |     |      * @param  from        Payer's address (Authorizer).
 1755 |     |      * @param  to          Payee's address.
 1756 |     |      * @param  value       Amount to be transferred.
 1757 |     |      * @param  validAfter  The time after which this is valid (unix time).
 1758 |     |      * @param  validBefore The time before which this is valid (unix time).
 1759 |     |      * @param  nonce       Unique nonce.
 1760 |     |      * @param  r           An ECDSA/secp256k1 signature parameter.
 1761 |     |      * @param  vs          An ECDSA/secp256k1 short signature parameter.
 1762 |     |      */
 1763 |     |     function transferWithAuthorization(
 1764 |     |         address from,
 1765 |     |         address to,
 1766 |     |         uint256 value,
 1767 |     |         uint256 validAfter,
 1768 |     |         uint256 validBefore,
 1769 |     |         bytes32 nonce,
 1770 |     |         bytes32 r,
 1771 |     |         bytes32 vs
 1772 |     |     ) external;
 1773 |     | 
 1774 |     |     /**
 1775 |     |      * @notice Execute a transfer with a signed authorization.
 1776 |     |      * @param  from        Payer's address (Authorizer).
 1777 |     |      * @param  to          Payee's address.
 1778 |     |      * @param  value       Amount to be transferred.
 1779 |     |      * @param  validAfter  The time after which this is valid (unix time).
 1780 |     |      * @param  validBefore The time before which this is valid (unix time).
 1781 |     |      * @param  nonce       Unique nonce.
 1782 |     |      * @param  v           v of the signature.
 1783 |     |      * @param  r           r of the signature.
 1784 |     |      * @param  s           s of the signature.
 1785 |     |      */
 1786 |     |     function transferWithAuthorization(
 1787 |     |         address from,
 1788 |     |         address to,
 1789 |     |         uint256 value,
 1790 |     |         uint256 validAfter,
 1791 |     |         uint256 validBefore,
 1792 |     |         bytes32 nonce,
 1793 |     |         uint8 v,
 1794 |     |         bytes32 r,
 1795 |     |         bytes32 s
 1796 |     |     ) external;
 1797 |     | 
 1798 |     |     /**
 1799 |     |      * @notice Receive a transfer with a signed authorization from the payer.
 1800 |     |      * @dev    This has an additional check to ensure that the payee's address matches
 1801 |     |      *         the caller of this function to prevent front-running attacks.
 1802 |     |      *         (See security considerations)
 1803 |     |      * @param  from        Payer's address (Authorizer).
 1804 |     |      * @param  to          Payee's address.
 1805 |     |      * @param  value       Amount to be transferred.
 1806 |     |      * @param  validAfter  The time after which this is valid (unix time).
 1807 |     |      * @param  validBefore The time before which this is valid (unix time).
 1808 |     |      * @param  nonce       Unique nonce.
 1809 |     |      * @param  signature   A byte array ECDSA/secp256k1 signature (encoded r, s, v).
 1810 |     |      */
 1811 |     |     function receiveWithAuthorization(
 1812 |     |         address from,
 1813 |     |         address to,
 1814 |     |         uint256 value,
 1815 |     |         uint256 validAfter,
 1816 |     |         uint256 validBefore,
 1817 |     |         bytes32 nonce,
 1818 |     |         bytes memory signature
 1819 |     |     ) external;
 1820 |     | 
 1821 |     |     /**
 1822 |     |      * @notice Receive a transfer with a signed authorization from the payer.
 1823 |     |      * @dev    This has an additional check to ensure that the payee's address matches
 1824 |     |      *         the caller of this function to prevent front-running attacks.
 1825 |     |      *         (See security considerations)
 1826 |     |      * @param  from        Payer's address (Authorizer).
 1827 |     |      * @param  to          Payee's address.
 1828 |     |      * @param  value       Amount to be transferred.
 1829 |     |      * @param  validAfter  The time after which this is valid (unix time).
 1830 |     |      * @param  validBefore The time before which this is valid (unix time).
 1831 |     |      * @param  nonce       Unique nonce.
 1832 |     |      * @param  r           An ECDSA/secp256k1 signature parameter.
 1833 |     |      * @param  vs          An ECDSA/secp256k1 short signature parameter.
 1834 |     |      */
 1835 |     |     function receiveWithAuthorization(
 1836 |     |         address from,
 1837 |     |         address to,
 1838 |     |         uint256 value,
 1839 |     |         uint256 validAfter,
 1840 |     |         uint256 validBefore,
 1841 |     |         bytes32 nonce,
 1842 |     |         bytes32 r,
 1843 |     |         bytes32 vs
 1844 |     |     ) external;
 1845 |     | 
 1846 |     |     /**
 1847 |     |      * @notice Receive a transfer with a signed authorization from the payer.
 1848 |     |      * @dev    This has an additional check to ensure that the payee's address matches
 1849 |     |      *         the caller of this function to prevent front-running attacks.
 1850 |     |      *         (See security considerations)
 1851 |     |      * @param  from        Payer's address (Authorizer).
 1852 |     |      * @param  to          Payee's address.
 1853 |     |      * @param  value       Amount to be transferred.
 1854 |     |      * @param  validAfter  The time after which this is valid (unix time).
 1855 |     |      * @param  validBefore The time before which this is valid (unix time).
 1856 |     |      * @param  nonce       Unique nonce.
 1857 |     |      * @param  v           v of the signature.
 1858 |     |      * @param  r           r of the signature.
 1859 |     |      * @param  s           s of the signature.
 1860 |     |      */
 1861 |     |     function receiveWithAuthorization(
 1862 |     |         address from,
 1863 |     |         address to,
 1864 |     |         uint256 value,
 1865 |     |         uint256 validAfter,
 1866 |     |         uint256 validBefore,
 1867 |     |         bytes32 nonce,
 1868 |     |         uint8 v,
 1869 |     |         bytes32 r,
 1870 |     |         bytes32 s
 1871 |     |     ) external;
 1872 |     | 
 1873 |     |     /**
 1874 |     |      * @notice Attempt to cancel an authorization.
 1875 |     |      * @param  authorizer Authorizer's address.
 1876 |     |      * @param  nonce      Nonce of the authorization.
 1877 |     |      * @param  signature  A byte array ECDSA/secp256k1 signature (encoded r, s, v).
 1878 |     |      */
 1879 |     |     function cancelAuthorization(address authorizer, bytes32 nonce, bytes memory signature) external;
 1880 |     | 
 1881 |     |     /**
 1882 |     |      * @notice Attempt to cancel an authorization.
 1883 |     |      * @param  authorizer Authorizer's address.
 1884 |     |      * @param  nonce      Nonce of the authorization.
 1885 |     |      * @param  r          An ECDSA/secp256k1 signature parameter.
 1886 |     |      * @param  vs         An ECDSA/secp256k1 short signature parameter.
 1887 |     |      */
 1888 |     |     function cancelAuthorization(address authorizer, bytes32 nonce, bytes32 r, bytes32 vs) external;
 1889 |     | 
 1890 |     |     /**
 1891 |     |      * @notice Attempt to cancel an authorization.
 1892 |     |      * @param  authorizer Authorizer's address.
 1893 |     |      * @param  nonce      Nonce of the authorization.
 1894 |     |      * @param  v          v of the signature.
 1895 |     |      * @param  r          r of the signature.
 1896 |     |      * @param  s          s of the signature.
 1897 |     |      */
 1898 |     |     function cancelAuthorization(address authorizer, bytes32 nonce, uint8 v, bytes32 r, bytes32 s) external;
 1899 |     | 
 1900 |     |     /* ============ View/Pure Functions ============ */
 1901 |     | 
 1902 |     |     /**
 1903 |     |      * @notice Returns the state of an authorization.
 1904 |     |      * @dev    Nonces are randomly generated 32-byte data unique to the authorizer's address
 1905 |     |      * @param  authorizer Authorizer's address.
 1906 |     |      * @param  nonce      Nonce of the authorization.
 1907 |     |      * @return True if the nonce is used.
 1908 |     |      */
 1909 |     |     function authorizationState(address authorizer, bytes32 nonce) external view returns (bool);
 1910 |     | 
 1911 |     |     /// @notice Returns `transferWithAuthorization` typehash.
 1912 |     |     function TRANSFER_WITH_AUTHORIZATION_TYPEHASH() external view returns (bytes32);
 1913 |     | 
 1914 |     |     /// @notice Returns `receiveWithAuthorization` typehash.
 1915 |     |     function RECEIVE_WITH_AUTHORIZATION_TYPEHASH() external view returns (bytes32);
 1916 |     | 
 1917 |     |     /// @notice Returns `cancelAuthorization` typehash.
 1918 |     |     function CANCEL_AUTHORIZATION_TYPEHASH() external view returns (bytes32);
 1919 |     | }
 1920 |     | 
 1921 |     | // lib/common/src/ERC712Extended.sol
 1922 |     | 
 1923 |     | /**
 1924 |     |  * @title  Typed structured data hashing and signing via EIP-712, extended by EIP-5267.
 1925 |     |  * @author M^0 Labs
 1926 |     |  * @dev    An abstract implementation to satisfy EIP-712: https://eips.ethereum.org/EIPS/eip-712
 1927 |     |  */
 1928 |     | abstract contract ERC712Extended is IERC712Extended {
 1929 |     |     /* ============ Variables ============ */
 1930 |     | 
 1931 |     |     /// @dev keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")
 1932 | *   |     bytes32 internal constant _EIP712_DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;
 1933 |     | 
 1934 |     |     /// @dev keccak256("1")
 1935 | *   |     bytes32 internal constant _EIP712_VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;
 1936 |     | 
 1937 |     |     /// @dev Initial Chain ID set at deployment.
 1938 |     |     uint256 internal immutable _INITIAL_CHAIN_ID;
 1939 |     | 
 1940 |     |     /// @dev Initial EIP-712 domain separator set at deployment.
 1941 |     |     bytes32 internal immutable _INITIAL_DOMAIN_SEPARATOR;
 1942 |     | 
 1943 |     |     /// @dev The name of the contract (stored as a bytes32 instead of a string in order to be immutable).
 1944 |     |     bytes32 internal immutable _name;
 1945 |     | 
 1946 |     |     /* ============ Constructor ============ */
 1947 |     | 
 1948 |     |     /**
 1949 |     |      * @notice Constructs the EIP-712 domain separator.
 1950 |     |      * @param  name_ The name of the contract.
 1951 |     |      */
 1952 | *   |     constructor(string memory name_) {
 1953 | *   |         _name = Bytes32String.toBytes32(name_);
 1954 |     | 
 1955 | *   |         _INITIAL_CHAIN_ID = block.chainid;
 1956 | *   |         _INITIAL_DOMAIN_SEPARATOR = _getDomainSeparator();
 1957 |     |     }
 1958 |     | 
 1959 |     |     /* ============ View/Pure Functions ============ */
 1960 |     | 
 1961 |     |     /// @inheritdoc IERC712Extended
 1962 |     |     function eip712Domain()
 1963 |     |         external
 1964 |     |         view
 1965 |     |         virtual
 1966 |     |         returns (
 1967 |     |             bytes1 fields_,
 1968 |     |             string memory name_,
 1969 |     |             string memory version_,
 1970 |     |             uint256 chainId_,
 1971 |     |             address verifyingContract_,
 1972 |     |             bytes32 salt_,
 1973 |     |             uint256[] memory extensions_
 1974 |     |         )
 1975 |     |     {
 1976 |     |         return (
 1977 |     |             hex"0f", // 01111
 1978 |     |             Bytes32String.toString(_name),
 1979 |     |             "1",
 1980 |     |             block.chainid,
 1981 |     |             address(this),
 1982 |     |             bytes32(0),
 1983 |     |             new uint256[](0)
 1984 |     |         );
 1985 |     |     }
 1986 |     | 
 1987 |     |     /// @inheritdoc IERC712
 1988 |     |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
 1989 |     |         return block.chainid == _INITIAL_CHAIN_ID ? _INITIAL_DOMAIN_SEPARATOR : _getDomainSeparator();
 1990 |     |     }
 1991 |     | 
 1992 |     |     /* ============ Internal View/Pure Functions ============ */
 1993 |     | 
 1994 |     |     /**
 1995 |     |      * @dev    Computes the EIP-712 domain separator.
 1996 |     |      * @return The EIP-712 domain separator.
 1997 |     |      */
 1998 | *   |     function _getDomainSeparator() internal view returns (bytes32) {
 1999 | *   |         return
 2000 | *   |             keccak256(
 2001 | *   |                 abi.encode(
 2002 | *   |                     _EIP712_DOMAIN_HASH,
 2003 | *   |                     keccak256(bytes(Bytes32String.toString(_name))),
 2004 | *   |                     _EIP712_VERSION_HASH,
 2005 | *   |                     block.chainid,
 2006 | *   |                     address(this)
 2007 |     |                 )
 2008 |     |             );
 2009 |     |     }
 2010 |     | 
 2011 |     |     /**
 2012 |     |      * @dev    Returns the digest to be signed, via EIP-712, given an internal digest (i.e. hash struct).
 2013 |     |      * @param  internalDigest_ The internal digest.
 2014 |     |      * @return The digest to be signed.
 2015 |     |      */
 2016 |     |     function _getDigest(bytes32 internalDigest_) internal view returns (bytes32) {
 2017 |     |         return keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR(), internalDigest_));
 2018 |     |     }
 2019 |     | 
 2020 |     |     /**
 2021 |     |      * @dev   Revert if the signature is expired.
 2022 |     |      * @param expiry_ Timestamp at which the signature expires or max uint256 for no expiry.
 2023 |     |      */
 2024 |     |     function _revertIfExpired(uint256 expiry_) internal view {
 2025 |     |         if (block.timestamp > expiry_) revert SignatureExpired(expiry_, block.timestamp);
 2026 |     |     }
 2027 |     | 
 2028 |     |     /**
 2029 |     |      * @dev   Revert if the signature is invalid.
 2030 |     |      * @dev   We first validate if the signature is a valid ECDSA signature and return early if it is the case.
 2031 |     |      *        Then, we validate if it is a valid ERC-1271 signature, and return early if it is the case.
 2032 |     |      *        If not, we revert with the error from the ECDSA signature validation.
 2033 |     |      * @param signer_    The signer of the signature.
 2034 |     |      * @param digest_    The digest that was signed.
 2035 |     |      * @param signature_ The signature.
 2036 |     |      */
 2037 |     |     function _revertIfInvalidSignature(address signer_, bytes32 digest_, bytes memory signature_) internal view {
 2038 |     |         SignatureChecker.Error error_ = SignatureChecker.validateECDSASignature(signer_, digest_, signature_);
 2039 |     | 
 2040 |     |         if (error_ == SignatureChecker.Error.NoError) return;
 2041 |     | 
 2042 |     |         if (SignatureChecker.isValidERC1271Signature(signer_, digest_, signature_)) return;
 2043 |     | 
 2044 |     |         _revertIfError(error_);
 2045 |     |     }
 2046 |     | 
 2047 |     |     /**
 2048 |     |      * @dev    Returns the signer of a signed digest, via EIP-712, and reverts if the signature is invalid.
 2049 |     |      * @param  digest_ The digest that was signed.
 2050 |     |      * @param  v_      v of the signature.
 2051 |     |      * @param  r_      r of the signature.
 2052 |     |      * @param  s_      s of the signature.
 2053 |     |      * @return signer_ The signer of the digest.
 2054 |     |      */
 2055 |     |     function _getSignerAndRevertIfInvalidSignature(
 2056 |     |         bytes32 digest_,
 2057 |     |         uint8 v_,
 2058 |     |         bytes32 r_,
 2059 |     |         bytes32 s_
 2060 |     |     ) internal pure returns (address signer_) {
 2061 |     |         SignatureChecker.Error error_;
 2062 |     | 
 2063 |     |         (error_, signer_) = SignatureChecker.recoverECDSASigner(digest_, v_, r_, s_);
 2064 |     | 
 2065 |     |         _revertIfError(error_);
 2066 |     |     }
 2067 |     | 
 2068 |     |     /**
 2069 |     |      * @dev   Revert if the signature is invalid.
 2070 |     |      * @param signer_ The signer of the signature.
 2071 |     |      * @param digest_ The digest that was signed.
 2072 |     |      * @param r_      An ECDSA/secp256k1 signature parameter.
 2073 |     |      * @param vs_     An ECDSA/secp256k1 short signature parameter.
 2074 |     |      */
 2075 |     |     function _revertIfInvalidSignature(address signer_, bytes32 digest_, bytes32 r_, bytes32 vs_) internal pure {
 2076 |     |         _revertIfError(SignatureChecker.validateECDSASignature(signer_, digest_, r_, vs_));
 2077 |     |     }
 2078 |     | 
 2079 |     |     /**
 2080 |     |      * @dev   Revert if the signature is invalid.
 2081 |     |      * @param signer_ The signer of the signature.
 2082 |     |      * @param digest_ The digest that was signed.
 2083 |     |      * @param v_      v of the signature.
 2084 |     |      * @param r_      r of the signature.
 2085 |     |      * @param s_      s of the signature.
 2086 |     |      */
 2087 |     |     function _revertIfInvalidSignature(
 2088 |     |         address signer_,
 2089 |     |         bytes32 digest_,
 2090 |     |         uint8 v_,
 2091 |     |         bytes32 r_,
 2092 |     |         bytes32 s_
 2093 |     |     ) internal pure {
 2094 |     |         _revertIfError(SignatureChecker.validateECDSASignature(signer_, digest_, v_, r_, s_));
 2095 |     |     }
 2096 |     | 
 2097 |     |     /**
 2098 |     |      * @dev   Revert if error.
 2099 |     |      * @param error_ The SignatureChecker Error enum.
 2100 |     |      */
 2101 |     |     function _revertIfError(SignatureChecker.Error error_) private pure {
 2102 |     |         if (error_ == SignatureChecker.Error.NoError) return;
 2103 |     |         if (error_ == SignatureChecker.Error.InvalidSignature) revert InvalidSignature();
 2104 |     |         if (error_ == SignatureChecker.Error.InvalidSignatureLength) revert InvalidSignatureLength();
 2105 |     |         if (error_ == SignatureChecker.Error.InvalidSignatureS) revert InvalidSignatureS();
 2106 |     |         if (error_ == SignatureChecker.Error.InvalidSignatureV) revert InvalidSignatureV();
 2107 |     |         if (error_ == SignatureChecker.Error.SignerMismatch) revert SignerMismatch();
 2108 |     | 
 2109 |     |         revert InvalidSignature();
 2110 |     |     }
 2111 |     | }
 2112 |     | 
 2113 |     | // lib/common/src/interfaces/IERC20Extended.sol
 2114 |     | 
 2115 |     | /**
 2116 |     |  * @title  An ERC20 token extended with EIP-2612 permits for signed approvals (via EIP-712
 2117 |     |  *         and with EIP-1271 compatibility), and extended with EIP-3009 transfer with authorization (via EIP-712).
 2118 |     |  * @author M^0 Labs
 2119 |     |  * @dev    The additional interface as defined by EIP-2612: https://eips.ethereum.org/EIPS/eip-2612
 2120 |     |  */
 2121 |     | interface IERC20Extended is IERC20, IERC3009 {
 2122 |     |     /* ============ Custom Errors ============ */
 2123 |     | 
 2124 |     |     /**
 2125 |     |      * @notice Revert message when spender's allowance is not sufficient.
 2126 |     |      * @param  spender    Address that may be allowed to operate on tokens without being their owner.
 2127 |     |      * @param  allowance  Amount of tokens a `spender` is allowed to operate with.
 2128 |     |      * @param  needed     Minimum amount required to perform a transfer.
 2129 |     |      */
 2130 |     |     error InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
 2131 |     | 
 2132 |     |     /**
 2133 |     |      * @notice Revert message emitted when the transferred amount is insufficient.
 2134 |     |      * @param  amount Amount transferred.
 2135 |     |      */
 2136 |     |     error InsufficientAmount(uint256 amount);
 2137 |     | 
 2138 |     |     /**
 2139 |     |      * @notice Revert message emitted when the recipient of a token is invalid.
 2140 |     |      * @param  recipient Address of the invalid recipient.
 2141 |     |      */
 2142 |     |     error InvalidRecipient(address recipient);
 2143 |     | 
 2144 |     |     /* ============ Interactive Functions ============ */
 2145 |     | 
 2146 |     |     /**
 2147 |     |      * @notice Approves `spender` to spend up to `amount` of the token balance of `owner`, via a signature.
 2148 |     |      * @param  owner    The address of the account who's token balance is being approved to be spent by `spender`.
 2149 |     |      * @param  spender  The address of an account allowed to spend on behalf of `owner`.
 2150 |     |      * @param  value    The amount of the allowance being approved.
 2151 |     |      * @param  deadline The last timestamp where the signature is still valid.
 2152 |     |      * @param  v        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 2153 |     |      * @param  r        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 2154 |     |      * @param  s        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 2155 |     |      */
 2156 |     |     function permit(
 2157 |     |         address owner,
 2158 |     |         address spender,
 2159 |     |         uint256 value,
 2160 |     |         uint256 deadline,
 2161 |     |         uint8 v,
 2162 |     |         bytes32 r,
 2163 |     |         bytes32 s
 2164 |     |     ) external;
 2165 |     | 
 2166 |     |     /**
 2167 |     |      * @notice Approves `spender` to spend up to `amount` of the token balance of `owner`, via a signature.
 2168 |     |      * @param  owner     The address of the account who's token balance is being approved to be spent by `spender`.
 2169 |     |      * @param  spender   The address of an account allowed to spend on behalf of `owner`.
 2170 |     |      * @param  value     The amount of the allowance being approved.
 2171 |     |      * @param  deadline  The last timestamp where the signature is still valid.
 2172 |     |      * @param  signature An arbitrary signature (EIP-712).
 2173 |     |      */
 2174 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) external;
 2175 |     | 
 2176 |     |     /* ============ View/Pure Functions ============ */
 2177 |     | 
 2178 |     |     /// @notice Returns the EIP712 typehash used in the encoding of the digest for the permit function.
 2179 |     |     function PERMIT_TYPEHASH() external view returns (bytes32);
 2180 |     | }
 2181 |     | 
 2182 |     | // src/interfaces/IMToken.sol
 2183 |     | 
 2184 |     | /**
 2185 |     |  * @title  M Token Interface.
 2186 |     |  * @author M^0 Labs
 2187 |     |  */
 2188 |     | interface IMToken is IContinuousIndexing, IERC20Extended {
 2189 |     |     /* ============ Events ============ */
 2190 |     | 
 2191 |     |     /**
 2192 |     |      * @notice Emitted when account starts being an M earner.
 2193 |     |      * @param  account The account that started earning.
 2194 |     |      */
 2195 |     |     event StartedEarning(address indexed account);
 2196 |     | 
 2197 |     |     /**
 2198 |     |      * @notice Emitted when account stops being an M earner.
 2199 |     |      * @param  account The account that stopped earning.
 2200 |     |      */
 2201 |     |     event StoppedEarning(address indexed account);
 2202 |     | 
 2203 |     |     /* ============ Custom Errors ============ */
 2204 |     | 
 2205 |     |     /**
 2206 |     |      * @notice Emitted when there is insufficient balance to decrement from `account`.
 2207 |     |      * @param  account     The account with insufficient balance.
 2208 |     |      * @param  rawBalance  The raw balance of the account.
 2209 |     |      * @param  amount      The amount to decrement the `rawBalance` by.
 2210 |     |      */
 2211 |     |     error InsufficientBalance(address account, uint256 rawBalance, uint256 amount);
 2212 |     | 
 2213 |     |     /// @notice Emitted when calling `stopEarning` for an account approved as earner by TTG.
 2214 |     |     error IsApprovedEarner();
 2215 |     | 
 2216 |     |     /// @notice Emitted when calling `startEarning` for an account not approved as earner by TTG.
 2217 |     |     error NotApprovedEarner();
 2218 |     | 
 2219 |     |     /// @notice Emitted when calling `mint`, `burn` not by Minter Gateway.
 2220 |     |     error NotMinterGateway();
 2221 |     | 
 2222 |     |     /// @notice Emitted when principal of total supply (earning and non-earning) will overflow a `type(uint112).max`.
 2223 |     |     error OverflowsPrincipalOfTotalSupply();
 2224 |     | 
 2225 |     |     /// @notice Emitted in constructor if Minter Gateway is 0x0.
 2226 |     |     error ZeroMinterGateway();
 2227 |     | 
 2228 |     |     /// @notice Emitted in constructor if TTG Registrar is 0x0.
 2229 |     |     error ZeroTTGRegistrar();
 2230 |     | 
 2231 |     |     /* ============ Interactive Functions ============ */
 2232 |     | 
 2233 |     |     /**
 2234 |     |      * @notice Mints tokens.
 2235 |     |      * @param  account The address of account to mint to.
 2236 |     |      * @param  amount  The amount of M Token to mint.
 2237 |     |      */
 2238 |     |     function mint(address account, uint256 amount) external;
 2239 |     | 
 2240 |     |     /**
 2241 |     |      * @notice Burns tokens.
 2242 |     |      * @param  account The address of account to burn from.
 2243 |     |      * @param  amount  The amount of M Token to burn.
 2244 |     |      */
 2245 |     |     function burn(address account, uint256 amount) external;
 2246 |     | 
 2247 |     |     /// @notice Starts earning for caller if allowed by TTG.
 2248 |     |     function startEarning() external;
 2249 |     | 
 2250 |     |     /// @notice Stops earning for caller.
 2251 |     |     function stopEarning() external;
 2252 |     | 
 2253 |     |     /**
 2254 |     |      * @notice Stops earning for `account`.
 2255 |     |      * @dev    MUST revert if `account` is an approved earner in TTG Registrar.
 2256 |     |      * @param  account The account to stop earning for.
 2257 |     |      */
 2258 |     |     function stopEarning(address account) external;
 2259 |     | 
 2260 |     |     /* ============ View/Pure Functions ============ */
 2261 |     | 
 2262 |     |     /// @notice The address of the Minter Gateway contract.
 2263 |     |     function minterGateway() external view returns (address);
 2264 |     | 
 2265 |     |     /// @notice The address of the TTG Registrar contract.
 2266 |     |     function ttgRegistrar() external view returns (address);
 2267 |     | 
 2268 |     |     /// @notice The address of TTG approved earner rate model.
 2269 |     |     function rateModel() external view returns (address);
 2270 |     | 
 2271 |     |     /// @notice The current value of earner rate in basis points.
 2272 |     |     function earnerRate() external view returns (uint32);
 2273 |     | 
 2274 |     |     /**
 2275 |     |      * @notice The principal of an earner M token balance.
 2276 |     |      * @param  account The account to get the principal balance of.
 2277 |     |      * @return The principal balance of the account.
 2278 |     |      */
 2279 |     |     function principalBalanceOf(address account) external view returns (uint240);
 2280 |     | 
 2281 |     |     /// @notice The principal of the total earning supply of M Token.
 2282 |     |     function principalOfTotalEarningSupply() external view returns (uint112);
 2283 |     | 
 2284 |     |     /// @notice The total earning supply of M Token.
 2285 |     |     function totalEarningSupply() external view returns (uint240);
 2286 |     | 
 2287 |     |     /// @notice The total non-earning supply of M Token.
 2288 |     |     function totalNonEarningSupply() external view returns (uint240);
 2289 |     | 
 2290 |     |     /**
 2291 |     |      * @notice Checks if account is an earner.
 2292 |     |      * @param  account The account to check.
 2293 |     |      * @return True if account is an earner, false otherwise.
 2294 |     |      */
 2295 |     |     function isEarning(address account) external view returns (bool);
 2296 |     | }
 2297 |     | 
 2298 |     | // src/MinterGateway.sol
 2299 |     | 
 2300 |     | /*
 2301 |     | 
 2302 |     |                         
 2303 |     |              
 2304 |     |                           
 2305 |     |                          
 2306 |     |                             
 2307 |     |                                     
 2308 |     | 
 2309 |     | -->> Where money is born. <<--
 2310 |     | 
 2311 |     | */
 2312 |     | 
 2313 |     | /**
 2314 |     |  * @title  MinterGateway
 2315 |     |  * @author M^0 Labs
 2316 |     |  * @notice Minting Gateway of M Token for all approved by TTG and activated minters.
 2317 |     |  */
 2318 | *   | contract MinterGateway is IMinterGateway, ContinuousIndexing, ERC712Extended {
 2319 |     |     /* ============ Structs ============ */
 2320 |     | 
 2321 |     |     /**
 2322 |     |      * @notice Mint proposal struct.
 2323 |     |      * @param  id          The unique ID of the mint proposal.
 2324 |     |      * @param  createdAt   The timestamp at which the mint proposal was created.
 2325 |     |      * @param  destination The address to mint M to.
 2326 |     |      * @param  amount      The amount of M to mint.
 2327 |     |      */
 2328 |     |     struct MintProposal {
 2329 |     |         // 1st slot
 2330 |     |         uint48 id;
 2331 |     |         uint40 createdAt;
 2332 |     |         address destination;
 2333 |     |         // 2nd slot
 2334 |     |         uint240 amount;
 2335 |     |     }
 2336 |     | 
 2337 |     |     /**
 2338 |     |      * @notice Minter state struct.
 2339 |     |      * @param  isActive                Whether the minter is active or not.
 2340 |     |      * @param  isDeactivated           Whether the minter is deactivated or not.
 2341 |     |      * @param  collateral              The amount of collateral the minter has.
 2342 |     |      * @param  totalPendingRetrievals  The total amount of pending retrievals.
 2343 |     |      * @param  updateTimestamp         The timestamp at which the minter last updated their collateral.
 2344 |     |      * @param  penalizedUntilTimestamp The timestamp until which the minter is penalized.
 2345 |     |      * @param  frozenUntilTimestamp    The timestamp until which the minter is frozen.
 2346 |     |      * @param  latestProposedRetrievalTimestamp The timestamp at which the minter last proposed a retrieval.
 2347 |     |      */
 2348 |     |     struct MinterState {
 2349 |     |         // 1st slot
 2350 |     |         bool isActive;
 2351 |     |         bool isDeactivated;
 2352 |     |         uint240 collateral;
 2353 |     |         // 2nd slot
 2354 |     |         uint240 totalPendingRetrievals;
 2355 |     |         // 3rd slot
 2356 |     |         uint40 updateTimestamp;
 2357 |     |         uint40 penalizedUntilTimestamp;
 2358 |     |         uint40 frozenUntilTimestamp;
 2359 |     |         uint40 latestProposedRetrievalTimestamp;
 2360 |     |     }
 2361 |     | 
 2362 |     |     /* ============ Variables ============ */
 2363 |     | 
 2364 |     |     /// @inheritdoc IMinterGateway
 2365 | *   |     uint16 public constant ONE = 10_000;
 2366 |     | 
 2367 |     |     /// @inheritdoc IMinterGateway
 2368 | *   |     uint32 public constant MAX_MINT_RATIO = 65_000;
 2369 |     | 
 2370 |     |     /// @notice IMinterGateway
 2371 | *   |     uint32 public constant MIN_UPDATE_COLLATERAL_INTERVAL = 3_600;
 2372 |     | 
 2373 |     |     // solhint-disable-next-line max-line-length
 2374 |     |     /// @dev keccak256("UpdateCollateral(address minter,uint256 collateral,uint256[] retrievalIds,bytes32 metadataHash,uint256 timestamp)")
 2375 |     |     /// @inheritdoc IMinterGateway
 2376 |     |     bytes32 public constant UPDATE_COLLATERAL_TYPEHASH =
 2377 |     |         0x22b57ca54bd15c6234b29e87aa1d76a0841b6e65e63d7acacef989de0bc3ff9e;
 2378 |     | 
 2379 |     |     /// @inheritdoc IMinterGateway
 2380 |     |     address public immutable ttgRegistrar;
 2381 |     | 
 2382 |     |     /// @inheritdoc IMinterGateway
 2383 |     |     address public immutable ttgVault;
 2384 |     | 
 2385 |     |     /// @inheritdoc IMinterGateway
 2386 |     |     address public immutable mToken;
 2387 |     | 
 2388 |     |     /// @inheritdoc IMinterGateway
 2389 |     |     uint240 public totalInactiveOwedM;
 2390 |     | 
 2391 |     |     /// @inheritdoc IMinterGateway
 2392 |     |     uint112 public principalOfTotalActiveOwedM;
 2393 |     | 
 2394 |     |     /// @dev Nonce used to generate unique mint proposal IDs.
 2395 |     |     uint48 internal _mintNonce;
 2396 |     | 
 2397 |     |     /// @dev Nonce used to generate unique retrieval proposal IDs.
 2398 |     |     uint48 internal _retrievalNonce;
 2399 |     | 
 2400 |     |     /// @dev The state of each minter, their collaterals, relevant timestamps, and total pending retrievals.
 2401 |     |     mapping(address minter => MinterState state) internal _minterStates;
 2402 |     | 
 2403 |     |     /// @dev The mint proposals of minter (mint ID, creation timestamp, destination, amount).
 2404 |     |     mapping(address minter => MintProposal proposal) internal _mintProposals;
 2405 |     | 
 2406 |     |     /// @dev The owed M of active and inactive minters (principal of active, inactive).
 2407 |     |     mapping(address minter => uint240 rawOwedM) internal _rawOwedM;
 2408 |     | 
 2409 |     |     /// @dev The pending collateral retrievals of minter (retrieval ID, amount).
 2410 |     |     mapping(address minter => mapping(uint48 retrievalId => uint240 amount)) internal _pendingCollateralRetrievals;
 2411 |     | 
 2412 |     |     /// @dev The last update signature timestamp of each validator for each minter.
 2413 |     |     mapping(address minter => mapping(address validator => uint256 timestamp)) internal _lastSignatureTimestamp;
 2414 |     | 
 2415 |     |     /* ============ Modifiers ============ */
 2416 |     | 
 2417 |     |     /**
 2418 |     |      * @notice Only allow active minter to call function.
 2419 |     |      * @param  minter_ The address of the minter to check.
 2420 |     |      */
 2421 |     |     modifier onlyActiveMinter(address minter_) {
 2422 | *   |         _revertIfInactiveMinter(minter_);
 2423 |     | 
 2424 |     |         _;
 2425 |     |     }
 2426 |     | 
 2427 |     |     /// @notice Only allow approved validator in TTG to call function.
 2428 |     |     modifier onlyApprovedValidator() {
 2429 |     |         _revertIfNotApprovedValidator(msg.sender);
 2430 |     | 
 2431 |     |         _;
 2432 |     |     }
 2433 |     | 
 2434 |     |     /// @notice Only allow unfrozen minter to call function.
 2435 |     |     modifier onlyUnfrozenMinter() {
 2436 | *   |         _revertIfFrozenMinter(msg.sender);
 2437 |     | 
 2438 |     |         _;
 2439 |     |     }
 2440 |     | 
 2441 |     |     /* ============ Constructor ============ */
 2442 |     | 
 2443 |     |     /**
 2444 |     |      * @notice Constructor.
 2445 |     |      * @param  ttgRegistrar_ The address of the TTG Registrar contract.
 2446 |     |      * @param  mToken_        The address of the M Token.
 2447 |     |      */
 2448 | *   |     constructor(address ttgRegistrar_, address mToken_) ContinuousIndexing() ERC712Extended("MinterGateway") {
 2449 | *   |         if ((ttgRegistrar = ttgRegistrar_) == address(0)) revert ZeroTTGRegistrar();
 2450 | *   |         if ((ttgVault = TTGRegistrarReader.getVault(ttgRegistrar_)) == address(0)) revert ZeroTTGVault();
 2451 | *   |         if ((mToken = mToken_) == address(0)) revert ZeroMToken();
 2452 |     |     }
 2453 |     | 
 2454 |     |     /* ============ Interactive Functions ============ */
 2455 |     | 
 2456 |     |     /// @inheritdoc IMinterGateway
 2457 |     |     function updateCollateral(
 2458 |     |         uint256 collateral_,
 2459 |     |         uint256[] calldata retrievalIds_,
 2460 |     |         bytes32 metadataHash_,
 2461 |     |         address[] calldata validators_,
 2462 |     |         uint256[] calldata timestamps_,
 2463 |     |         bytes[] calldata signatures_
 2464 |     |     ) external onlyActiveMinter(msg.sender) returns (uint40 minTimestamp_) {
 2465 |     |         if (validators_.length != signatures_.length || signatures_.length != timestamps_.length) {
 2466 |     |             revert SignatureArrayLengthsMismatch();
 2467 |     |         }
 2468 |     | 
 2469 |     |         // Verify that enough valid signatures are provided, and get the minimum timestamp across all valid signatures.
 2470 |     |         minTimestamp_ = _verifyValidatorSignatures(
 2471 |     |             msg.sender,
 2472 |     |             collateral_,
 2473 |     |             retrievalIds_,
 2474 |     |             metadataHash_,
 2475 |     |             validators_,
 2476 |     |             timestamps_,
 2477 |     |             signatures_
 2478 |     |         );
 2479 |     | 
 2480 |     |         _imposePenaltyIfMissedCollateralUpdates(msg.sender);
 2481 |     | 
 2482 |     |         _imposePenaltyIfUndercollateralized(msg.sender, minTimestamp_);
 2483 |     | 
 2484 |     |         uint240 safeCollateral_ = UIntMath.safe240(collateral_);
 2485 |     |         uint240 totalResolvedCollateralRetrieval_ = _resolvePendingRetrievals(msg.sender, retrievalIds_);
 2486 |     | 
 2487 |     |         emit CollateralUpdated(
 2488 |     |             msg.sender,
 2489 |     |             safeCollateral_,
 2490 |     |             totalResolvedCollateralRetrieval_,
 2491 |     |             metadataHash_,
 2492 |     |             minTimestamp_
 2493 |     |         );
 2494 |     | 
 2495 |     |         _updateCollateral(msg.sender, safeCollateral_, minTimestamp_);
 2496 |     | 
 2497 |     |         // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the collateral
 2498 |     |         //       update can result in a new rate, we should update the index here to lock in that rate.
 2499 |     |         updateIndex();
 2500 |     |     }
 2501 |     | 
 2502 |     |     /// @inheritdoc IMinterGateway
 2503 |     |     function proposeRetrieval(uint256 collateral_) external onlyActiveMinter(msg.sender) returns (uint48 retrievalId_) {
 2504 |     |         if (collateral_ == 0) revert ZeroRetrievalAmount();
 2505 |     | 
 2506 |     |         unchecked {
 2507 |     |             retrievalId_ = ++_retrievalNonce;
 2508 |     |         }
 2509 |     | 
 2510 |     |         MinterState storage minterState_ = _minterStates[msg.sender];
 2511 |     |         uint240 currentCollateral_ = minterState_.collateral;
 2512 |     |         uint240 safeCollateral_ = UIntMath.safe240(collateral_);
 2513 |     |         uint240 updatedTotalPendingRetrievals_ = minterState_.totalPendingRetrievals + safeCollateral_;
 2514 |     | 
 2515 |     |         // NOTE: Revert if collateral is less than sum of all pending retrievals even if there is no owed M by minter.
 2516 |     |         if (currentCollateral_ < updatedTotalPendingRetrievals_) {
 2517 |     |             revert RetrievalsExceedCollateral(updatedTotalPendingRetrievals_, currentCollateral_);
 2518 |     |         }
 2519 |     | 
 2520 |     |         minterState_.latestProposedRetrievalTimestamp = uint40(block.timestamp);
 2521 |     |         minterState_.totalPendingRetrievals = updatedTotalPendingRetrievals_;
 2522 |     |         _pendingCollateralRetrievals[msg.sender][retrievalId_] = safeCollateral_;
 2523 |     | 
 2524 |     |         _revertIfUndercollateralized(msg.sender, 0);
 2525 |     | 
 2526 |     |         emit RetrievalCreated(retrievalId_, msg.sender, safeCollateral_);
 2527 |     |     }
 2528 |     | 
 2529 |     |     /// @inheritdoc IMinterGateway
 2530 | *   |     function proposeMint(
 2531 |     |         uint256 amount_,
 2532 |     |         address destination_
 2533 | *   |     ) external onlyActiveMinter(msg.sender) onlyUnfrozenMinter returns (uint48 mintId_) {
 2534 | *   |         if (amount_ == 0) revert ZeroMintAmount();
 2535 | *   |         if (destination_ == address(0)) revert ZeroMintDestination();
 2536 |     | 
 2537 | *   |         uint240 safeAmount_ = UIntMath.safe240(amount_);
 2538 |     | 
 2539 |     |         //NOTE: remove by fuzzer, not checking collateral on this stage
 2540 | *   |         _revertIfUndercollateralized(msg.sender, safeAmount_); // Ensure minter remains sufficiently collateralized.
 2541 |     | 
 2542 |     |         unchecked {
 2543 | *   |             mintId_ = ++_mintNonce;
 2544 |     |         }
 2545 |     | 
 2546 | *   |         _mintProposals[msg.sender] = MintProposal(mintId_, uint40(block.timestamp), destination_, safeAmount_);
 2547 |     | 
 2548 | *   |         emit MintProposed(mintId_, msg.sender, safeAmount_, destination_);
 2549 |     |     }
 2550 |     | 
 2551 |     |     /// @inheritdoc IMinterGateway
 2552 | *   |     function mintM(
 2553 |     |         uint256 mintId_
 2554 | *   |     ) external onlyActiveMinter(msg.sender) onlyUnfrozenMinter returns (uint112 principalAmount_, uint240 amount_) {
 2555 | *   |         MintProposal storage mintProposal_ = _mintProposals[msg.sender];
 2556 |     | 
 2557 | *   |         uint48 id_;
 2558 | *   |         uint40 createdAt_;
 2559 | *   |         address destination_;
 2560 | *   |         (id_, createdAt_, destination_, amount_) = (
 2561 | *   |             mintProposal_.id,
 2562 | *   |             mintProposal_.createdAt,
 2563 | *   |             mintProposal_.destination,
 2564 | *   |             mintProposal_.amount
 2565 |     |         );
 2566 |     | 
 2567 | *   |         if (id_ != mintId_) revert InvalidMintProposal();
 2568 |     | 
 2569 | *   |         unchecked {
 2570 |     |             // Check that mint proposal is executable.
 2571 | *   |             uint40 activeAt_ = createdAt_ + mintDelay();
 2572 | *   |             if (block.timestamp < activeAt_) revert PendingMintProposal(activeAt_);
 2573 |     | 
 2574 | *   |             uint40 expiresAt_ = activeAt_ + mintTTL();
 2575 | *   |             if (block.timestamp > expiresAt_) revert ExpiredMintProposal(expiresAt_);
 2576 |     |         }
 2577 |     | 
 2578 | *   |         _revertIfUndercollateralized(msg.sender, amount_); // Ensure minter remains sufficiently collateralized.
 2579 |     | 
 2580 | *   |         delete _mintProposals[msg.sender]; // Delete mint request.
 2581 |     | 
 2582 |     |         // Adjust principal of active owed M for minter.
 2583 |     |         // NOTE: When minting a present amount, round the principal up in favor of the protocol.
 2584 | *   |         principalAmount_ = _getPrincipalAmountRoundedUp(amount_);
 2585 | *   |         uint112 principalOfTotalActiveOwedM_ = principalOfTotalActiveOwedM;
 2586 |     | 
 2587 | *   |         emit MintExecuted(id_, msg.sender, principalAmount_, amount_);
 2588 |     | 
 2589 | *   |         unchecked {
 2590 | *   |             uint256 newPrincipalOfTotalActiveOwedM_ = uint256(principalOfTotalActiveOwedM_) + principalAmount_;
 2591 |     | 
 2592 |     |             // As an edge case precaution, prevent a mint that, if all owed M (active and inactive) was converted to
 2593 |     |             // a principal active amount, would overflow the `uint112 principalOfTotalActiveOwedM`.
 2594 | *   |             if (
 2595 |     |                 // NOTE: Round the principal up for worst case.
 2596 | *   |                 newPrincipalOfTotalActiveOwedM_ + _getPrincipalAmountRoundedUp(totalInactiveOwedM) >= type(uint112).max
 2597 |     |             ) {
 2598 |     |                 revert OverflowsPrincipalOfTotalOwedM();
 2599 |     |             }
 2600 |     | 
 2601 | *   |             principalOfTotalActiveOwedM = uint112(newPrincipalOfTotalActiveOwedM_);
 2602 | *   |             _rawOwedM[msg.sender] += principalAmount_; // Treat rawOwedM as principal since minter is active.
 2603 |     |         }
 2604 |     | 
 2605 | *   |         IMToken(mToken).mint(destination_, amount_);
 2606 |     | 
 2607 |     |         // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the mint
 2608 |     |         //       can result in a new rate, we should update the index here to lock in that rate.
 2609 | *   |         updateIndex();
 2610 |     |     }
 2611 |     | 
 2612 |     |     /// @inheritdoc IMinterGateway
 2613 |     |     function burnM(address minter_, uint256 maxAmount_) external returns (uint112 principalAmount_, uint240 amount_) {
 2614 |     |         (principalAmount_, amount_) = burnM(
 2615 |     |             minter_,
 2616 |     |             _getPrincipalAmountRoundedDown(UIntMath.safe240(maxAmount_)),
 2617 |     |             maxAmount_
 2618 |     |         );
 2619 |     |     }
 2620 |     | 
 2621 |     |     /// @inheritdoc IMinterGateway
 2622 |     |     function burnM(
 2623 |     |         address minter_,
 2624 |     |         uint256 maxPrincipalAmount_,
 2625 |     |         uint256 maxAmount_
 2626 |     |     ) public returns (uint112 principalAmount_, uint240 amount_) {
 2627 |     |         if (maxPrincipalAmount_ == 0 || maxAmount_ == 0) revert ZeroBurnAmount();
 2628 |     | 
 2629 |     |         MinterState storage minterState_ = _minterStates[minter_];
 2630 |     |         bool isActive_ = minterState_.isActive;
 2631 |     | 
 2632 |     |         // Revert early if minter has not been activated.
 2633 |     |         if (!isActive_ && !minterState_.isDeactivated) revert InactiveMinter();
 2634 |     | 
 2635 |     |         if (isActive_) {
 2636 |     |             // NOTE: Penalize only for missed collateral updates, not for undercollateralization.
 2637 |     |             // Undercollateralization within one update interval is forgiven.
 2638 |     |             _imposePenaltyIfMissedCollateralUpdates(minter_);
 2639 |     | 
 2640 |     |             (principalAmount_, amount_) = _repayForActiveMinter(
 2641 |     |                 minter_,
 2642 |     |                 UIntMath.safe112(maxPrincipalAmount_),
 2643 |     |                 UIntMath.safe240(maxAmount_)
 2644 |     |             );
 2645 |     | 
 2646 |     |             emit BurnExecuted(minter_, principalAmount_, amount_, msg.sender);
 2647 |     |         } else {
 2648 |     |             amount_ = _repayForDeactivatedMinter(minter_, UIntMath.safe240(maxAmount_));
 2649 |     | 
 2650 |     |             emit BurnExecuted(minter_, amount_, msg.sender);
 2651 |     |         }
 2652 |     | 
 2653 |     |         IMToken(mToken).burn(msg.sender, amount_); // Burn actual M tokens
 2654 |     | 
 2655 |     |         // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the burn
 2656 |     |         //       can result in a new rate, we should update the index here to lock in that rate.
 2657 |     |         updateIndex();
 2658 |     |     }
 2659 |     | 
 2660 |     |     /// @inheritdoc IMinterGateway
 2661 |     |     function cancelMint(address minter_, uint256 mintId_) external onlyApprovedValidator {
 2662 |     |         uint48 id_ = _mintProposals[minter_].id;
 2663 |     | 
 2664 |     |         if (id_ != mintId_ || id_ == 0) revert InvalidMintProposal();
 2665 |     | 
 2666 |     |         delete _mintProposals[minter_];
 2667 |     | 
 2668 |     |         emit MintCanceled(id_, minter_, msg.sender);
 2669 |     |     }
 2670 |     | 
 2671 |     |     /// @inheritdoc IMinterGateway
 2672 |     |     function freezeMinter(address minter_) external onlyApprovedValidator returns (uint40 frozenUntil_) {
 2673 |     |         unchecked {
 2674 |     |             _minterStates[minter_].frozenUntilTimestamp = frozenUntil_ = uint40(block.timestamp) + minterFreezeTime();
 2675 |     |         }
 2676 |     | 
 2677 |     |         emit MinterFrozen(minter_, frozenUntil_);
 2678 |     |     }
 2679 |     | 
 2680 |     |     /// @inheritdoc IMinterGateway
 2681 | *   |     function activateMinter(address minter_) external {
 2682 | *   |         if (!isMinterApproved(minter_)) revert NotApprovedMinter();
 2683 |     | 
 2684 | *   |         MinterState storage minterState_ = _minterStates[minter_];
 2685 |     | 
 2686 |     |         // NOTE: Once deactivated, a minter cannot be reactivated.
 2687 | *   |         if (minterState_.isDeactivated) revert DeactivatedMinter();
 2688 |     | 
 2689 | *   |         minterState_.isActive = true;
 2690 |     | 
 2691 | *   |         emit MinterActivated(minter_, msg.sender);
 2692 |     |     }
 2693 |     | 
 2694 |     |     /// @inheritdoc IMinterGateway
 2695 |     |     function deactivateMinter(address minter_) external onlyActiveMinter(minter_) returns (uint240 inactiveOwedM_) {
 2696 |     |         if (isMinterApproved(minter_)) revert StillApprovedMinter();
 2697 |     | 
 2698 |     |         _imposePenaltyIfMissedCollateralUpdates(minter_);
 2699 |     | 
 2700 |     |         uint112 principalOfOwedM_ = principalOfActiveOwedMOf(minter_);
 2701 |     | 
 2702 |     |         inactiveOwedM_ = _getPresentAmount(principalOfOwedM_);
 2703 |     | 
 2704 |     |         unchecked {
 2705 |     |             // Treat rawOwedM as principal since minter is active.
 2706 |     |             principalOfTotalActiveOwedM -= principalOfOwedM_;
 2707 |     |             totalInactiveOwedM += inactiveOwedM_;
 2708 |     |         }
 2709 |     | 
 2710 |     |         emit MinterDeactivated(minter_, inactiveOwedM_, msg.sender);
 2711 |     | 
 2712 |     |         // Reset reasonable aspects of minter's state
 2713 |     |         delete _minterStates[minter_];
 2714 |     |         delete _mintProposals[minter_];
 2715 |     | 
 2716 |     |         // Deactivate minter.
 2717 |     |         _minterStates[minter_].isDeactivated = true;
 2718 |     | 
 2719 |     |         _rawOwedM[minter_] = inactiveOwedM_; // Treat rawOwedM as inactive owed M since minter is now inactive.
 2720 |     | 
 2721 |     |         // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the
 2722 |     |         //       deactivation can result in a new rate, we should update the index here to lock in that rate.
 2723 |     |         updateIndex();
 2724 |     |     }
 2725 |     | 
 2726 |     |     /// @inheritdoc IContinuousIndexing
 2727 | *   |     function updateIndex() public override(IContinuousIndexing, ContinuousIndexing) returns (uint128 index_) {
 2728 |     |         // NOTE: Since the currentIndex of the Minter Gateway and mToken are constant through this context's execution
 2729 |     |         //       (the block.timestamp is not changing) we can compute excessOwedM without updating the mToken index.
 2730 | *   |         uint240 excessOwedM_ = excessOwedM();
 2731 |     | 
 2732 | *   |         if (excessOwedM_ > 0) IMToken(mToken).mint(ttgVault, excessOwedM_); // Mint M to TTG Vault.
 2733 |     | 
 2734 |     |         // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the collateral
 2735 |     |         //       update can result in a new rate, we should update the index here to lock in that rate.
 2736 |     |         // NOTE: With the current rate models, the minter rate does not depend on anything in the Minter Gateway
 2737 |     |         //       or mToken, so we can update the minter rate and index here.
 2738 | *   |         index_ = super.updateIndex(); // Update minter index and rate.
 2739 |     | 
 2740 |     |         // NOTE: Given the current implementation of the mToken transfers and its rate model, while it is possible for
 2741 |     |         //       the above mint to already have updated the mToken index if M was minted to an earning account, we want
 2742 |     |         //       to ensure the rate provided by the mToken's rate model is locked in.
 2743 | *   |         IMToken(mToken).updateIndex(); // Update earning index and rate.
 2744 |     |     }
 2745 |     | 
 2746 |     |     /* ============ View/Pure Functions ============ */
 2747 |     | 
 2748 |     |     /// @inheritdoc IMinterGateway
 2749 | *   |     function totalActiveOwedM() public view returns (uint240) {
 2750 | *   |         return _getPresentAmount(principalOfTotalActiveOwedM);
 2751 |     |     }
 2752 |     | 
 2753 |     |     /// @inheritdoc IMinterGateway
 2754 |     |     function totalOwedM() external view returns (uint240) {
 2755 |     |         unchecked {
 2756 |     |             // NOTE: This can never overflow since the `mint` functions caps the principal of total owed M (active and
 2757 |     |             //       inactive) to `type(uint112).max`. Thus, there can never be enough inactive owed M (which is an
 2758 |     |             //       accumulations principal of active owed M values converted to present values at previous and lower
 2759 |     |             //       indices) or active owed M to overflow this.
 2760 |     |             return totalActiveOwedM() + totalInactiveOwedM;
 2761 |     |         }
 2762 |     |     }
 2763 |     | 
 2764 |     |     /// @inheritdoc IMinterGateway
 2765 | *   |     function excessOwedM() public view returns (uint240 excessOwedM_) {
 2766 |     |         // NOTE: Can safely cast to `uint240` since we know M Token totalSupply constraints.
 2767 | *   |         uint240 totalMSupply_ = uint240(IMToken(mToken).totalSupply());
 2768 |     | 
 2769 | *   |         uint240 totalOwedM_ = _getPresentAmountRoundedDown(principalOfTotalActiveOwedM, currentIndex()) +
 2770 | *   |             totalInactiveOwedM;
 2771 |     | 
 2772 |     |         unchecked {
 2773 | *   |             if (totalOwedM_ > totalMSupply_) return totalOwedM_ - totalMSupply_;
 2774 |     |         }
 2775 |     |     }
 2776 |     | 
 2777 |     |     /// @inheritdoc IMinterGateway
 2778 | *   |     function minterRate() external view returns (uint32) {
 2779 | *   |         return _latestRate;
 2780 |     |     }
 2781 |     | 
 2782 |     |     /// @inheritdoc IMinterGateway
 2783 |     |     function isActiveMinter(address minter_) external view returns (bool) {
 2784 |     |         return _minterStates[minter_].isActive;
 2785 |     |     }
 2786 |     | 
 2787 |     |     /// @inheritdoc IMinterGateway
 2788 |     |     function isDeactivatedMinter(address minter_) external view returns (bool) {
 2789 |     |         return _minterStates[minter_].isDeactivated;
 2790 |     |     }
 2791 |     | 
 2792 |     |     /// @inheritdoc IMinterGateway
 2793 |     |     function isFrozenMinter(address minter_) external view returns (bool) {
 2794 |     |         return block.timestamp < _minterStates[minter_].frozenUntilTimestamp;
 2795 |     |     }
 2796 |     | 
 2797 |     |     /// @inheritdoc IMinterGateway
 2798 |     |     function principalOfActiveOwedMOf(address minter_) public view returns (uint112) {
 2799 |     |         // NOTE: This should also include the principal value of unavoidable penalities. But then it would be very, if
 2800 |     |         //       not impossible, to determine the `principalOfTotalActiveOwedM` to the same standards.
 2801 |     |         return
 2802 |     |             _minterStates[minter_].isActive
 2803 |     |                 ? uint112(_rawOwedM[minter_]) // Treat rawOwedM as principal since minter is active.
 2804 |     |                 : 0;
 2805 |     |     }
 2806 |     | 
 2807 |     |     /// @inheritdoc IMinterGateway
 2808 | *   |     function activeOwedMOf(address minter_) public view returns (uint240) {
 2809 |     |         // NOTE: This should also include the present value of unavoidable penalities. But then it would be very, if
 2810 |     |         //       not impossible, to determine the `totalActiveOwedM` to the same standards.
 2811 | *   |         return
 2812 | *   |             _minterStates[minter_].isActive
 2813 | *   |                 ? _getPresentAmount(uint112(_rawOwedM[minter_])) // Treat rawOwedM as principal since minter is active.
 2814 |     |                 : 0;
 2815 |     |     }
 2816 |     | 
 2817 |     |     /// @inheritdoc IMinterGateway
 2818 | *   |     function maxAllowedActiveOwedMOf(address minter_) public view returns (uint256) {
 2819 |     |         // NOTE: Since `mintRatio()` is capped at 650% (i.e. 65_000) this cannot overflow.
 2820 |     |         unchecked {
 2821 | *   |             return _minterStates[minter_].isActive ? (uint256(collateralOf(minter_)) * mintRatio()) / ONE : 0;
 2822 |     |         }
 2823 |     |     }
 2824 |     | 
 2825 |     |     /// @inheritdoc IMinterGateway
 2826 |     |     function inactiveOwedMOf(address minter_) public view returns (uint240) {
 2827 |     |         // Treat rawOwedM as present amount since minter is inactive.
 2828 |     |         return _minterStates[minter_].isActive ? 0 : _rawOwedM[minter_];
 2829 |     |     }
 2830 |     | 
 2831 |     |     /// @inheritdoc IMinterGateway
 2832 | *   |     function collateralOf(address minter_) public view returns (uint240) {
 2833 |     |         // If collateral was not updated by the deadline, assume that minter's collateral is zero.
 2834 | *   |         if (block.timestamp >= collateralExpiryTimestampOf(minter_)) return 0;
 2835 |     | 
 2836 |     |         MinterState storage minterState_ = _minterStates[minter_];
 2837 |     |         uint240 totalPendingRetrievals_ = minterState_.totalPendingRetrievals;
 2838 |     |         uint240 collateral_ = minterState_.collateral;
 2839 |     | 
 2840 |     |         // If the minter's total pending retrievals is greater than their collateral, then their collateral is zero.
 2841 |     |         if (totalPendingRetrievals_ >= collateral_) return 0;
 2842 |     | 
 2843 |     |         unchecked {
 2844 |     |             return collateral_ - totalPendingRetrievals_;
 2845 |     |         }
 2846 |     |     }
 2847 |     | 
 2848 |     |     /// @inheritdoc IMinterGateway
 2849 |     |     function collateralUpdateTimestampOf(address minter_) external view returns (uint40) {
 2850 |     |         return _minterStates[minter_].updateTimestamp;
 2851 |     |     }
 2852 |     | 
 2853 |     |     /// @inheritdoc IMinterGateway
 2854 |     |     function collateralPenaltyDeadlineOf(address minter_) external view returns (uint40) {
 2855 |     |         MinterState storage minterState_ = _minterStates[minter_];
 2856 |     |         uint32 updateCollateralInterval_ = updateCollateralInterval();
 2857 |     | 
 2858 |     |         (, uint40 missedUntil_) = _getMissedCollateralUpdateParameters(
 2859 |     |             minterState_.updateTimestamp,
 2860 |     |             minterState_.penalizedUntilTimestamp,
 2861 |     |             updateCollateralInterval_
 2862 |     |         );
 2863 |     | 
 2864 |     |         return missedUntil_ + updateCollateralInterval_;
 2865 |     |     }
 2866 |     | 
 2867 |     |     /// @inheritdoc IMinterGateway
 2868 | *   |     function collateralExpiryTimestampOf(address minter_) public view returns (uint40) {
 2869 |     |         unchecked {
 2870 | *   |             return _minterStates[minter_].updateTimestamp + updateCollateralInterval();
 2871 |     |         }
 2872 |     |     }
 2873 |     | 
 2874 |     |     /// @inheritdoc IMinterGateway
 2875 |     |     function penalizedUntilOf(address minter_) external view returns (uint40) {
 2876 |     |         return _minterStates[minter_].penalizedUntilTimestamp;
 2877 |     |     }
 2878 |     | 
 2879 |     |     /// @inheritdoc IMinterGateway
 2880 |     |     function latestProposedRetrievalTimestampOf(address minter_) external view returns (uint40) {
 2881 |     |         return _minterStates[minter_].latestProposedRetrievalTimestamp;
 2882 |     |     }
 2883 |     | 
 2884 |     |     /// @inheritdoc IMinterGateway
 2885 |     |     function getLastSignatureTimestamp(address minter_, address validator_) external view returns (uint256) {
 2886 |     |         return _lastSignatureTimestamp[minter_][validator_];
 2887 |     |     }
 2888 |     | 
 2889 |     |     /// @inheritdoc IMinterGateway
 2890 |     |     function getUpdateCollateralDigest(
 2891 |     |         address minter_,
 2892 |     |         uint256 collateral_,
 2893 |     |         uint256[] calldata retrievalIds_,
 2894 |     |         bytes32 metadataHash_,
 2895 |     |         uint256 timestamp_
 2896 |     |     ) external view returns (bytes32) {
 2897 |     |         return _getUpdateCollateralDigest(minter_, collateral_, retrievalIds_, metadataHash_, timestamp_);
 2898 |     |     }
 2899 |     | 
 2900 |     |     /// @inheritdoc IMinterGateway
 2901 |     |     function mintProposalOf(
 2902 |     |         address minter_
 2903 |     |     ) external view returns (uint48 mintId_, uint40 createdAt_, address destination_, uint240 amount_) {
 2904 |     |         mintId_ = _mintProposals[minter_].id;
 2905 |     |         createdAt_ = _mintProposals[minter_].createdAt;
 2906 |     |         destination_ = _mintProposals[minter_].destination;
 2907 |     |         amount_ = _mintProposals[minter_].amount;
 2908 |     |     }
 2909 |     | 
 2910 |     |     /// @inheritdoc IMinterGateway
 2911 |     |     function pendingCollateralRetrievalOf(address minter_, uint256 retrievalId_) external view returns (uint240) {
 2912 |     |         return
 2913 |     |             _minterStates[minter_].isDeactivated
 2914 |     |                 ? 0
 2915 |     |                 : _pendingCollateralRetrievals[minter_][UIntMath.safe48(retrievalId_)];
 2916 |     |     }
 2917 |     | 
 2918 |     |     /// @inheritdoc IMinterGateway
 2919 |     |     function totalPendingCollateralRetrievalOf(address minter_) external view returns (uint240) {
 2920 |     |         return _minterStates[minter_].isDeactivated ? 0 : _minterStates[minter_].totalPendingRetrievals;
 2921 |     |     }
 2922 |     | 
 2923 |     |     /// @inheritdoc IMinterGateway
 2924 |     |     function frozenUntilOf(address minter_) external view returns (uint40) {
 2925 |     |         return _minterStates[minter_].frozenUntilTimestamp;
 2926 |     |     }
 2927 |     | 
 2928 |     |     /* ============ TTG Registrar Reader Functions ============ */
 2929 |     | 
 2930 |     |     /// @inheritdoc IMinterGateway
 2931 | *   |     function isMinterApproved(address minter_) public view returns (bool) {
 2932 | *   |         return TTGRegistrarReader.isApprovedMinter(ttgRegistrar, minter_);
 2933 |     |     }
 2934 |     | 
 2935 |     |     /// @inheritdoc IMinterGateway
 2936 |     |     function isValidatorApproved(address validator_) public view returns (bool) {
 2937 |     |         return TTGRegistrarReader.isApprovedValidator(ttgRegistrar, validator_);
 2938 |     |     }
 2939 |     | 
 2940 |     |     /// @inheritdoc IMinterGateway
 2941 | *   |     function updateCollateralInterval() public view returns (uint32) {
 2942 | *   |         return
 2943 | *   |             UIntMath.max32(
 2944 | *   |                 UIntMath.bound32(TTGRegistrarReader.getUpdateCollateralInterval(ttgRegistrar)),
 2945 |     |                 MIN_UPDATE_COLLATERAL_INTERVAL
 2946 |     |             );
 2947 |     |     }
 2948 |     | 
 2949 |     |     /// @inheritdoc IMinterGateway
 2950 |     |     function updateCollateralValidatorThreshold() public view returns (uint256) {
 2951 |     |         return TTGRegistrarReader.getUpdateCollateralValidatorThreshold(ttgRegistrar);
 2952 |     |     }
 2953 |     | 
 2954 |     |     /// @inheritdoc IMinterGateway
 2955 | *   |     function mintRatio() public view returns (uint32) {
 2956 |     |         // NOTE: It is possible for the mint ratio to be greater than 100%, but capped at 650%.
 2957 | *   |         return UIntMath.min32(MAX_MINT_RATIO, UIntMath.bound32(TTGRegistrarReader.getMintRatio(ttgRegistrar)));
 2958 |     |     }
 2959 |     | 
 2960 |     |     /// @inheritdoc IMinterGateway
 2961 | *   |     function mintDelay() public view returns (uint32) {
 2962 | *   |         return UIntMath.bound32(TTGRegistrarReader.getMintDelay(ttgRegistrar));
 2963 |     |     }
 2964 |     | 
 2965 |     |     /// @inheritdoc IMinterGateway
 2966 | *   |     function mintTTL() public view returns (uint32) {
 2967 | *   |         return UIntMath.bound32(TTGRegistrarReader.getMintTTL(ttgRegistrar));
 2968 |     |     }
 2969 |     | 
 2970 |     |     /// @inheritdoc IMinterGateway
 2971 |     |     function minterFreezeTime() public view returns (uint32) {
 2972 |     |         return UIntMath.bound32(TTGRegistrarReader.getMinterFreezeTime(ttgRegistrar));
 2973 |     |     }
 2974 |     | 
 2975 |     |     /// @inheritdoc IMinterGateway
 2976 |     |     function penaltyRate() public view returns (uint32) {
 2977 |     |         return UIntMath.bound32(TTGRegistrarReader.getPenaltyRate(ttgRegistrar));
 2978 |     |     }
 2979 |     | 
 2980 |     |     /// @inheritdoc IMinterGateway
 2981 | *   |     function rateModel() public view returns (address) {
 2982 | *   |         return TTGRegistrarReader.getMinterRateModel(ttgRegistrar);
 2983 |     |     }
 2984 |     | 
 2985 |     |     /// @inheritdoc IContinuousIndexing
 2986 | *   |     function currentIndex() public view override(ContinuousIndexing, IContinuousIndexing) returns (uint128) {
 2987 |     |         // NOTE: Safe to use unchecked here, since `block.timestamp` is always greater than `latestUpdateTimestamp`.
 2988 |     |         unchecked {
 2989 | *   |             return
 2990 |     |                 // NOTE: Cap the index to `type(uint128).max` to prevent overflow in present value math.
 2991 | *   |                 UIntMath.bound128(
 2992 | *   |                     ContinuousIndexingMath.multiplyIndicesUp(
 2993 | *   |                         latestIndex,
 2994 | *   |                         ContinuousIndexingMath.getContinuousIndex(
 2995 | *   |                             ContinuousIndexingMath.convertFromBasisPoints(_latestRate),
 2996 | *   |                             uint32(block.timestamp - latestUpdateTimestamp)
 2997 |     |                         )
 2998 |     |                     )
 2999 |     |                 );
 3000 |     |         }
 3001 |     |     }
 3002 |     | 
 3003 |     |     /* ============ Internal Interactive Functions ============ */
 3004 |     | 
 3005 |     |     /**
 3006 |     |      * @dev    Imposes penalty on an active minter. Calling this for an inactive minter will break accounting.
 3007 |     |      * @param  minter_                 The address of the minter.
 3008 |     |      * @param  principalOfPenaltyBase_ The principal of the base for penalization.
 3009 |     |      * @return The principal of the imposed penalty.
 3010 |     |      */
 3011 |     |     function _imposePenalty(address minter_, uint152 principalOfPenaltyBase_) internal returns (uint112) {
 3012 |     |         if (principalOfPenaltyBase_ == 0) return 0;
 3013 |     | 
 3014 |     |         uint32 penaltyRate_ = penaltyRate();
 3015 |     | 
 3016 |     |         if (penaltyRate_ == 0) return 0;
 3017 |     | 
 3018 |     |         unchecked {
 3019 |     |             uint256 penaltyPrincipal_ = (uint256(principalOfPenaltyBase_) * penaltyRate_) / ONE;
 3020 |     | 
 3021 |     |             // As an edge case precaution, cap the penalty principal such that the resulting principal of total active
 3022 |     |             // owed M plus the penalty principal is not greater than the max uint112.
 3023 |     |             uint256 newPrincipalOfTotalActiveOwedM_ = principalOfTotalActiveOwedM + penaltyPrincipal_;
 3024 |     | 
 3025 |     |             if (newPrincipalOfTotalActiveOwedM_ > type(uint112).max) {
 3026 |     |                 penaltyPrincipal_ = type(uint112).max - principalOfTotalActiveOwedM;
 3027 |     |                 newPrincipalOfTotalActiveOwedM_ = type(uint112).max;
 3028 |     |             }
 3029 |     | 
 3030 |     |             // Calculate and add penalty principal to total minter's principal of active owed M
 3031 |     |             principalOfTotalActiveOwedM = uint112(newPrincipalOfTotalActiveOwedM_);
 3032 |     | 
 3033 |     |             _rawOwedM[minter_] += uint112(penaltyPrincipal_); // Treat rawOwedM as principal since minter is active.
 3034 |     | 
 3035 |     |             return uint112(penaltyPrincipal_);
 3036 |     |         }
 3037 |     |     }
 3038 |     | 
 3039 |     |     /**
 3040 |     |      * @dev   Imposes penalty if minter missed collateral updates.
 3041 |     |      * @param minter_ The address of the minter.
 3042 |     |      */
 3043 |     |     function _imposePenaltyIfMissedCollateralUpdates(address minter_) internal {
 3044 |     |         uint112 principalOfActiveOwedM_ = principalOfActiveOwedMOf(minter_);
 3045 |     | 
 3046 |     |         if (principalOfActiveOwedM_ == 0) return;
 3047 |     | 
 3048 |     |         MinterState storage minterState_ = _minterStates[minter_];
 3049 |     | 
 3050 |     |         (uint40 missedIntervals_, uint40 missedUntil_) = _getMissedCollateralUpdateParameters(
 3051 |     |             minterState_.updateTimestamp,
 3052 |     |             minterState_.penalizedUntilTimestamp,
 3053 |     |             updateCollateralInterval()
 3054 |     |         );
 3055 |     | 
 3056 |     |         if (missedIntervals_ == 0) return;
 3057 |     | 
 3058 |     |         // Save until when the minter has been penalized for missed intervals to prevent double penalizing them.
 3059 |     |         minterState_.penalizedUntilTimestamp = missedUntil_;
 3060 |     | 
 3061 |     |         uint112 penaltyPrincipal_ = _imposePenalty(minter_, uint152(principalOfActiveOwedM_) * missedIntervals_);
 3062 |     | 
 3063 |     |         if (penaltyPrincipal_ == 0) return;
 3064 |     | 
 3065 |     |         emit MissedIntervalsPenaltyImposed(minter_, missedIntervals_, _getPresentAmount(penaltyPrincipal_));
 3066 |     |     }
 3067 |     | 
 3068 |     |     /**
 3069 |     |      * @dev   Imposes penalty if minter is undercollateralized.
 3070 |     |      * @param minter_       The address of the minter.
 3071 |     |      * @param newTimestamp_ The timestamp of the collateral update.
 3072 |     |      */
 3073 |     |     function _imposePenaltyIfUndercollateralized(address minter_, uint40 newTimestamp_) internal {
 3074 |     |         uint112 principalOfActiveOwedM_ = principalOfActiveOwedMOf(minter_);
 3075 |     | 
 3076 |     |         if (principalOfActiveOwedM_ == 0) return;
 3077 |     | 
 3078 |     |         uint256 maxAllowedActiveOwedM_ = maxAllowedActiveOwedMOf(minter_);
 3079 |     | 
 3080 |     |         // If the minter's max allowed active owed M is greater than `type(uint240).max`, then it's definitely greater
 3081 |     |         // than the max possible active owed M for the minter, which is capped at `type(uint240).max`.
 3082 |     |         if (maxAllowedActiveOwedM_ >= type(uint240).max) return;
 3083 |     | 
 3084 |     |         // NOTE: Round the principal down in favor of the protocol since this is a max applied to the minter.
 3085 |     |         uint112 principalOfMaxAllowedActiveOwedM_ = _getPrincipalAmountRoundedDown(uint240(maxAllowedActiveOwedM_));
 3086 |     | 
 3087 |     |         // If the minter is not undercollateralized, then no penalty is imposed.
 3088 |     |         if (principalOfMaxAllowedActiveOwedM_ >= principalOfActiveOwedM_) return;
 3089 |     | 
 3090 |     |         MinterState storage minterState_ = _minterStates[minter_];
 3091 |     | 
 3092 |     |         uint40 penalizeFrom_ = UIntMath.max40(minterState_.updateTimestamp, minterState_.penalizedUntilTimestamp);
 3093 |     | 
 3094 |     |         if (newTimestamp_ <= penalizeFrom_) return;
 3095 |     | 
 3096 |     |         unchecked {
 3097 |     |             uint40 timeSpan_ = newTimestamp_ - penalizeFrom_;
 3098 |     | 
 3099 |     |             uint112 principalOfExcessOwedM_ = principalOfActiveOwedM_ - principalOfMaxAllowedActiveOwedM_;
 3100 |     | 
 3101 |     |             // NOTE: `newTimestamp_ - penalizeFrom_` will never be larger than `updateCollateralInterval_` since this
 3102 |     |             //       function is only called after `_imposePenaltyIfMissedCollateralUpdates`, which ensures that the
 3103 |     |             //       `penalizedUntilTimestamp` is within one `updateCollateralInterval_` of the `newTimestamp_`.
 3104 |     |             //
 3105 |     |             // NOTE: `updateCollateralInterval()` never equals 0, so the division is safe.
 3106 |     |             //       Its minimum is capped at `MIN_UPDATE_COLLATERAL_INTERVAL`.
 3107 |     |             uint112 penaltyPrincipal_ = _imposePenalty(
 3108 |     |                 minter_,
 3109 |     |                 (principalOfExcessOwedM_ * timeSpan_) / updateCollateralInterval()
 3110 |     |             );
 3111 |     | 
 3112 |     |             if (penaltyPrincipal_ == 0) return;
 3113 |     | 
 3114 |     |             emit UndercollateralizedPenaltyImposed(
 3115 |     |                 minter_,
 3116 |     |                 _getPresentAmount(principalOfExcessOwedM_),
 3117 |     |                 timeSpan_,
 3118 |     |                 _getPresentAmount(penaltyPrincipal_)
 3119 |     |             );
 3120 |     |         }
 3121 |     |     }
 3122 |     | 
 3123 |     |     /**
 3124 |     |      * @dev    Repays active minter's owed M.
 3125 |     |      * @param  minter_             The address of the minter.
 3126 |     |      * @param  maxPrincipalAmount_ The maximum principal amount of active owed M to repay.
 3127 |     |      * @param  maxAmount_          The maximum amount of active owed M to repay.
 3128 |     |      * @return principalAmount_    The principal amount of active owed M that was actually repaid.
 3129 |     |      * @return amount_             The amount of active owed M that was actually repaid.
 3130 |     |      */
 3131 |     |     function _repayForActiveMinter(
 3132 |     |         address minter_,
 3133 |     |         uint112 maxPrincipalAmount_,
 3134 |     |         uint240 maxAmount_
 3135 |     |     ) internal returns (uint112 principalAmount_, uint240 amount_) {
 3136 |     |         principalAmount_ = UIntMath.min112(principalOfActiveOwedMOf(minter_), maxPrincipalAmount_);
 3137 |     |         amount_ = _getPresentAmount(principalAmount_);
 3138 |     | 
 3139 |     |         if (amount_ > maxAmount_) revert ExceedsMaxRepayAmount(amount_, maxAmount_);
 3140 |     | 
 3141 |     |         unchecked {
 3142 |     |             // Treat rawOwedM as principal since `principalAmount_` would only be non-zero for an active minter.
 3143 |     |             _rawOwedM[minter_] -= principalAmount_;
 3144 |     |             principalOfTotalActiveOwedM -= principalAmount_;
 3145 |     |         }
 3146 |     |     }
 3147 |     | 
 3148 |     |     /**
 3149 |     |      * @dev    Repays deactivated minter's owed M.
 3150 |     |      * @param  minter_    The address of the minter.
 3151 |     |      * @param  maxAmount_ The maximum amount of inactive owed M to repay.
 3152 |     |      * @return amount_    The amount of inactive owed M that was actually repaid.
 3153 |     |      */
 3154 |     |     function _repayForDeactivatedMinter(address minter_, uint240 maxAmount_) internal returns (uint240 amount_) {
 3155 |     |         amount_ = UIntMath.min240(inactiveOwedMOf(minter_), maxAmount_);
 3156 |     | 
 3157 |     |         unchecked {
 3158 |     |             // Treat rawOwedM as present amount since `amount_` would only be non-zero for an inactive minter.
 3159 |     |             _rawOwedM[minter_] -= amount_;
 3160 |     |             totalInactiveOwedM -= amount_;
 3161 |     |         }
 3162 |     |     }
 3163 |     | 
 3164 |     |     /**
 3165 |     |      * @dev    Resolves the collateral retrieval IDs and updates the total pending collateral retrieval amount.
 3166 |     |      * @param  minter_                           The address of the minter.
 3167 |     |      * @param  retrievalIds_                     The list of outstanding collateral retrieval IDs to resolve.
 3168 |     |      * @return totalResolvedCollateralRetrieval_ The total amount of collateral retrieval resolved.
 3169 |     |      */
 3170 |     |     function _resolvePendingRetrievals(
 3171 |     |         address minter_,
 3172 |     |         uint256[] calldata retrievalIds_
 3173 |     |     ) internal returns (uint240 totalResolvedCollateralRetrieval_) {
 3174 |     |         for (uint256 index_; index_ < retrievalIds_.length; ++index_) {
 3175 |     |             uint48 retrievalId_ = UIntMath.safe48(retrievalIds_[index_]);
 3176 |     |             uint240 pendingCollateralRetrieval_ = _pendingCollateralRetrievals[minter_][retrievalId_];
 3177 |     | 
 3178 |     |             if (pendingCollateralRetrieval_ == 0) continue;
 3179 |     | 
 3180 |     |             unchecked {
 3181 |     |                 // NOTE: The `proposeRetrieval` function already ensures that the sum of all
 3182 |     |                 // `_pendingCollateralRetrievals` is not larger than `type(uint240).max`.
 3183 |     |                 totalResolvedCollateralRetrieval_ += pendingCollateralRetrieval_;
 3184 |     |             }
 3185 |     | 
 3186 |     |             delete _pendingCollateralRetrievals[minter_][retrievalId_];
 3187 |     | 
 3188 |     |             emit RetrievalResolved(retrievalId_, minter_);
 3189 |     |         }
 3190 |     | 
 3191 |     |         unchecked {
 3192 |     |             // NOTE: The `proposeRetrieval` function already ensures that `totalPendingRetrievals` is the sum of all
 3193 |     |             // `_pendingCollateralRetrievals`.
 3194 |     |             _minterStates[minter_].totalPendingRetrievals -= totalResolvedCollateralRetrieval_;
 3195 |     |         }
 3196 |     |     }
 3197 |     | 
 3198 |     |     /**
 3199 |     |      * @dev   Updates the collateral amount and update timestamp for the minter.
 3200 |     |      * @param minter_       The address of the minter.
 3201 |     |      * @param amount_       The amount of collateral.
 3202 |     |      * @param newTimestamp_ The timestamp of the collateral update.
 3203 |     |      */
 3204 |     |     function _updateCollateral(address minter_, uint240 amount_, uint40 newTimestamp_) internal {
 3205 |     |         MinterState storage minterState_ = _minterStates[minter_];
 3206 |     | 
 3207 |     |         // The earliest allowed timestamp for a collateral update is the maximum of:
 3208 |     |         //   - the last update timestamp,
 3209 |     |         //   - the latest proposed retrieval timestamp, and
 3210 |     |         //   - the current timestamp minus the update collateral interval.
 3211 |     |         unchecked {
 3212 |     |             // NOTE: Cannot underflow since `min40` is applied when `updateCollateralInterval()` > `block.timestamp`.
 3213 |     |             uint40 earliestAllowedTimestamp_ = UIntMath.max40(
 3214 |     |                 UIntMath.max40(minterState_.updateTimestamp, minterState_.latestProposedRetrievalTimestamp),
 3215 |     |                 uint40(block.timestamp) - UIntMath.min40(updateCollateralInterval(), uint40(block.timestamp))
 3216 |     |             );
 3217 |     | 
 3218 |     |             if (newTimestamp_ <= earliestAllowedTimestamp_) {
 3219 |     |                 revert StaleCollateralUpdate(newTimestamp_, earliestAllowedTimestamp_);
 3220 |     |             }
 3221 |     |         }
 3222 |     | 
 3223 |     |         minterState_.collateral = amount_;
 3224 |     |         minterState_.updateTimestamp = newTimestamp_;
 3225 |     |     }
 3226 |     | 
 3227 |     |     /* ============ Internal View/Pure Functions ============ */
 3228 |     | 
 3229 |     |     /**
 3230 |     |      * @dev    Returns the penalization base and the penalized until timestamp.
 3231 |     |      * @param  lastUpdateTimestamp_ The last timestamp at which the minter updated their collateral.
 3232 |     |      * @param  lastPenalizedUntil_  The timestamp before which the minter shouldn't be penalized for missed updates.
 3233 |     |      * @param  updateInterval_      The update collateral interval.
 3234 |     |      * @return missedIntervals_     The number of missed update intervals.
 3235 |     |      * @return missedUntil_         The timestamp until which `missedIntervals_` covers,
 3236 |     |      *                              even if `missedIntervals_` is 0.
 3237 |     |      */
 3238 |     |     function _getMissedCollateralUpdateParameters(
 3239 |     |         uint40 lastUpdateTimestamp_,
 3240 |     |         uint40 lastPenalizedUntil_,
 3241 |     |         uint32 updateInterval_
 3242 |     |     ) internal view returns (uint40 missedIntervals_, uint40 missedUntil_) {
 3243 |     |         uint40 penalizeFrom_ = UIntMath.max40(lastUpdateTimestamp_, lastPenalizedUntil_);
 3244 |     | 
 3245 |     |         // If brand new minter then there is no missed interval charge at all.
 3246 |     |         if (lastUpdateTimestamp_ == 0) return (0, penalizeFrom_);
 3247 |     | 
 3248 |     |         uint40 timeElapsed_ = uint40(block.timestamp) - penalizeFrom_;
 3249 |     | 
 3250 |     |         if (timeElapsed_ < updateInterval_) return (0, penalizeFrom_);
 3251 |     | 
 3252 |     |         unchecked {
 3253 |     |             // NOTE: `updateInterval_` never equals 0, so the division is safe.
 3254 |     |             //       Its minimum is capped at `MIN_UPDATE_COLLATERAL_INTERVAL`.
 3255 |     |             missedIntervals_ = timeElapsed_ / updateInterval_;
 3256 |     | 
 3257 |     |             // NOTE: Cannot really overflow a `uint40` since `missedIntervals_ * updateInterval_ <= timeElapsed_`.
 3258 |     |             missedUntil_ = penalizeFrom_ + (missedIntervals_ * updateInterval_);
 3259 |     |         }
 3260 |     |     }
 3261 |     | 
 3262 |     |     /**
 3263 |     |      * @dev    Returns the present amount (rounded up) given the principal amount, using the current index.
 3264 |     |      *         All present amounts are rounded up in favor of the protocol, since they are owed.
 3265 |     |      * @param  principalAmount_ The principal amount.
 3266 |     |      * @return The present amount.
 3267 |     |      */
 3268 | *   |     function _getPresentAmount(uint112 principalAmount_) internal view returns (uint240) {
 3269 | *   |         return _getPresentAmountRoundedUp(principalAmount_, currentIndex());
 3270 |     |     }
 3271 |     | 
 3272 |     |     /**
 3273 |     |      * @dev    Returns the EIP-712 digest for updateCollateral method.
 3274 |     |      * @param  minter_       The address of the minter.
 3275 |     |      * @param  collateral_   The amount of collateral.
 3276 |     |      * @param  retrievalIds_ The list of outstanding collateral retrieval IDs to resolve.
 3277 |     |      * @param  metadataHash_ The hash of metadata of the collateral update, reserved for future informational use.
 3278 |     |      * @param  timestamp_    The timestamp of the collateral update.
 3279 |     |      * @return The EIP-712 digest.
 3280 |     |      */
 3281 |     |     function _getUpdateCollateralDigest(
 3282 |     |         address minter_,
 3283 |     |         uint256 collateral_,
 3284 |     |         uint256[] calldata retrievalIds_,
 3285 |     |         bytes32 metadataHash_,
 3286 |     |         uint256 timestamp_
 3287 |     |     ) internal view returns (bytes32) {
 3288 |     |         return
 3289 |     |             _getDigest(
 3290 |     |                 keccak256(
 3291 |     |                     abi.encode(
 3292 |     |                         UPDATE_COLLATERAL_TYPEHASH,
 3293 |     |                         minter_,
 3294 |     |                         collateral_,
 3295 |     |                         keccak256(abi.encodePacked(retrievalIds_)),
 3296 |     |                         metadataHash_,
 3297 |     |                         timestamp_
 3298 |     |                     )
 3299 |     |                 )
 3300 |     |             );
 3301 |     |     }
 3302 |     | 
 3303 |     |     /// @dev Returns the current rate from the rate model contract.
 3304 | *   |     function _rate() internal view override returns (uint32 rate_) {
 3305 | *   |         (bool success_, bytes memory returnData_) = rateModel().staticcall(
 3306 | *   |             abi.encodeWithSelector(IRateModel.rate.selector)
 3307 |     |         );
 3308 |     | 
 3309 | *   |         rate_ = (success_ && returnData_.length >= 32) ? UIntMath.bound32(abi.decode(returnData_, (uint256))) : 0;
 3310 |     |     }
 3311 |     | 
 3312 |     |     /**
 3313 |     |      * @dev   Reverts if minter is frozen by validator.
 3314 |     |      * @param minter_ The address of the minter
 3315 |     |      */
 3316 | *   |     function _revertIfFrozenMinter(address minter_) internal view {
 3317 | *   |         if (block.timestamp < _minterStates[minter_].frozenUntilTimestamp) revert FrozenMinter();
 3318 |     |     }
 3319 |     | 
 3320 |     |     /**
 3321 |     |      * @dev   Reverts if minter is inactive.
 3322 |     |      * @param minter_ The address of the minter
 3323 |     |      */
 3324 | *   |     function _revertIfInactiveMinter(address minter_) internal view {
 3325 | *   |         if (!_minterStates[minter_].isActive) revert InactiveMinter();
 3326 |     |     }
 3327 |     | 
 3328 |     |     /**
 3329 |     |      * @dev   Reverts if validator is not approved.
 3330 |     |      * @param validator_ The address of the validator
 3331 |     |      */
 3332 |     |     function _revertIfNotApprovedValidator(address validator_) internal view {
 3333 |     |         if (!isValidatorApproved(validator_)) revert NotApprovedValidator(validator_);
 3334 |     |     }
 3335 |     | 
 3336 |     |     /**
 3337 |     |      * @dev   Reverts if minter position will be undercollateralized after changes.
 3338 |     |      * @param minter_          The address of the minter
 3339 |     |      * @param additionalOwedM_ The amount of additional owed M the action will add to minter's position
 3340 |     |      */
 3341 | *   |     function _revertIfUndercollateralized(address minter_, uint240 additionalOwedM_) internal view {
 3342 | *   |         uint256 maxAllowedActiveOwedM_ = maxAllowedActiveOwedMOf(minter_);
 3343 |     | 
 3344 | *   |         unchecked {
 3345 | *   |             uint256 finalActiveOwedM_ = uint256(activeOwedMOf(minter_)) + additionalOwedM_;
 3346 |     | 
 3347 |     |             if (finalActiveOwedM_ > maxAllowedActiveOwedM_) {
 3348 |     |                 //NOTE: remove by fuzzer, not checking collateral on this stage
 3349 |     |                 // revert Undercollateralized(finalActiveOwedM_, maxAllowedActiveOwedM_);
 3350 |     |             }
 3351 |     |         }
 3352 |     |     }
 3353 |     | 
 3354 |     |     /**
 3355 |     |      * @dev    Checks that enough valid unique signatures were provided.
 3356 |     |      * @param  minter_       The address of the minter.
 3357 |     |      * @param  collateral_   The amount of collateral.
 3358 |     |      * @param  retrievalIds_ The list of outstanding collateral retrieval IDs to resolve.
 3359 |     |      * @param  metadataHash_ The hash of metadata of the collateral update, reserved for future informational use.
 3360 |     |      * @param  validators_   The list of validators.
 3361 |     |      * @param  timestamps_   The list of validator timestamps for the collateral update signatures.
 3362 |     |      * @param  signatures_   The list of signatures.
 3363 |     |      * @return minTimestamp_ The minimum timestamp across all valid timestamps with valid signatures.
 3364 |     |      */
 3365 |     |     function _verifyValidatorSignatures(
 3366 |     |         address minter_,
 3367 |     |         uint256 collateral_,
 3368 |     |         uint256[] calldata retrievalIds_,
 3369 |     |         bytes32 metadataHash_,
 3370 |     |         address[] calldata validators_,
 3371 |     |         uint256[] calldata timestamps_,
 3372 |     |         bytes[] calldata signatures_
 3373 |     |     ) internal returns (uint40 minTimestamp_) {
 3374 |     |         minTimestamp_ = uint40(block.timestamp);
 3375 |     | 
 3376 |     |         uint256 validCount_;
 3377 |     | 
 3378 |     |         for (uint256 index_; index_ < signatures_.length; ++index_) {
 3379 |     |             unchecked {
 3380 |     |                 // Check that validator address is unique and not accounted for
 3381 |     |                 // NOTE: We revert here because this failure is entirely within the minter's control.
 3382 |     |                 if (index_ > 0 && validators_[index_] <= validators_[index_ - 1]) revert InvalidSignatureOrder();
 3383 |     |             }
 3384 |     | 
 3385 |     |             if (
 3386 |     |                 !_verifyValidatorSignature(
 3387 |     |                     minter_,
 3388 |     |                     collateral_,
 3389 |     |                     retrievalIds_,
 3390 |     |                     metadataHash_,
 3391 |     |                     validators_[index_],
 3392 |     |                     timestamps_[index_],
 3393 |     |                     signatures_[index_]
 3394 |     |                 )
 3395 |     |             ) continue;
 3396 |     | 
 3397 |     |             // Find minimum between all valid timestamps for valid signatures.
 3398 |     |             minTimestamp_ = UIntMath.min40(minTimestamp_, uint40(timestamps_[index_]));
 3399 |     | 
 3400 |     |             unchecked {
 3401 |     |                 ++validCount_;
 3402 |     |             }
 3403 |     |         }
 3404 |     | 
 3405 |     |         uint256 requiredThreshold_ = updateCollateralValidatorThreshold();
 3406 |     | 
 3407 |     |         if (validCount_ < requiredThreshold_) revert NotEnoughValidSignatures(validCount_, requiredThreshold_);
 3408 |     |     }
 3409 |     | 
 3410 |     |     /**
 3411 |     |      * @dev    Checks that a signature is a valid validator signature.
 3412 |     |      * @param  minter_       The address of the minter.
 3413 |     |      * @param  collateral_   The amount of collateral.
 3414 |     |      * @param  retrievalIds_ The list of outstanding collateral retrieval IDs to resolve.
 3415 |     |      * @param  metadataHash_ The hash of metadata of the collateral update, reserved for future informational use.
 3416 |     |      * @param  validator_    The address of a validator.
 3417 |     |      * @param  timestamp_    The timestamp for the collateral update signature.
 3418 |     |      * @param  signature_    The signature from the validator.
 3419 |     |      * @return Whether the signature is a valid validator signature or not.
 3420 |     |      */
 3421 |     |     function _verifyValidatorSignature(
 3422 |     |         address minter_,
 3423 |     |         uint256 collateral_,
 3424 |     |         uint256[] calldata retrievalIds_,
 3425 |     |         bytes32 metadataHash_,
 3426 |     |         address validator_,
 3427 |     |         uint256 timestamp_,
 3428 |     |         bytes calldata signature_
 3429 |     |     ) internal returns (bool) {
 3430 |     |         // Check that the timestamp is not 0.
 3431 |     |         // NOTE: Revert here because this failure is entirely within the minter's control.
 3432 |     |         if (timestamp_ == 0) revert ZeroTimestamp();
 3433 |     | 
 3434 |     |         // Check that the timestamp is not in the future.
 3435 |     |         // NOTE: Revert here because this failure is entirely within the minter's control.
 3436 |     |         if (timestamp_ > uint40(block.timestamp)) revert FutureTimestamp();
 3437 |     | 
 3438 |     |         uint256 lastTimestamp_ = _lastSignatureTimestamp[minter_][validator_];
 3439 |     | 
 3440 |     |         // Check that the timestamp is not older than the last signature timestamp.
 3441 |     |         // NOTE: Revert here because this failure is entirely within the minter's control.
 3442 |     |         if (timestamp_ <= lastTimestamp_) revert OutdatedValidatorTimestamp(validator_, timestamp_, lastTimestamp_);
 3443 |     | 
 3444 |     |         // Check that validator is approved by TTG.
 3445 |     |         if (!isValidatorApproved(validator_)) return false;
 3446 |     | 
 3447 |     |         // Check that ECDSA or ERC1271 signatures for given digest are valid.
 3448 |     |         if (
 3449 |     |             !SignatureChecker.isValidSignature(
 3450 |     |                 validator_,
 3451 |     |                 _getUpdateCollateralDigest(minter_, collateral_, retrievalIds_, metadataHash_, timestamp_),
 3452 |     |                 signature_
 3453 |     |             )
 3454 |     |         ) return false;
 3455 |     | 
 3456 |     |         // Save the last signature timestamp for the minter and validator combination.
 3457 |     |         _lastSignatureTimestamp[minter_][validator_] = timestamp_;
 3458 |     | 
 3459 |     |         return true;
 3460 |     |     }
 3461 |     | }
 3462 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/MockERC20.sol
   1 |     | //SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | // From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol
   5 |     | // Subject to the MIT license.
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Wrappers over Solidity's arithmetic operations with added overflow
   9 |     |  * checks.
  10 |     |  *
  11 |     |  * Arithmetic operations in Solidity wrap on overflow. This can easily result
  12 |     |  * in bugs, because programmers usually assume that an overflow raises an
  13 |     |  * error, which is the standard behavior in high level programming languages.
  14 |     |  * `SafeMath` restores this intuition by reverting the transaction when an
  15 |     |  * operation overflows.
  16 |     |  *
  17 |     |  * Using this library instead of the unchecked operations eliminates an entire
  18 |     |  * class of bugs, so it's recommended to use it always.
  19 |     |  */
  20 |     | library SafeMath {
  21 |     |     /**
  22 |     |      * @dev Returns the addition of two unsigned integers, reverting on overflow.
  23 |     |      *
  24 |     |      * Counterpart to Solidity's `+` operator.
  25 |     |      *
  26 |     |      * Requirements:
  27 |     |      * - Addition cannot overflow.
  28 |     |      */
  29 | *   |     function add(uint256 a, uint256 b) internal pure returns (uint256) {
  30 | *   |         uint256 c = a + b;
  31 | *   |         require(c >= a, "SafeMath: addition overflow");
  32 |     | 
  33 | *   |         return c;
  34 |     |     }
  35 |     | 
  36 |     |     /**
  37 |     |      * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.
  38 |     |      *
  39 |     |      * Counterpart to Solidity's `+` operator.
  40 |     |      *
  41 |     |      * Requirements:
  42 |     |      * - Addition cannot overflow.
  43 |     |      */
  44 |     |     function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
  45 |     |         uint256 c = a + b;
  46 |     |         require(c >= a, errorMessage);
  47 |     | 
  48 |     |         return c;
  49 |     |     }
  50 |     | 
  51 |     |     /**
  52 |     |      * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).
  53 |     |      *
  54 |     |      * Counterpart to Solidity's `-` operator.
  55 |     |      *
  56 |     |      * Requirements:
  57 |     |      * - Subtraction cannot underflow.
  58 |     |      */
  59 |     |     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
  60 |     |         return sub(a, b, "SafeMath: subtraction underflow");
  61 |     |     }
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).
  65 |     |      *
  66 |     |      * Counterpart to Solidity's `-` operator.
  67 |     |      *
  68 |     |      * Requirements:
  69 |     |      * - Subtraction cannot underflow.
  70 |     |      */
  71 | *   |     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
  72 | *   |         require(b <= a, errorMessage);
  73 | *   |         uint256 c = a - b;
  74 |     | 
  75 | *   |         return c;
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev Returns the multiplication of two unsigned integers, reverting on overflow.
  80 |     |      *
  81 |     |      * Counterpart to Solidity's `*` operator.
  82 |     |      *
  83 |     |      * Requirements:
  84 |     |      * - Multiplication cannot overflow.
  85 |     |      */
  86 |     |     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
  87 |     |         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
  88 |     |         // benefit is lost if 'b' is also tested.
  89 |     |         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
  90 |     |         if (a == 0) {
  91 |     |             return 0;
  92 |     |         }
  93 |     | 
  94 |     |         uint256 c = a * b;
  95 |     |         require(c / a == b, "SafeMath: multiplication overflow");
  96 |     | 
  97 |     |         return c;
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Returns the multiplication of two unsigned integers, reverting on overflow.
 102 |     |      *
 103 |     |      * Counterpart to Solidity's `*` operator.
 104 |     |      *
 105 |     |      * Requirements:
 106 |     |      * - Multiplication cannot overflow.
 107 |     |      */
 108 |     |     function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
 109 |     |         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
 110 |     |         // benefit is lost if 'b' is also tested.
 111 |     |         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
 112 |     |         if (a == 0) {
 113 |     |             return 0;
 114 |     |         }
 115 |     | 
 116 |     |         uint256 c = a * b;
 117 |     |         require(c / a == b, errorMessage);
 118 |     | 
 119 |     |         return c;
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Returns the integer division of two unsigned integers.
 124 |     |      * Reverts on division by zero. The result is rounded towards zero.
 125 |     |      *
 126 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
 127 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
 128 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
 129 |     |      *
 130 |     |      * Requirements:
 131 |     |      * - The divisor cannot be zero.
 132 |     |      */
 133 |     |     function div(uint256 a, uint256 b) internal pure returns (uint256) {
 134 |     |         return div(a, b, "SafeMath: division by zero");
 135 |     |     }
 136 |     | 
 137 |     |     /**
 138 |     |      * @dev Returns the integer division of two unsigned integers.
 139 |     |      * Reverts with custom message on division by zero. The result is rounded towards zero.
 140 |     |      *
 141 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
 142 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
 143 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
 144 |     |      *
 145 |     |      * Requirements:
 146 |     |      * - The divisor cannot be zero.
 147 |     |      */
 148 |     |     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
 149 |     |         // Solidity only automatically asserts when dividing by 0
 150 |     |         require(b > 0, errorMessage);
 151 |     |         uint256 c = a / b;
 152 |     |         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
 153 |     | 
 154 |     |         return c;
 155 |     |     }
 156 |     | 
 157 |     |     /**
 158 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 159 |     |      * Reverts when dividing by zero.
 160 |     |      *
 161 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 162 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 163 |     |      * invalid opcode to revert (consuming all remaining gas).
 164 |     |      *
 165 |     |      * Requirements:
 166 |     |      * - The divisor cannot be zero.
 167 |     |      */
 168 |     |     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
 169 |     |         return mod(a, b, "SafeMath: modulo by zero");
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 174 |     |      * Reverts with custom message when dividing by zero.
 175 |     |      *
 176 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 177 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 178 |     |      * invalid opcode to revert (consuming all remaining gas).
 179 |     |      *
 180 |     |      * Requirements:
 181 |     |      * - The divisor cannot be zero.
 182 |     |      */
 183 |     |     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
 184 |     |         require(b != 0, errorMessage);
 185 |     |         return a % b;
 186 |     |     }
 187 |     | }
 188 |     | 
 189 | *   | contract MockERC20 {
 190 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 191 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 192 |     | 
 193 |     |     using SafeMath for uint256;
 194 |     | 
 195 |     |     mapping(address => uint256) internal _balances;
 196 |     | 
 197 |     |     mapping(address => mapping(address => uint256)) internal _allowances;
 198 |     | 
 199 |     |     uint256 internal _totalSupply;
 200 |     | 
 201 |     |     string internal _name;
 202 |     |     string internal _symbol;
 203 |     |     uint8 internal _decimals;
 204 |     | 
 205 | *   |     constructor(string memory name, string memory symbol, uint8 decimals) public {
 206 | *   |         _name = name;
 207 | *   |         _symbol = symbol;
 208 | *   |         _decimals = decimals;
 209 |     |         // _decimals = 18; //NOTE: changed by fuzzer
 210 |     |     }
 211 |     | 
 212 |     |     function name() external view returns (string memory) {
 213 |     |         return _name;
 214 |     |     }
 215 |     | 
 216 |     |     function symbol() external view returns (string memory) {
 217 |     |         return _symbol;
 218 |     |     }
 219 |     | 
 220 | *   |     function decimals() external view returns (uint8) {
 221 | *   |         return _decimals;
 222 |     |     }
 223 |     | 
 224 |     |     function totalSupply() external view returns (uint256) {
 225 |     |         return _totalSupply;
 226 |     |     }
 227 |     | 
 228 | *   |     function balanceOf(address account) external view returns (uint256) {
 229 | *   |         return _balances[account];
 230 |     |     }
 231 |     | 
 232 | *   |     function transfer(address to, uint256 amount) external returns (bool) {
 233 | *   |         _transfer(msg.sender, to, amount);
 234 | *   |         return true;
 235 |     |     }
 236 |     | 
 237 |     |     function allowance(address owner, address spender) external view returns (uint256) {
 238 |     |         return _allowances[owner][spender];
 239 |     |     }
 240 |     | 
 241 | *   |     function approve(address spender, uint256 amount) external returns (bool) {
 242 | *   |         _approve(msg.sender, spender, amount);
 243 | *   |         return true;
 244 |     |     }
 245 |     | 
 246 | *   |     function transferFrom(address from, address to, uint256 amount) external returns (bool) {
 247 | *   |         _transfer(from, to, amount);
 248 | *   |         _approve(
 249 | *   |             from,
 250 | *   |             msg.sender,
 251 | *   |             _allowances[from][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance")
 252 |     |         );
 253 | *   |         return true;
 254 |     |     }
 255 |     | 
 256 | *   |     function mint(address account, uint256 amount) external {
 257 | *   |         _mint(account, amount);
 258 |     |     }
 259 |     | 
 260 |     |     function burn(address account, uint256 amount) external {
 261 |     |         _burn(account, amount);
 262 |     |     }
 263 |     | 
 264 |     |     function setDecimals(uint8 decimals) external {
 265 |     |         _decimals = decimals;
 266 |     |     }
 267 |     | 
 268 | *   |     function _transfer(address from, address to, uint256 amount) internal {
 269 | *   |         _balances[from] = _balances[from].sub(amount, "ERC20: transfer amount exceeds balance");
 270 | *   |         _balances[to] = _balances[to].add(amount);
 271 | *   |         emit Transfer(from, to, amount);
 272 |     |     }
 273 |     | 
 274 | *   |     function _mint(address account, uint256 amount) internal {
 275 | *   |         _totalSupply = _totalSupply.add(amount);
 276 | *   |         _balances[account] = _balances[account].add(amount);
 277 | *   |         emit Transfer(address(0), account, amount);
 278 |     |     }
 279 |     | 
 280 |     |     function _burn(address account, uint256 amount) internal {
 281 |     |         _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
 282 |     |         _totalSupply = _totalSupply.sub(amount);
 283 |     |         emit Transfer(account, address(0), amount);
 284 |     |     }
 285 |     | 
 286 | *   |     function _approve(address owner, address spender, uint256 amount) internal {
 287 | *   |         _allowances[owner][spender] = amount;
 288 | *   |         emit Approval(owner, spender, amount);
 289 |     |     }
 290 |     | }
 291 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/MockRegistar.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 | *   | contract MockRegistrar {
  5 | *   |     constructor(address vault_) {
  6 | *   |         vault = vault_;
  7 |     |     }
  8 |     | 
  9 | *   |     address public vault;
 10 |     | 
 11 |     |     bytes32 public constant EARNERS_LIST_NAME = "earners";
 12 |     |     bytes32 internal constant EARNERS_LIST_IGNORED = "earners_list_ignored";
 13 |     | 
 14 |     |     mapping(bytes32 key => bytes32 value) internal _values;
 15 |     | 
 16 |     |     mapping(bytes32 listName => mapping(address account => bool contains)) public listContainsMap;
 17 |     | 
 18 | *   |     function listContains(bytes32 listName, address account) external view returns (bool contains) {
 19 | *   |         return true; //mock approved minter
 20 |     |     }
 21 |     | 
 22 | *   |     function get(bytes32 key) external view returns (bytes32 value) {
 23 | *   |         if (key == EARNERS_LIST_IGNORED) {
 24 | *   |             return bytes32(uint256(1));
 25 |     |         }
 26 | *   |         return _values[key];
 27 |     |     }
 28 |     | 
 29 | *   |     function set(bytes32 key, bytes32 value) external {
 30 | *   |         _values[key] = value;
 31 |     |     }
 32 |     | 
 33 | *   |     function setEarner(address account, bool contains) external {
 34 | *   |         listContainsMap[EARNERS_LIST_NAME][account] = contains;
 35 |     |     }
 36 |     | 
 37 | *   |     function updateConfig(bytes32 key_, address value_) external {
 38 | *   |         _values[key_] = bytes32(uint256(uint160(value_)));
 39 |     |     }
 40 |     | 
 41 | *   |     function updateConfig(bytes32 key_, uint256 value_) external {
 42 | *   |         _values[key_] = bytes32(value_);
 43 |     |     }
 44 |     | 
 45 |     |     function updateConfig(bytes32 key_, bytes32 value_) external {
 46 |     |         _values[key_] = value_;
 47 |     |     }
 48 |     | }
 49 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/WrappedMToken.f.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity ^0.8.0;
    3 |     | 
    4 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/libs/Bytes32String.sol
    5 |     | 
    6 |     | /**
    7 |     |  * @title  A library to convert between string and bytes32 (assuming 32 characters or less).
    8 |     |  * @author M^0 Labs
    9 |     |  */
   10 |     | library Bytes32String {
   11 | *   |     function toBytes32(string memory input_) internal pure returns (bytes32) {
   12 | *   |         return bytes32(abi.encodePacked(input_));
   13 |     |     }
   14 |     | 
   15 | *   |     function toString(bytes32 input_) internal pure returns (string memory) {
   16 | *   |         uint256 length_;
   17 |     | 
   18 | *   |         while (length_ < 32 && uint8(input_[length_]) != 0) {
   19 | *   |             ++length_;
   20 |     |         }
   21 |     | 
   22 | *   |         bytes memory name_ = new bytes(length_);
   23 |     | 
   24 | *   |         for (uint256 index_; index_ < length_; ++index_) {
   25 | *   |             name_[index_] = input_[index_];
   26 |     |         }
   27 |     | 
   28 | *   |         return string(name_);
   29 |     |     }
   30 |     | }
   31 |     | 
   32 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/interfaces/IERC1271.sol
   33 |     | 
   34 |     | /**
   35 |     |  * @title  Standard Signature Validation Method for Contracts via EIP-1271.
   36 |     |  * @author M^0 Labs
   37 |     |  * @dev    The interface as defined by EIP-1271: https://eips.ethereum.org/EIPS/eip-1271
   38 |     |  */
   39 |     | interface IERC1271 {
   40 |     |     /**
   41 |     |      * @dev    Returns a specific magic value if the provided signature is valid for the provided digest.
   42 |     |      * @param  digest     Hash of the data purported to have been signed.
   43 |     |      * @param  signature  Signature byte array associated with the digest.
   44 |     |      * @return magicValue Magic value 0x1626ba7e if the signature is valid.
   45 |     |      */
   46 |     |     function isValidSignature(bytes32 digest, bytes memory signature) external view returns (bytes4 magicValue);
   47 |     | }
   48 |     | 
   49 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/interfaces/IERC20.sol
   50 |     | 
   51 |     | /**
   52 |     |  * @title  ERC20 Token Standard.
   53 |     |  * @author M^0 Labs
   54 |     |  * @dev    The interface as defined by EIP-20: https://eips.ethereum.org/EIPS/eip-20
   55 |     |  */
   56 |     | interface IERC20 {
   57 |     |     /* ============ Events ============ */
   58 |     | 
   59 |     |     /**
   60 |     |      * @notice Emitted when `spender` has been approved for `amount` of the token balance of `account`.
   61 |     |      * @param  account The address of the account.
   62 |     |      * @param  spender The address of the spender being approved for the allowance.
   63 |     |      * @param  amount  The amount of the allowance being approved.
   64 |     |      */
   65 |     |     event Approval(address indexed account, address indexed spender, uint256 amount);
   66 |     | 
   67 |     |     /**
   68 |     |      * @notice Emitted when `amount` tokens is transferred from `sender` to `recipient`.
   69 |     |      * @param  sender    The address of the sender who's token balance is decremented.
   70 |     |      * @param  recipient The address of the recipient who's token balance is incremented.
   71 |     |      * @param  amount    The amount of tokens being transferred.
   72 |     |      */
   73 |     |     event Transfer(address indexed sender, address indexed recipient, uint256 amount);
   74 |     | 
   75 |     |     /* ============ Interactive Functions ============ */
   76 |     | 
   77 |     |     /**
   78 |     |      * @notice Allows a calling account to approve `spender` to spend up to `amount` of its token balance.
   79 |     |      * @dev    MUST emit an `Approval` event.
   80 |     |      * @param  spender The address of the account being allowed to spend up to the allowed amount.
   81 |     |      * @param  amount  The amount of the allowance being approved.
   82 |     |      * @return Whether or not the approval was successful.
   83 |     |      */
   84 |     |     function approve(address spender, uint256 amount) external returns (bool);
   85 |     | 
   86 |     |     /**
   87 |     |      * @notice Allows a calling account to transfer `amount` tokens to `recipient`.
   88 |     |      * @param  recipient The address of the recipient who's token balance will be incremented.
   89 |     |      * @param  amount    The amount of tokens being transferred.
   90 |     |      * @return Whether or not the transfer was successful.
   91 |     |      */
   92 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
   93 |     | 
   94 |     |     /**
   95 |     |      * @notice Allows a calling account to transfer `amount` tokens from `sender`, with allowance, to a `recipient`.
   96 |     |      * @param  sender    The address of the sender who's token balance will be decremented.
   97 |     |      * @param  recipient The address of the recipient who's token balance will be incremented.
   98 |     |      * @param  amount    The amount of tokens being transferred.
   99 |     |      * @return Whether or not the transfer was successful.
  100 |     |      */
  101 |     |     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
  102 |     | 
  103 |     |     /* ============ View/Pure Functions ============ */
  104 |     | 
  105 |     |     /**
  106 |     |      * @notice Returns the allowance `spender` is allowed to spend on behalf of `account`.
  107 |     |      * @param  account The address of the account who's token balance `spender` is allowed to spend.
  108 |     |      * @param  spender The address of an account allowed to spend on behalf of `account`.
  109 |     |      * @return The amount `spender` can spend on behalf of `account`.
  110 |     |      */
  111 |     |     function allowance(address account, address spender) external view returns (uint256);
  112 |     | 
  113 |     |     /**
  114 |     |      * @notice Returns the token balance of `account`.
  115 |     |      * @param  account The address of some account.
  116 |     |      * @return The token balance of `account`.
  117 |     |      */
  118 |     |     function balanceOf(address account) external view returns (uint256);
  119 |     | 
  120 |     |     /// @notice Returns the number of decimals UIs should assume all amounts have.
  121 |     |     function decimals() external view returns (uint8);
  122 |     | 
  123 |     |     /// @notice Returns the name of the contract/token.
  124 |     |     function name() external view returns (string memory);
  125 |     | 
  126 |     |     /// @notice Returns the symbol of the token.
  127 |     |     function symbol() external view returns (string memory);
  128 |     | 
  129 |     |     /// @notice Returns the current total supply of the token.
  130 |     |     function totalSupply() external view returns (uint256);
  131 |     | }
  132 |     | 
  133 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/interfaces/IERC712.sol
  134 |     | 
  135 |     | /**
  136 |     |  * @title  Typed structured data hashing and signing via EIP-712.
  137 |     |  * @author M^0 Labs
  138 |     |  * @dev    The interface as defined by EIP-712: https://eips.ethereum.org/EIPS/eip-712
  139 |     |  */
  140 |     | interface IERC712 {
  141 |     |     /* ============ Custom Errors ============ */
  142 |     | 
  143 |     |     /// @notice Revert message when an invalid signature is detected.
  144 |     |     error InvalidSignature();
  145 |     | 
  146 |     |     /// @notice Revert message when a signature with invalid length is detected.
  147 |     |     error InvalidSignatureLength();
  148 |     | 
  149 |     |     /// @notice Revert message when the S portion of a signature is invalid.
  150 |     |     error InvalidSignatureS();
  151 |     | 
  152 |     |     /// @notice Revert message when the V portion of a signature is invalid.
  153 |     |     error InvalidSignatureV();
  154 |     | 
  155 |     |     /**
  156 |     |      * @notice Revert message when a signature is being used beyond its deadline (i.e. expiry).
  157 |     |      * @param  deadline  The deadline of the signature.
  158 |     |      * @param  timestamp The current timestamp.
  159 |     |      */
  160 |     |     error SignatureExpired(uint256 deadline, uint256 timestamp);
  161 |     | 
  162 |     |     /// @notice Revert message when a recovered signer does not match the account being purported to have signed.
  163 |     |     error SignerMismatch();
  164 |     | 
  165 |     |     /* ============ View/Pure Functions ============ */
  166 |     | 
  167 |     |     /// @notice Returns the EIP712 domain separator used in the encoding of a signed digest.
  168 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
  169 |     | }
  170 |     | 
  171 |     | // test/fuzzing/mocks/wrappedMToken.sol/src/interfaces/IMTokenLike.sol
  172 |     | 
  173 |     | /**
  174 |     |  * @title  Subset of M Token interface required for source contracts.
  175 |     |  * @author M^0 Labs
  176 |     |  */
  177 |     | interface IMTokenLike {
  178 |     |     /* ============ Interactive Functions ============ */
  179 |     | 
  180 |     |     /**
  181 |     |      * @notice Allows a calling account to transfer `amount` tokens to `recipient`.
  182 |     |      * @param  recipient The address of the recipient who's token balance will be incremented.
  183 |     |      * @param  amount    The amount of tokens being transferred.
  184 |     |      * @return success   Whether or not the transfer was successful.
  185 |     |      */
  186 |     |     function transfer(address recipient, uint256 amount) external returns (bool success);
  187 |     | 
  188 |     |     /**
  189 |     |      * @notice Allows a calling account to transfer `amount` tokens from `sender`, with allowance, to a `recipient`.
  190 |     |      * @param  sender    The address of the sender who's token balance will be decremented.
  191 |     |      * @param  recipient The address of the recipient who's token balance will be incremented.
  192 |     |      * @param  amount    The amount of tokens being transferred.
  193 |     |      * @return success   Whether or not the transfer was successful.
  194 |     |      */
  195 |     |     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool success);
  196 |     | 
  197 |     |     /// @notice Starts earning for caller if allowed by TTG.
  198 |     |     function startEarning() external;
  199 |     | 
  200 |     |     /// @notice Stops earning for caller.
  201 |     |     function stopEarning() external;
  202 |     | 
  203 |     |     /* ============ View/Pure Functions ============ */
  204 |     | 
  205 |     |     /**
  206 |     |      * @notice Checks if account is an earner.
  207 |     |      * @param  account The account to check.
  208 |     |      * @return earning True if account is an earner, false otherwise.
  209 |     |      */
  210 |     |     function isEarning(address account) external view returns (bool earning);
  211 |     | 
  212 |     |     /**
  213 |     |      * @notice Returns the token balance of `account`.
  214 |     |      * @param  account The address of some account.
  215 |     |      * @return balance The token balance of `account`.
  216 |     |      */
  217 |     |     function balanceOf(address account) external view returns (uint256 balance);
  218 |     | 
  219 |     |     /// @notice The current index that would be written to storage if `updateIndex` is called.
  220 |     |     function currentIndex() external view returns (uint128 currentIndex);
  221 |     | 
  222 |     |     /// @notice The address of the TTG Registrar contract.
  223 |     |     function ttgRegistrar() external view returns (address ttgRegistrar);
  224 |     | }
  225 |     | 
  226 |     | // test/fuzzing/mocks/wrappedMToken.sol/src/interfaces/IMigratable.sol
  227 |     | 
  228 |     | /**
  229 |     |  * @title  Interface for exposing the ability to migrate a contract, extending the ERC-1967 interface.
  230 |     |  * @author M^0 Labs
  231 |     |  */
  232 |     | interface IMigratable {
  233 |     |     /* ============ Events ============ */
  234 |     | 
  235 |     |     /**
  236 |     |      * @notice Emitted when a migration to a new implementation is performed.
  237 |     |      * @param  migrator          The address that performed the migration.
  238 |     |      * @param  oldImplementation The address of the old implementation.
  239 |     |      * @param  newImplementation The address of the new implementation.
  240 |     |      */
  241 |     |     event Migrated(address indexed migrator, address indexed oldImplementation, address indexed newImplementation);
  242 |     | 
  243 |     |     /**
  244 |     |      * @notice Emitted when the implementation address for the proxy is changed.
  245 |     |      * @param  implementation The address of the new implementation for the proxy.
  246 |     |      */
  247 |     |     event Upgraded(address indexed implementation);
  248 |     | 
  249 |     |     /// @notice Emitted when calling `stopEarning` for an account approved as earner by TTG.
  250 |     |     error InvalidMigrator();
  251 |     | 
  252 |     |     /// @notice Emitted when the delegatecall to a migrator fails.
  253 |     |     error MigrationFailed();
  254 |     | 
  255 |     |     /// @notice Emitted when the zero address is passed as a migrator.
  256 |     |     error ZeroMigrator();
  257 |     | 
  258 |     |     /* ============ Interactive Functions ============ */
  259 |     | 
  260 |     |     /// @notice Performs an arbitrarily defined migration.
  261 |     |     function migrate() external;
  262 |     | 
  263 |     |     /* ============ View/Pure Functions ============ */
  264 |     | 
  265 |     |     /// @notice Returns the address of the current implementation contract.
  266 |     |     function implementation() external view returns (address implementation);
  267 |     | }
  268 |     | 
  269 |     | // test/fuzzing/mocks/wrappedMToken.sol/src/interfaces/IRegistrarLike.sol
  270 |     | 
  271 |     | /**
  272 |     |  * @title  Subset of Registrar interface required for source contracts.
  273 |     |  * @author M^0 Labs
  274 |     |  */
  275 |     | interface IRegistrarLike {
  276 |     |     /* ============ View/Pure Functions ============ */
  277 |     | 
  278 |     |     /**
  279 |     |      * @notice Returns the value of `key`.
  280 |     |      * @param  key   Some key.
  281 |     |      * @return value Some value.
  282 |     |      */
  283 |     |     function get(bytes32 key) external view returns (bytes32 value);
  284 |     | 
  285 |     |     /**
  286 |     |      * @notice Returns whether `list` contains `account` or not.
  287 |     |      * @param  list     The key for some list.
  288 |     |      * @param  account  The address of some account.
  289 |     |      * @return contains Whether `list` contains `account` or not.
  290 |     |      */
  291 |     |     function listContains(bytes32 list, address account) external view returns (bool contains);
  292 |     | 
  293 |     |     /// @notice Returns the address of the Vault.
  294 |     |     function vault() external view returns (address vault);
  295 |     | }
  296 |     | 
  297 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/libs/UIntMath.sol
  298 |     | 
  299 |     | /**
  300 |     |  * @title  Library to perform safe math operations on uint types
  301 |     |  * @author M^0 Labs
  302 |     |  */
  303 |     | library UIntMath {
  304 |     |     /* ============ Custom Errors ============ */
  305 |     | 
  306 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint16.
  307 |     |     error InvalidUInt16();
  308 |     | 
  309 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint40.
  310 |     |     error InvalidUInt40();
  311 |     | 
  312 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint48.
  313 |     |     error InvalidUInt48();
  314 |     | 
  315 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint112.
  316 |     |     error InvalidUInt112();
  317 |     | 
  318 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint128.
  319 |     |     error InvalidUInt128();
  320 |     | 
  321 |     |     /// @notice Emitted when a passed value is greater than the maximum value of uint240.
  322 |     |     error InvalidUInt240();
  323 |     | 
  324 |     |     /* ============ Internal View/Pure Functions ============ */
  325 |     | 
  326 |     |     /**
  327 |     |      * @notice Casts a given uint256 value to a uint16,
  328 |     |      *         ensuring that it is less than or equal to the maximum uint16 value.
  329 |     |      * @param  n The value to check.
  330 |     |      * @return The value casted to uint16.
  331 |     |      */
  332 |     |     function safe16(uint256 n) internal pure returns (uint16) {
  333 |     |         if (n > type(uint16).max) revert InvalidUInt16();
  334 |     |         return uint16(n);
  335 |     |     }
  336 |     | 
  337 |     |     /**
  338 |     |      * @notice Casts a given uint256 value to a uint40,
  339 |     |      *         ensuring that it is less than or equal to the maximum uint40 value.
  340 |     |      * @param  n The value to check.
  341 |     |      * @return The value casted to uint40.
  342 |     |      */
  343 |     |     function safe40(uint256 n) internal pure returns (uint40) {
  344 |     |         if (n > type(uint40).max) revert InvalidUInt40();
  345 |     |         return uint40(n);
  346 |     |     }
  347 |     | 
  348 |     |     /**
  349 |     |      * @notice Casts a given uint256 value to a uint48,
  350 |     |      *         ensuring that it is less than or equal to the maximum uint48 value.
  351 |     |      * @param  n The value to check.
  352 |     |      * @return The value casted to uint48.
  353 |     |      */
  354 |     |     function safe48(uint256 n) internal pure returns (uint48) {
  355 |     |         if (n > type(uint48).max) revert InvalidUInt48();
  356 |     |         return uint48(n);
  357 |     |     }
  358 |     | 
  359 |     |     /**
  360 |     |      * @notice Casts a given uint256 value to a uint112,
  361 |     |      *         ensuring that it is less than or equal to the maximum uint112 value.
  362 |     |      * @param  n The value to check.
  363 |     |      * @return The value casted to uint112.
  364 |     |      */
  365 |     |     function safe112(uint256 n) internal pure returns (uint112) {
  366 |     |         if (n > type(uint112).max) revert InvalidUInt112();
  367 |     |         return uint112(n);
  368 |     |     }
  369 |     | 
  370 |     |     /**
  371 |     |      * @notice Casts a given uint256 value to a uint128,
  372 |     |      *         ensuring that it is less than or equal to the maximum uint128 value.
  373 |     |      * @param  n The value to check.
  374 |     |      * @return The value casted to uint128.
  375 |     |      */
  376 |     |     function safe128(uint256 n) internal pure returns (uint128) {
  377 |     |         if (n > type(uint128).max) revert InvalidUInt128();
  378 |     |         return uint128(n);
  379 |     |     }
  380 |     | 
  381 |     |     /**
  382 |     |      * @notice Casts a given uint256 value to a uint240,
  383 |     |      *         ensuring that it is less than or equal to the maximum uint240 value.
  384 |     |      * @param  n The value to check.
  385 |     |      * @return The value casted to uint240.
  386 |     |      */
  387 | *   |     function safe240(uint256 n) internal pure returns (uint240) {
  388 | *   |         if (n > type(uint240).max) revert InvalidUInt240();
  389 | *   |         return uint240(n);
  390 |     |     }
  391 |     | 
  392 |     |     /**
  393 |     |      * @notice Limits a given uint256 value to the maximum uint32 value.
  394 |     |      * @param  n The value to check.
  395 |     |      * @return The value limited to within uint32 bounds.
  396 |     |      */
  397 |     |     function bound32(uint256 n) internal pure returns (uint32) {
  398 |     |         return uint32(min256(n, uint256(type(uint32).max)));
  399 |     |     }
  400 |     | 
  401 |     |     /**
  402 |     |      * @notice Limits a given uint256 value to the maximum uint112 value.
  403 |     |      * @param  n The value to check.
  404 |     |      * @return The value limited to within uint112 bounds.
  405 |     |      */
  406 |     |     function bound112(uint256 n) internal pure returns (uint112) {
  407 |     |         return uint112(min256(n, uint256(type(uint112).max)));
  408 |     |     }
  409 |     | 
  410 |     |     /**
  411 |     |      * @notice Limits a given uint256 value to the maximum uint128 value.
  412 |     |      * @param  n The value to check.
  413 |     |      * @return The value limited to within uint128 bounds.
  414 |     |      */
  415 |     |     function bound128(uint256 n) internal pure returns (uint128) {
  416 |     |         return uint128(min256(n, uint256(type(uint128).max)));
  417 |     |     }
  418 |     | 
  419 |     |     /**
  420 |     |      * @notice Limits a given uint256 value to the maximum uint240 value.
  421 |     |      * @param  n The value to check.
  422 |     |      * @return The value limited to within uint240 bounds.
  423 |     |      */
  424 |     |     function bound240(uint256 n) internal pure returns (uint240) {
  425 |     |         return uint240(min256(n, uint256(type(uint240).max)));
  426 |     |     }
  427 |     | 
  428 |     |     /**
  429 |     |      * @notice Compares two uint32 values and returns the larger one.
  430 |     |      * @param  a_  Value to check.
  431 |     |      * @param  b_  Value to check.
  432 |     |      * @return The larger value.
  433 |     |      */
  434 |     |     function max32(uint32 a_, uint32 b_) internal pure returns (uint32) {
  435 |     |         return a_ > b_ ? a_ : b_;
  436 |     |     }
  437 |     | 
  438 |     |     /**
  439 |     |      * @notice Compares two uint40 values and returns the larger one.
  440 |     |      * @param  a_  Value to check.
  441 |     |      * @param  b_  Value to check.
  442 |     |      * @return The larger value.
  443 |     |      */
  444 |     |     function max40(uint40 a_, uint40 b_) internal pure returns (uint40) {
  445 |     |         return a_ > b_ ? a_ : b_;
  446 |     |     }
  447 |     | 
  448 |     |     /**
  449 |     |      * @notice Compares two uint32 values and returns the lesser one.
  450 |     |      * @param  a_  Value to check.
  451 |     |      * @param  b_  Value to check.
  452 |     |      * @return The lesser value.
  453 |     |      */
  454 |     |     function min32(uint32 a_, uint32 b_) internal pure returns (uint32) {
  455 |     |         return a_ < b_ ? a_ : b_;
  456 |     |     }
  457 |     | 
  458 |     |     /**
  459 |     |      * @notice Compares two uint40 values and returns the lesser one.
  460 |     |      * @param  a_  Value to check.
  461 |     |      * @param  b_  Value to check.
  462 |     |      * @return The lesser value.
  463 |     |      */
  464 |     |     function min40(uint40 a_, uint40 b_) internal pure returns (uint40) {
  465 |     |         return a_ < b_ ? a_ : b_;
  466 |     |     }
  467 |     | 
  468 |     |     /**
  469 |     |      * @notice Compares two uint240 values and returns the lesser one.
  470 |     |      * @param  a_  Value to check.
  471 |     |      * @param  b_  Value to check.
  472 |     |      * @return The lesser value.
  473 |     |      */
  474 |     |     function min240(uint240 a_, uint240 b_) internal pure returns (uint240) {
  475 |     |         return a_ < b_ ? a_ : b_;
  476 |     |     }
  477 |     | 
  478 |     |     /**
  479 |     |      * @notice Compares two uint112 values and returns the lesser one.
  480 |     |      * @param  a_  Value to check.
  481 |     |      * @param  b_  Value to check.
  482 |     |      * @return The lesser value.
  483 |     |      */
  484 |     |     function min112(uint112 a_, uint112 b_) internal pure returns (uint112) {
  485 |     |         return a_ < b_ ? a_ : b_;
  486 |     |     }
  487 |     | 
  488 |     |     /**
  489 |     |      * @notice Compares two uint256 values and returns the lesser one.
  490 |     |      * @param  a_  Value to check.
  491 |     |      * @param  b_  Value to check.
  492 |     |      * @return The lesser value.
  493 |     |      */
  494 |     |     function min256(uint256 a_, uint256 b_) internal pure returns (uint256) {
  495 |     |         return a_ < b_ ? a_ : b_;
  496 |     |     }
  497 |     | }
  498 |     | 
  499 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/interfaces/IERC712Extended.sol
  500 |     | 
  501 |     | /**
  502 |     |  * @title  EIP-712 extended by EIP-5267.
  503 |     |  * @author M^0 Labs
  504 |     |  * @dev    The additional interface as defined by EIP-5267: https://eips.ethereum.org/EIPS/eip-5267
  505 |     |  */
  506 |     | interface IERC712Extended is IERC712 {
  507 |     |     /* ============ Events ============ */
  508 |     | 
  509 |     |     /// @notice MAY be emitted to signal that the domain could have changed.
  510 |     |     event EIP712DomainChanged();
  511 |     | 
  512 |     |     /* ============ View/Pure Functions ============ */
  513 |     | 
  514 |     |     /// @notice Returns the fields and values that describe the domain separator used by this contract for EIP-712.
  515 |     |     function eip712Domain()
  516 |     |         external
  517 |     |         view
  518 |     |         returns (
  519 |     |             bytes1 fields,
  520 |     |             string memory name,
  521 |     |             string memory version,
  522 |     |             uint256 chainId,
  523 |     |             address verifyingContract,
  524 |     |             bytes32 salt,
  525 |     |             uint256[] memory extensions
  526 |     |         );
  527 |     | }
  528 |     | 
  529 |     | // test/fuzzing/mocks/wrappedMToken.sol/src/libs/IndexingMath.sol
  530 |     | 
  531 |     | /**
  532 |     |  * @title  Helper library for indexing math functions.
  533 |     |  * @author M^0 Labs
  534 |     |  */
  535 |     | library IndexingMath {
  536 |     |     /* ============ Variables ============ */
  537 |     | 
  538 |     |     /// @notice The scaling of indexes for exponent math.
  539 |     |     uint56 internal constant EXP_SCALED_ONE = 1e12;
  540 |     | 
  541 |     |     /* ============ Custom Errors ============ */
  542 |     | 
  543 |     |     /// @notice Emitted when a division by zero occurs.
  544 |     |     error DivisionByZero();
  545 |     | 
  546 |     |     /* ============ Internal View/Pure Functions ============ */
  547 |     | 
  548 |     |     /**
  549 |     |      * @notice Helper function to calculate `(x * EXP_SCALED_ONE) / y`, rounded down.
  550 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  551 |     |      */
  552 |     |     function divide240By128Down(uint240 x_, uint128 y_) internal pure returns (uint112) {
  553 |     |         if (y_ == 0) revert DivisionByZero();
  554 |     | 
  555 |     |         unchecked {
  556 |     |             // NOTE: While `uint256(x) * EXP_SCALED_ONE` can technically overflow, these divide/multiply functions are
  557 |     |             //       only used for the purpose of principal/present amount calculations for continuous indexing, and
  558 |     |             //       so for an `x` to be large enough to overflow this, it would have to be a possible result of
  559 |     |             //       `multiply112By128Down` or `multiply112By128Up`, which would already satisfy
  560 |     |             //       `uint256(x) * EXP_SCALED_ONE < type(uint240).max`.
  561 |     |             return UIntMath.safe112((uint256(x_) * EXP_SCALED_ONE) / y_);
  562 |     |         }
  563 |     |     }
  564 |     | 
  565 |     |     /**
  566 |     |      * @notice Helper function to calculate `(x * EXP_SCALED_ONE) / y`, rounded up.
  567 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  568 |     |      */
  569 |     |     function divide240By128Up(uint240 x_, uint128 y_) internal pure returns (uint112) {
  570 |     |         if (y_ == 0) revert DivisionByZero();
  571 |     | 
  572 |     |         unchecked {
  573 |     |             // NOTE: While `uint256(x) * EXP_SCALED_ONE` can technically overflow, these divide/multiply functions are
  574 |     |             //       only used for the purpose of principal/present amount calculations for continuous indexing, and
  575 |     |             //       so for an `x` to be large enough to overflow this, it would have to be a possible result of
  576 |     |             //       `multiply112By128Down` or `multiply112By128Up`, which would already satisfy
  577 |     |             //       `uint256(x) * EXP_SCALED_ONE < type(uint240).max`.
  578 |     |             return UIntMath.safe112(((uint256(x_) * EXP_SCALED_ONE) + y_ - 1) / y_);
  579 |     |         }
  580 |     |     }
  581 |     | 
  582 |     |     /**
  583 |     |      * @notice Helper function to calculate `(x * y) / EXP_SCALED_ONE`, rounded down.
  584 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  585 |     |      */
  586 |     |     function multiply112By128Down(uint112 x_, uint128 y_) internal pure returns (uint240) {
  587 |     |         unchecked {
  588 |     |             return uint240((uint256(x_) * y_) / EXP_SCALED_ONE);
  589 |     |         }
  590 |     |     }
  591 |     | 
  592 |     |     /**
  593 |     |      * @dev    Returns the present amount (rounded down) given the principal amount and an index.
  594 |     |      * @param  principalAmount_ The principal amount.
  595 |     |      * @param  index_           An index.
  596 |     |      * @return The present amount rounded down.
  597 |     |      */
  598 |     |     function getPresentAmountRoundedDown(uint112 principalAmount_, uint128 index_) internal pure returns (uint240) {
  599 |     |         return multiply112By128Down(principalAmount_, index_);
  600 |     |     }
  601 |     | 
  602 |     |     /**
  603 |     |      * @dev    Returns the principal amount given the present amount, using the current index.
  604 |     |      * @param  presentAmount_ The present amount.
  605 |     |      * @param  index_         An index.
  606 |     |      * @return The principal amount rounded down.
  607 |     |      */
  608 |     |     function getPrincipalAmountRoundedDown(uint240 presentAmount_, uint128 index_) internal pure returns (uint112) {
  609 |     |         return divide240By128Down(presentAmount_, index_);
  610 |     |     }
  611 |     | 
  612 |     |     /**
  613 |     |      * @dev    Returns the principal amount given the present amount, using the current index.
  614 |     |      * @param  presentAmount_ The present amount.
  615 |     |      * @param  index_         An index.
  616 |     |      * @return The principal amount rounded up.
  617 |     |      */
  618 |     |     function getPrincipalAmountRoundedUp(uint240 presentAmount_, uint128 index_) internal pure returns (uint112) {
  619 |     |         return divide240By128Up(presentAmount_, index_);
  620 |     |     }
  621 |     | }
  622 |     | 
  623 |     | // test/fuzzing/mocks/wrappedMToken.sol/src/Migratable.sol
  624 |     | 
  625 |     | /**
  626 |     |  * @title  Abstract implementation for exposing the ability to migrate a contract, extending ERC-1967.
  627 |     |  * @author M^0 Labs
  628 |     |  */
  629 |     | abstract contract Migratable is IMigratable {
  630 |     |     /* ============ Variables ============ */
  631 |     | 
  632 |     |     /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.
  633 |     |     uint256 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  634 |     | 
  635 |     |     /* ============ Interactive Functions ============ */
  636 |     | 
  637 |     |     /// @inheritdoc IMigratable
  638 |     |     function migrate() external {
  639 |     |         _migrate(_getMigrator());
  640 |     |     }
  641 |     | 
  642 |     |     /* ============ View/Pure Functions ============ */
  643 |     | 
  644 |     |     /// @inheritdoc IMigratable
  645 |     |     function implementation() public view returns (address implementation_) {
  646 |     |         assembly {
  647 |     |             implementation_ := sload(_IMPLEMENTATION_SLOT)
  648 |     |         }
  649 |     |     }
  650 |     | 
  651 |     |     /* ============ Internal Interactive Functions ============ */
  652 |     | 
  653 |     |     /**
  654 |     |      * @dev   Performs an arbitrary migration by delegate-calling `migrator_`.
  655 |     |      * @param migrator_ The address of a migrator contract.
  656 |     |      */
  657 |     |     function _migrate(address migrator_) internal {
  658 |     |         if (migrator_ == address(0)) revert ZeroMigrator();
  659 |     | 
  660 |     |         if (migrator_.code.length == 0) revert InvalidMigrator();
  661 |     | 
  662 |     |         address oldImplementation_ = implementation();
  663 |     | 
  664 |     |         (bool success_, ) = migrator_.delegatecall("");
  665 |     |         if (!success_) revert MigrationFailed();
  666 |     | 
  667 |     |         address newImplementation_ = implementation();
  668 |     | 
  669 |     |         emit Migrated(migrator_, oldImplementation_, newImplementation_);
  670 |     | 
  671 |     |         // NOTE: Redundant event emitted to conform to the EIP-1967 standard.
  672 |     |         emit Upgraded(newImplementation_);
  673 |     |     }
  674 |     | 
  675 |     |     /* ============ Internal View/Pure Functions ============ */
  676 |     | 
  677 |     |     /// @dev Returns the address of a migrator contract.
  678 |     |     function _getMigrator() internal view virtual returns (address migrator_);
  679 |     | }
  680 |     | 
  681 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/libs/SignatureChecker.sol
  682 |     | 
  683 |     | /**
  684 |     |  * @title  A library to handle ECDSA/secp256k1 and ERC1271 signatures, individually or in arbitrarily in combination.
  685 |     |  * @author M^0 Labs
  686 |     |  */
  687 |     | library SignatureChecker {
  688 |     |     /* ============ Enums ============ */
  689 |     | 
  690 |     |     /**
  691 |     |      * @notice An enum representing the possible errors that can be emitted during signature validation.
  692 |     |      * @param  NoError                No error occurred during signature validation.
  693 |     |      * @param  InvalidSignature       The signature is invalid.
  694 |     |      * @param  InvalidSignatureLength The signature length is invalid.
  695 |     |      * @param  InvalidSignatureS      The signature parameter S is invalid.
  696 |     |      * @param  InvalidSignatureV      The signature parameter V is invalid.
  697 |     |      * @param  SignerMismatch         The signer does not match the recovered signer.
  698 |     |      */
  699 |     |     enum Error {
  700 |     |         NoError,
  701 |     |         InvalidSignature,
  702 |     |         InvalidSignatureLength,
  703 |     |         InvalidSignatureS,
  704 |     |         InvalidSignatureV,
  705 |     |         SignerMismatch
  706 |     |     }
  707 |     | 
  708 |     |     /* ============ Internal View/Pure Functions ============ */
  709 |     | 
  710 |     |     /**
  711 |     |      * @dev    Returns whether a signature is valid (ECDSA/secp256k1 or ERC1271) for a signer and digest.
  712 |     |      * @dev    Signatures must not be used as unique identifiers since the `ecrecover` EVM opcode
  713 |     |      *         allows for malleable (non-unique) signatures.
  714 |     |      *         See https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h
  715 |     |      * @param  signer    The address of the account purported to have signed.
  716 |     |      * @param  digest    The hash of the data that was signed.
  717 |     |      * @param  signature A byte array signature.
  718 |     |      * @return           Whether the signature is valid or not.
  719 |     |      */
  720 |     |     function isValidSignature(address signer, bytes32 digest, bytes memory signature) internal view returns (bool) {
  721 |     |         return isValidECDSASignature(signer, digest, signature) || isValidERC1271Signature(signer, digest, signature);
  722 |     |     }
  723 |     | 
  724 |     |     /**
  725 |     |      * @dev    Returns whether an ERC1271 signature is valid for a signer and digest.
  726 |     |      * @param  signer    The address of the account purported to have signed.
  727 |     |      * @param  digest    The hash of the data that was signed.
  728 |     |      * @param  signature A byte array ERC1271 signature.
  729 |     |      * @return           Whether the signature is valid or not.
  730 |     |      */
  731 |     |     function isValidERC1271Signature(
  732 |     |         address signer,
  733 |     |         bytes32 digest,
  734 |     |         bytes memory signature
  735 |     |     ) internal view returns (bool) {
  736 |     |         (bool success, bytes memory result) = signer.staticcall(
  737 |     |             abi.encodeCall(IERC1271.isValidSignature, (digest, signature))
  738 |     |         );
  739 |     | 
  740 |     |         return
  741 |     |             success &&
  742 |     |             result.length >= 32 &&
  743 |     |             abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector);
  744 |     |     }
  745 |     | 
  746 |     |     /**
  747 |     |      * @dev    Decodes an ECDSA/secp256k1 signature from a byte array to standard v, r, and s parameters.
  748 |     |      * @param  signature A byte array ECDSA/secp256k1 signature.
  749 |     |      * @return v         An ECDSA/secp256k1 signature parameter.
  750 |     |      * @return r         An ECDSA/secp256k1 signature parameter.
  751 |     |      * @return s         An ECDSA/secp256k1 signature parameter.
  752 |     |      */
  753 |     |     function decodeECDSASignature(bytes memory signature) internal pure returns (uint8 v, bytes32 r, bytes32 s) {
  754 |     |         // ecrecover takes the signature parameters, and they can be decoded using assembly.
  755 |     |         /// @solidity memory-safe-assembly
  756 |     |         assembly {
  757 |     |             r := mload(add(signature, 0x20))
  758 |     |             s := mload(add(signature, 0x40))
  759 |     |             v := byte(0, mload(add(signature, 0x60)))
  760 |     |         }
  761 |     |     }
  762 |     | 
  763 |     |     /**
  764 |     |      * @dev    Decodes an ECDSA/secp256k1 short signature as defined by EIP2098
  765 |     |      *         from a byte array to standard v, r, and s parameters.
  766 |     |      * @param  signature A byte array ECDSA/secp256k1 short signature.
  767 |     |      * @return r         An ECDSA/secp256k1 signature parameter.
  768 |     |      * @return vs        An ECDSA/secp256k1 short signature parameter.
  769 |     |      */
  770 |     |     function decodeShortECDSASignature(bytes memory signature) internal pure returns (bytes32 r, bytes32 vs) {
  771 |     |         // ecrecover takes the signature parameters, and they can be decoded using assembly.
  772 |     |         /// @solidity memory-safe-assembly
  773 |     |         assembly {
  774 |     |             r := mload(add(signature, 0x20))
  775 |     |             vs := mload(add(signature, 0x40))
  776 |     |         }
  777 |     |     }
  778 |     | 
  779 |     |     /**
  780 |     |      * @dev    Returns whether an ECDSA/secp256k1 signature is valid for a signer and digest.
  781 |     |      * @param  signer    The address of the account purported to have signed.
  782 |     |      * @param  digest    The hash of the data that was signed.
  783 |     |      * @param  signature A byte array ECDSA/secp256k1 signature (encoded r, s, v).
  784 |     |      * @return           Whether the signature is valid or not.
  785 |     |      */
  786 |     |     function isValidECDSASignature(
  787 |     |         address signer,
  788 |     |         bytes32 digest,
  789 |     |         bytes memory signature
  790 |     |     ) internal pure returns (bool) {
  791 |     |         if (signature.length == 64) {
  792 |     |             (bytes32 r, bytes32 vs) = decodeShortECDSASignature(signature);
  793 |     |             return isValidECDSASignature(signer, digest, r, vs);
  794 |     |         }
  795 |     | 
  796 |     |         return validateECDSASignature(signer, digest, signature) == Error.NoError;
  797 |     |     }
  798 |     | 
  799 |     |     /**
  800 |     |      * @dev    Returns whether an ECDSA/secp256k1 short signature is valid for a signer and digest.
  801 |     |      * @param  signer  The address of the account purported to have signed.
  802 |     |      * @param  digest  The hash of the data that was signed.
  803 |     |      * @param  r       An ECDSA/secp256k1 signature parameter.
  804 |     |      * @param  vs      An ECDSA/secp256k1 short signature parameter.
  805 |     |      * @return         Whether the signature is valid or not.
  806 |     |      */
  807 |     |     function isValidECDSASignature(address signer, bytes32 digest, bytes32 r, bytes32 vs) internal pure returns (bool) {
  808 |     |         return validateECDSASignature(signer, digest, r, vs) == Error.NoError;
  809 |     |     }
  810 |     | 
  811 |     |     /**
  812 |     |      * @dev    Returns the signer of an ECDSA/secp256k1 signature for some digest.
  813 |     |      * @param  digest    The hash of the data that was signed.
  814 |     |      * @param  signature A byte array ECDSA/secp256k1 signature.
  815 |     |      * @return           An error, if any, that occurred during the signer recovery.
  816 |     |      * @return           The address of the account recovered form the signature (0 if error).
  817 |     |      */
  818 |     |     function recoverECDSASigner(bytes32 digest, bytes memory signature) internal pure returns (Error, address) {
  819 |     |         if (signature.length != 65) return (Error.InvalidSignatureLength, address(0));
  820 |     | 
  821 |     |         (uint8 v, bytes32 r, bytes32 s) = decodeECDSASignature(signature);
  822 |     | 
  823 |     |         return recoverECDSASigner(digest, v, r, s);
  824 |     |     }
  825 |     | 
  826 |     |     /**
  827 |     |      * @dev    Returns the signer of an ECDSA/secp256k1 short signature for some digest.
  828 |     |      * @dev    See https://eips.ethereum.org/EIPS/eip-2098
  829 |     |      * @param  digest The hash of the data that was signed.
  830 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
  831 |     |      * @param  vs     An ECDSA/secp256k1 short signature parameter.
  832 |     |      * @return        An error, if any, that occurred during the signer recovery.
  833 |     |      * @return        The address of the account recovered form the signature (0 if error).
  834 |     |      */
  835 |     |     function recoverECDSASigner(bytes32 digest, bytes32 r, bytes32 vs) internal pure returns (Error, address) {
  836 |     |         unchecked {
  837 |     |             // We do not check for an overflow here since the shift operation results in 0 or 1.
  838 |     |             uint8 v = uint8((uint256(vs) >> 255) + 27);
  839 |     |             bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  840 |     |             return recoverECDSASigner(digest, v, r, s);
  841 |     |         }
  842 |     |     }
  843 |     | 
  844 |     |     /**
  845 |     |      * @dev    Returns the signer of an ECDSA/secp256k1 signature for some digest.
  846 |     |      * @param  digest The hash of the data that was signed.
  847 |     |      * @param  v      An ECDSA/secp256k1 signature parameter.
  848 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
  849 |     |      * @param  s      An ECDSA/secp256k1 signature parameter.
  850 |     |      * @return        An error, if any, that occurred during the signer recovery.
  851 |     |      * @return signer The address of the account recovered form the signature (0 if error).
  852 |     |      */
  853 |     |     function recoverECDSASigner(
  854 |     |         bytes32 digest,
  855 |     |         uint8 v,
  856 |     |         bytes32 r,
  857 |     |         bytes32 s
  858 |     |     ) internal pure returns (Error, address signer) {
  859 |     |         // Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
  860 |     |         // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}.
  861 |     |         if (uint256(s) > uint256(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0))
  862 |     |             return (Error.InvalidSignatureS, address(0));
  863 |     | 
  864 |     |         if (v != 27 && v != 28) return (Error.InvalidSignatureV, address(0));
  865 |     | 
  866 |     |         signer = ecrecover(digest, v, r, s);
  867 |     | 
  868 |     |         return (signer == address(0)) ? (Error.InvalidSignature, address(0)) : (Error.NoError, signer);
  869 |     |     }
  870 |     | 
  871 |     |     /**
  872 |     |      * @dev    Returns an error, if any, in validating an ECDSA/secp256k1 signature for a signer and digest.
  873 |     |      * @param  signer    The address of the account purported to have signed.
  874 |     |      * @param  digest    The hash of the data that was signed.
  875 |     |      * @param  signature A byte array ERC1271 signature.
  876 |     |      * @return           An error, if any, that occurred during the signer recovery.
  877 |     |      */
  878 |     |     function validateECDSASignature(
  879 |     |         address signer,
  880 |     |         bytes32 digest,
  881 |     |         bytes memory signature
  882 |     |     ) internal pure returns (Error) {
  883 |     |         (Error recoverError, address recoveredSigner) = recoverECDSASigner(digest, signature);
  884 |     | 
  885 |     |         return (recoverError == Error.NoError) ? validateRecoveredSigner(signer, recoveredSigner) : recoverError;
  886 |     |     }
  887 |     | 
  888 |     |     /**
  889 |     |      * @dev    Returns an error, if any, in validating an ECDSA/secp256k1 short signature for a signer and digest.
  890 |     |      * @param  signer The address of the account purported to have signed.
  891 |     |      * @param  digest The hash of the data that was signed.
  892 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
  893 |     |      * @param  vs     An ECDSA/secp256k1 short signature parameter.
  894 |     |      * @return        An error, if any, that occurred during the signer recovery.
  895 |     |      */
  896 |     |     function validateECDSASignature(
  897 |     |         address signer,
  898 |     |         bytes32 digest,
  899 |     |         bytes32 r,
  900 |     |         bytes32 vs
  901 |     |     ) internal pure returns (Error) {
  902 |     |         (Error recoverError, address recoveredSigner) = recoverECDSASigner(digest, r, vs);
  903 |     | 
  904 |     |         return (recoverError == Error.NoError) ? validateRecoveredSigner(signer, recoveredSigner) : recoverError;
  905 |     |     }
  906 |     | 
  907 |     |     /**
  908 |     |      * @dev    Returns an error, if any, in validating an ECDSA/secp256k1 signature for a signer and digest.
  909 |     |      * @param  signer The address of the account purported to have signed.
  910 |     |      * @param  digest The hash of the data that was signed.
  911 |     |      * @param  v      An ECDSA/secp256k1 signature parameter.
  912 |     |      * @param  r      An ECDSA/secp256k1 signature parameter.
  913 |     |      * @param  s      An ECDSA/secp256k1 signature parameter.
  914 |     |      * @return        An error, if any, that occurred during the signer recovery.
  915 |     |      */
  916 |     |     function validateECDSASignature(
  917 |     |         address signer,
  918 |     |         bytes32 digest,
  919 |     |         uint8 v,
  920 |     |         bytes32 r,
  921 |     |         bytes32 s
  922 |     |     ) internal pure returns (Error) {
  923 |     |         (Error recoverError, address recoveredSigner) = recoverECDSASigner(digest, v, r, s);
  924 |     | 
  925 |     |         return (recoverError == Error.NoError) ? validateRecoveredSigner(signer, recoveredSigner) : recoverError;
  926 |     |     }
  927 |     | 
  928 |     |     /**
  929 |     |      * @dev    Returns an error if `signer` is not `recoveredSigner`.
  930 |     |      * @param  signer          The address of the some signer.
  931 |     |      * @param  recoveredSigner The address of the some recoveredSigner.
  932 |     |      * @return                 An error if `signer` is not `recoveredSigner`.
  933 |     |      */
  934 |     |     function validateRecoveredSigner(address signer, address recoveredSigner) internal pure returns (Error) {
  935 |     |         return (signer == recoveredSigner) ? Error.NoError : Error.SignerMismatch;
  936 |     |     }
  937 |     | }
  938 |     | 
  939 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/interfaces/IStatefulERC712.sol
  940 |     | 
  941 |     | /**
  942 |     |  * @title  Stateful Extension for EIP-712 typed structured data hashing and signing with nonces.
  943 |     |  * @author M^0 Labs
  944 |     |  */
  945 |     | interface IStatefulERC712 is IERC712Extended {
  946 |     |     /* ============ Custom Errors ============ */
  947 |     | 
  948 |     |     /**
  949 |     |      * @notice Revert message when a signing account's nonce is not the expected current nonce.
  950 |     |      * @param  nonce         The nonce used in the signature.
  951 |     |      * @param  expectedNonce The expected nonce to be used in a signature by the signing account.
  952 |     |      */
  953 |     |     error InvalidAccountNonce(uint256 nonce, uint256 expectedNonce);
  954 |     | 
  955 |     |     /* ============ View/Pure Functions ============ */
  956 |     | 
  957 |     |     /**
  958 |     |      * @notice Returns the next nonce to be used in a signature by `account`.
  959 |     |      * @param  account The address of some account.
  960 |     |      * @return nonce   The next nonce to be used in a signature by `account`.
  961 |     |      */
  962 |     |     function nonces(address account) external view returns (uint256 nonce);
  963 |     | }
  964 |     | 
  965 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/interfaces/IERC3009.sol
  966 |     | 
  967 |     | /**
  968 |     |  * @title  Transfer via signed authorization following EIP-3009 standard.
  969 |     |  * @author M^0 Labs
  970 |     |  * @dev    The interface as defined by EIP-3009: https://eips.ethereum.org/EIPS/eip-3009
  971 |     |  */
  972 |     | interface IERC3009 is IStatefulERC712 {
  973 |     |     /* ============ Events ============ */
  974 |     | 
  975 |     |     /**
  976 |     |      * @notice Emitted when an authorization has been canceled.
  977 |     |      * @param  authorizer Authorizer's address.
  978 |     |      * @param  nonce      Nonce of the canceled authorization.
  979 |     |      */
  980 |     |     event AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);
  981 |     | 
  982 |     |     /**
  983 |     |      * @notice Emitted when an authorization has been used.
  984 |     |      * @param  authorizer Authorizer's address.
  985 |     |      * @param  nonce      Nonce of the used authorization.
  986 |     |      */
  987 |     |     event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);
  988 |     | 
  989 |     |     /* ============ Custom Errors ============ */
  990 |     | 
  991 |     |     /**
  992 |     |      * @notice Emitted when an authorization has already been used.
  993 |     |      * @param  authorizer Authorizer's address.
  994 |     |      * @param  nonce      Nonce of the used authorization.
  995 |     |      */
  996 |     |     error AuthorizationAlreadyUsed(address authorizer, bytes32 nonce);
  997 |     | 
  998 |     |     /**
  999 |     |      * @notice Emitted when an authorization is expired.
 1000 |     |      * @param  timestamp   Timestamp at which the transaction was submitted.
 1001 |     |      * @param  validBefore Timestamp before which the authorization would have been valid.
 1002 |     |      */
 1003 |     |     error AuthorizationExpired(uint256 timestamp, uint256 validBefore);
 1004 |     | 
 1005 |     |     /**
 1006 |     |      * @notice Emitted when an authorization is not yet valid.
 1007 |     |      * @param  timestamp  Timestamp at which the transaction was submitted.
 1008 |     |      * @param  validAfter Timestamp after which the authorization will be valid.
 1009 |     |      */
 1010 |     |     error AuthorizationNotYetValid(uint256 timestamp, uint256 validAfter);
 1011 |     | 
 1012 |     |     /**
 1013 |     |      * @notice Emitted when the caller of `receiveWithAuthorization` is not the payee.
 1014 |     |      * @param  caller Caller's address.
 1015 |     |      * @param  payee  Payee's address.
 1016 |     |      */
 1017 |     |     error CallerMustBePayee(address caller, address payee);
 1018 |     | 
 1019 |     |     /* ============ Interactive Functions ============ */
 1020 |     | 
 1021 |     |     /**
 1022 |     |      * @notice Execute a transfer with a signed authorization.
 1023 |     |      * @param  from        Payer's address (Authorizer).
 1024 |     |      * @param  to          Payee's address.
 1025 |     |      * @param  value       Amount to be transferred.
 1026 |     |      * @param  validAfter  The time after which this is valid (unix time).
 1027 |     |      * @param  validBefore The time before which this is valid (unix time).
 1028 |     |      * @param  nonce       Unique nonce.
 1029 |     |      * @param  signature   A byte array ECDSA/secp256k1 signature (encoded r, s, v).
 1030 |     |      */
 1031 |     |     function transferWithAuthorization(
 1032 |     |         address from,
 1033 |     |         address to,
 1034 |     |         uint256 value,
 1035 |     |         uint256 validAfter,
 1036 |     |         uint256 validBefore,
 1037 |     |         bytes32 nonce,
 1038 |     |         bytes memory signature
 1039 |     |     ) external;
 1040 |     | 
 1041 |     |     /**
 1042 |     |      * @notice Execute a transfer with a signed authorization.
 1043 |     |      * @param  from        Payer's address (Authorizer).
 1044 |     |      * @param  to          Payee's address.
 1045 |     |      * @param  value       Amount to be transferred.
 1046 |     |      * @param  validAfter  The time after which this is valid (unix time).
 1047 |     |      * @param  validBefore The time before which this is valid (unix time).
 1048 |     |      * @param  nonce       Unique nonce.
 1049 |     |      * @param  r           An ECDSA/secp256k1 signature parameter.
 1050 |     |      * @param  vs          An ECDSA/secp256k1 short signature parameter.
 1051 |     |      */
 1052 |     |     function transferWithAuthorization(
 1053 |     |         address from,
 1054 |     |         address to,
 1055 |     |         uint256 value,
 1056 |     |         uint256 validAfter,
 1057 |     |         uint256 validBefore,
 1058 |     |         bytes32 nonce,
 1059 |     |         bytes32 r,
 1060 |     |         bytes32 vs
 1061 |     |     ) external;
 1062 |     | 
 1063 |     |     /**
 1064 |     |      * @notice Execute a transfer with a signed authorization.
 1065 |     |      * @param  from        Payer's address (Authorizer).
 1066 |     |      * @param  to          Payee's address.
 1067 |     |      * @param  value       Amount to be transferred.
 1068 |     |      * @param  validAfter  The time after which this is valid (unix time).
 1069 |     |      * @param  validBefore The time before which this is valid (unix time).
 1070 |     |      * @param  nonce       Unique nonce.
 1071 |     |      * @param  v           v of the signature.
 1072 |     |      * @param  r           r of the signature.
 1073 |     |      * @param  s           s of the signature.
 1074 |     |      */
 1075 |     |     function transferWithAuthorization(
 1076 |     |         address from,
 1077 |     |         address to,
 1078 |     |         uint256 value,
 1079 |     |         uint256 validAfter,
 1080 |     |         uint256 validBefore,
 1081 |     |         bytes32 nonce,
 1082 |     |         uint8 v,
 1083 |     |         bytes32 r,
 1084 |     |         bytes32 s
 1085 |     |     ) external;
 1086 |     | 
 1087 |     |     /**
 1088 |     |      * @notice Receive a transfer with a signed authorization from the payer.
 1089 |     |      * @dev    This has an additional check to ensure that the payee's address matches
 1090 |     |      *         the caller of this function to prevent front-running attacks.
 1091 |     |      *         (See security considerations)
 1092 |     |      * @param  from        Payer's address (Authorizer).
 1093 |     |      * @param  to          Payee's address.
 1094 |     |      * @param  value       Amount to be transferred.
 1095 |     |      * @param  validAfter  The time after which this is valid (unix time).
 1096 |     |      * @param  validBefore The time before which this is valid (unix time).
 1097 |     |      * @param  nonce       Unique nonce.
 1098 |     |      * @param  signature   A byte array ECDSA/secp256k1 signature (encoded r, s, v).
 1099 |     |      */
 1100 |     |     function receiveWithAuthorization(
 1101 |     |         address from,
 1102 |     |         address to,
 1103 |     |         uint256 value,
 1104 |     |         uint256 validAfter,
 1105 |     |         uint256 validBefore,
 1106 |     |         bytes32 nonce,
 1107 |     |         bytes memory signature
 1108 |     |     ) external;
 1109 |     | 
 1110 |     |     /**
 1111 |     |      * @notice Receive a transfer with a signed authorization from the payer.
 1112 |     |      * @dev    This has an additional check to ensure that the payee's address matches
 1113 |     |      *         the caller of this function to prevent front-running attacks.
 1114 |     |      *         (See security considerations)
 1115 |     |      * @param  from        Payer's address (Authorizer).
 1116 |     |      * @param  to          Payee's address.
 1117 |     |      * @param  value       Amount to be transferred.
 1118 |     |      * @param  validAfter  The time after which this is valid (unix time).
 1119 |     |      * @param  validBefore The time before which this is valid (unix time).
 1120 |     |      * @param  nonce       Unique nonce.
 1121 |     |      * @param  r           An ECDSA/secp256k1 signature parameter.
 1122 |     |      * @param  vs          An ECDSA/secp256k1 short signature parameter.
 1123 |     |      */
 1124 |     |     function receiveWithAuthorization(
 1125 |     |         address from,
 1126 |     |         address to,
 1127 |     |         uint256 value,
 1128 |     |         uint256 validAfter,
 1129 |     |         uint256 validBefore,
 1130 |     |         bytes32 nonce,
 1131 |     |         bytes32 r,
 1132 |     |         bytes32 vs
 1133 |     |     ) external;
 1134 |     | 
 1135 |     |     /**
 1136 |     |      * @notice Receive a transfer with a signed authorization from the payer.
 1137 |     |      * @dev    This has an additional check to ensure that the payee's address matches
 1138 |     |      *         the caller of this function to prevent front-running attacks.
 1139 |     |      *         (See security considerations)
 1140 |     |      * @param  from        Payer's address (Authorizer).
 1141 |     |      * @param  to          Payee's address.
 1142 |     |      * @param  value       Amount to be transferred.
 1143 |     |      * @param  validAfter  The time after which this is valid (unix time).
 1144 |     |      * @param  validBefore The time before which this is valid (unix time).
 1145 |     |      * @param  nonce       Unique nonce.
 1146 |     |      * @param  v           v of the signature.
 1147 |     |      * @param  r           r of the signature.
 1148 |     |      * @param  s           s of the signature.
 1149 |     |      */
 1150 |     |     function receiveWithAuthorization(
 1151 |     |         address from,
 1152 |     |         address to,
 1153 |     |         uint256 value,
 1154 |     |         uint256 validAfter,
 1155 |     |         uint256 validBefore,
 1156 |     |         bytes32 nonce,
 1157 |     |         uint8 v,
 1158 |     |         bytes32 r,
 1159 |     |         bytes32 s
 1160 |     |     ) external;
 1161 |     | 
 1162 |     |     /**
 1163 |     |      * @notice Attempt to cancel an authorization.
 1164 |     |      * @param  authorizer Authorizer's address.
 1165 |     |      * @param  nonce      Nonce of the authorization.
 1166 |     |      * @param  signature  A byte array ECDSA/secp256k1 signature (encoded r, s, v).
 1167 |     |      */
 1168 |     |     function cancelAuthorization(address authorizer, bytes32 nonce, bytes memory signature) external;
 1169 |     | 
 1170 |     |     /**
 1171 |     |      * @notice Attempt to cancel an authorization.
 1172 |     |      * @param  authorizer Authorizer's address.
 1173 |     |      * @param  nonce      Nonce of the authorization.
 1174 |     |      * @param  r          An ECDSA/secp256k1 signature parameter.
 1175 |     |      * @param  vs         An ECDSA/secp256k1 short signature parameter.
 1176 |     |      */
 1177 |     |     function cancelAuthorization(address authorizer, bytes32 nonce, bytes32 r, bytes32 vs) external;
 1178 |     | 
 1179 |     |     /**
 1180 |     |      * @notice Attempt to cancel an authorization.
 1181 |     |      * @param  authorizer Authorizer's address.
 1182 |     |      * @param  nonce      Nonce of the authorization.
 1183 |     |      * @param  v          v of the signature.
 1184 |     |      * @param  r          r of the signature.
 1185 |     |      * @param  s          s of the signature.
 1186 |     |      */
 1187 |     |     function cancelAuthorization(address authorizer, bytes32 nonce, uint8 v, bytes32 r, bytes32 s) external;
 1188 |     | 
 1189 |     |     /* ============ View/Pure Functions ============ */
 1190 |     | 
 1191 |     |     /**
 1192 |     |      * @notice Returns the state of an authorization.
 1193 |     |      * @dev    Nonces are randomly generated 32-byte data unique to the authorizer's address
 1194 |     |      * @param  authorizer Authorizer's address.
 1195 |     |      * @param  nonce      Nonce of the authorization.
 1196 |     |      * @return True if the nonce is used.
 1197 |     |      */
 1198 |     |     function authorizationState(address authorizer, bytes32 nonce) external view returns (bool);
 1199 |     | 
 1200 |     |     /// @notice Returns `transferWithAuthorization` typehash.
 1201 |     |     function TRANSFER_WITH_AUTHORIZATION_TYPEHASH() external view returns (bytes32);
 1202 |     | 
 1203 |     |     /// @notice Returns `receiveWithAuthorization` typehash.
 1204 |     |     function RECEIVE_WITH_AUTHORIZATION_TYPEHASH() external view returns (bytes32);
 1205 |     | 
 1206 |     |     /// @notice Returns `cancelAuthorization` typehash.
 1207 |     |     function CANCEL_AUTHORIZATION_TYPEHASH() external view returns (bytes32);
 1208 |     | }
 1209 |     | 
 1210 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/ERC712Extended.sol
 1211 |     | 
 1212 |     | /**
 1213 |     |  * @title  Typed structured data hashing and signing via EIP-712, extended by EIP-5267.
 1214 |     |  * @author M^0 Labs
 1215 |     |  * @dev    An abstract implementation to satisfy EIP-712: https://eips.ethereum.org/EIPS/eip-712
 1216 |     |  */
 1217 |     | abstract contract ERC712Extended is IERC712Extended {
 1218 |     |     /* ============ Variables ============ */
 1219 |     | 
 1220 |     |     /// @dev keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")
 1221 | *   |     bytes32 internal constant _EIP712_DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;
 1222 |     | 
 1223 |     |     /// @dev keccak256("1")
 1224 | *   |     bytes32 internal constant _EIP712_VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;
 1225 |     | 
 1226 |     |     /// @dev Initial Chain ID set at deployment.
 1227 |     |     uint256 internal immutable _INITIAL_CHAIN_ID;
 1228 |     | 
 1229 |     |     /// @dev Initial EIP-712 domain separator set at deployment.
 1230 |     |     bytes32 internal immutable _INITIAL_DOMAIN_SEPARATOR;
 1231 |     | 
 1232 |     |     /// @dev The name of the contract (stored as a bytes32 instead of a string in order to be immutable).
 1233 |     |     bytes32 internal immutable _name;
 1234 |     | 
 1235 |     |     /* ============ Constructor ============ */
 1236 |     | 
 1237 |     |     /**
 1238 |     |      * @notice Constructs the EIP-712 domain separator.
 1239 |     |      * @param  name_ The name of the contract.
 1240 |     |      */
 1241 | *   |     constructor(string memory name_) {
 1242 | *   |         _name = Bytes32String.toBytes32(name_);
 1243 |     | 
 1244 | *   |         _INITIAL_CHAIN_ID = block.chainid;
 1245 | *   |         _INITIAL_DOMAIN_SEPARATOR = _getDomainSeparator();
 1246 |     |     }
 1247 |     | 
 1248 |     |     /* ============ View/Pure Functions ============ */
 1249 |     | 
 1250 |     |     /// @inheritdoc IERC712Extended
 1251 |     |     function eip712Domain()
 1252 |     |         external
 1253 |     |         view
 1254 |     |         virtual
 1255 |     |         returns (
 1256 |     |             bytes1 fields_,
 1257 |     |             string memory name_,
 1258 |     |             string memory version_,
 1259 |     |             uint256 chainId_,
 1260 |     |             address verifyingContract_,
 1261 |     |             bytes32 salt_,
 1262 |     |             uint256[] memory extensions_
 1263 |     |         )
 1264 |     |     {
 1265 |     |         return (
 1266 |     |             hex"0f", // 01111
 1267 |     |             Bytes32String.toString(_name),
 1268 |     |             "1",
 1269 |     |             block.chainid,
 1270 |     |             address(this),
 1271 |     |             bytes32(0),
 1272 |     |             new uint256[](0)
 1273 |     |         );
 1274 |     |     }
 1275 |     | 
 1276 |     |     /// @inheritdoc IERC712
 1277 |     |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
 1278 |     |         return block.chainid == _INITIAL_CHAIN_ID ? _INITIAL_DOMAIN_SEPARATOR : _getDomainSeparator();
 1279 |     |     }
 1280 |     | 
 1281 |     |     /* ============ Internal View/Pure Functions ============ */
 1282 |     | 
 1283 |     |     /**
 1284 |     |      * @dev    Computes the EIP-712 domain separator.
 1285 |     |      * @return The EIP-712 domain separator.
 1286 |     |      */
 1287 | *   |     function _getDomainSeparator() internal view returns (bytes32) {
 1288 | *   |         return
 1289 | *   |             keccak256(
 1290 | *   |                 abi.encode(
 1291 | *   |                     _EIP712_DOMAIN_HASH,
 1292 | *   |                     keccak256(bytes(Bytes32String.toString(_name))),
 1293 | *   |                     _EIP712_VERSION_HASH,
 1294 | *   |                     block.chainid,
 1295 | *   |                     address(this)
 1296 |     |                 )
 1297 |     |             );
 1298 |     |     }
 1299 |     | 
 1300 |     |     /**
 1301 |     |      * @dev    Returns the digest to be signed, via EIP-712, given an internal digest (i.e. hash struct).
 1302 |     |      * @param  internalDigest_ The internal digest.
 1303 |     |      * @return The digest to be signed.
 1304 |     |      */
 1305 |     |     function _getDigest(bytes32 internalDigest_) internal view returns (bytes32) {
 1306 |     |         return keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR(), internalDigest_));
 1307 |     |     }
 1308 |     | 
 1309 |     |     /**
 1310 |     |      * @dev   Revert if the signature is expired.
 1311 |     |      * @param expiry_ Timestamp at which the signature expires or max uint256 for no expiry.
 1312 |     |      */
 1313 |     |     function _revertIfExpired(uint256 expiry_) internal view {
 1314 |     |         if (block.timestamp > expiry_) revert SignatureExpired(expiry_, block.timestamp);
 1315 |     |     }
 1316 |     | 
 1317 |     |     /**
 1318 |     |      * @dev   Revert if the signature is invalid.
 1319 |     |      * @dev   We first validate if the signature is a valid ECDSA signature and return early if it is the case.
 1320 |     |      *        Then, we validate if it is a valid ERC-1271 signature, and return early if it is the case.
 1321 |     |      *        If not, we revert with the error from the ECDSA signature validation.
 1322 |     |      * @param signer_    The signer of the signature.
 1323 |     |      * @param digest_    The digest that was signed.
 1324 |     |      * @param signature_ The signature.
 1325 |     |      */
 1326 |     |     function _revertIfInvalidSignature(address signer_, bytes32 digest_, bytes memory signature_) internal view {
 1327 |     |         SignatureChecker.Error error_ = SignatureChecker.validateECDSASignature(signer_, digest_, signature_);
 1328 |     | 
 1329 |     |         if (error_ == SignatureChecker.Error.NoError) return;
 1330 |     | 
 1331 |     |         if (SignatureChecker.isValidERC1271Signature(signer_, digest_, signature_)) return;
 1332 |     | 
 1333 |     |         _revertIfError(error_);
 1334 |     |     }
 1335 |     | 
 1336 |     |     /**
 1337 |     |      * @dev    Returns the signer of a signed digest, via EIP-712, and reverts if the signature is invalid.
 1338 |     |      * @param  digest_ The digest that was signed.
 1339 |     |      * @param  v_      v of the signature.
 1340 |     |      * @param  r_      r of the signature.
 1341 |     |      * @param  s_      s of the signature.
 1342 |     |      * @return signer_ The signer of the digest.
 1343 |     |      */
 1344 |     |     function _getSignerAndRevertIfInvalidSignature(
 1345 |     |         bytes32 digest_,
 1346 |     |         uint8 v_,
 1347 |     |         bytes32 r_,
 1348 |     |         bytes32 s_
 1349 |     |     ) internal pure returns (address signer_) {
 1350 |     |         SignatureChecker.Error error_;
 1351 |     | 
 1352 |     |         (error_, signer_) = SignatureChecker.recoverECDSASigner(digest_, v_, r_, s_);
 1353 |     | 
 1354 |     |         _revertIfError(error_);
 1355 |     |     }
 1356 |     | 
 1357 |     |     /**
 1358 |     |      * @dev   Revert if the signature is invalid.
 1359 |     |      * @param signer_ The signer of the signature.
 1360 |     |      * @param digest_ The digest that was signed.
 1361 |     |      * @param r_      An ECDSA/secp256k1 signature parameter.
 1362 |     |      * @param vs_     An ECDSA/secp256k1 short signature parameter.
 1363 |     |      */
 1364 |     |     function _revertIfInvalidSignature(address signer_, bytes32 digest_, bytes32 r_, bytes32 vs_) internal pure {
 1365 |     |         _revertIfError(SignatureChecker.validateECDSASignature(signer_, digest_, r_, vs_));
 1366 |     |     }
 1367 |     | 
 1368 |     |     /**
 1369 |     |      * @dev   Revert if the signature is invalid.
 1370 |     |      * @param signer_ The signer of the signature.
 1371 |     |      * @param digest_ The digest that was signed.
 1372 |     |      * @param v_      v of the signature.
 1373 |     |      * @param r_      r of the signature.
 1374 |     |      * @param s_      s of the signature.
 1375 |     |      */
 1376 |     |     function _revertIfInvalidSignature(
 1377 |     |         address signer_,
 1378 |     |         bytes32 digest_,
 1379 |     |         uint8 v_,
 1380 |     |         bytes32 r_,
 1381 |     |         bytes32 s_
 1382 |     |     ) internal pure {
 1383 |     |         _revertIfError(SignatureChecker.validateECDSASignature(signer_, digest_, v_, r_, s_));
 1384 |     |     }
 1385 |     | 
 1386 |     |     /**
 1387 |     |      * @dev   Revert if error.
 1388 |     |      * @param error_ The SignatureChecker Error enum.
 1389 |     |      */
 1390 |     |     function _revertIfError(SignatureChecker.Error error_) private pure {
 1391 |     |         if (error_ == SignatureChecker.Error.NoError) return;
 1392 |     |         if (error_ == SignatureChecker.Error.InvalidSignature) revert InvalidSignature();
 1393 |     |         if (error_ == SignatureChecker.Error.InvalidSignatureLength) revert InvalidSignatureLength();
 1394 |     |         if (error_ == SignatureChecker.Error.InvalidSignatureS) revert InvalidSignatureS();
 1395 |     |         if (error_ == SignatureChecker.Error.InvalidSignatureV) revert InvalidSignatureV();
 1396 |     |         if (error_ == SignatureChecker.Error.SignerMismatch) revert SignerMismatch();
 1397 |     | 
 1398 |     |         revert InvalidSignature();
 1399 |     |     }
 1400 |     | }
 1401 |     | 
 1402 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/interfaces/IERC20Extended.sol
 1403 |     | 
 1404 |     | /**
 1405 |     |  * @title  An ERC20 token extended with EIP-2612 permits for signed approvals (via EIP-712
 1406 |     |  *         and with EIP-1271 compatibility), and extended with EIP-3009 transfer with authorization (via EIP-712).
 1407 |     |  * @author M^0 Labs
 1408 |     |  * @dev    The additional interface as defined by EIP-2612: https://eips.ethereum.org/EIPS/eip-2612
 1409 |     |  */
 1410 |     | interface IERC20Extended is IERC20, IERC3009 {
 1411 |     |     /* ============ Custom Errors ============ */
 1412 |     | 
 1413 |     |     /**
 1414 |     |      * @notice Revert message when spender's allowance is not sufficient.
 1415 |     |      * @param  spender    Address that may be allowed to operate on tokens without being their owner.
 1416 |     |      * @param  allowance  Amount of tokens a `spender` is allowed to operate with.
 1417 |     |      * @param  needed     Minimum amount required to perform a transfer.
 1418 |     |      */
 1419 |     |     error InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
 1420 |     | 
 1421 |     |     /**
 1422 |     |      * @notice Revert message emitted when the transferred amount is insufficient.
 1423 |     |      * @param  amount Amount transferred.
 1424 |     |      */
 1425 |     |     error InsufficientAmount(uint256 amount);
 1426 |     | 
 1427 |     |     /**
 1428 |     |      * @notice Revert message emitted when the recipient of a token is invalid.
 1429 |     |      * @param  recipient Address of the invalid recipient.
 1430 |     |      */
 1431 |     |     error InvalidRecipient(address recipient);
 1432 |     | 
 1433 |     |     /* ============ Interactive Functions ============ */
 1434 |     | 
 1435 |     |     /**
 1436 |     |      * @notice Approves `spender` to spend up to `amount` of the token balance of `owner`, via a signature.
 1437 |     |      * @param  owner    The address of the account who's token balance is being approved to be spent by `spender`.
 1438 |     |      * @param  spender  The address of an account allowed to spend on behalf of `owner`.
 1439 |     |      * @param  value    The amount of the allowance being approved.
 1440 |     |      * @param  deadline The last block number where the signature is still valid.
 1441 |     |      * @param  v        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 1442 |     |      * @param  r        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 1443 |     |      * @param  s        An ECDSA secp256k1 signature parameter (EIP-2612 via EIP-712).
 1444 |     |      */
 1445 |     |     function permit(
 1446 |     |         address owner,
 1447 |     |         address spender,
 1448 |     |         uint256 value,
 1449 |     |         uint256 deadline,
 1450 |     |         uint8 v,
 1451 |     |         bytes32 r,
 1452 |     |         bytes32 s
 1453 |     |     ) external;
 1454 |     | 
 1455 |     |     /**
 1456 |     |      * @notice Approves `spender` to spend up to `amount` of the token balance of `owner`, via a signature.
 1457 |     |      * @param  owner     The address of the account who's token balance is being approved to be spent by `spender`.
 1458 |     |      * @param  spender   The address of an account allowed to spend on behalf of `owner`.
 1459 |     |      * @param  value     The amount of the allowance being approved.
 1460 |     |      * @param  deadline  The last block number where the signature is still valid.
 1461 |     |      * @param  signature An arbitrary signature (EIP-712).
 1462 |     |      */
 1463 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) external;
 1464 |     | 
 1465 |     |     /* ============ View/Pure Functions ============ */
 1466 |     | 
 1467 |     |     /// @notice Returns the EIP712 typehash used in the encoding of the digest for the permit function.
 1468 |     |     function PERMIT_TYPEHASH() external view returns (bytes32);
 1469 |     | }
 1470 |     | 
 1471 |     | // test/fuzzing/mocks/wrappedMToken.sol/src/interfaces/IWrappedMToken.sol
 1472 |     | 
 1473 |     | /**
 1474 |     |  * @title  Wrapped M Token interface extending Extended ERC20.
 1475 |     |  * @author M^0 Labs
 1476 |     |  */
 1477 |     | interface IWrappedMToken is IMigratable, IERC20Extended {
 1478 |     |     /* ============ Events ============ */
 1479 |     | 
 1480 |     |     /**
 1481 |     |      * @notice Emitted when some yield is claim for `account` to `recipient`.
 1482 |     |      * @param  account   The account under which yield was generated.
 1483 |     |      * @param  recipient The account that received the yield.
 1484 |     |      * @param  yield     The amount of yield claimed.
 1485 |     |      */
 1486 |     |     event Claimed(address indexed account, address indexed recipient, uint240 yield);
 1487 |     | 
 1488 |     |     /**
 1489 |     |      * @notice Emitted when earning is enabled for the entire wrapper.
 1490 |     |      * @param  index The index at the moment earning is enabled.
 1491 |     |      */
 1492 |     |     event EarningEnabled(uint128 index);
 1493 |     | 
 1494 |     |     /**
 1495 |     |      * @notice Emitted when earning is disabled for the entire wrapper.
 1496 |     |      * @param  index The index at the moment earning is disabled.
 1497 |     |      */
 1498 |     |     event EarningDisabled(uint128 index);
 1499 |     | 
 1500 |     |     /**
 1501 |     |      * @notice Emitted when the wrapper's excess M is claimed.
 1502 |     |      * @param  excess The amount of excess M claimed.
 1503 |     |      */
 1504 |     |     event ExcessClaimed(uint240 excess);
 1505 |     | 
 1506 |     |     /**
 1507 |     |      * @notice Emitted when `account` starts being an wM earner.
 1508 |     |      * @param  account The account that started earning.
 1509 |     |      */
 1510 |     |     event StartedEarning(address indexed account);
 1511 |     | 
 1512 |     |     /**
 1513 |     |      * @notice Emitted when `account` stops being an wM earner.
 1514 |     |      * @param  account The account that stopped earning.
 1515 |     |      */
 1516 |     |     event StoppedEarning(address indexed account);
 1517 |     | 
 1518 |     |     /* ============ Custom Errors ============ */
 1519 |     | 
 1520 |     |     /// @notice Emitted when performing an operation that is not allowed when earning is disabled.
 1521 |     |     error EarningIsDisabled();
 1522 |     | 
 1523 |     |     /// @notice Emitted when performing an operation that is not allowed when earning is enabled.
 1524 |     |     error EarningIsEnabled();
 1525 |     | 
 1526 |     |     /// @notice Emitted when trying to enable earning after it has been explicitly disabled.
 1527 |     |     error EarningCannotBeReenabled();
 1528 |     | 
 1529 |     |     /// @notice Emitted when calling `stopEarning` for an account approved as earner by TTG.
 1530 |     |     error IsApprovedEarner();
 1531 |     | 
 1532 |     |     /**
 1533 |     |      * @notice Emitted when there is insufficient balance to decrement from `account`.
 1534 |     |      * @param  account The account with insufficient balance.
 1535 |     |      * @param  balance The balance of the account.
 1536 |     |      * @param  amount  The amount to decrement.
 1537 |     |      */
 1538 |     |     error InsufficientBalance(address account, uint240 balance, uint240 amount);
 1539 |     | 
 1540 |     |     /// @notice Emitted when calling `startEarning` for an account not approved as earner by TTG.
 1541 |     |     error NotApprovedEarner();
 1542 |     | 
 1543 |     |     /// @notice Emitted when the non-governance migrate function is called by a account other than the migration admin.
 1544 |     |     error UnauthorizedMigration();
 1545 |     | 
 1546 |     |     /// @notice Emitted in constructor if M Token is 0x0.
 1547 |     |     error ZeroMToken();
 1548 |     | 
 1549 |     |     /// @notice Emitted in constructor if Migration Admin is 0x0.
 1550 |     |     error ZeroMigrationAdmin();
 1551 |     | 
 1552 |     |     /* ============ Interactive Functions ============ */
 1553 |     | 
 1554 |     |     /**
 1555 |     |      * @notice Wraps `amount` M from the caller into wM for `recipient`.
 1556 |     |      * @param  recipient The account receiving the minted wM.
 1557 |     |      * @param  amount    The amount of M deposited.
 1558 |     |      * @return wrapped   The amount of wM minted.
 1559 |     |      */
 1560 |     |     function wrap(address recipient, uint256 amount) external returns (uint240 wrapped);
 1561 |     | 
 1562 |     |     /**
 1563 |     |      * @notice Wraps all the M from the caller into wM for `recipient`.
 1564 |     |      * @param  recipient The account receiving the minted wM.
 1565 |     |      * @return wrapped   The amount of wM minted.
 1566 |     |      */
 1567 |     |     function wrap(address recipient) external returns (uint240 wrapped);
 1568 |     | 
 1569 |     |     /**
 1570 |     |      * @notice Unwraps `amount` wM from the caller into M for `recipient`.
 1571 |     |      * @param  recipient The account receiving the withdrawn M.
 1572 |     |      * @param  amount    The amount of wM burned.
 1573 |     |      * @return unwrapped The amount of M withdrawn.
 1574 |     |      */
 1575 |     |     function unwrap(address recipient, uint256 amount) external returns (uint240 unwrapped);
 1576 |     | 
 1577 |     |     /**
 1578 |     |      * @notice Unwraps all the wM from the caller into M for `recipient`.
 1579 |     |      * @param  recipient The account receiving the withdrawn M.
 1580 |     |      * @return unwrapped The amount of M withdrawn.
 1581 |     |      */
 1582 |     |     function unwrap(address recipient) external returns (uint240 unwrapped);
 1583 |     | 
 1584 |     |     /**
 1585 |     |      * @notice Claims any claimable yield for `account`.
 1586 |     |      * @param  account The account under which yield was generated.
 1587 |     |      * @return yield   The amount of yield claimed.
 1588 |     |      */
 1589 |     |     function claimFor(address account) external returns (uint240 yield);
 1590 |     | 
 1591 |     |     /**
 1592 |     |      * @notice Claims any excess M of the wrapper.
 1593 |     |      * @return excess The amount of excess claimed.
 1594 |     |      */
 1595 |     |     function claimExcess() external returns (uint240 excess);
 1596 |     | 
 1597 |     |     /// @notice Enables earning for the wrapper if allowed by TTG and if it has never been done.
 1598 |     |     function enableEarning() external;
 1599 |     | 
 1600 |     |     /// @notice Disables earning for the wrapper if disallowed by TTG and if it has never been done.
 1601 |     |     function disableEarning() external;
 1602 |     | 
 1603 |     |     /**
 1604 |     |      * @notice Starts earning for `account` if allowed by TTG.
 1605 |     |      * @param  account The account to start earning for.
 1606 |     |      */
 1607 |     |     function startEarningFor(address account) external;
 1608 |     | 
 1609 |     |     /**
 1610 |     |      * @notice Stops earning for `account` if disallowed by TTG.
 1611 |     |      * @param  account The account to stop earning for.
 1612 |     |      */
 1613 |     |     function stopEarningFor(address account) external;
 1614 |     | 
 1615 |     |     /* ============ Temporary Admin Migration ============ */
 1616 |     | 
 1617 |     |     /**
 1618 |     |      * @notice Performs an arbitrarily defined migration.
 1619 |     |      * @param  migrator The address of a migrator contract.
 1620 |     |      */
 1621 |     |     function migrate(address migrator) external;
 1622 |     | 
 1623 |     |     /* ============ View/Pure Functions ============ */
 1624 |     | 
 1625 |     |     /**
 1626 |     |      * @notice Returns the yield accrued for `account`, which is claimable.
 1627 |     |      * @param  account The account being queried.
 1628 |     |      * @return yield   The amount of yield that is claimable.
 1629 |     |      */
 1630 |     |     function accruedYieldOf(address account) external view returns (uint240 yield);
 1631 |     | 
 1632 |     |     /**
 1633 |     |      * @notice Returns the token balance of `account` including any accrued yield.
 1634 |     |      * @param  account The address of some account.
 1635 |     |      * @return balance The token balance of `account` including any accrued yield.
 1636 |     |      */
 1637 |     |     function balanceWithYieldOf(address account) external view returns (uint256 balance);
 1638 |     | 
 1639 |     |     /**
 1640 |     |      * @notice Returns the last index of `account`.
 1641 |     |      * @param  account   The address of some account.
 1642 |     |      * @return lastIndex The last index of `account`, 0 if the account is not earning.
 1643 |     |      */
 1644 |     |     function lastIndexOf(address account) external view returns (uint128 lastIndex);
 1645 |     | 
 1646 |     |     /**
 1647 |     |      * @notice Returns the recipient to override as the destination for an account's claim of yield.
 1648 |     |      * @param  account   The account being queried.
 1649 |     |      * @return recipient The address of the recipient, if any, to override as the destination of claimed yield.
 1650 |     |      */
 1651 |     |     function claimOverrideRecipientFor(address account) external view returns (address recipient);
 1652 |     | 
 1653 |     |     /// @notice The current index of the wrapper's earning mechanism.
 1654 |     |     function currentIndex() external view returns (uint128 index);
 1655 |     | 
 1656 |     |     /// @notice The current excess M of the wrapper that is not earmarked for account balances or accrued yield.
 1657 |     |     function excess() external view returns (uint240 excess);
 1658 |     | 
 1659 |     |     /**
 1660 |     |      * @notice Returns whether `account` is a wM earner.
 1661 |     |      * @param  account   The account being queried.
 1662 |     |      * @return isEarning true if the account has started earning.
 1663 |     |      */
 1664 |     |     function isEarning(address account) external view returns (bool isEarning);
 1665 |     | 
 1666 |     |     /// @notice Whether earning is enabled for the entire wrapper.
 1667 |     |     function isEarningEnabled() external view returns (bool isEnabled);
 1668 |     | 
 1669 |     |     /// @notice Whether earning has been enabled at least once or not.
 1670 |     |     function wasEarningEnabled() external view returns (bool wasEnabled);
 1671 |     | 
 1672 |     |     /// @notice The account that can bypass TTG and call the `migrate(address migrator)` function.
 1673 |     |     function migrationAdmin() external view returns (address migrationAdmin);
 1674 |     | 
 1675 |     |     /// @notice The address of the M Token contract.
 1676 |     |     function mToken() external view returns (address mToken);
 1677 |     | 
 1678 |     |     /// @notice The address of the TTG registrar.
 1679 |     |     function registrar() external view returns (address registrar);
 1680 |     | 
 1681 |     |     /// @notice The portion of total supply that is not earning yield.
 1682 |     |     function totalNonEarningSupply() external view returns (uint240 totalSupply);
 1683 |     | 
 1684 |     |     /// @notice The accrued yield of the portion of total supply that is earning yield.
 1685 |     |     function totalAccruedYield() external view returns (uint240 yield);
 1686 |     | 
 1687 |     |     /// @notice The portion of total supply that is earning yield.
 1688 |     |     function totalEarningSupply() external view returns (uint240 totalSupply);
 1689 |     | 
 1690 |     |     /// @notice The principal of totalEarningSupply to help compute totalAccruedYield(), and thus excess().
 1691 |     |     function principalOfTotalEarningSupply() external view returns (uint112 principalOfTotalEarningSupply);
 1692 |     | 
 1693 |     |     /// @notice The address of the vault where excess is claimed to.
 1694 |     |     function vault() external view returns (address vault);
 1695 |     | }
 1696 |     | 
 1697 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/StatefulERC712.sol
 1698 |     | 
 1699 |     | /**
 1700 |     |  * @title  Stateful Extension for EIP-712 typed structured data hashing and signing with nonces.
 1701 |     |  * @author M^0 Labs
 1702 |     |  * @dev    An abstract implementation to satisfy stateful EIP-712 with nonces.
 1703 |     |  */
 1704 |     | abstract contract StatefulERC712 is IStatefulERC712, ERC712Extended {
 1705 |     |     /// @inheritdoc IStatefulERC712
 1706 |     |     mapping(address account => uint256 nonce) public nonces; // Nonces for all signatures.
 1707 |     | 
 1708 |     |     /**
 1709 |     |      * @notice Construct the StatefulERC712 contract.
 1710 |     |      * @param  name_ The name of the contract.
 1711 |     |      */
 1712 | *   |     constructor(string memory name_) ERC712Extended(name_) {}
 1713 |     | }
 1714 |     | 
 1715 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/ERC3009.sol
 1716 |     | 
 1717 |     | /**
 1718 |     |  * @title  ERC3009 implementation allowing the transfer of fungible assets via a signed authorization.
 1719 |     |  * @author M^0 Labs
 1720 |     |  * @dev    Inherits from ERC712 and StatefulERC712.
 1721 |     |  */
 1722 |     | abstract contract ERC3009 is IERC3009, StatefulERC712 {
 1723 |     |     /* ============ Variables ============ */
 1724 |     | 
 1725 |     |     // solhint-disable-next-line max-line-length
 1726 |     |     /// @dev        keccak256("TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)")
 1727 |     |     /// @inheritdoc IERC3009
 1728 |     |     bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =
 1729 |     |         0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;
 1730 |     | 
 1731 |     |     // solhint-disable-next-line max-line-length
 1732 |     |     /// @dev        keccak256("ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)")
 1733 |     |     /// @inheritdoc IERC3009
 1734 |     |     bytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH =
 1735 |     |         0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;
 1736 |     | 
 1737 |     |     /**
 1738 |     |      * @inheritdoc IERC3009
 1739 |     |      * @dev        keccak256("CancelAuthorization(address authorizer,bytes32 nonce)")
 1740 |     |      */
 1741 |     |     bytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH =
 1742 |     |         0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;
 1743 |     | 
 1744 |     |     /// @inheritdoc IERC3009
 1745 |     |     mapping(address authorizer => mapping(bytes32 nonce => bool isNonceUsed)) public authorizationState;
 1746 |     | 
 1747 |     |     /* ============ Constructor ============ */
 1748 |     | 
 1749 |     |     /**
 1750 |     |      * @notice Construct the ERC3009 contract.
 1751 |     |      * @param  name_ The name of the contract.
 1752 |     |      */
 1753 | *   |     constructor(string memory name_) StatefulERC712(name_) {}
 1754 |     | 
 1755 |     |     /* ============ Interactive Functions ============ */
 1756 |     | 
 1757 |     |     /// @inheritdoc IERC3009
 1758 |     |     function transferWithAuthorization(
 1759 |     |         address from_,
 1760 |     |         address to_,
 1761 |     |         uint256 value_,
 1762 |     |         uint256 validAfter_,
 1763 |     |         uint256 validBefore_,
 1764 |     |         bytes32 nonce_,
 1765 |     |         bytes memory signature_
 1766 |     |     ) external {
 1767 |     |         _revertIfInvalidSignature(
 1768 |     |             from_,
 1769 |     |             _getTransferWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 1770 |     |             signature_
 1771 |     |         );
 1772 |     | 
 1773 |     |         _transferWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 1774 |     |     }
 1775 |     | 
 1776 |     |     /// @inheritdoc IERC3009
 1777 |     |     function transferWithAuthorization(
 1778 |     |         address from_,
 1779 |     |         address to_,
 1780 |     |         uint256 value_,
 1781 |     |         uint256 validAfter_,
 1782 |     |         uint256 validBefore_,
 1783 |     |         bytes32 nonce_,
 1784 |     |         bytes32 r_,
 1785 |     |         bytes32 vs_
 1786 |     |     ) external {
 1787 |     |         _revertIfInvalidSignature(
 1788 |     |             from_,
 1789 |     |             _getTransferWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 1790 |     |             r_,
 1791 |     |             vs_
 1792 |     |         );
 1793 |     | 
 1794 |     |         _transferWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 1795 |     |     }
 1796 |     | 
 1797 |     |     /// @inheritdoc IERC3009
 1798 |     |     function transferWithAuthorization(
 1799 |     |         address from_,
 1800 |     |         address to_,
 1801 |     |         uint256 value_,
 1802 |     |         uint256 validAfter_,
 1803 |     |         uint256 validBefore_,
 1804 |     |         bytes32 nonce_,
 1805 |     |         uint8 v_,
 1806 |     |         bytes32 r_,
 1807 |     |         bytes32 s_
 1808 |     |     ) external {
 1809 |     |         _revertIfInvalidSignature(
 1810 |     |             from_,
 1811 |     |             _getTransferWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 1812 |     |             v_,
 1813 |     |             r_,
 1814 |     |             s_
 1815 |     |         );
 1816 |     | 
 1817 |     |         _transferWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 1818 |     |     }
 1819 |     | 
 1820 |     |     /// @inheritdoc IERC3009
 1821 |     |     function receiveWithAuthorization(
 1822 |     |         address from_,
 1823 |     |         address to_,
 1824 |     |         uint256 value_,
 1825 |     |         uint256 validAfter_,
 1826 |     |         uint256 validBefore_,
 1827 |     |         bytes32 nonce_,
 1828 |     |         bytes memory signature_
 1829 |     |     ) external {
 1830 |     |         _revertIfInvalidSignature(
 1831 |     |             from_,
 1832 |     |             _getReceiveWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 1833 |     |             signature_
 1834 |     |         );
 1835 |     | 
 1836 |     |         _receiveWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 1837 |     |     }
 1838 |     | 
 1839 |     |     /// @inheritdoc IERC3009
 1840 |     |     function receiveWithAuthorization(
 1841 |     |         address from_,
 1842 |     |         address to_,
 1843 |     |         uint256 value_,
 1844 |     |         uint256 validAfter_,
 1845 |     |         uint256 validBefore_,
 1846 |     |         bytes32 nonce_,
 1847 |     |         bytes32 r_,
 1848 |     |         bytes32 vs_
 1849 |     |     ) external {
 1850 |     |         _revertIfInvalidSignature(
 1851 |     |             from_,
 1852 |     |             _getReceiveWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 1853 |     |             r_,
 1854 |     |             vs_
 1855 |     |         );
 1856 |     | 
 1857 |     |         _receiveWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 1858 |     |     }
 1859 |     | 
 1860 |     |     /// @inheritdoc IERC3009
 1861 |     |     function receiveWithAuthorization(
 1862 |     |         address from_,
 1863 |     |         address to_,
 1864 |     |         uint256 value_,
 1865 |     |         uint256 validAfter_,
 1866 |     |         uint256 validBefore_,
 1867 |     |         bytes32 nonce_,
 1868 |     |         uint8 v_,
 1869 |     |         bytes32 r_,
 1870 |     |         bytes32 s_
 1871 |     |     ) external {
 1872 |     |         _revertIfInvalidSignature(
 1873 |     |             from_,
 1874 |     |             _getReceiveWithAuthorizationDigest(from_, to_, value_, validAfter_, validBefore_, nonce_),
 1875 |     |             v_,
 1876 |     |             r_,
 1877 |     |             s_
 1878 |     |         );
 1879 |     | 
 1880 |     |         _receiveWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 1881 |     |     }
 1882 |     | 
 1883 |     |     /// @inheritdoc IERC3009
 1884 |     |     function cancelAuthorization(address authorizer_, bytes32 nonce_, bytes memory signature_) external {
 1885 |     |         _revertIfInvalidSignature(authorizer_, _getCancelAuthorizationDigest(authorizer_, nonce_), signature_);
 1886 |     |         _cancelAuthorization(authorizer_, nonce_);
 1887 |     |     }
 1888 |     | 
 1889 |     |     /// @inheritdoc IERC3009
 1890 |     |     function cancelAuthorization(address authorizer_, bytes32 nonce_, bytes32 r_, bytes32 vs_) external {
 1891 |     |         _revertIfInvalidSignature(authorizer_, _getCancelAuthorizationDigest(authorizer_, nonce_), r_, vs_);
 1892 |     |         _cancelAuthorization(authorizer_, nonce_);
 1893 |     |     }
 1894 |     | 
 1895 |     |     /// @inheritdoc IERC3009
 1896 |     |     function cancelAuthorization(address authorizer_, bytes32 nonce_, uint8 v_, bytes32 r_, bytes32 s_) external {
 1897 |     |         _revertIfInvalidSignature(authorizer_, _getCancelAuthorizationDigest(authorizer_, nonce_), v_, r_, s_);
 1898 |     |         _cancelAuthorization(authorizer_, nonce_);
 1899 |     |     }
 1900 |     | 
 1901 |     |     /* ============ Internal Interactive Functions ============ */
 1902 |     | 
 1903 |     |     /**
 1904 |     |      * @dev   Common transfer function used by `transferWithAuthorization` and `_receiveWithAuthorization`.
 1905 |     |      * @param from_        Payer's address (Authorizer).
 1906 |     |      * @param to_          Payee's address.
 1907 |     |      * @param value_       Amount to be transferred.
 1908 |     |      * @param validAfter_  The time after which this is valid (unix time).
 1909 |     |      * @param validBefore_ The time before which this is valid (unix time).
 1910 |     |      * @param nonce_       Unique nonce.
 1911 |     |      */
 1912 |     |     function _transferWithAuthorization(
 1913 |     |         address from_,
 1914 |     |         address to_,
 1915 |     |         uint256 value_,
 1916 |     |         uint256 validAfter_,
 1917 |     |         uint256 validBefore_,
 1918 |     |         bytes32 nonce_
 1919 |     |     ) internal {
 1920 |     |         if (block.timestamp <= validAfter_) revert AuthorizationNotYetValid(block.timestamp, validAfter_);
 1921 |     |         if (block.timestamp >= validBefore_) revert AuthorizationExpired(block.timestamp, validBefore_);
 1922 |     | 
 1923 |     |         _revertIfAuthorizationAlreadyUsed(from_, nonce_);
 1924 |     | 
 1925 |     |         authorizationState[from_][nonce_] = true;
 1926 |     | 
 1927 |     |         emit AuthorizationUsed(from_, nonce_);
 1928 |     | 
 1929 |     |         _transfer(from_, to_, value_);
 1930 |     |     }
 1931 |     | 
 1932 |     |     /**
 1933 |     |      * @dev   Common receive function used by `receiveWithAuthorization`.
 1934 |     |      * @param from_        Payer's address (Authorizer).
 1935 |     |      * @param to_          Payee's address.
 1936 |     |      * @param value_       Amount to be transferred.
 1937 |     |      * @param validAfter_  The time after which this is valid (unix time).
 1938 |     |      * @param validBefore_ The time before which this is valid (unix time).
 1939 |     |      * @param nonce_       Unique nonce.
 1940 |     |      */
 1941 |     |     function _receiveWithAuthorization(
 1942 |     |         address from_,
 1943 |     |         address to_,
 1944 |     |         uint256 value_,
 1945 |     |         uint256 validAfter_,
 1946 |     |         uint256 validBefore_,
 1947 |     |         bytes32 nonce_
 1948 |     |     ) internal {
 1949 |     |         if (msg.sender != to_) revert CallerMustBePayee(msg.sender, to_);
 1950 |     | 
 1951 |     |         _transferWithAuthorization(from_, to_, value_, validAfter_, validBefore_, nonce_);
 1952 |     |     }
 1953 |     | 
 1954 |     |     /**
 1955 |     |      * @dev   Common cancel function used by `cancelAuthorization`.
 1956 |     |      * @param authorizer_ Authorizer's address.
 1957 |     |      * @param nonce_      Nonce of the authorization.
 1958 |     |      */
 1959 |     |     function _cancelAuthorization(address authorizer_, bytes32 nonce_) internal {
 1960 |     |         _revertIfAuthorizationAlreadyUsed(authorizer_, nonce_);
 1961 |     | 
 1962 |     |         authorizationState[authorizer_][nonce_] = true;
 1963 |     | 
 1964 |     |         emit AuthorizationCanceled(authorizer_, nonce_);
 1965 |     |     }
 1966 |     | 
 1967 |     |     /**
 1968 |     |      * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.
 1969 |     |      * @param sender_    The sender's address.
 1970 |     |      * @param recipient_ The recipient's address.
 1971 |     |      * @param amount_    The amount to be transferred.
 1972 |     |      */
 1973 |     |     function _transfer(address sender_, address recipient_, uint256 amount_) internal virtual;
 1974 |     | 
 1975 |     |     /* ============ Internal View/Pure Functions ============ */
 1976 |     | 
 1977 |     |     /**
 1978 |     |      * @dev    Returns the internal EIP-712 digest of a transferWithAuthorization call.
 1979 |     |      * @param  from_        Payer's address (Authorizer).
 1980 |     |      * @param  to_          Payee's address.
 1981 |     |      * @param  value_       Amount to be transferred.
 1982 |     |      * @param  validAfter_  The time after which this is valid (unix time).
 1983 |     |      * @param  validBefore_ The time before which this is valid (unix time).
 1984 |     |      * @param  nonce_       Unique nonce.
 1985 |     |      * @return The internal EIP-712 digest.
 1986 |     |      */
 1987 |     |     function _getTransferWithAuthorizationDigest(
 1988 |     |         address from_,
 1989 |     |         address to_,
 1990 |     |         uint256 value_,
 1991 |     |         uint256 validAfter_,
 1992 |     |         uint256 validBefore_,
 1993 |     |         bytes32 nonce_
 1994 |     |     ) internal view returns (bytes32) {
 1995 |     |         return
 1996 |     |             _getDigest(
 1997 |     |                 keccak256(
 1998 |     |                     abi.encode(
 1999 |     |                         TRANSFER_WITH_AUTHORIZATION_TYPEHASH,
 2000 |     |                         from_,
 2001 |     |                         to_,
 2002 |     |                         value_,
 2003 |     |                         validAfter_,
 2004 |     |                         validBefore_,
 2005 |     |                         nonce_
 2006 |     |                     )
 2007 |     |                 )
 2008 |     |             );
 2009 |     |     }
 2010 |     | 
 2011 |     |     /**
 2012 |     |      * @dev    Returns the internal EIP-712 digest of a receiveWithAuthorization call.
 2013 |     |      * @param  from_        Payer's address (Authorizer).
 2014 |     |      * @param  to_          Payee's address.
 2015 |     |      * @param  value_       Amount to be transferred.
 2016 |     |      * @param  validAfter_  The time after which this is valid (unix time).
 2017 |     |      * @param  validBefore_ The time before which this is valid (unix time).
 2018 |     |      * @param  nonce_       Unique nonce.
 2019 |     |      * @return The internal EIP-712 digest.
 2020 |     |      */
 2021 |     |     function _getReceiveWithAuthorizationDigest(
 2022 |     |         address from_,
 2023 |     |         address to_,
 2024 |     |         uint256 value_,
 2025 |     |         uint256 validAfter_,
 2026 |     |         uint256 validBefore_,
 2027 |     |         bytes32 nonce_
 2028 |     |     ) internal view returns (bytes32) {
 2029 |     |         return
 2030 |     |             _getDigest(
 2031 |     |                 keccak256(
 2032 |     |                     abi.encode(
 2033 |     |                         RECEIVE_WITH_AUTHORIZATION_TYPEHASH,
 2034 |     |                         from_,
 2035 |     |                         to_,
 2036 |     |                         value_,
 2037 |     |                         validAfter_,
 2038 |     |                         validBefore_,
 2039 |     |                         nonce_
 2040 |     |                     )
 2041 |     |                 )
 2042 |     |             );
 2043 |     |     }
 2044 |     | 
 2045 |     |     /**
 2046 |     |      * @dev    Returns the internal EIP-712 digest of a cancelAuthorization call.
 2047 |     |      * @param  authorizer_ Authorizer's address.
 2048 |     |      * @param  nonce_      Nonce of the authorization.
 2049 |     |      * @return The internal EIP-712 digest.
 2050 |     |      */
 2051 |     |     function _getCancelAuthorizationDigest(address authorizer_, bytes32 nonce_) internal view returns (bytes32) {
 2052 |     |         return _getDigest(keccak256(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, authorizer_, nonce_)));
 2053 |     |     }
 2054 |     | 
 2055 |     |     /**
 2056 |     |      * @dev   Reverts if the authorization is already used.
 2057 |     |      * @param authorizer_ The authorizer's address.
 2058 |     |      * @param nonce_      The nonce of the authorization.
 2059 |     |      */
 2060 |     |     function _revertIfAuthorizationAlreadyUsed(address authorizer_, bytes32 nonce_) internal view {
 2061 |     |         if (authorizationState[authorizer_][nonce_]) revert AuthorizationAlreadyUsed(authorizer_, nonce_);
 2062 |     |     }
 2063 |     | }
 2064 |     | 
 2065 |     | // test/fuzzing/mocks/wrappedMToken.sol/lib/common/src/ERC20Extended.sol
 2066 |     | 
 2067 |     | /**
 2068 |     |  * @title  An ERC20 token extended with EIP-2612 permits for signed approvals (via EIP-712 and with EIP-1271
 2069 |     |  *         and EIP-5267 compatibility), and extended with EIP-3009 transfer with authorization (via EIP-712).
 2070 |     |  * @author M^0 Labs
 2071 |     |  */
 2072 |     | abstract contract ERC20Extended is IERC20Extended, ERC3009 {
 2073 |     |     /* ============ Variables ============ */
 2074 |     | 
 2075 |     |     /**
 2076 |     |      * @inheritdoc IERC20Extended
 2077 |     |      * @dev Keeping this constant, despite `permit` parameter name differences, to ensure max EIP-2612 compatibility.
 2078 |     |      *      keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")
 2079 |     |      */
 2080 |     |     bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
 2081 |     | 
 2082 |     |     /// @inheritdoc IERC20
 2083 |     |     uint8 public immutable decimals;
 2084 |     | 
 2085 |     |     /// @dev The symbol of the token (stored as a bytes32 instead of a string in order to be immutable).
 2086 |     |     bytes32 internal immutable _symbol;
 2087 |     | 
 2088 |     |     /// @inheritdoc IERC20
 2089 |     |     mapping(address account => mapping(address spender => uint256 allowance)) public allowance;
 2090 |     | 
 2091 |     |     /* ============ Constructor ============ */
 2092 |     | 
 2093 |     |     /**
 2094 |     |      * @notice Constructs the ERC20Extended contract.
 2095 |     |      * @param  name_     The name of the token.
 2096 |     |      * @param  symbol_   The symbol of the token.
 2097 |     |      * @param  decimals_ The number of decimals the token uses.
 2098 |     |      */
 2099 | *   |     constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC3009(name_) {
 2100 | *   |         _symbol = Bytes32String.toBytes32(symbol_);
 2101 | *   |         decimals = decimals_;
 2102 |     |     }
 2103 |     | 
 2104 |     |     /* ============ Interactive Functions ============ */
 2105 |     | 
 2106 |     |     /// @inheritdoc IERC20
 2107 | *   |     function approve(address spender_, uint256 amount_) external returns (bool success_) {
 2108 | *   |         _approve(msg.sender, spender_, amount_);
 2109 | *   |         return true;
 2110 |     |     }
 2111 |     | 
 2112 |     |     /// @inheritdoc IERC20Extended
 2113 |     |     function permit(
 2114 |     |         address owner_,
 2115 |     |         address spender_,
 2116 |     |         uint256 value_,
 2117 |     |         uint256 deadline_,
 2118 |     |         uint8 v_,
 2119 |     |         bytes32 r_,
 2120 |     |         bytes32 s_
 2121 |     |     ) external {
 2122 |     |         _revertIfInvalidSignature(owner_, _permitAndGetDigest(owner_, spender_, value_, deadline_), v_, r_, s_);
 2123 |     |     }
 2124 |     | 
 2125 |     |     /// @inheritdoc IERC20Extended
 2126 |     |     function permit(
 2127 |     |         address owner_,
 2128 |     |         address spender_,
 2129 |     |         uint256 value_,
 2130 |     |         uint256 deadline_,
 2131 |     |         bytes memory signature_
 2132 |     |     ) external {
 2133 |     |         _revertIfInvalidSignature(owner_, _permitAndGetDigest(owner_, spender_, value_, deadline_), signature_);
 2134 |     |     }
 2135 |     | 
 2136 |     |     /// @inheritdoc IERC20
 2137 | *   |     function transfer(address recipient_, uint256 amount_) external returns (bool success_) {
 2138 | *   |         _transfer(msg.sender, recipient_, amount_);
 2139 | *   |         return true;
 2140 |     |     }
 2141 |     | 
 2142 |     |     /// @inheritdoc IERC20
 2143 | *   |     function transferFrom(address sender_, address recipient_, uint256 amount_) external returns (bool success_) {
 2144 | *   |         uint256 spenderAllowance_ = allowance[sender_][msg.sender]; // Cache `spenderAllowance_` to stack.
 2145 |     | 
 2146 | *   |         if (spenderAllowance_ != type(uint256).max) {
 2147 | *   |             if (spenderAllowance_ < amount_) revert InsufficientAllowance(msg.sender, spenderAllowance_, amount_);
 2148 |     | 
 2149 |     |             unchecked {
 2150 | *   |                 _setAllowance(sender_, msg.sender, spenderAllowance_ - amount_);
 2151 |     |             }
 2152 |     |         }
 2153 |     | 
 2154 | *   |         _transfer(sender_, recipient_, amount_);
 2155 |     | 
 2156 | *   |         return true;
 2157 |     |     }
 2158 |     | 
 2159 |     |     /* ============ View/Pure Functions ============ */
 2160 |     | 
 2161 |     |     /// @inheritdoc IERC20
 2162 |     |     function name() external view returns (string memory) {
 2163 |     |         return Bytes32String.toString(_name);
 2164 |     |     }
 2165 |     | 
 2166 |     |     /// @inheritdoc IERC20
 2167 |     |     function symbol() external view returns (string memory) {
 2168 |     |         return Bytes32String.toString(_symbol);
 2169 |     |     }
 2170 |     | 
 2171 |     |     /* ============ Internal Interactive Functions ============ */
 2172 |     | 
 2173 |     |     /**
 2174 |     |      * @dev Approve `spender_` to spend `amount_` of tokens from `account_`.
 2175 |     |      * @param  account_ The address approving the allowance.
 2176 |     |      * @param  spender_ The address approved to spend the tokens.
 2177 |     |      * @param  amount_  The amount of tokens being approved for spending.
 2178 |     |      */
 2179 | *   |     function _approve(address account_, address spender_, uint256 amount_) internal virtual {
 2180 | *   |         _setAllowance(account_, spender_, amount_);
 2181 | *   |         emit Approval(account_, spender_, amount_);
 2182 |     |     }
 2183 |     | 
 2184 |     |     /**
 2185 |     |      * @dev Set the `amount_` of tokens `spender_` is allowed to spend from `account_`.
 2186 |     |      * @param  account_ The address for which the allowance is set.
 2187 |     |      * @param  spender_ The address allowed to spend the tokens.
 2188 |     |      * @param  amount_  The amount of tokens being allowed for spending.
 2189 |     |      */
 2190 | *   |     function _setAllowance(address account_, address spender_, uint256 amount_) internal virtual {
 2191 | *   |         allowance[account_][spender_] = amount_;
 2192 |     |     }
 2193 |     | 
 2194 |     |     /**
 2195 |     |      * @dev    Performs the approval based on the permit info, validates the deadline, and returns the digest.
 2196 |     |      * @param  owner_    The address of the account approving the allowance.
 2197 |     |      * @param  spender_  The address of the account being allowed to spend the tokens.
 2198 |     |      * @param  amount_   The amount of tokens being approved for spending.
 2199 |     |      * @param  deadline_ The deadline by which the signature must be used.
 2200 |     |      * @return digest_   The EIP-712 digest of the permit.
 2201 |     |      */
 2202 |     |     function _permitAndGetDigest(
 2203 |     |         address owner_,
 2204 |     |         address spender_,
 2205 |     |         uint256 amount_,
 2206 |     |         uint256 deadline_
 2207 |     |     ) internal virtual returns (bytes32 digest_) {
 2208 |     |         _revertIfExpired(deadline_);
 2209 |     | 
 2210 |     |         _approve(owner_, spender_, amount_);
 2211 |     | 
 2212 |     |         unchecked {
 2213 |     |             // Nonce realistically cannot overflow.
 2214 |     |             return
 2215 |     |                 _getDigest(
 2216 |     |                     keccak256(abi.encode(PERMIT_TYPEHASH, owner_, spender_, amount_, nonces[owner_]++, deadline_))
 2217 |     |                 );
 2218 |     |         }
 2219 |     |     }
 2220 |     | }
 2221 |     | 
 2222 |     | // test/fuzzing/mocks/wrappedMToken.sol/src/WrappedMToken.sol
 2223 |     | 
 2224 |     | /*
 2225 |     | 
 2226 |     |                             
 2227 |     |                 
 2228 |     |                            
 2229 |     |                           
 2230 |     |                                  
 2231 |     |                                           
 2232 |     | 
 2233 |     | */
 2234 |     | 
 2235 |     | /**
 2236 |     |  * @title  ERC20 Token contract for wrapping M into a non-rebasing token with claimable yields.
 2237 |     |  * @author M^0 Labs
 2238 |     |  */
 2239 | *   | contract WrappedMToken is IWrappedMToken, Migratable, ERC20Extended {
 2240 |     |     struct Account {
 2241 |     |         bool isEarning;
 2242 |     |         uint240 balance;
 2243 |     |         uint128 lastIndex;
 2244 |     |     }
 2245 |     | 
 2246 |     |     /* ============ Variables ============ */
 2247 |     | 
 2248 |     |     /// @dev Registrar key holding value of whether the earners list can be ignored or not.
 2249 |     |     bytes32 internal constant _EARNERS_LIST_IGNORED = "earners_list_ignored";
 2250 |     | 
 2251 |     |     /// @dev Registrar key of earners list.
 2252 |     |     bytes32 internal constant _EARNERS_LIST = "earners";
 2253 |     | 
 2254 |     |     /// @dev Registrar key prefix to determine the override recipient of an account's accrued yield.
 2255 |     |     bytes32 internal constant _CLAIM_OVERRIDE_RECIPIENT_PREFIX = "wm_claim_override_recipient";
 2256 |     | 
 2257 |     |     /// @dev Registrar key prefix to determine the migrator contract.
 2258 |     |     bytes32 internal constant _MIGRATOR_V1_PREFIX = "wm_migrator_v1";
 2259 |     | 
 2260 |     |     /// @inheritdoc IWrappedMToken
 2261 |     |     address public immutable migrationAdmin;
 2262 |     | 
 2263 |     |     /// @inheritdoc IWrappedMToken
 2264 |     |     address public immutable mToken;
 2265 |     | 
 2266 |     |     /// @inheritdoc IWrappedMToken
 2267 |     |     address public immutable registrar;
 2268 |     | 
 2269 |     |     /// @inheritdoc IWrappedMToken
 2270 |     |     address public immutable vault;
 2271 |     | 
 2272 |     |     /// @inheritdoc IWrappedMToken
 2273 |     |     uint112 public principalOfTotalEarningSupply;
 2274 |     | 
 2275 |     |     /// @inheritdoc IWrappedMToken
 2276 |     |     uint240 public totalEarningSupply;
 2277 |     | 
 2278 |     |     /// @inheritdoc IWrappedMToken
 2279 |     |     uint240 public totalNonEarningSupply;
 2280 |     | 
 2281 |     |     /// @dev Mapping of accounts to their respective `AccountInfo` structs.
 2282 |     |     mapping(address account => Account balance) internal _accounts;
 2283 |     | 
 2284 |     |     /// @dev Array of indices at which earning was enabled or disabled.
 2285 |     |     uint128[] internal _enableDisableEarningIndices;
 2286 |     | 
 2287 |     |     /* ============ Constructor ============ */
 2288 |     | 
 2289 |     |     /**
 2290 |     |      * @dev   Constructs the contract given an M Token address and migration admin.
 2291 |     |      *        Note that a proxy will not need to initialize since there are no mutable storage values affected.
 2292 |     |      * @param mToken_         The address of an M Token.
 2293 |     |      * @param migrationAdmin_ The address of a migration admin.
 2294 |     |      */
 2295 | *   |     constructor(address mToken_, address migrationAdmin_) ERC20Extended("WrappedM by M^0", "wM", 6) {
 2296 | *   |         if ((mToken = mToken_) == address(0)) revert ZeroMToken();
 2297 | *   |         if ((migrationAdmin = migrationAdmin_) == address(0)) revert ZeroMigrationAdmin();
 2298 |     | 
 2299 | *   |         registrar = IMTokenLike(mToken_).ttgRegistrar();
 2300 | *   |         vault = IRegistrarLike(registrar).vault();
 2301 |     |     }
 2302 |     | 
 2303 |     |     /* ============ Interactive Functions ============ */
 2304 |     | 
 2305 |     |     /// @inheritdoc IWrappedMToken
 2306 | *   |     function wrap(address recipient_, uint256 amount_) external returns (uint240 wrapped_) {
 2307 | *   |         return _wrap(msg.sender, recipient_, UIntMath.safe240(amount_));
 2308 |     |     }
 2309 |     | 
 2310 |     |     /// @inheritdoc IWrappedMToken
 2311 |     |     function wrap(address recipient_) external returns (uint240 wrapped_) {
 2312 |     |         return _wrap(msg.sender, recipient_, UIntMath.safe240(IMTokenLike(mToken).balanceOf(msg.sender)));
 2313 |     |     }
 2314 |     | 
 2315 |     |     /// @inheritdoc IWrappedMToken
 2316 |     |     function unwrap(address recipient_, uint256 amount_) external returns (uint240 unwrapped_) {
 2317 |     |         return _unwrap(msg.sender, recipient_, UIntMath.safe240(amount_));
 2318 |     |     }
 2319 |     | 
 2320 |     |     /// @inheritdoc IWrappedMToken
 2321 |     |     function unwrap(address recipient_) external returns (uint240 unwrapped_) {
 2322 |     |         return _unwrap(msg.sender, recipient_, uint240(balanceWithYieldOf(msg.sender)));
 2323 |     |     }
 2324 |     | 
 2325 |     |     /// @inheritdoc IWrappedMToken
 2326 |     |     function claimFor(address account_) external returns (uint240 yield_) {
 2327 |     |         return _claim(account_, currentIndex());
 2328 |     |     }
 2329 |     | 
 2330 |     |     /// @inheritdoc IWrappedMToken
 2331 |     |     function claimExcess() external returns (uint240 excess_) {
 2332 |     |         emit ExcessClaimed(excess_ = excess());
 2333 |     | 
 2334 |     |         IMTokenLike(mToken).transfer(vault, excess_);
 2335 |     |     }
 2336 |     | 
 2337 |     |     /// @inheritdoc IWrappedMToken
 2338 |     |     function enableEarning() external {
 2339 |     |         _revertIfNotApprovedEarner(address(this));
 2340 |     | 
 2341 |     |         if (isEarningEnabled()) revert EarningIsEnabled();
 2342 |     | 
 2343 |     |         // NOTE: This is a temporary measure to prevent re-enabling earning after it has been disabled.
 2344 |     |         //       This line will be removed in the future.
 2345 |     |         if (wasEarningEnabled()) revert EarningCannotBeReenabled();
 2346 |     | 
 2347 |     |         uint128 currentMIndex_ = _currentMIndex();
 2348 |     | 
 2349 |     |         _enableDisableEarningIndices.push(currentMIndex_);
 2350 |     | 
 2351 |     |         IMTokenLike(mToken).startEarning();
 2352 |     | 
 2353 |     |         emit EarningEnabled(currentMIndex_);
 2354 |     |     }
 2355 |     | 
 2356 |     |     /// @inheritdoc IWrappedMToken
 2357 |     |     function disableEarning() external {
 2358 |     |         _revertIfApprovedEarner(address(this));
 2359 |     | 
 2360 |     |         if (!isEarningEnabled()) revert EarningIsDisabled();
 2361 |     | 
 2362 |     |         uint128 currentMIndex_ = _currentMIndex();
 2363 |     | 
 2364 |     |         _enableDisableEarningIndices.push(currentMIndex_);
 2365 |     | 
 2366 |     |         IMTokenLike(mToken).stopEarning();
 2367 |     | 
 2368 |     |         emit EarningDisabled(currentMIndex_);
 2369 |     |     }
 2370 |     | 
 2371 |     |     /// @inheritdoc IWrappedMToken
 2372 |     |     function startEarningFor(address account_) external {
 2373 |     |         _revertIfNotApprovedEarner(account_);
 2374 |     | 
 2375 |     |         if (!isEarningEnabled()) revert EarningIsDisabled();
 2376 |     | 
 2377 |     |         Account storage accountInfo_ = _accounts[account_];
 2378 |     | 
 2379 |     |         if (accountInfo_.isEarning) return;
 2380 |     | 
 2381 |     |         // NOTE: Use `currentIndex()` if/when upgrading to support `startEarningFor` while earning is disabled.
 2382 |     |         uint128 currentIndex_ = _currentMIndex();
 2383 |     | 
 2384 |     |         accountInfo_.isEarning = true;
 2385 |     |         accountInfo_.lastIndex = currentIndex_;
 2386 |     | 
 2387 |     |         uint240 balance_ = accountInfo_.balance;
 2388 |     | 
 2389 |     |         _addTotalEarningSupply(balance_, currentIndex_);
 2390 |     | 
 2391 |     |         unchecked {
 2392 |     |             totalNonEarningSupply -= balance_;
 2393 |     |         }
 2394 |     | 
 2395 |     |         emit StartedEarning(account_);
 2396 |     |     }
 2397 |     | 
 2398 |     |     /// @inheritdoc IWrappedMToken
 2399 |     |     function stopEarningFor(address account_) external {
 2400 |     |         _revertIfApprovedEarner(account_);
 2401 |     | 
 2402 |     |         uint128 currentIndex_ = currentIndex();
 2403 |     | 
 2404 |     |         _claim(account_, currentIndex_);
 2405 |     | 
 2406 |     |         Account storage accountInfo_ = _accounts[account_];
 2407 |     | 
 2408 |     |         if (!accountInfo_.isEarning) return;
 2409 |     | 
 2410 |     |         accountInfo_.isEarning = false;
 2411 |     |         accountInfo_.lastIndex = 0;
 2412 |     | 
 2413 |     |         uint240 balance_ = accountInfo_.balance;
 2414 |     | 
 2415 |     |         _subtractTotalEarningSupply(balance_, currentIndex_);
 2416 |     | 
 2417 |     |         unchecked {
 2418 |     |             totalNonEarningSupply += balance_;
 2419 |     |         }
 2420 |     | 
 2421 |     |         emit StoppedEarning(account_);
 2422 |     |     }
 2423 |     | 
 2424 |     |     /* ============ Temporary Admin Migration ============ */
 2425 |     | 
 2426 |     |     /// @inheritdoc IWrappedMToken
 2427 |     |     function migrate(address migrator_) external {
 2428 |     |         if (msg.sender != migrationAdmin) revert UnauthorizedMigration();
 2429 |     | 
 2430 |     |         _migrate(migrator_);
 2431 |     |     }
 2432 |     | 
 2433 |     |     /* ============ View/Pure Functions ============ */
 2434 |     | 
 2435 |     |     /// @inheritdoc IWrappedMToken
 2436 |     |     function accruedYieldOf(address account_) public view returns (uint240 yield_) {
 2437 |     |         Account storage accountInfo_ = _accounts[account_];
 2438 |     | 
 2439 |     |         if (!accountInfo_.isEarning) return 0;
 2440 |     | 
 2441 |     |         return _getAccruedYield(accountInfo_.balance, accountInfo_.lastIndex, currentIndex());
 2442 |     |     }
 2443 |     | 
 2444 |     |     /// @inheritdoc IERC20
 2445 | *   |     function balanceOf(address account_) public view returns (uint256 balance_) {
 2446 | *   |         return _accounts[account_].balance;
 2447 |     |     }
 2448 |     | 
 2449 |     |     /// @inheritdoc IWrappedMToken
 2450 |     |     function balanceWithYieldOf(address account_) public view returns (uint256 balance_) {
 2451 |     |         return balanceOf(account_) + accruedYieldOf(account_);
 2452 |     |     }
 2453 |     | 
 2454 |     |     /// @inheritdoc IWrappedMToken
 2455 |     |     function lastIndexOf(address account_) public view returns (uint128 lastIndex_) {
 2456 |     |         return _accounts[account_].lastIndex;
 2457 |     |     }
 2458 |     | 
 2459 |     |     /// @inheritdoc IWrappedMToken
 2460 |     |     function claimOverrideRecipientFor(address account_) public view returns (address recipient_) {
 2461 |     |         return
 2462 |     |             address(
 2463 |     |                 uint160(
 2464 |     |                     uint256(
 2465 |     |                         IRegistrarLike(registrar).get(keccak256(abi.encode(_CLAIM_OVERRIDE_RECIPIENT_PREFIX, account_)))
 2466 |     |                     )
 2467 |     |                 )
 2468 |     |             );
 2469 |     |     }
 2470 |     | 
 2471 |     |     /// @inheritdoc IWrappedMToken
 2472 | *   |     function currentIndex() public view returns (uint128 index_) {
 2473 | *   |         return isEarningEnabled() ? _currentMIndex() : _lastDisableEarningIndex();
 2474 |     |     }
 2475 |     | 
 2476 |     |     /// @inheritdoc IWrappedMToken
 2477 |     |     function isEarning(address account_) external view returns (bool isEarning_) {
 2478 |     |         return _accounts[account_].isEarning;
 2479 |     |     }
 2480 |     | 
 2481 |     |     /// @inheritdoc IWrappedMToken
 2482 | *   |     function isEarningEnabled() public view returns (bool isEnabled_) {
 2483 | *   |         return _enableDisableEarningIndices.length % 2 == 1;
 2484 |     |     }
 2485 |     | 
 2486 |     |     /// @inheritdoc IWrappedMToken
 2487 | *   |     function wasEarningEnabled() public view returns (bool wasEarning_) {
 2488 | *   |         return _enableDisableEarningIndices.length != 0;
 2489 |     |     }
 2490 |     | 
 2491 |     |     /// @inheritdoc IWrappedMToken
 2492 |     |     function excess() public view returns (uint240 excess_) {
 2493 |     |         unchecked {
 2494 |     |             uint128 currentIndex_ = currentIndex();
 2495 |     |             uint240 balance_ = uint240(IMTokenLike(mToken).balanceOf(address(this)));
 2496 |     |             uint240 earmarked_ = totalNonEarningSupply + _projectedEarningSupply(currentIndex_);
 2497 |     | 
 2498 |     |             return balance_ > earmarked_ ? _getSafeTransferableM(balance_ - earmarked_, currentIndex_) : 0;
 2499 |     |         }
 2500 |     |     }
 2501 |     | 
 2502 |     |     /// @inheritdoc IWrappedMToken
 2503 |     |     function totalAccruedYield() external view returns (uint240 yield_) {
 2504 |     |         uint240 projectedEarningSupply_ = _projectedEarningSupply(currentIndex());
 2505 |     |         uint240 earningSupply_ = totalEarningSupply;
 2506 |     | 
 2507 |     |         unchecked {
 2508 |     |             return projectedEarningSupply_ <= earningSupply_ ? 0 : projectedEarningSupply_ - earningSupply_;
 2509 |     |         }
 2510 |     |     }
 2511 |     | 
 2512 |     |     /// @inheritdoc IERC20
 2513 |     |     function totalSupply() external view returns (uint256 totalSupply_) {
 2514 |     |         return totalEarningSupply + totalNonEarningSupply;
 2515 |     |     }
 2516 |     | 
 2517 |     |     /* ============ Internal Interactive Functions ============ */
 2518 |     | 
 2519 |     |     /**
 2520 |     |      * @dev   Mints `amount_` tokens to `recipient_`.
 2521 |     |      * @param recipient_ The address whose account balance will be incremented.
 2522 |     |      * @param amount_    The present amount of tokens to mint.
 2523 |     |      */
 2524 | *   |     function _mint(address recipient_, uint240 amount_) internal {
 2525 | *   |         _revertIfInsufficientAmount(amount_);
 2526 | *   |         _revertIfInvalidRecipient(recipient_);
 2527 |     | 
 2528 | *   |         if (_accounts[recipient_].isEarning) {
 2529 |     |             uint128 currentIndex_ = currentIndex();
 2530 |     | 
 2531 |     |             _claim(recipient_, currentIndex_);
 2532 |     | 
 2533 |     |             // NOTE: Additional principal may end up being rounded to 0 and this will not `_revertIfInsufficientAmount`.
 2534 |     |             _addEarningAmount(recipient_, amount_, currentIndex_);
 2535 |     |         } else {
 2536 | *   |             _addNonEarningAmount(recipient_, amount_);
 2537 |     |         }
 2538 |     | 
 2539 | *   |         emit Transfer(address(0), recipient_, amount_);
 2540 |     |     }
 2541 |     | 
 2542 |     |     /**
 2543 |     |      * @dev   Burns `amount_` tokens from `account_`.
 2544 |     |      * @param account_ The address whose account balance will be decremented.
 2545 |     |      * @param amount_  The present amount of tokens to burn.
 2546 |     |      */
 2547 |     |     function _burn(address account_, uint240 amount_) internal {
 2548 |     |         _revertIfInsufficientAmount(amount_);
 2549 |     | 
 2550 |     |         if (_accounts[account_].isEarning) {
 2551 |     |             uint128 currentIndex_ = currentIndex();
 2552 |     | 
 2553 |     |             _claim(account_, currentIndex_);
 2554 |     | 
 2555 |     |             // NOTE: Subtracted principal may end up being rounded to 0 and this will not `_revertIfInsufficientAmount`.
 2556 |     |             _subtractEarningAmount(account_, amount_, currentIndex_);
 2557 |     |         } else {
 2558 |     |             _subtractNonEarningAmount(account_, amount_);
 2559 |     |         }
 2560 |     | 
 2561 |     |         emit Transfer(account_, address(0), amount_);
 2562 |     |     }
 2563 |     | 
 2564 |     |     /**
 2565 |     |      * @dev   Increments the token balance of `account_` by `amount_`, assuming non-earning status.
 2566 |     |      * @param account_ The address whose account balance will be incremented.
 2567 |     |      * @param amount_  The present amount of tokens to increment by.
 2568 |     |      */
 2569 | *   |     function _addNonEarningAmount(address account_, uint240 amount_) internal {
 2570 |     |         // NOTE: Can be `unchecked` because the max amount of wrappable M is never greater than `type(uint240).max`.
 2571 |     |         unchecked {
 2572 | *   |             _accounts[account_].balance += amount_;
 2573 | *   |             totalNonEarningSupply += amount_;
 2574 |     |         }
 2575 |     |     }
 2576 |     | 
 2577 |     |     /**
 2578 |     |      * @dev   Decrements the token balance of `account_` by `amount_`, assuming non-earning status.
 2579 |     |      * @param account_ The address whose account balance will be decremented.
 2580 |     |      * @param amount_  The present amount of tokens to decrement by.
 2581 |     |      */
 2582 |     |     function _subtractNonEarningAmount(address account_, uint240 amount_) internal {
 2583 |     |         unchecked {
 2584 |     |             Account storage accountInfo_ = _accounts[account_];
 2585 |     | 
 2586 |     |             uint240 balance_ = accountInfo_.balance;
 2587 |     | 
 2588 |     |             if (balance_ < amount_) revert InsufficientBalance(account_, balance_, amount_);
 2589 |     | 
 2590 |     |             accountInfo_.balance = balance_ - amount_;
 2591 |     |             totalNonEarningSupply -= amount_;
 2592 |     |         }
 2593 |     |     }
 2594 |     | 
 2595 |     |     /**
 2596 |     |      * @dev   Increments the token balance of `account_` by `amount_`, assuming earning status and updated index.
 2597 |     |      * @param account_      The address whose account balance will be incremented.
 2598 |     |      * @param amount_       The present amount of tokens to increment by.
 2599 |     |      * @param currentIndex_ The current index to use to compute the principal amount.
 2600 |     |      */
 2601 |     |     function _addEarningAmount(address account_, uint240 amount_, uint128 currentIndex_) internal {
 2602 |     |         // NOTE: Can be `unchecked` because the max amount of wrappable M is never greater than `type(uint240).max`.
 2603 |     |         unchecked {
 2604 |     |             _accounts[account_].balance += amount_;
 2605 |     |             _addTotalEarningSupply(amount_, currentIndex_);
 2606 |     |         }
 2607 |     |     }
 2608 |     | 
 2609 |     |     /**
 2610 |     |      * @dev   Decrements the token balance of `account_` by `amount_`, assuming earning status and updated index.
 2611 |     |      * @param account_      The address whose account balance will be decremented.
 2612 |     |      * @param amount_       The present amount of tokens to decrement by.
 2613 |     |      * @param currentIndex_ The current index to use to compute the principal amount.
 2614 |     |      */
 2615 |     |     function _subtractEarningAmount(address account_, uint240 amount_, uint128 currentIndex_) internal {
 2616 |     |         unchecked {
 2617 |     |             Account storage accountInfo_ = _accounts[account_];
 2618 |     | 
 2619 |     |             uint240 balance_ = accountInfo_.balance;
 2620 |     | 
 2621 |     |             if (balance_ < amount_) revert InsufficientBalance(account_, balance_, amount_);
 2622 |     | 
 2623 |     |             accountInfo_.balance = balance_ - amount_;
 2624 |     |             _subtractTotalEarningSupply(amount_, currentIndex_);
 2625 |     |         }
 2626 |     |     }
 2627 |     | 
 2628 |     |     /**
 2629 |     |      * @dev    Claims accrued yield for `account_` given a `currentIndex_`.
 2630 |     |      * @param  account_      The address to claim accrued yield for.
 2631 |     |      * @param  currentIndex_ The current index to accrue until.
 2632 |     |      * @return yield_        The accrued yield that was claimed.
 2633 |     |      */
 2634 | *   |     function _claim(address account_, uint128 currentIndex_) internal returns (uint240 yield_) {
 2635 | *   |         Account storage accountInfo_ = _accounts[account_];
 2636 |     | 
 2637 | *   |         if (!accountInfo_.isEarning) return 0;
 2638 |     | 
 2639 |     |         uint128 index_ = accountInfo_.lastIndex;
 2640 |     | 
 2641 |     |         if (currentIndex_ == index_) return 0;
 2642 |     | 
 2643 |     |         uint240 startingBalance_ = accountInfo_.balance;
 2644 |     | 
 2645 |     |         yield_ = _getAccruedYield(startingBalance_, index_, currentIndex_);
 2646 |     | 
 2647 |     |         accountInfo_.lastIndex = currentIndex_;
 2648 |     | 
 2649 |     |         unchecked {
 2650 |     |             if (yield_ == 0) return 0;
 2651 |     | 
 2652 |     |             accountInfo_.balance = startingBalance_ + yield_;
 2653 |     | 
 2654 |     |             // Update the total earning supply to account for the yield, but the principal has not changed.
 2655 |     |             totalEarningSupply += yield_;
 2656 |     |         }
 2657 |     | 
 2658 |     |         address claimOverrideRecipient_ = claimOverrideRecipientFor(account_);
 2659 |     |         address claimRecipient_ = claimOverrideRecipient_ == address(0) ? account_ : claimOverrideRecipient_;
 2660 |     | 
 2661 |     |         // Emit the appropriate `Claimed` and `Transfer` events, depending on the claim override recipient
 2662 |     |         emit Claimed(account_, claimRecipient_, yield_);
 2663 |     |         emit Transfer(address(0), account_, yield_);
 2664 |     | 
 2665 |     |         if (claimRecipient_ != account_) {
 2666 |     |             // NOTE: Watch out for a long chain of earning claim override recipients.
 2667 |     |             _transfer(account_, claimRecipient_, yield_, currentIndex_);
 2668 |     |         }
 2669 |     |     }
 2670 |     | 
 2671 |     |     /**
 2672 |     |      * @dev   Transfers `amount_` tokens from `sender_` to `recipient_` given some current index.
 2673 |     |      * @param sender_       The sender's address.
 2674 |     |      * @param recipient_    The recipient's address.
 2675 |     |      * @param amount_       The amount to be transferred.
 2676 |     |      * @param currentIndex_ The current index.
 2677 |     |      */
 2678 | *   |     function _transfer(address sender_, address recipient_, uint240 amount_, uint128 currentIndex_) internal {
 2679 | *   |         _revertIfInvalidRecipient(recipient_);
 2680 |     | 
 2681 |     |         // Claims for both the sender and recipient are required before transferring since add an subtract functions
 2682 |     |         // assume accounts' balances are up-to-date with the current index.
 2683 | *   |         _claim(sender_, currentIndex_);
 2684 | *   |         _claim(recipient_, currentIndex_);
 2685 |     | 
 2686 | *   |         emit Transfer(sender_, recipient_, amount_);
 2687 |     | 
 2688 | *   |         Account storage senderAccountInfo_ = _accounts[sender_];
 2689 | *   |         Account storage recipientAccountInfo_ = _accounts[recipient_];
 2690 |     | 
 2691 |     |         // If the sender and recipient are both earning or both non-earning, update their balances without affecting
 2692 |     |         // the total earning and non-earning supply storage variables.
 2693 | *   |         if (senderAccountInfo_.isEarning == recipientAccountInfo_.isEarning) {
 2694 | *   |             uint240 senderBalance_ = senderAccountInfo_.balance;
 2695 |     | 
 2696 | *   |             if (senderBalance_ < amount_) revert InsufficientBalance(sender_, senderBalance_, amount_);
 2697 |     | 
 2698 |     |             unchecked {
 2699 | *   |                 senderAccountInfo_.balance = senderBalance_ - amount_;
 2700 | *   |                 recipientAccountInfo_.balance += amount_;
 2701 |     |             }
 2702 |     | 
 2703 | *   |             return;
 2704 |     |         }
 2705 |     | 
 2706 |     |         senderAccountInfo_.isEarning
 2707 |     |             ? _subtractEarningAmount(sender_, amount_, currentIndex_)
 2708 |     |             : _subtractNonEarningAmount(sender_, amount_);
 2709 |     | 
 2710 |     |         recipientAccountInfo_.isEarning
 2711 |     |             ? _addEarningAmount(recipient_, amount_, currentIndex_)
 2712 |     |             : _addNonEarningAmount(recipient_, amount_);
 2713 |     |     }
 2714 |     | 
 2715 |     |     /**
 2716 |     |      * @dev   Internal ERC20 transfer function that needs to be implemented by the inheriting contract.
 2717 |     |      * @param sender_    The sender's address.
 2718 |     |      * @param recipient_ The recipient's address.
 2719 |     |      * @param amount_    The amount to be transferred.
 2720 |     |      */
 2721 | *   |     function _transfer(address sender_, address recipient_, uint256 amount_) internal override {
 2722 | *   |         _transfer(sender_, recipient_, UIntMath.safe240(amount_), currentIndex());
 2723 |     |     }
 2724 |     | 
 2725 |     |     /**
 2726 |     |      * @dev   Increments total earning supply by `amount_` tokens.
 2727 |     |      * @param amount_       The present amount of tokens to increment total earning supply by.
 2728 |     |      * @param currentIndex_ The current index used to compute the principal amount.
 2729 |     |      */
 2730 |     |     function _addTotalEarningSupply(uint240 amount_, uint128 currentIndex_) internal {
 2731 |     |         unchecked {
 2732 |     |             // Increment the total earning supply and principal proportionally.
 2733 |     |             totalEarningSupply += amount_;
 2734 |     |             principalOfTotalEarningSupply += IndexingMath.getPrincipalAmountRoundedUp(amount_, currentIndex_);
 2735 |     |         }
 2736 |     |     }
 2737 |     | 
 2738 |     |     /**
 2739 |     |      * @dev   Decrements total earning supply by `amount_` tokens.
 2740 |     |      * @param amount_       The present amount of tokens to decrement total earning supply by.
 2741 |     |      * @param currentIndex_ The current index used to compute the principal amount.
 2742 |     |      */
 2743 |     |     function _subtractTotalEarningSupply(uint240 amount_, uint128 currentIndex_) internal {
 2744 |     |         if (amount_ >= totalEarningSupply) {
 2745 |     |             totalEarningSupply = 0;
 2746 |     |             principalOfTotalEarningSupply = 0;
 2747 |     | 
 2748 |     |             return;
 2749 |     |         }
 2750 |     | 
 2751 |     |         unchecked {
 2752 |     |             uint112 principal_ = IndexingMath.getPrincipalAmountRoundedDown(amount_, currentIndex_);
 2753 |     | 
 2754 |     |             principalOfTotalEarningSupply -= (
 2755 |     |                 principal_ > principalOfTotalEarningSupply ? principalOfTotalEarningSupply : principal_
 2756 |     |             );
 2757 |     | 
 2758 |     |             totalEarningSupply -= amount_;
 2759 |     |         }
 2760 |     |     }
 2761 |     | 
 2762 |     |     /**
 2763 |     |      * @dev    Wraps `amount` M from `account_` into wM for `recipient`.
 2764 |     |      * @param  account_   The account from which M is deposited.
 2765 |     |      * @param  recipient_ The account receiving the minted wM.
 2766 |     |      * @param  amount_    The amount of M deposited.
 2767 |     |      * @return wrapped_   The amount of wM minted.
 2768 |     |      */
 2769 | *   |     function _wrap(address account_, address recipient_, uint240 amount_) internal returns (uint240 wrapped_) {
 2770 | *   |         uint256 startingBalance_ = IMTokenLike(mToken).balanceOf(address(this));
 2771 |     | 
 2772 |     |         // NOTE: The behavior of `IMTokenLike.transferFrom` is known, so its return can be ignored.
 2773 | *   |         IMTokenLike(mToken).transferFrom(account_, address(this), amount_);
 2774 |     | 
 2775 |     |         // NOTE: When this WrappedMToken contract is earning, any amount of M sent to it is converted to a principal
 2776 |     |         //       amount at the MToken contract, which when represented as a present amount, may be a rounding error
 2777 |     |         //       amount less than `amount_`. In order to capture the real increase in M, the difference between the
 2778 |     |         //       starting and ending M balance is minted as WrappedM.
 2779 | *   |         _mint(recipient_, wrapped_ = UIntMath.safe240(IMTokenLike(mToken).balanceOf(address(this)) - startingBalance_));
 2780 |     |     }
 2781 |     | 
 2782 |     |     /**
 2783 |     |      * @dev    Unwraps `amount` wM from `account_` into M for `recipient`.
 2784 |     |      * @param  account_   The account from which WM is burned.
 2785 |     |      * @param  recipient_ The account receiving the withdrawn M.
 2786 |     |      * @param  amount_    The amount of wM burned.
 2787 |     |      * @return unwrapped_ The amount of M withdrawn.
 2788 |     |      */
 2789 |     |     function _unwrap(address account_, address recipient_, uint240 amount_) internal returns (uint240 unwrapped_) {
 2790 |     |         _burn(account_, amount_);
 2791 |     | 
 2792 |     |         uint256 startingBalance_ = IMTokenLike(mToken).balanceOf(address(this));
 2793 |     | 
 2794 |     |         // NOTE: The behavior of `IMTokenLike.transfer` is known, so its return can be ignored.
 2795 |     |         IMTokenLike(mToken).transfer(recipient_, _getSafeTransferableM(amount_, currentIndex()));
 2796 |     | 
 2797 |     |         // NOTE: When this WrappedMToken contract is earning, any amount of M sent from it is converted to a principal
 2798 |     |         //       amount at the MToken contract, which when represented as a present amount, may be a rounding error
 2799 |     |         //       amount more than `amount_`. In order to capture the real decrease in M, the difference between the
 2800 |     |         //       ending and starting M balance is returned.
 2801 |     |         return UIntMath.safe240(startingBalance_ - IMTokenLike(mToken).balanceOf(address(this)));
 2802 |     |     }
 2803 |     | 
 2804 |     |     /* ============ Internal View/Pure Functions ============ */
 2805 |     | 
 2806 |     |     /// @dev Returns the current index of the M Token.
 2807 |     |     function _currentMIndex() internal view returns (uint128 index_) {
 2808 |     |         return IMTokenLike(mToken).currentIndex();
 2809 |     |     }
 2810 |     | 
 2811 |     |     /// @dev Returns the earning index from the last `disableEarning` call.
 2812 | *   |     function _lastDisableEarningIndex() internal view returns (uint128 index_) {
 2813 | *   |         return wasEarningEnabled() ? _unsafeAccess(_enableDisableEarningIndices, 1) : 0;
 2814 |     |     }
 2815 |     | 
 2816 |     |     /**
 2817 |     |      * @dev    Compute the yield given an account's balance, last index, and the current index.
 2818 |     |      * @param  balance_      The token balance of an earning account.
 2819 |     |      * @param  lastIndex_    The index of ast interaction for the account.
 2820 |     |      * @param  currentIndex_ The current index.
 2821 |     |      * @return yield_        The yield accrued since the last interaction.
 2822 |     |      */
 2823 |     |     function _getAccruedYield(
 2824 |     |         uint240 balance_,
 2825 |     |         uint128 lastIndex_,
 2826 |     |         uint128 currentIndex_
 2827 |     |     ) internal pure returns (uint240 yield_) {
 2828 |     |         uint240 balanceWithYield_ = IndexingMath.getPresentAmountRoundedDown(
 2829 |     |             IndexingMath.getPrincipalAmountRoundedDown(balance_, lastIndex_),
 2830 |     |             currentIndex_
 2831 |     |         );
 2832 |     | 
 2833 |     |         unchecked {
 2834 |     |             return (balanceWithYield_ <= balance_) ? 0 : balanceWithYield_ - balance_;
 2835 |     |         }
 2836 |     |     }
 2837 |     | 
 2838 |     |     /**
 2839 |     |      * @dev    Compute the adjusted amount of M that can safely be transferred out given the current index.
 2840 |     |      * @param  amount_       Some amount to be transferred out of the wrapper.
 2841 |     |      * @param  currentIndex_ The current index.
 2842 |     |      * @return safeAmount_   The adjusted amount that can safely be transferred out.
 2843 |     |      */
 2844 |     |     function _getSafeTransferableM(uint240 amount_, uint128 currentIndex_) internal view returns (uint240 safeAmount_) {
 2845 |     |         // If the wrapper is earning, adjust `amount_` to ensure it's M balance decrement is limited to `amount_`.
 2846 |     |         return
 2847 |     |             IMTokenLike(mToken).isEarning(address(this))
 2848 |     |                 ? IndexingMath.getPresentAmountRoundedDown(
 2849 |     |                     IndexingMath.getPrincipalAmountRoundedDown(amount_, currentIndex_),
 2850 |     |                     currentIndex_
 2851 |     |                 )
 2852 |     |                 : amount_;
 2853 |     |     }
 2854 |     | 
 2855 |     |     /// @dev Returns the address of the contract to use as a migrator, if any.
 2856 |     |     function _getMigrator() internal view override returns (address migrator_) {
 2857 |     |         return
 2858 |     |             address(
 2859 |     |                 uint160(
 2860 |     |                     // NOTE: A subsequent implementation should use a unique migrator prefix.
 2861 |     |                     uint256(IRegistrarLike(registrar).get(keccak256(abi.encode(_MIGRATOR_V1_PREFIX, address(this)))))
 2862 |     |                 )
 2863 |     |             );
 2864 |     |     }
 2865 |     | 
 2866 |     |     /**
 2867 |     |      * @dev    Returns whether `account_` is a TTG-approved earner.
 2868 |     |      * @param  account_    The account being queried.
 2869 |     |      * @return isApproved_ True if the account_ is a TTG-approved earner, false otherwise.
 2870 |     |      */
 2871 |     |     function _isApprovedEarner(address account_) internal view returns (bool isApproved_) {
 2872 |     |         return
 2873 |     |             IRegistrarLike(registrar).get(_EARNERS_LIST_IGNORED) != bytes32(0) ||
 2874 |     |             IRegistrarLike(registrar).listContains(_EARNERS_LIST, account_);
 2875 |     |     }
 2876 |     | 
 2877 |     |     /**
 2878 |     |      * @dev    Returns the projected total earning supply if all accrued yield was claimed at this moment.
 2879 |     |      * @param  currentIndex_ The current index.
 2880 |     |      * @return supply_       The projected total earning supply.
 2881 |     |      */
 2882 |     |     function _projectedEarningSupply(uint128 currentIndex_) internal view returns (uint240 supply_) {
 2883 |     |         return IndexingMath.getPresentAmountRoundedDown(principalOfTotalEarningSupply, currentIndex_);
 2884 |     |     }
 2885 |     | 
 2886 |     |     /**
 2887 |     |      * @dev   Reverts if `amount_` is equal to 0.
 2888 |     |      * @param amount_ Amount of token.
 2889 |     |      */
 2890 | *   |     function _revertIfInsufficientAmount(uint256 amount_) internal pure {
 2891 | *   |         if (amount_ == 0) revert InsufficientAmount(amount_);
 2892 |     |     }
 2893 |     | 
 2894 |     |     /**
 2895 |     |      * @dev   Reverts if `recipient_` is address(0).
 2896 |     |      * @param recipient_ Address of a recipient.
 2897 |     |      */
 2898 | *   |     function _revertIfInvalidRecipient(address recipient_) internal pure {
 2899 | *   |         if (recipient_ == address(0)) revert InvalidRecipient(recipient_);
 2900 |     |     }
 2901 |     | 
 2902 |     |     /**
 2903 |     |      * @dev   Reverts if `account_` is an approved earner.
 2904 |     |      * @param account_ Address of an account.
 2905 |     |      */
 2906 |     |     function _revertIfApprovedEarner(address account_) internal view {
 2907 |     |         if (_isApprovedEarner(account_)) revert IsApprovedEarner();
 2908 |     |     }
 2909 |     | 
 2910 |     |     /**
 2911 |     |      * @dev   Reverts if `account_` is not an approved earner.
 2912 |     |      * @param account_ Address of an account.
 2913 |     |      */
 2914 |     |     function _revertIfNotApprovedEarner(address account_) internal view {
 2915 |     |         if (!_isApprovedEarner(account_)) revert NotApprovedEarner();
 2916 |     |     }
 2917 |     | 
 2918 |     |     /**
 2919 |     |      * @dev   Reads the uint128 value at some index of an array of uint128 values whose storage pointer is given,
 2920 |     |      *        assuming the index is valid, without wasting gas checking for out-of-bounds errors.
 2921 |     |      * @param array_ The storage pointer of an array of uint128 values.
 2922 |     |      * @param i_     The index of the array to read.
 2923 |     |      */
 2924 |     |     function _unsafeAccess(uint128[] storage array_, uint256 i_) internal view returns (uint128 value_) {
 2925 |     |         assembly {
 2926 |     |             mstore(0, array_.slot)
 2927 |     | 
 2928 |     |             value_ := sload(add(keccak256(0, 0x20), div(i_, 2)))
 2929 |     | 
 2930 |     |             // Since uint128 values take up either the top half or bottom half of a slot, shift the result accordingly.
 2931 |     |             if eq(mod(i_, 2), 1) {
 2932 |     |                 value_ := shr(128, value_)
 2933 |     |             }
 2934 |     |         }
 2935 |     |     }
 2936 |     | }
 2937 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/abstract/ContinuousIndexing.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import { IContinuousIndexing } from "../interfaces/IContinuousIndexing.sol";
   6 |     | 
   7 |     | import { ContinuousIndexingMath } from "../libs/ContinuousIndexingMath.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title Abstract Continuous Indexing Contract to handle rate/index updates in inheriting contracts.
  11 |     |  * @author M^0 Labs
  12 |     |  */
  13 |     | abstract contract ContinuousIndexing is IContinuousIndexing {
  14 |     |     /* ============ Variables ============ */
  15 |     | 
  16 |     |     /// @inheritdoc IContinuousIndexing
  17 |     |     uint128 public latestIndex;
  18 |     | 
  19 |     |     /// @dev The latest updated rate.
  20 |     |     uint32 internal _latestRate;
  21 |     | 
  22 |     |     /// @inheritdoc IContinuousIndexing
  23 |     |     uint40 public latestUpdateTimestamp;
  24 |     | 
  25 |     |     /* ============ Constructor ============ */
  26 |     | 
  27 |     |     /// @notice Constructs the ContinuousIndexing contract.
  28 |     |     constructor() {
  29 | *   |         latestIndex = ContinuousIndexingMath.EXP_SCALED_ONE;
  30 | *   |         latestUpdateTimestamp = uint40(block.timestamp);
  31 |     |     }
  32 |     | 
  33 |     |     /* ============ Interactive Functions ============ */
  34 |     | 
  35 |     |     /// @inheritdoc IContinuousIndexing
  36 | *   |     function updateIndex() public virtual returns (uint128 currentIndex_) {
  37 |     |         // NOTE: `_rate()` can depend indirectly on `latestIndex` and `latestUpdateTimestamp`, if the RateModel
  38 |     |         //       depends on earning balances/supply, which depends on `currentIndex()`, so only update them after this.
  39 | *   |         uint32 rate_ = _rate();
  40 |     | 
  41 | *   |         if (latestUpdateTimestamp == block.timestamp && _latestRate == rate_) return latestIndex;
  42 |     | 
  43 |     |         // NOTE: `currentIndex()` depends on `_latestRate`, so only update it after this.
  44 | *   |         latestIndex = currentIndex_ = currentIndex();
  45 | *   |         _latestRate = rate_;
  46 | *   |         latestUpdateTimestamp = uint40(block.timestamp);
  47 |     | 
  48 | *   |         emit IndexUpdated(currentIndex_, rate_);
  49 |     |     }
  50 |     | 
  51 |     |     /* ============ View/Pure Functions ============ */
  52 |     | 
  53 |     |     /// @inheritdoc IContinuousIndexing
  54 |     |     function currentIndex() public view virtual returns (uint128);
  55 |     | 
  56 |     |     /* ============ Internal View/Pure Functions ============ */
  57 |     | 
  58 |     |     /**
  59 |     |      * @dev    Returns the principal amount (rounded down) given the present amount, using the current index.
  60 |     |      * @param  presentAmount_ The present amount.
  61 |     |      * @return The principal amount rounded down.
  62 |     |      */
  63 | *   |     function _getPrincipalAmountRoundedDown(uint240 presentAmount_) internal view returns (uint112) {
  64 | *   |         return _getPrincipalAmountRoundedDown(presentAmount_, currentIndex());
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev    Returns the principal amount (rounded up) given the present amount and an index.
  69 |     |      * @param  presentAmount_ The present amount.
  70 |     |      * @return The principal amount rounded up.
  71 |     |      */
  72 | *   |     function _getPrincipalAmountRoundedUp(uint240 presentAmount_) internal view returns (uint112) {
  73 | *   |         return _getPrincipalAmountRoundedUp(presentAmount_, currentIndex());
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev    Returns the present amount (rounded down) given the principal amount and an index.
  78 |     |      * @param  principalAmount_ The principal amount.
  79 |     |      * @param  index_           An index.
  80 |     |      * @return The present amount rounded down.
  81 |     |      */
  82 | *   |     function _getPresentAmountRoundedDown(uint112 principalAmount_, uint128 index_) internal pure returns (uint240) {
  83 | *   |         return ContinuousIndexingMath.multiplyDown(principalAmount_, index_);
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev    Returns the present amount (rounded up) given the principal amount and an index.
  88 |     |      * @param  principalAmount_ The principal amount.
  89 |     |      * @param  index_           An index.
  90 |     |      * @return The present amount rounded up.
  91 |     |      */
  92 |     |     function _getPresentAmountRoundedUp(uint112 principalAmount_, uint128 index_) internal pure returns (uint240) {
  93 |     |         return ContinuousIndexingMath.multiplyUp(principalAmount_, index_);
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev    Returns the principal amount given the present amount, using the current index.
  98 |     |      * @param  presentAmount_ The present amount.
  99 |     |      * @param  index_         An index.
 100 |     |      * @return The principal amount rounded down.
 101 |     |      */
 102 | *   |     function _getPrincipalAmountRoundedDown(uint240 presentAmount_, uint128 index_) internal pure returns (uint112) {
 103 | *   |         return ContinuousIndexingMath.divideDown(presentAmount_, index_);
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev    Returns the principal amount given the present amount, using the current index.
 108 |     |      * @param  presentAmount_ The present amount.
 109 |     |      * @param  index_         An index.
 110 |     |      * @return The principal amount rounded up.
 111 |     |      */
 112 | *   |     function _getPrincipalAmountRoundedUp(uint240 presentAmount_, uint128 index_) internal pure returns (uint112) {
 113 | *   |         return ContinuousIndexingMath.divideUp(presentAmount_, index_);
 114 |     |     }
 115 |     | 
 116 |     |     /// @dev To be overridden by the inheriting contract to return the current rate.
 117 |     |     function _rate() internal view virtual returns (uint32);
 118 |     | }
 119 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/interfaces/IContinuousIndexing.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  Continuous Indexing Interface.
  7 |     |  * @author M^0 Labs
  8 |     |  */
  9 |     | interface IContinuousIndexing {
 10 |     |     /* ============ Events ============ */
 11 |     | 
 12 |     |     /**
 13 |     |      * @notice Emitted when the index is updated.
 14 |     |      * @param  index The new index.
 15 |     |      * @param  rate  The current rate.
 16 |     |      */
 17 |     |     event IndexUpdated(uint128 indexed index, uint32 indexed rate);
 18 |     | 
 19 |     |     /* ============ Interactive Functions ============ */
 20 |     | 
 21 |     |     /**
 22 |     |      * @notice Updates the latest index and latest accrual time in storage.
 23 |     |      * @return index The new stored index for computing present amounts from principal amounts.
 24 |     |      */
 25 |     |     function updateIndex() external returns (uint128);
 26 |     | 
 27 |     |     /* ============ View/Pure Functions ============ */
 28 |     | 
 29 |     |     /// @notice The current index that would be written to storage if `updateIndex` is called.
 30 |     |     function currentIndex() external view returns (uint128);
 31 |     | 
 32 |     |     /// @notice The latest updated index.
 33 |     |     function latestIndex() external view returns (uint128);
 34 |     | 
 35 |     |     /// @notice The latest timestamp when the index was updated.
 36 |     |     function latestUpdateTimestamp() external view returns (uint40);
 37 |     | }
 38 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/interfaces/IMToken.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import { IERC20Extended } from "lib/common/src/interfaces/IERC20Extended.sol";
   6 |     | 
   7 |     | import { IContinuousIndexing } from "./IContinuousIndexing.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title  M Token Interface.
  11 |     |  * @author M^0 Labs
  12 |     |  */
  13 |     | interface IMToken is IContinuousIndexing, IERC20Extended {
  14 |     |     /* ============ Events ============ */
  15 |     | 
  16 |     |     /**
  17 |     |      * @notice Emitted when account starts being an M earner.
  18 |     |      * @param  account The account that started earning.
  19 |     |      */
  20 |     |     event StartedEarning(address indexed account);
  21 |     | 
  22 |     |     /**
  23 |     |      * @notice Emitted when account stops being an M earner.
  24 |     |      * @param  account The account that stopped earning.
  25 |     |      */
  26 |     |     event StoppedEarning(address indexed account);
  27 |     | 
  28 |     |     /* ============ Custom Errors ============ */
  29 |     | 
  30 |     |     /**
  31 |     |      * @notice Emitted when there is insufficient balance to decrement from `account`.
  32 |     |      * @param  account     The account with insufficient balance.
  33 |     |      * @param  rawBalance  The raw balance of the account.
  34 |     |      * @param  amount      The amount to decrement the `rawBalance` by.
  35 |     |      */
  36 |     |     error InsufficientBalance(address account, uint256 rawBalance, uint256 amount);
  37 |     | 
  38 |     |     /// @notice Emitted when calling `stopEarning` for an account approved as earner by TTG.
  39 |     |     error IsApprovedEarner();
  40 |     | 
  41 |     |     /// @notice Emitted when calling `startEarning` for an account not approved as earner by TTG.
  42 |     |     error NotApprovedEarner();
  43 |     | 
  44 |     |     /// @notice Emitted when calling `mint`, `burn` not by Minter Gateway.
  45 |     |     error NotMinterGateway();
  46 |     | 
  47 |     |     /// @notice Emitted when principal of total supply (earning and non-earning) will overflow a `type(uint112).max`.
  48 |     |     error OverflowsPrincipalOfTotalSupply();
  49 |     | 
  50 |     |     /// @notice Emitted in constructor if Minter Gateway is 0x0.
  51 |     |     error ZeroMinterGateway();
  52 |     | 
  53 |     |     /// @notice Emitted in constructor if TTG Registrar is 0x0.
  54 |     |     error ZeroTTGRegistrar();
  55 |     | 
  56 |     |     /* ============ Interactive Functions ============ */
  57 |     | 
  58 |     |     /**
  59 |     |      * @notice Mints tokens.
  60 |     |      * @param  account The address of account to mint to.
  61 |     |      * @param  amount  The amount of M Token to mint.
  62 |     |      */
  63 |     |     function mint(address account, uint256 amount) external;
  64 |     | 
  65 |     |     /**
  66 |     |      * @notice Burns tokens.
  67 |     |      * @param  account The address of account to burn from.
  68 |     |      * @param  amount  The amount of M Token to burn.
  69 |     |      */
  70 |     |     function burn(address account, uint256 amount) external;
  71 |     | 
  72 |     |     /// @notice Starts earning for caller if allowed by TTG.
  73 |     |     function startEarning() external;
  74 |     | 
  75 |     |     /// @notice Stops earning for caller.
  76 |     |     function stopEarning() external;
  77 |     | 
  78 |     |     /**
  79 |     |      * @notice Stops earning for `account`.
  80 |     |      * @dev    MUST revert if `account` is an approved earner in TTG Registrar.
  81 |     |      * @param  account The account to stop earning for.
  82 |     |      */
  83 |     |     function stopEarning(address account) external;
  84 |     | 
  85 |     |     /* ============ View/Pure Functions ============ */
  86 |     | 
  87 |     |     /// @notice The address of the Minter Gateway contract.
  88 |     |     function minterGateway() external view returns (address);
  89 |     | 
  90 |     |     /// @notice The address of the TTG Registrar contract.
  91 |     |     function ttgRegistrar() external view returns (address);
  92 |     | 
  93 |     |     /// @notice The address of TTG approved earner rate model.
  94 |     |     function rateModel() external view returns (address);
  95 |     | 
  96 |     |     /// @notice The current value of earner rate in basis points.
  97 |     |     function earnerRate() external view returns (uint32);
  98 |     | 
  99 |     |     /**
 100 |     |      * @notice The principal of an earner M token balance.
 101 |     |      * @param  account The account to get the principal balance of.
 102 |     |      * @return The principal balance of the account.
 103 |     |      */
 104 |     |     function principalBalanceOf(address account) external view returns (uint240);
 105 |     | 
 106 |     |     /// @notice The principal of the total earning supply of M Token.
 107 |     |     function principalOfTotalEarningSupply() external view returns (uint112);
 108 |     | 
 109 |     |     /// @notice The total earning supply of M Token.
 110 |     |     function totalEarningSupply() external view returns (uint240);
 111 |     | 
 112 |     |     /// @notice The total non-earning supply of M Token.
 113 |     |     function totalNonEarningSupply() external view returns (uint240);
 114 |     | 
 115 |     |     /**
 116 |     |      * @notice Checks if account is an earner.
 117 |     |      * @param  account The account to check.
 118 |     |      * @return True if account is an earner, false otherwise.
 119 |     |      */
 120 |     |     function isEarning(address account) external view returns (bool);
 121 |     | }
 122 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/interfaces/IRateModel.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  Rate Model Interface.
  7 |     |  * @author M^0 Labs
  8 |     |  */
  9 |     | interface IRateModel {
 10 |     |     /**
 11 |     |      * @notice Returns the current yearly rate in BPS.
 12 |     |      *         This value does not account for the compounding interest.
 13 |     |      */
 14 |     |     function rate() external view returns (uint256);
 15 |     | }
 16 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/libs/ContinuousIndexingMath.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import { UIntMath } from "lib/common/src/libs/UIntMath.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title  Arithmetic library with operations for calculating continuous indexing.
   9 |     |  * @author M^0 Labs
  10 |     |  */
  11 |     | library ContinuousIndexingMath {
  12 |     |     /* ============ Variables ============ */
  13 |     | 
  14 |     |     /// @notice The number of seconds in a year.
  15 | *   |     uint32 internal constant SECONDS_PER_YEAR = 31_536_000;
  16 |     | 
  17 |     |     /// @notice 100% in basis points.
  18 | *   |     uint16 internal constant BPS_SCALED_ONE = 1e4;
  19 |     | 
  20 |     |     /// @notice The scaling of rates in for exponent math.
  21 | *   |     uint56 internal constant EXP_SCALED_ONE = 1e12;
  22 |     | 
  23 |     |     /* ============ Custom Errors ============ */
  24 |     | 
  25 |     |     /// @notice Emitted when a division by zero occurs.
  26 |     |     error DivisionByZero();
  27 |     | 
  28 |     |     /* ============ Internal View/Pure Functions ============ */
  29 |     | 
  30 |     |     /**
  31 |     |      * @notice Helper function to calculate `(x * EXP_SCALED_ONE) / index`, rounded down.
  32 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  33 |     |      */
  34 | *   |     function divideDown(uint240 x, uint128 index) internal pure returns (uint112 z) {
  35 | *   |         if (index == 0) revert DivisionByZero();
  36 |     | 
  37 |     |         unchecked {
  38 |     |             // NOTE: While `uint256(x) * EXP_SCALED_ONE` can technically overflow, these divide/multiply functions are
  39 |     |             //       only used for the purpose of principal/present amount calculations for continuous indexing, and
  40 |     |             //       so for an `x` to be large enough to overflow this, it would have to be a possible result of
  41 |     |             //       `multiplyDown` or `multiplyUp`, which would already satisfy
  42 |     |             //       `uint256(x) * EXP_SCALED_ONE < type(uint240).max`.
  43 | *   |             return UIntMath.safe112((uint256(x) * EXP_SCALED_ONE) / index);
  44 |     |         }
  45 |     |     }
  46 |     | 
  47 |     |     /**
  48 |     |      * @notice Helper function to calculate `(x * EXP_SCALED_ONE) / index`, rounded up.
  49 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  50 |     |      */
  51 | *   |     function divideUp(uint240 x, uint128 index) internal pure returns (uint112 z) {
  52 | *   |         if (index == 0) revert DivisionByZero();
  53 |     | 
  54 |     |         unchecked {
  55 |     |             // NOTE: While `uint256(x) * EXP_SCALED_ONE` can technically overflow, these divide/multiply functions are
  56 |     |             //       only used for the purpose of principal/present amount calculations for continuous indexing, and
  57 |     |             //       so for an `x` to be large enough to overflow this, it would have to be a possible result of
  58 |     |             //       `multiplyDown` or `multiplyUp`, which would already satisfy
  59 |     |             //       `uint256(x) * EXP_SCALED_ONE < type(uint240).max`.
  60 | *   |             return UIntMath.safe112(((uint256(x) * EXP_SCALED_ONE) + index - 1) / index);
  61 |     |         }
  62 |     |     }
  63 |     | 
  64 |     |     /**
  65 |     |      * @notice Helper function to calculate `(x * index) / EXP_SCALED_ONE`, rounded down.
  66 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  67 |     |      */
  68 | *   |     function multiplyDown(uint112 x, uint128 index) internal pure returns (uint240 z) {
  69 |     |         unchecked {
  70 | *   |             return uint240((uint256(x) * index) / EXP_SCALED_ONE);
  71 |     |         }
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice Helper function to calculate `(x * index) / EXP_SCALED_ONE`, rounded up.
  76 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  77 |     |      */
  78 |     |     function multiplyUp(uint112 x, uint128 index) internal pure returns (uint240 z) {
  79 |     |         unchecked {
  80 |     |             return uint240(((uint256(x) * index) + (EXP_SCALED_ONE - 1)) / EXP_SCALED_ONE);
  81 |     |         }
  82 |     |     }
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice Helper function to calculate `(index * deltaIndex) / EXP_SCALED_ONE`, rounded down.
  86 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  87 |     |      */
  88 | *   |     function multiplyIndicesDown(uint128 index, uint48 deltaIndex) internal pure returns (uint144 z) {
  89 |     |         unchecked {
  90 | *   |             return uint144((uint256(index) * deltaIndex) / EXP_SCALED_ONE);
  91 |     |         }
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @notice Helper function to calculate `(index * deltaIndex) / EXP_SCALED_ONE`, rounded up.
  96 |     |      * @dev    Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
  97 |     |      */
  98 |     |     function multiplyIndicesUp(uint128 index, uint48 deltaIndex) internal pure returns (uint144 z) {
  99 |     |         unchecked {
 100 |     |             return uint144((uint256(index) * deltaIndex + (EXP_SCALED_ONE - 1)) / EXP_SCALED_ONE);
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     /**
 105 |     |      * @notice Helper function to calculate e^rt (continuous compounding formula).
 106 |     |      * @dev    `uint64 yearlyRate` can accommodate 1000% interest per year.
 107 |     |      * @dev    `uint32 time` can accommodate 100 years.
 108 |     |      * @dev    `type(uint64).max * type(uint32).max / SECONDS_PER_YEAR` fits in a `uint72`.
 109 |     |      */
 110 | *   |     function getContinuousIndex(uint64 yearlyRate, uint32 time) internal pure returns (uint48 index) {
 111 |     |         unchecked {
 112 |     |             // NOTE: Casting `uint256(yearlyRate) * time` to a `uint72` is safe because the largest value is
 113 |     |             //      `type(uint64).max * type(uint32).max / SECONDS_PER_YEAR`, which is less than `type(uint72).max`.
 114 | *   |             return exponent(uint72((uint256(yearlyRate) * time) / SECONDS_PER_YEAR));
 115 |     |         }
 116 |     |     }
 117 |     | 
 118 |     |     /**
 119 |     |      * @notice Helper function to calculate y = e^x using R(4,4) Pad approximation:
 120 |     |      *           e(x) = (1 + x/2 + 3(x^2)/28 + x^3/84 + x^4/1680) / (1 - x/2 + 3(x^2)/28 - x^3/84 + x^4/1680)
 121 |     |      *           See: https://en.wikipedia.org/wiki/Pad%C3%A9_table
 122 |     |      *           See: https://www.wolframalpha.com/input?i=PadeApproximant%5Bexp%5Bx%5D%2C%7Bx%2C0%2C%7B4%2C+4%7D%7D%5D
 123 |     |      *         Despite itself being a whole number, `x` represents a real number scaled by `EXP_SCALED_ONE`, thus
 124 |     |      *         allowing for y = e^x where x is a real number.
 125 |     |      * @dev    Output `y` for a `uint72` input `x` will fit in `uint48`
 126 |     |      */
 127 | *   |     function exponent(uint72 x) internal pure returns (uint48 y) {
 128 |     |         // NOTE: This can be done unchecked even for `x = type(uint72).max`.
 129 |     |         //       Verify by removing `unchecked` and running `test_exponent()`.
 130 |     |         unchecked {
 131 | *   |             uint256 x2 = uint256(x) * x;
 132 |     | 
 133 |     |             // `additiveTerms` is `(1 + 3(x^2)/28 + x^4/1680)`, and scaled by `84e27`.
 134 |     |             // NOTE: `84e27` the cleanest and largest scalar, given the various intermediate overflow possibilities.
 135 |     |             // NOTE: The resulting `(x2 * x2) / 20e21` term has been split up in order to avoid overflow of `x2 * x2`.
 136 | *   |             uint256 additiveTerms = 84e27 + (9e3 * x2) + ((x2 / 2e11) * (x2 / 1e11));
 137 |     | 
 138 |     |             // `differentTerms` is `(- x/2 - x^3/84)`, but positive (will be subtracted later), and scaled by `84e27`.
 139 | *   |             uint256 differentTerms = uint256(x) * (42e15 + (x2 / 1e9));
 140 |     | 
 141 |     |             // Result needs to be scaled by `1e12`.
 142 |     |             // NOTE: Can cast to `uint48` because contents can never be larger than `type(uint48).max` for any `x`.
 143 |     |             //       Max `y` is ~200e12, before falling off. See links above for reference.
 144 | *   |             return uint48(((additiveTerms + differentTerms) * 1e12) / (additiveTerms - differentTerms));
 145 |     |         }
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @notice Helper function to convert 12-decimal representation to basis points.
 150 |     |      * @param  input The input in 12-decimal representation.
 151 |     |      * @return The output in basis points.
 152 |     |      */
 153 |     |     function convertToBasisPoints(uint64 input) internal pure returns (uint40) {
 154 |     |         unchecked {
 155 |     |             return uint40((uint256(input) * BPS_SCALED_ONE) / EXP_SCALED_ONE);
 156 |     |         }
 157 |     |     }
 158 |     | 
 159 |     |     /**
 160 |     |      * @notice Helper function to convert basis points to 12-decimal representation.
 161 |     |      * @param  input The input in basis points.
 162 |     |      * @return The output in 12-decimal representation.
 163 |     |      */
 164 | *   |     function convertFromBasisPoints(uint32 input) internal pure returns (uint64) {
 165 |     |         unchecked {
 166 | *   |             return uint64((uint256(input) * EXP_SCALED_ONE) / BPS_SCALED_ONE);
 167 |     |         }
 168 |     |     }
 169 |     | }
 170 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/rateModels/EarnerRateModel.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import { wadLn } from "./solmate/src/utils/SignedWadMath.sol";
   6 |     | import { UIntMath } from "lib/common/src/libs/UIntMath.sol";
   7 |     | 
   8 |     | import { ContinuousIndexingMath } from "lib/common/src/libs/ContinuousIndexingMath.sol";
   9 |     | 
  10 |     | import { IMToken } from "../interfaces/IMToken.sol";
  11 |     | import { IMinterGateway } from "src/interfaces/IMinterGateway.sol";
  12 |     | import { IRateModel } from "./interfaces/IRateModel.sol";
  13 |     | import { ITTGRegistrar } from "src/libs/TTGRegistrarReader.sol";
  14 |     | 
  15 |     | import { IEarnerRateModel } from "./interfaces/IEarnerRateModel.sol";
  16 |     | 
  17 |     | /**
  18 |     |  * @title  Earner Rate Model contract set in TTG (Two Token Governance) Registrar and accessed by MToken.
  19 |     |  * @author M0 Labs
  20 |     |  */
  21 | *   | contract EarnerRateModel is IEarnerRateModel {
  22 |     |     /* ============ Variables ============ */
  23 |     | 
  24 |     |     /// @inheritdoc IEarnerRateModel
  25 |     |     uint32 public constant RATE_CONFIDENCE_INTERVAL = 30 days;
  26 |     | 
  27 |     |     /// @inheritdoc IEarnerRateModel
  28 |     |     uint32 public constant RATE_MULTIPLIER = 9_800; // 98% in basis points.
  29 |     | 
  30 |     |     /// @inheritdoc IEarnerRateModel
  31 |     |     uint32 public constant ONE = 10_000; // 100% in basis points.
  32 |     | 
  33 |     |     /// @notice The name of parameter in TTG that defines the max earner rate.
  34 |     |     bytes32 internal constant _MAX_EARNER_RATE = "max_earner_rate";
  35 |     | 
  36 |     |     /// @notice The scaling of rates in for exponent math.
  37 |     |     uint256 internal constant _EXP_SCALED_ONE = 1e12;
  38 |     | 
  39 |     |     /// @notice The scaling of `_EXP_SCALED_ONE` for wad maths operations.
  40 |     |     int256 internal constant _WAD_TO_EXP_SCALER = 1e6;
  41 |     | 
  42 |     |     /// @inheritdoc IEarnerRateModel
  43 |     |     address public immutable mToken;
  44 |     | 
  45 |     |     /// @inheritdoc IEarnerRateModel
  46 |     |     address public immutable minterGateway;
  47 |     | 
  48 |     |     /// @inheritdoc IEarnerRateModel
  49 |     |     address public immutable ttgRegistrar;
  50 |     | 
  51 |     |     /* ============ Constructor ============ */
  52 |     | 
  53 |     |     /**
  54 |     |      * @notice Constructs the EarnerRateModel contract.
  55 |     |      * @param minterGateway_ The address of the Minter Gateway contract.
  56 |     |      */
  57 | *   |     constructor(address minterGateway_, address ttgRegistrar_, address mToken_) {
  58 | *   |         ttgRegistrar = ttgRegistrar_;
  59 | *   |         minterGateway = minterGateway_;
  60 | *   |         mToken = mToken_;
  61 |     |         //     if ((minterGateway = minterGateway_) == address(0)) revert ZeroMinterGateway(); //NOTE: changed by fuzzer
  62 |     |         //     if ((ttgRegistrar = IMinterGateway(minterGateway_).ttgRegistrar()) == address(0)) revert ZeroTTGRegistrar();
  63 |     |         //     if ((mToken = IMinterGateway(minterGateway_).mToken()) == address(0)) revert ZeroMToken();
  64 |     |     }
  65 |     | 
  66 |     |     /* ============ View/Pure Functions ============ */
  67 |     | 
  68 | *   |     function rate() external view returns (uint256) {
  69 | *   |         uint256 earnerRate_ = maxRate();
  70 | *   |         uint32 minterRate_ = IMinterGateway(minterGateway).minterRate();
  71 | *   |         uint240 totalActiveOwedM_ = IMinterGateway(minterGateway).totalActiveOwedM();
  72 | *   |         uint240 totalEarningSupply_ = IMToken(mToken).totalEarningSupply();
  73 |     | 
  74 |     |         // If there are no active minters or minter rate is zero, do not accrue yield to earners.
  75 | *   |         if (totalActiveOwedM_ == 0 || minterRate_ == 0) return 0;
  76 |     | 
  77 |     |         // NOTE: If `earnerRate` <= `minterRate` and there are no deactivated minters in the system,
  78 |     |         //       it is safe to return `earnerRate` as the effective rate.
  79 | *   |         if (earnerRate_ <= minterRate_ && totalActiveOwedM_ >= totalEarningSupply_) return earnerRate_;
  80 |     | 
  81 |     |         return
  82 |     |             UIntMath.min256(earnerRate_, getExtraSafeEarnerRate(totalActiveOwedM_, totalEarningSupply_, minterRate_));
  83 |     |     }
  84 |     | 
  85 |     |     /// @inheritdoc IEarnerRateModel
  86 | *   |     function maxRate() public view returns (uint256) {
  87 | *   |         return uint256(ITTGRegistrar(ttgRegistrar).get(_MAX_EARNER_RATE));
  88 |     |     }
  89 |     | 
  90 |     |     /// @inheritdoc IEarnerRateModel
  91 |     |     function getExtraSafeEarnerRate(
  92 |     |         uint240 totalActiveOwedM_,
  93 |     |         uint240 totalEarningSupply_,
  94 |     |         uint32 minterRate_
  95 |     |     ) public pure returns (uint32) {
  96 |     |         uint256 safeEarnerRate_ = getSafeEarnerRate(totalActiveOwedM_, totalEarningSupply_, minterRate_);
  97 |     |         uint256 extraSafeEarnerRate_ = (safeEarnerRate_ * RATE_MULTIPLIER) / ONE;
  98 |     | 
  99 |     |         return (extraSafeEarnerRate_ > type(uint32).max) ? type(uint32).max : uint32(extraSafeEarnerRate_);
 100 |     |     }
 101 |     | 
 102 |     |     /// @inheritdoc IEarnerRateModel
 103 |     |     function getSafeEarnerRate(
 104 |     |         uint240 totalActiveOwedM_,
 105 |     |         uint240 totalEarningSupply_,
 106 |     |         uint32 minterRate_
 107 |     |     ) public pure returns (uint32) {
 108 |     |         // solhint-disable max-line-length
 109 |     |         // When `totalActiveOwedM_ >= totalEarningSupply_`, it is possible for the earner rate to be higher than the
 110 |     |         // minter rate and still ensure cashflow safety over some period of time (`RATE_CONFIDENCE_INTERVAL`). To ensure
 111 |     |         // cashflow safety, we start with `cashFlowOfActiveOwedM >= cashFlowOfEarningSupply` over some time `dt`.
 112 |     |         // Effectively: p1 * (exp(rate1 * dt) - 1) >= p2 * (exp(rate2 * dt) - 1)
 113 |     |         //          So: rate2 <= ln(1 + (p1 * (exp(rate1 * dt) - 1)) / p2) / dt
 114 |     |         // 1. totalActive * (delta_minterIndex - 1) >= totalEarning * (delta_earnerIndex - 1)
 115 |     |         // 2. totalActive * (delta_minterIndex - 1) / totalEarning >= delta_earnerIndex - 1
 116 |     |         // 3. 1 + (totalActive * (delta_minterIndex - 1) / totalEarning) >= delta_earnerIndex
 117 |     |         // Substitute `delta_earnerIndex` with `exponent((earnerRate * dt) / SECONDS_PER_YEAR)`:
 118 |     |         // 4. 1 + (totalActive * (delta_minterIndex - 1) / totalEarning) >= exponent((earnerRate * dt) / SECONDS_PER_YEAR)
 119 |     |         // 5. ln(1 + (totalActive * (delta_minterIndex - 1) / totalEarning)) >= (earnerRate * dt) / SECONDS_PER_YEAR
 120 |     |         // 6. ln(1 + (totalActive * (delta_minterIndex - 1) / totalEarning)) * SECONDS_PER_YEAR / dt >= earnerRate
 121 |     | 
 122 |     |         // When `totalActiveOwedM_ <= totalEarningSupply_`, the instantaneous earner cash flow must be less than the
 123 |     |         // instantaneous minter cash flow. To ensure instantaneous cashflow safety, we we use the derivatives of the
 124 |     |         // previous starting inequality, and substitute `dt = 0`.
 125 |     |         // Effectively: p1 * rate1 >= p2 * rate2
 126 |     |         //          So: rate2 <= p1 * rate1 / p2
 127 |     |         // 1. totalActive * minterRate >= totalEarning * earnerRate
 128 |     |         // 2. totalActive * minterRate / totalEarning >= earnerRate
 129 |     |         // solhint-enable max-line-length
 130 |     | 
 131 |     |         if (totalActiveOwedM_ == 0 || minterRate_ == 0) return 0;
 132 |     | 
 133 |     |         if (totalEarningSupply_ == 0) return type(uint32).max;
 134 |     | 
 135 |     |         if (totalActiveOwedM_ <= totalEarningSupply_) {
 136 |     |             // NOTE: `totalActiveOwedM_ * minterRate_` can revert due to overflow, so in some distant future, a new
 137 |     |             //       rate model contract may be needed that handles this differently.
 138 |     |             return uint32((uint256(totalActiveOwedM_) * minterRate_) / totalEarningSupply_);
 139 |     |         }
 140 |     | 
 141 |     |         uint48 deltaMinterIndex_ = ContinuousIndexingMath.getContinuousIndex(
 142 |     |             ContinuousIndexingMath.convertFromBasisPoints(minterRate_),
 143 |     |             RATE_CONFIDENCE_INTERVAL
 144 |     |         );
 145 |     | 
 146 |     |         // NOTE: `totalActiveOwedM_ * deltaMinterIndex_` can revert due to overflow, so in some distant future, a new
 147 |     |         //       rate model contract may be needed that handles this differently.
 148 |     |         int256 lnArg_ = int256(
 149 |     |             _EXP_SCALED_ONE +
 150 |     |                 ((uint256(totalActiveOwedM_) * (deltaMinterIndex_ - _EXP_SCALED_ONE)) / totalEarningSupply_)
 151 |     |         );
 152 |     | 
 153 |     |         int256 lnResult_ = wadLn(lnArg_ * _WAD_TO_EXP_SCALER) / _WAD_TO_EXP_SCALER;
 154 |     | 
 155 |     |         uint256 expRate_ = (uint256(lnResult_) * ContinuousIndexingMath.SECONDS_PER_YEAR) / RATE_CONFIDENCE_INTERVAL;
 156 |     | 
 157 |     |         if (expRate_ > type(uint64).max) return type(uint32).max;
 158 |     | 
 159 |     |         // NOTE: Do not need to do `UIntMath.safe256` because it is known that `lnResult_` will not be negative.
 160 |     |         uint40 safeRate_ = ContinuousIndexingMath.convertToBasisPoints(uint64(expRate_));
 161 |     | 
 162 |     |         return (safeRate_ > type(uint32).max) ? type(uint32).max : uint32(safeRate_);
 163 |     |     }
 164 |     | }
 165 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/rateModels/MinterRateModel.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import { UIntMath } from "lib/common/src/libs/UIntMath.sol";
  6 |     | 
  7 |     | import { IRateModel } from "../interfaces/IRateModel.sol";
  8 |     | import { ITTGRegistrar } from "src/libs/TTGRegistrarReader.sol";
  9 |     | import { IMinterRateModel } from "./interfaces/IMinterRateModel.sol";
 10 |     | 
 11 |     | /**
 12 |     |  * @title  Minter Rate Model contract set in TTG (Two Token Governance) Registrar and accessed by Minter Gateway.
 13 |     |  * @author M^0 Labs
 14 |     |  */
 15 | *   | contract MinterRateModel is IMinterRateModel {
 16 |     |     /* ============ Variables ============ */
 17 |     | 
 18 |     |     /// @notice The name of parameter in TTG that defines the base minter rate.
 19 |     |     bytes32 internal constant _BASE_MINTER_RATE = "base_minter_rate";
 20 |     | 
 21 |     |     /// @notice The maximum allowed rate in basis points.
 22 | *   |     uint256 public constant MAX_MINTER_RATE = 40_000; // 400%
 23 |     | 
 24 |     |     /// @inheritdoc IMinterRateModel
 25 |     |     address public immutable ttgRegistrar;
 26 |     | 
 27 |     |     /* ============ Constructor ============ */
 28 |     | 
 29 |     |     /**
 30 |     |      * @notice Constructs the MinterRateModel contract.
 31 |     |      * @param ttgRegistrar_ The address of the TTG Registrar contract.
 32 |     |      */
 33 | *   |     constructor(address ttgRegistrar_) {
 34 | *   |         if ((ttgRegistrar = ttgRegistrar_) == address(0)) revert ZeroTTGRegistrar();
 35 |     |     }
 36 |     | 
 37 |     |     /* ============ View/Pure Functions ============ */
 38 |     | 
 39 |     |     /// @inheritdoc IRateModel
 40 | *   |     function rate() external view returns (uint256 rate_) {
 41 | *   |         return UIntMath.min256(uint256(ITTGRegistrar(ttgRegistrar).get(_BASE_MINTER_RATE)), MAX_MINTER_RATE);
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/rateModels/interfaces/IEarnerRateModel.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import { IRateModel } from "../../interfaces/IRateModel.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title  Earner Rate Model Interface.
  9 |     |  * @author M^0 Labs
 10 |     |  */
 11 |     | interface IEarnerRateModel is IRateModel {
 12 |     |     /* ============ Custom Errors ============ */
 13 |     | 
 14 |     |     /// @notice Emitted when M Token contract address is zero.
 15 |     |     error ZeroMToken();
 16 |     | 
 17 |     |     /// @notice Emitted when Minter Gateway contract address is zero.
 18 |     |     error ZeroMinterGateway();
 19 |     | 
 20 |     |     /// @notice Emitted when TTG Registrar contract address is zero.
 21 |     |     error ZeroTTGRegistrar();
 22 |     | 
 23 |     |     /* ============ View/Pure Functions ============ */
 24 |     | 
 25 |     |     /// @notice The interval over which there's confidence cash flow to earners will not exceed cash flows from minters.
 26 |     |     function RATE_CONFIDENCE_INTERVAL() external view returns (uint32);
 27 |     | 
 28 |     |     /// @notice The percent (in basis points) of the earner rate that will be effectively used.
 29 |     |     function RATE_MULTIPLIER() external view returns (uint32);
 30 |     | 
 31 |     |     /// @notice 100% in basis points.
 32 |     |     function ONE() external view returns (uint32);
 33 |     | 
 34 |     |     /// @notice The M Token contract address.
 35 |     |     function mToken() external view returns (address);
 36 |     | 
 37 |     |     /// @notice The Minter Gateway contract address.
 38 |     |     function minterGateway() external view returns (address);
 39 |     | 
 40 |     |     /// @notice The TTG Registrar contract address.
 41 |     |     function ttgRegistrar() external view returns (address);
 42 |     | 
 43 |     |     /// @notice The max rate in basis points.
 44 |     |     function maxRate() external view returns (uint256);
 45 |     | 
 46 |     |     /**
 47 |     |      * @notice Returns the safe earner rate.
 48 |     |      * @param  totalActiveOwedM   The total active owed M.
 49 |     |      * @param  totalEarningSupply The total earning supply of M Token.
 50 |     |      * @param  minterRate         The minter rate.
 51 |     |      * @return The safe earner rate.
 52 |     |      */
 53 |     |     function getSafeEarnerRate(
 54 |     |         uint240 totalActiveOwedM,
 55 |     |         uint240 totalEarningSupply,
 56 |     |         uint32 minterRate
 57 |     |     ) external pure returns (uint32);
 58 |     | 
 59 |     |     /**
 60 |     |      * @notice Returns the extra safe earner rate - safe earner rate adjusted by `RATE_MULTIPLIER`.
 61 |     |      * @dev    `extraSafeEarnerRate = safeEarnerRate * RATE_MULTIPLIER`
 62 |     |      * @param  totalActiveOwedM   The total active owed M.
 63 |     |      * @param  totalEarningSupply The total earning supply of M Token.
 64 |     |      * @param  minterRate         The minter rate.
 65 |     |      * @return The extra safe earner rate.
 66 |     |      */
 67 |     |     function getExtraSafeEarnerRate(
 68 |     |         uint240 totalActiveOwedM,
 69 |     |         uint240 totalEarningSupply,
 70 |     |         uint32 minterRate
 71 |     |     ) external pure returns (uint32);
 72 |     | }
 73 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/rateModels/interfaces/IMinterRateModel.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import { IRateModel } from "../../interfaces/IRateModel.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title Minter Rate Model Interface.
  9 |     |  * @author M^0 Labs
 10 |     |  */
 11 |     | interface IMinterRateModel is IRateModel {
 12 |     |     /* ============ Custom Errors ============ */
 13 |     | 
 14 |     |     /// @notice Emitted when TTG Registrar contract address is zero.
 15 |     |     error ZeroTTGRegistrar();
 16 |     | 
 17 |     |     /* ============ View/Pure Functions ============ */
 18 |     | 
 19 |     |     /// @notice The TTG Registrar contract address.
 20 |     |     function ttgRegistrar() external view returns (address);
 21 |     | }
 22 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/rateModels/interfaces/IRateModel.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title  Rate Model Interface.
  7 |     |  * @author M^0 Labs
  8 |     |  */
  9 |     | interface IRateModel {
 10 |     |     /**
 11 |     |      * @notice Returns the current yearly rate in BPS.
 12 |     |      *         This value does not account for the compounding interest.
 13 |     |      */
 14 |     |     function rate() external view returns (uint256);
 15 |     | }
 16 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/mocks/rateModels/solmate/src/utils/SignedWadMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @notice Signed 18 decimal fixed point (wad) arithmetic library.
   5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)
   6 |     | /// @author Modified from Remco Bloemen (https://xn--2-umb.com/22/exp-ln/index.html)
   7 |     | 
   8 |     | /// @dev Will not revert on overflow, only use where overflow is not possible.
   9 |     | function toWadUnsafe(uint256 x) pure returns (int256 r) {
  10 |     |     /// @solidity memory-safe-assembly
  11 |     |     assembly {
  12 |     |         // Multiply x by 1e18.
  13 |     |         r := mul(x, 1000000000000000000)
  14 |     |     }
  15 |     | }
  16 |     | 
  17 |     | /// @dev Takes an integer amount of seconds and converts it to a wad amount of days.
  18 |     | /// @dev Will not revert on overflow, only use where overflow is not possible.
  19 |     | /// @dev Not meant for negative second amounts, it assumes x is positive.
  20 |     | function toDaysWadUnsafe(uint256 x) pure returns (int256 r) {
  21 |     |     /// @solidity memory-safe-assembly
  22 |     |     assembly {
  23 |     |         // Multiply x by 1e18 and then divide it by 86400.
  24 |     |         r := div(mul(x, 1000000000000000000), 86400)
  25 |     |     }
  26 |     | }
  27 |     | 
  28 |     | /// @dev Takes a wad amount of days and converts it to an integer amount of seconds.
  29 |     | /// @dev Will not revert on overflow, only use where overflow is not possible.
  30 |     | /// @dev Not meant for negative day amounts, it assumes x is positive.
  31 |     | function fromDaysWadUnsafe(int256 x) pure returns (uint256 r) {
  32 |     |     /// @solidity memory-safe-assembly
  33 |     |     assembly {
  34 |     |         // Multiply x by 86400 and then divide it by 1e18.
  35 |     |         r := div(mul(x, 86400), 1000000000000000000)
  36 |     |     }
  37 |     | }
  38 |     | 
  39 |     | /// @dev Will not revert on overflow, only use where overflow is not possible.
  40 |     | function unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {
  41 |     |     /// @solidity memory-safe-assembly
  42 |     |     assembly {
  43 |     |         // Multiply x by y and divide by 1e18.
  44 |     |         r := sdiv(mul(x, y), 1000000000000000000)
  45 |     |     }
  46 |     | }
  47 |     | 
  48 |     | /// @dev Will return 0 instead of reverting if y is zero and will
  49 |     | /// not revert on overflow, only use where overflow is not possible.
  50 |     | function unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {
  51 |     |     /// @solidity memory-safe-assembly
  52 |     |     assembly {
  53 |     |         // Multiply x by 1e18 and divide it by y.
  54 |     |         r := sdiv(mul(x, 1000000000000000000), y)
  55 |     |     }
  56 |     | }
  57 |     | 
  58 |     | function wadMul(int256 x, int256 y) pure returns (int256 r) {
  59 |     |     /// @solidity memory-safe-assembly
  60 |     |     assembly {
  61 |     |         // Store x * y in r for now.
  62 |     |         r := mul(x, y)
  63 |     | 
  64 |     |         // Combined overflow check (`x == 0 || (x * y) / x == y`) and edge case check
  65 |     |         // where x == -1 and y == type(int256).min, for y == -1 and x == min int256,
  66 |     |         // the second overflow check will catch this.
  67 |     |         // See: https://secure-contracts.com/learn_evm/arithmetic-checks.html#arithmetic-checks-for-int256-multiplication
  68 |     |         // Combining into 1 expression saves gas as resulting bytecode will only have 1 `JUMPI`
  69 |     |         // rather than 2.
  70 |     |         if iszero(
  71 |     |             and(
  72 |     |                 or(iszero(x), eq(sdiv(r, x), y)),
  73 |     |                 or(lt(x, not(0)), sgt(y, 0x8000000000000000000000000000000000000000000000000000000000000000))
  74 |     |             )
  75 |     |         ) {
  76 |     |             revert(0, 0)
  77 |     |         }
  78 |     | 
  79 |     |         // Scale the result down by 1e18.
  80 |     |         r := sdiv(r, 1000000000000000000)
  81 |     |     }
  82 |     | }
  83 |     | 
  84 |     | function wadDiv(int256 x, int256 y) pure returns (int256 r) {
  85 |     |     /// @solidity memory-safe-assembly
  86 |     |     assembly {
  87 |     |         // Store x * 1e18 in r for now.
  88 |     |         r := mul(x, 1000000000000000000)
  89 |     | 
  90 |     |         // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))
  91 |     |         if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {
  92 |     |             revert(0, 0)
  93 |     |         }
  94 |     | 
  95 |     |         // Divide r by y.
  96 |     |         r := sdiv(r, y)
  97 |     |     }
  98 |     | }
  99 |     | 
 100 |     | /// @dev Will not work with negative bases, only use when x is positive.
 101 |     | function wadPow(int256 x, int256 y) pure returns (int256) {
 102 |     |     // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)
 103 |     |     return wadExp((wadLn(x) * y) / 1e18); // Using ln(x) means x must be greater than 0.
 104 |     | }
 105 |     | 
 106 |     | function wadExp(int256 x) pure returns (int256 r) {
 107 |     |     unchecked {
 108 |     |         // When the result is < 0.5 we return zero. This happens when
 109 |     |         // x <= floor(log(0.5e18) * 1e18) ~ -42e18
 110 |     |         if (x <= -42139678854452767551) return 0;
 111 |     | 
 112 |     |         // When the result is > (2**255 - 1) / 1e18 we can not represent it as an
 113 |     |         // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.
 114 |     |         if (x >= 135305999368893231589) revert("EXP_OVERFLOW");
 115 |     | 
 116 |     |         // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96
 117 |     |         // for more intermediate precision and a binary basis. This base conversion
 118 |     |         // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.
 119 |     |         x = (x << 78) / 5 ** 18;
 120 |     | 
 121 |     |         // Reduce range of x to (- ln 2,  ln 2) * 2**96 by factoring out powers
 122 |     |         // of two such that exp(x) = exp(x') * 2**k, where k is an integer.
 123 |     |         // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).
 124 |     |         int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;
 125 |     |         x = x - k * 54916777467707473351141471128;
 126 |     | 
 127 |     |         // k is in the range [-61, 195].
 128 |     | 
 129 |     |         // Evaluate using a (6, 7)-term rational approximation.
 130 |     |         // p is made monic, we'll multiply by a scale factor later.
 131 |     |         int256 y = x + 1346386616545796478920950773328;
 132 |     |         y = ((y * x) >> 96) + 57155421227552351082224309758442;
 133 |     |         int256 p = y + x - 94201549194550492254356042504812;
 134 |     |         p = ((p * y) >> 96) + 28719021644029726153956944680412240;
 135 |     |         p = p * x + (4385272521454847904659076985693276 << 96);
 136 |     | 
 137 |     |         // We leave p in 2**192 basis so we don't need to scale it back up for the division.
 138 |     |         int256 q = x - 2855989394907223263936484059900;
 139 |     |         q = ((q * x) >> 96) + 50020603652535783019961831881945;
 140 |     |         q = ((q * x) >> 96) - 533845033583426703283633433725380;
 141 |     |         q = ((q * x) >> 96) + 3604857256930695427073651918091429;
 142 |     |         q = ((q * x) >> 96) - 14423608567350463180887372962807573;
 143 |     |         q = ((q * x) >> 96) + 26449188498355588339934803723976023;
 144 |     | 
 145 |     |         /// @solidity memory-safe-assembly
 146 |     |         assembly {
 147 |     |             // Div in assembly because solidity adds a zero check despite the unchecked.
 148 |     |             // The q polynomial won't have zeros in the domain as all its roots are complex.
 149 |     |             // No scaling is necessary because p is already 2**96 too large.
 150 |     |             r := sdiv(p, q)
 151 |     |         }
 152 |     | 
 153 |     |         // r should be in the range (0.09, 0.25) * 2**96.
 154 |     | 
 155 |     |         // We now need to multiply r by:
 156 |     |         // * the scale factor s = ~6.031367120.
 157 |     |         // * the 2**k factor from the range reduction.
 158 |     |         // * the 1e18 / 2**96 factor for base conversion.
 159 |     |         // We do this all at once, with an intermediate result in 2**213
 160 |     |         // basis, so the final right shift is always by a positive amount.
 161 |     |         r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));
 162 |     |     }
 163 |     | }
 164 |     | 
 165 |     | function wadLn(int256 x) pure returns (int256 r) {
 166 |     |     unchecked {
 167 |     |         require(x > 0, "UNDEFINED");
 168 |     | 
 169 |     |         // We want to convert x from 10**18 fixed point to 2**96 fixed point.
 170 |     |         // We do this by multiplying by 2**96 / 10**18. But since
 171 |     |         // ln(x * C) = ln(x) + ln(C), we can simply do nothing here
 172 |     |         // and add ln(2**96 / 10**18) at the end.
 173 |     | 
 174 |     |         /// @solidity memory-safe-assembly
 175 |     |         assembly {
 176 |     |             r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))
 177 |     |             r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))
 178 |     |             r := or(r, shl(5, lt(0xffffffff, shr(r, x))))
 179 |     |             r := or(r, shl(4, lt(0xffff, shr(r, x))))
 180 |     |             r := or(r, shl(3, lt(0xff, shr(r, x))))
 181 |     |             r := or(r, shl(2, lt(0xf, shr(r, x))))
 182 |     |             r := or(r, shl(1, lt(0x3, shr(r, x))))
 183 |     |             r := or(r, lt(0x1, shr(r, x)))
 184 |     |         }
 185 |     | 
 186 |     |         // Reduce range of x to (1, 2) * 2**96
 187 |     |         // ln(2^k * x) = k * ln(2) + ln(x)
 188 |     |         int256 k = r - 96;
 189 |     |         x <<= uint256(159 - k);
 190 |     |         x = int256(uint256(x) >> 159);
 191 |     | 
 192 |     |         // Evaluate using a (8, 8)-term rational approximation.
 193 |     |         // p is made monic, we will multiply by a scale factor later.
 194 |     |         int256 p = x + 3273285459638523848632254066296;
 195 |     |         p = ((p * x) >> 96) + 24828157081833163892658089445524;
 196 |     |         p = ((p * x) >> 96) + 43456485725739037958740375743393;
 197 |     |         p = ((p * x) >> 96) - 11111509109440967052023855526967;
 198 |     |         p = ((p * x) >> 96) - 45023709667254063763336534515857;
 199 |     |         p = ((p * x) >> 96) - 14706773417378608786704636184526;
 200 |     |         p = p * x - (795164235651350426258249787498 << 96);
 201 |     | 
 202 |     |         // We leave p in 2**192 basis so we don't need to scale it back up for the division.
 203 |     |         // q is monic by convention.
 204 |     |         int256 q = x + 5573035233440673466300451813936;
 205 |     |         q = ((q * x) >> 96) + 71694874799317883764090561454958;
 206 |     |         q = ((q * x) >> 96) + 283447036172924575727196451306956;
 207 |     |         q = ((q * x) >> 96) + 401686690394027663651624208769553;
 208 |     |         q = ((q * x) >> 96) + 204048457590392012362485061816622;
 209 |     |         q = ((q * x) >> 96) + 31853899698501571402653359427138;
 210 |     |         q = ((q * x) >> 96) + 909429971244387300277376558375;
 211 |     |         /// @solidity memory-safe-assembly
 212 |     |         assembly {
 213 |     |             // Div in assembly because solidity adds a zero check despite the unchecked.
 214 |     |             // The q polynomial is known not to have zeros in the domain.
 215 |     |             // No scaling required because p is already 2**96 too large.
 216 |     |             r := sdiv(p, q)
 217 |     |         }
 218 |     | 
 219 |     |         // r is in the range (0, 0.125) * 2**96
 220 |     | 
 221 |     |         // Finalization, we need to:
 222 |     |         // * multiply by the scale factor s = 5.549
 223 |     |         // * add ln(2**96 / 10**18)
 224 |     |         // * add k * ln(2)
 225 |     |         // * multiply by 10**18 / 2**96 = 5**18 >> 78
 226 |     | 
 227 |     |         // mul s * 5e18 * 2**96, base is now 5**18 * 2**192
 228 |     |         r *= 1677202110996718588342820967067443963516166;
 229 |     |         // add ln(2) * k * 5e18 * 2**192
 230 |     |         r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;
 231 |     |         // add ln(2**96 / 10**18) * 5e18 * 2**192
 232 |     |         r += 600920179829731861736702779321621459595472258049074101567377883020018308;
 233 |     |         // base conversion: mul 2**18 / 2**192
 234 |     |         r >>= 174;
 235 |     |     }
 236 |     | }
 237 |     | 
 238 |     | /// @dev Will return 0 instead of reverting if y is zero.
 239 |     | function unsafeDiv(int256 x, int256 y) pure returns (int256 r) {
 240 |     |     /// @solidity memory-safe-assembly
 241 |     |     assembly {
 242 |     |         // Divide x by y.
 243 |     |         r := sdiv(x, y)
 244 |     |     }
 245 |     | }
 246 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/properties/Properties.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./Properties_SWAP.sol";
  5 |     | import "./Properties_MYF.sol";
  6 |     | import "./Properties_MEARN.sol";
  7 |     | 
  8 |     | contract Properties is Properties_SWAP, Properties_MYF, Properties_MEARN {}
  9 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/properties/PropertiesBase.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
  5 |     | import "@perimetersec/fuzzlib/src/FuzzLibString.sol";
  6 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
  7 |     | 
  8 |     | import "./PropertiesDescriptions.sol";
  9 |     | import "../utils/FuzzConstants.sol";
 10 |     | import "../logicalCoverage/logicalBase.sol";
 11 |     | import { stdMath } from "forge-std/StdMath.sol";
 12 |     | 
 13 |     | contract PropertiesBase is PropertiesDescriptions, LogicalBase, FuzzConstants {
 14 |     |     // ==============================================================
 15 |     |     // Helpers
 16 |     |     // ==============================================================
 17 |     | 
 18 |     |     function assertApproxEq(uint256 a, uint256 b, uint256 maxDelta, string memory reason) internal {
 19 |     |         uint256 dt;
 20 |     |         if (a >= b) dt = a - b;
 21 |     |         else dt = b - a;
 22 |     |         if (dt > maxDelta) {
 23 |     |             bytes memory aBytes = abi.encodePacked(a);
 24 |     |             bytes memory bBytes = abi.encodePacked(b);
 25 |     |             string memory aStr = FuzzLibString.toHexString(aBytes);
 26 |     |             string memory bStr = FuzzLibString.toHexString(bBytes);
 27 |     |             fl.log("Error: a =~ b not satisfied [uint]");
 28 |     |             fl.log("   Value a", a);
 29 |     |             fl.log("   Value b", b);
 30 |     |             fl.log(" Max Delta", maxDelta);
 31 |     |             fl.log("     Delta", dt);
 32 |     |             fl.t(false, reason);
 33 |     |         }
 34 |     |     }
 35 |     | 
 36 |     |     function assertApproxEq(int256 a, int256 b, int256 maxDelta, string memory reason) internal {
 37 |     |         int256 dt;
 38 |     |         if (a >= b) dt = a - b;
 39 |     |         else dt = b - a;
 40 |     |         if (dt > maxDelta) {
 41 |     |             bytes memory aBytes = abi.encodePacked(a);
 42 |     |             bytes memory bBytes = abi.encodePacked(b);
 43 |     |             string memory aStr = FuzzLibString.toHexString(aBytes);
 44 |     |             string memory bStr = FuzzLibString.toHexString(bBytes);
 45 |     |             fl.log("Error: a =~ b not satisfied [uint]");
 46 |     |             fl.log("   Value a", a);
 47 |     |             fl.log("   Value b", b);
 48 |     |             fl.log(" Max Delta", maxDelta);
 49 |     |             fl.log("     Delta", dt);
 50 |     |             fl.t(false, reason);
 51 |     |         }
 52 |     |     }
 53 |     | 
 54 | *   |     function greaterThanOrEqualWithToleranceWei(
 55 |     |         uint256 a,
 56 |     |         uint256 b,
 57 |     |         uint256 maxWeiDiff,
 58 |     |         string memory reason
 59 | *   |     ) internal {
 60 | *   |         if (a >= b) {
 61 | *   |             fl.t(true, "Invariant ok, checked for: ");
 62 | *   |             fl.log(reason);
 63 | *   |             fl.log("a is greater than or equal to b");
 64 | *   |             return;
 65 |     |         }
 66 |     | 
 67 | *   |         uint256 diff = b - a;
 68 |     | 
 69 | *   |         if (diff > maxWeiDiff) {
 70 |     |             fl.log("a: ", a);
 71 |     |             fl.log("b: ", b);
 72 |     |             fl.log("Difference in wei is bigger than expected", diff);
 73 |     |             fl.t(false, reason);
 74 |     |         } else {
 75 | *   |             fl.t(true, "Invariant ok, checked for: ");
 76 | *   |             fl.log(reason);
 77 | *   |             fl.log("Difference in wei: ", diff);
 78 |     |         }
 79 |     |     }
 80 |     | 
 81 |     |     function isApproxEqRel(uint256 a, uint256 b, uint256 maxDelta, string memory reason) internal returns (bool) {
 82 |     |         a < b ? b = a : a = b;
 83 |     |         uint256 delta = stdMath.percentDelta(a, b);
 84 |     |         fl.log("a: ", a);
 85 |     |         fl.log("b: ", b);
 86 |     |         fl.log("Difference % is bigger than expected", delta);
 87 |     |         if (delta > maxDelta) fl.t(false, reason);
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/properties/PropertiesDescriptions.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | contract PropertiesDescriptions {
  5 |     |     // ==============================================================
  6 |     |     // Global Properties (GLOB)
  7 |     |     // These properties define invariants that must hold true across all market states and operations
  8 |     |     // ==============================================================
  9 |     | 
 10 |     |     string constant SWAP_01_00 = "SWAP_01 YTO_TO_YTO: MYieldToOne yield must not change after swaps";
 11 |     |     string constant SWAP_01_01 = "SWAP_01 YFEE_TO_YFEE: MYieldFee yield must not change after swaps";
 12 |     |     string constant SWAP_01_02 = "SWAP_01 MEARN_TO_MEARN: MEarnerManager yield must not change after swaps";
 13 |     |     string constant SWAP_02 = "SWAP_02: Swap facility M0 balance must be 0 after swap out";
 14 |     |     string constant SWAP_03 = "SWAP_03: Total M0 balance of all users must not change after swap";
 15 |     |     string constant SWAP_04 = "SWAP_04: Received amount of M0 must be greater or equal than slippage";
 16 |     |     string constant SWAP_05 = "SWAP_05: Received amount of USDC must be greater or equal than slippage";
 17 |     | 
 18 |     |     string constant MYF_01 = "MYF_01: MYieldFee extension mToken Balance must be greater or equal than projectedSupply";
 19 |     |     string constant MYF_02 =
 20 |     |         "MYF_02: MYieldFee extension mToken Balance must be greater or equal than projectedSupply + fee";
 21 |     | 
 22 |     |     string constant MEARN_01 =
 23 |     |         "MEARN_01: MEarnerManager extension mToken Balance must be greater or equal than projectedTotalSupply";
 24 |     | 
 25 |     |     // ==============================================================
 26 |     |     // Invariant Properties (INV)
 27 |     |     // These properties define invariants that must hold true as a sample
 28 |     |     // ==============================================================
 29 |     | 
 30 |     |     string constant ERR_01 = "ERR_01: Unexpected Error";
 31 |     | }
 32 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/properties/Properties_ERR.sol
   1 |     | //SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./RevertHandler.sol";
   5 |     | import "../../../src/projects/yieldToAllWithFee/interfaces/IMSpokeYieldFee.sol";
   6 |     | import "../../../src/projects/yieldToAllWithFee/interfaces/IMYieldFee.sol";
   7 |     | import "../../../src/projects/yieldToOne/IMYieldToOne.sol";
   8 |     | import "../../../src/projects/earnerManager/IMEarnerManager.sol";
   9 |     | import { IERC712 } from "test/fuzzing/mocks/WrappedMToken.f.sol";
  10 |     | import { IERC3009 } from "test/fuzzing/mocks/WrappedMToken.f.sol";
  11 |     | import { IWrappedMToken } from "test/fuzzing/mocks/WrappedMToken.f.sol";
  12 |     | import { IMigratable } from "test/fuzzing/mocks/WrappedMToken.f.sol";
  13 |     | import { UIntMath } from "test/fuzzing/mocks/WrappedMToken.f.sol";
  14 |     | import { IStatefulERC712 } from "test/fuzzing/mocks/WrappedMToken.f.sol";
  15 |     | import { IERC20Extended } from "test/fuzzing/mocks/WrappedMToken.f.sol";
  16 |     | import { IUniswapV3SwapAdapter } from "src/swap/interfaces/IUniswapV3SwapAdapter.sol";
  17 |     | import { IMExtension } from "src/interfaces/IMExtension.sol";
  18 |     | import {
  19 |     |     IAccessControl
  20 |     | } from "lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol";
  21 |     | import { V3SwapRouter } from "uniswapv3/v3-periphery/V3SwapRouter.sol";
  22 |     | 
  23 |     | abstract contract Properties_ERR is RevertHandler {
  24 |     |     /*
  25 |     |      *
  26 |     |      * FUZZ NOTE: CHECK REVERTS CONFIGURATION IN FUZZ STORAGE VARIABLES
  27 |     |      *
  28 |     |      */
  29 |     | 
  30 |     |     function _getAllowedPanicCodes() internal pure virtual override returns (uint256[] memory) {
  31 |     |         uint256[] memory panicCodes = new uint256[](3);
  32 |     |         panicCodes[0] = PANIC_ENUM_OUT_OF_BOUNDS;
  33 |     |         panicCodes[1] = PANIC_POP_EMPTY_ARRAY;
  34 |     |         panicCodes[2] = PANIC_ARRAY_OUT_OF_BOUNDS;
  35 |     | 
  36 |     |         // Add additional codes
  37 |     |         return panicCodes;
  38 |     |     }
  39 |     | 
  40 |     |     // Add additional errors here
  41 |     |     // Example:
  42 |     |     // Deposit errors [0-5]
  43 |     |     // allowedErrors[0] = IUsdnProtocolErrors.UsdnProtocolEmptyVault.selector;
  44 |     |     // allowedErrors[1] = IUsdnProtocolErrors
  45 |     |     //     .UsdnProtocolDepositTooSmall
  46 |     |     //     .selector;
  47 |     | 
  48 | *   |     function _getAllowedCustomErrors() internal pure virtual override returns (bytes4[] memory) {
  49 | *   |         bytes4[] memory allowedErrors = new bytes4[](79);
  50 |     | 
  51 |     |         // IMSpokeYieldFee errors
  52 | *   |         allowedErrors[0] = IMSpokeYieldFee.ZeroRateOracle.selector;
  53 |     | 
  54 |     |         // IMYieldFee errors
  55 | *   |         allowedErrors[1] = IMYieldFee.FeeRateTooHigh.selector;
  56 | *   |         allowedErrors[2] = IMYieldFee.ZeroAdmin.selector;
  57 | *   |         allowedErrors[3] = IMYieldFee.ZeroFeeManager.selector;
  58 | *   |         allowedErrors[4] = IMYieldFee.ZeroClaimRecipientManager.selector;
  59 | *   |         allowedErrors[5] = IMYieldFee.ZeroFeeRecipient.selector;
  60 | *   |         allowedErrors[6] = IMYieldFee.ZeroClaimRecipient.selector;
  61 | *   |         allowedErrors[7] = IMYieldFee.ZeroAccount.selector;
  62 |     | 
  63 |     |         // IMYieldToOne errors
  64 |     |         // allowedErrors[8] = IMYieldToOne.NoYield.selector;
  65 | *   |         allowedErrors[9] = IMYieldToOne.ZeroYieldRecipient.selector;
  66 | *   |         allowedErrors[10] = IMYieldToOne.ZeroYieldRecipientManager.selector;
  67 | *   |         allowedErrors[11] = IMYieldToOne.ZeroAdmin.selector;
  68 |     | 
  69 |     |         // IMEarnerManager errors
  70 | *   |         allowedErrors[12] = IMEarnerManager.ZeroFeeRecipient.selector;
  71 | *   |         allowedErrors[13] = IMEarnerManager.ZeroEarnerManager.selector;
  72 | *   |         allowedErrors[14] = IMEarnerManager.ZeroAdmin.selector;
  73 | *   |         allowedErrors[15] = IMEarnerManager.ZeroAccount.selector;
  74 | *   |         allowedErrors[16] = IMEarnerManager.InvalidFeeRate.selector;
  75 | *   |         allowedErrors[17] = IMEarnerManager.InvalidAccountInfo.selector;
  76 | *   |         allowedErrors[18] = IMEarnerManager.NotWhitelisted.selector;
  77 | *   |         allowedErrors[19] = IMEarnerManager.ArrayLengthMismatch.selector;
  78 | *   |         allowedErrors[20] = IMEarnerManager.ArrayLengthZero.selector;
  79 |     | 
  80 |     |         // WrappedMToken errors - IERC712
  81 | *   |         allowedErrors[21] = IERC712.InvalidSignature.selector;
  82 | *   |         allowedErrors[22] = IERC712.InvalidSignatureLength.selector;
  83 | *   |         allowedErrors[23] = IERC712.InvalidSignatureS.selector;
  84 | *   |         allowedErrors[24] = IERC712.InvalidSignatureV.selector;
  85 | *   |         allowedErrors[25] = IERC712.SignatureExpired.selector;
  86 | *   |         allowedErrors[26] = IERC712.SignerMismatch.selector;
  87 |     | 
  88 |     |         // WrappedMToken errors - IMigratable
  89 | *   |         allowedErrors[27] = IMigratable.InvalidMigrator.selector;
  90 | *   |         allowedErrors[28] = IMigratable.MigrationFailed.selector;
  91 | *   |         allowedErrors[29] = IMigratable.ZeroMigrator.selector;
  92 |     | 
  93 |     |         // WrappedMToken errors - UIntMath
  94 | *   |         allowedErrors[30] = UIntMath.InvalidUInt16.selector;
  95 | *   |         allowedErrors[31] = UIntMath.InvalidUInt40.selector;
  96 | *   |         allowedErrors[32] = UIntMath.InvalidUInt48.selector;
  97 | *   |         allowedErrors[33] = UIntMath.InvalidUInt112.selector;
  98 | *   |         allowedErrors[34] = UIntMath.InvalidUInt128.selector;
  99 | *   |         allowedErrors[35] = UIntMath.InvalidUInt240.selector;
 100 |     | 
 101 |     |         // WrappedMToken errors - IndexingMath
 102 | *   |         allowedErrors[36] = IndexingMath.DivisionByZero.selector;
 103 |     | 
 104 |     |         // WrappedMToken errors - IStatefulERC712
 105 | *   |         allowedErrors[37] = IStatefulERC712.InvalidAccountNonce.selector;
 106 |     | 
 107 |     |         // WrappedMToken errors - IERC3009
 108 | *   |         allowedErrors[38] = IERC3009.AuthorizationAlreadyUsed.selector;
 109 | *   |         allowedErrors[39] = IERC3009.AuthorizationExpired.selector;
 110 | *   |         allowedErrors[40] = IERC3009.AuthorizationNotYetValid.selector;
 111 | *   |         allowedErrors[41] = IERC3009.CallerMustBePayee.selector;
 112 |     | 
 113 |     |         // WrappedMToken errors - IERC20Extended
 114 | *   |         allowedErrors[42] = IERC20Extended.InsufficientAllowance.selector;
 115 | *   |         allowedErrors[43] = IERC20Extended.InsufficientAmount.selector;
 116 | *   |         allowedErrors[44] = IERC20Extended.InvalidRecipient.selector;
 117 |     | 
 118 |     |         // WrappedMToken errors - IWrappedMToken
 119 | *   |         allowedErrors[45] = IWrappedMToken.EarningIsDisabled.selector;
 120 | *   |         allowedErrors[46] = IWrappedMToken.EarningIsEnabled.selector;
 121 | *   |         allowedErrors[47] = IWrappedMToken.EarningCannotBeReenabled.selector;
 122 | *   |         allowedErrors[48] = IWrappedMToken.IsApprovedEarner.selector;
 123 | *   |         allowedErrors[49] = IWrappedMToken.InsufficientBalance.selector;
 124 | *   |         allowedErrors[50] = IWrappedMToken.NotApprovedEarner.selector;
 125 | *   |         allowedErrors[51] = IWrappedMToken.UnauthorizedMigration.selector;
 126 | *   |         allowedErrors[52] = IWrappedMToken.ZeroMToken.selector;
 127 | *   |         allowedErrors[53] = IWrappedMToken.ZeroMigrationAdmin.selector;
 128 |     | 
 129 | *   |         allowedErrors[54] = IAccessControl.AccessControlUnauthorizedAccount.selector;
 130 | *   |         allowedErrors[55] = IAccessControl.AccessControlBadConfirmation.selector;
 131 |     | 
 132 | *   |         allowedErrors[56] = IUniswapV3SwapAdapter.ZeroToken.selector;
 133 | *   |         allowedErrors[57] = IUniswapV3SwapAdapter.ZeroAmount.selector;
 134 | *   |         allowedErrors[58] = IUniswapV3SwapAdapter.ZeroRecipient.selector;
 135 | *   |         allowedErrors[59] = IUniswapV3SwapAdapter.NotWhitelistedToken.selector;
 136 | *   |         allowedErrors[60] = IUniswapV3SwapAdapter.InvalidPath.selector;
 137 | *   |         allowedErrors[61] = IUniswapV3SwapAdapter.InvalidPathFormat.selector;
 138 |     | 
 139 | *   |         allowedErrors[62] = IMExtension.ZeroMToken.selector;
 140 | *   |         allowedErrors[63] = IMExtension.ZeroSwapFacility.selector;
 141 | *   |         allowedErrors[64] = IMExtension.NotSwapFacility.selector;
 142 | *   |         allowedErrors[65] = IMExtension.InsufficientBalance.selector;
 143 |     | 
 144 | *   |         allowedErrors[66] = V3SwapRouter.V3InvalidSwap.selector;
 145 |     | 
 146 | *   |         return allowedErrors;
 147 |     |     }
 148 |     | 
 149 |     |     function _isAllowedERC20Error(bytes memory returnData) internal pure virtual override returns (bool) {
 150 |     |         bytes[] memory allowedErrors = new bytes[](9);
 151 |     |         allowedErrors[0] = INSUFFICIENT_ALLOWANCE;
 152 |     |         allowedErrors[1] = TRANSFER_FROM_ZERO;
 153 |     |         allowedErrors[2] = TRANSFER_TO_ZERO;
 154 |     |         allowedErrors[3] = APPROVE_TO_ZERO;
 155 |     |         allowedErrors[4] = MINT_TO_ZERO;
 156 |     |         allowedErrors[5] = BURN_FROM_ZERO;
 157 |     |         allowedErrors[6] = DECREASED_ALLOWANCE;
 158 |     |         allowedErrors[7] = BURN_EXCEEDS_BALANCE;
 159 |     |         allowedErrors[8] = EXCEEDS_BALANCE_ERROR;
 160 |     | 
 161 |     |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 162 |     |             if (keccak256(returnData) == keccak256(allowedErrors[i])) {
 163 |     |                 return true;
 164 |     |             }
 165 |     |         }
 166 |     | 
 167 |     |         // Check UniswapV3 string errors
 168 |     |         return _isAllowedUniswapV3Error(returnData);
 169 |     |     }
 170 |     | 
 171 |     |     function _isAllowedUniswapV3Error(bytes memory returnData) internal pure returns (bool) {
 172 |     |         bytes[] memory allowedErrors = new bytes[](51);
 173 |     | 
 174 |     |         // Short error codes
 175 |     |         allowedErrors[0] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "LOK");
 176 |     |         allowedErrors[1] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "TLU");
 177 |     |         allowedErrors[2] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "TLM");
 178 |     |         allowedErrors[3] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "TUM");
 179 |     |         allowedErrors[4] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "AI");
 180 |     |         allowedErrors[5] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "M0");
 181 |     |         allowedErrors[6] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "M1");
 182 |     |         allowedErrors[7] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "AS");
 183 |     |         allowedErrors[8] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "SPL");
 184 |     |         allowedErrors[9] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "IIA");
 185 |     |         allowedErrors[10] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "L");
 186 |     |         allowedErrors[11] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "F0");
 187 |     |         allowedErrors[12] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "F1");
 188 |     |         allowedErrors[13] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "NEO");
 189 |     |         allowedErrors[14] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ONI");
 190 |     |         allowedErrors[15] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "TD");
 191 |     |         allowedErrors[16] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "STE");
 192 |     |         allowedErrors[17] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "LS");
 193 |     |         allowedErrors[18] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "LA");
 194 |     |         allowedErrors[19] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "NP");
 195 |     |         allowedErrors[20] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "I");
 196 |     |         allowedErrors[21] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "LO");
 197 |     |         allowedErrors[22] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "T");
 198 |     |         allowedErrors[23] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "R");
 199 |     |         allowedErrors[24] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "BP");
 200 |     |         allowedErrors[25] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "NI");
 201 |     |         allowedErrors[26] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "DL");
 202 |     | 
 203 |     |         // Long error messages
 204 |     |         allowedErrors[27] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Transaction too old");
 205 |     |         allowedErrors[28] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Too little received");
 206 |     |         allowedErrors[29] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Too much requested");
 207 |     |         allowedErrors[30] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Permit expired");
 208 |     |         allowedErrors[31] = abi.encodeWithSelector(
 209 |     |             bytes4(keccak256("Error(string)")),
 210 |     |             "ERC721Permit: approval to current owner"
 211 |     |         );
 212 |     |         allowedErrors[32] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Invalid signature");
 213 |     |         allowedErrors[33] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Unauthorized");
 214 |     |         allowedErrors[34] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Not WETH9");
 215 |     |         allowedErrors[35] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Insufficient WETH9");
 216 |     |         allowedErrors[36] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Insufficient token");
 217 |     |         allowedErrors[37] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Price slippage check");
 218 |     |         allowedErrors[38] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Blockhash");
 219 |     |         allowedErrors[39] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Invalid token ID");
 220 |     |         allowedErrors[40] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "Not cleared");
 221 |     |         allowedErrors[41] = abi.encodeWithSelector(
 222 |     |             bytes4(keccak256("Error(string)")),
 223 |     |             "ERC721: approved query for nonexistent token"
 224 |     |         );
 225 |     |         allowedErrors[42] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "slice_overflow");
 226 |     |         allowedErrors[43] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "slice_outOfBounds");
 227 |     |         allowedErrors[44] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "toAddress_overflow");
 228 |     |         allowedErrors[45] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "toAddress_outOfBounds");
 229 |     |         allowedErrors[46] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "toUint24_overflow");
 230 |     |         allowedErrors[47] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "toUint24_outOfBounds");
 231 |     |         allowedErrors[48] = abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "invalid base64 decoder input");
 232 |     |         allowedErrors[49] = abi.encodeWithSelector(
 233 |     |             bytes4(keccak256("Error(string)")),
 234 |     |             "Strings: hex length insufficient"
 235 |     |         );
 236 |     |         allowedErrors[50] = abi.encodeWithSelector(
 237 |     |             bytes4(keccak256("Error(string)")),
 238 |     |             "AddressStringUtil: INVALID_LEN"
 239 |     |         );
 240 |     | 
 241 |     |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 242 |     |             if (keccak256(returnData) == keccak256(allowedErrors[i])) {
 243 |     |                 return true;
 244 |     |             }
 245 |     |         }
 246 |     |         return false;
 247 |     |     }
 248 |     | 
 249 |     |     function _getAllowedSoladyERC20Error() internal pure virtual override returns (bytes4[] memory) {
 250 |     |         bytes4[] memory allowedErrors = new bytes4[](0);
 251 |     |         // allowedErrors[0] = SafeTransferLib.ETHTransferFailed.selector;
 252 |     |         // allowedErrors[1] = SafeTransferLib.TransferFromFailed.selector;
 253 |     |         // allowedErrors[2] = SafeTransferLib.TransferFailed.selector;
 254 |     |         // allowedErrors[3] = SafeTransferLib.ApproveFailed.selector;
 255 |     |         // allowedErrors[4] = SafeTransferLib.Permit2Failed.selector;
 256 |     |         // allowedErrors[5] = SafeTransferLib.Permit2AmountOverflow.selector;
 257 |     |         // allowedErrors[6] = bytes4(0x82b42900); //unauthorized selector
 258 |     | 
 259 |     |         return allowedErrors;
 260 |     |     }
 261 |     | }
 262 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/properties/Properties_MEARN.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.26;
  3 |     | 
  4 |     | import "./Properties_ERR.sol";
  5 |     | 
  6 |     | contract Properties_MEARN is Properties_ERR {
  7 | *   |     function invariant_MEARN_01() internal returns (bool) {
  8 | *   |         for (uint256 i = 0; i < mEarnerManagerArray.length; i++) {
  9 | *   |             address extAddress = mEarnerManagerArray[i];
 10 |     | 
 11 | *   |             greaterThanOrEqualWithToleranceWei(
 12 | *   |                 states[1].mEarnerManager[extAddress].mBalanceOf,
 13 | *   |                 states[1].mEarnerManager[extAddress].projectedTotalSupply,
 14 | *   |                 1,
 15 | *   |                 MEARN_01
 16 |     |             );
 17 |     |         }
 18 |     |     }
 19 |     | }
 20 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/properties/Properties_MYF.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.26;
  3 |     | 
  4 |     | import "./Properties_ERR.sol";
  5 |     | 
  6 |     | contract Properties_MYF is Properties_ERR {
  7 | *   |     function invariant_MYF_01() internal returns (bool) {
  8 | *   |         for (uint256 i = 0; i < mYieldFeeArray.length; i++) {
  9 | *   |             address extAddress = mYieldFeeArray[i];
 10 | *   |             fl.gte(
 11 | *   |                 states[1].mYieldFee[extAddress].balanceOfM0,
 12 | *   |                 states[1].mYieldFee[extAddress].projectedTotalSupply,
 13 | *   |                 MYF_01
 14 |     |             );
 15 |     |         }
 16 |     |     }
 17 |     | 
 18 | *   |     function invariant_MYF_02() internal returns (bool) {
 19 | *   |         for (uint256 i = 0; i < mYieldFeeArray.length; i++) {
 20 | *   |             address extAddress = mYieldFeeArray[i];
 21 | *   |             greaterThanOrEqualWithToleranceWei(
 22 | *   |                 states[1].mYieldFee[extAddress].balanceOfM0,
 23 | *   |                 states[1].mYieldFee[extAddress].projectedTotalSupply + states[1].mYieldFee[extAddress].totalAccruedFee,
 24 | *   |                 1000,
 25 | *   |                 MYF_02
 26 |     |             );
 27 |     |         }
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/properties/Properties_SWAP.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.26;
  3 |     | 
  4 |     | import "./Properties_ERR.sol";
  5 |     | 
  6 |     | contract Properties_SWAP is Properties_ERR {
  7 |     |     function invariant_SWAP_01(SwapParams memory params) internal returns (bool) {
  8 |     |         if (params.swapType == uint8(SwapType.YTO_TO_YTO)) {
  9 |     |             uint256 yieldExtA = states[0].mYieldToOne[params.extensionIn].yield;
 10 |     |             uint256 yieldExtB = states[0].mYieldToOne[params.extensionOut].yield;
 11 |     |             uint256 yieldExtAAfter = states[1].mYieldToOne[params.extensionIn].yield;
 12 |     |             uint256 yieldExtBAfter = states[1].mYieldToOne[params.extensionOut].yield;
 13 |     |             assertApproxEqAbs(yieldExtA, yieldExtAAfter, 1, SWAP_01_00);
 14 |     |             assertApproxEqAbs(yieldExtB, yieldExtBAfter, 1, SWAP_01_00);
 15 |     |         } else if (params.swapType == uint8(SwapType.YFEE_TO_YFEE)) {
 16 |     |             uint256 yieldExtA = states[0].mYieldFee[params.extensionIn].totalAccruedYield;
 17 |     |             uint256 yieldExtB = states[0].mYieldFee[params.extensionOut].totalAccruedYield;
 18 |     |             uint256 yieldExtAAfter = states[1].mYieldFee[params.extensionIn].totalAccruedYield;
 19 |     |             uint256 yieldExtBAfter = states[1].mYieldFee[params.extensionOut].totalAccruedYield;
 20 |     |             assertApproxEqAbs(yieldExtA, yieldExtAAfter, 1, SWAP_01_01);
 21 |     |             assertApproxEqAbs(yieldExtB, yieldExtBAfter, 1, SWAP_01_01);
 22 |     |         } else if (params.swapType == uint8(SwapType.MEARN_TO_MEARN)) {
 23 |     |             uint256 yieldExtA = states[0].mEarnerManager[params.extensionIn].yield;
 24 |     |             uint256 yieldExtB = states[0].mEarnerManager[params.extensionOut].yield;
 25 |     |             uint256 yieldExtAAfter = states[1].mEarnerManager[params.extensionIn].yield;
 26 |     |             uint256 yieldExtBAfter = states[1].mEarnerManager[params.extensionOut].yield;
 27 |     |             assertApproxEqAbs(yieldExtA, yieldExtAAfter, 1, SWAP_01_02);
 28 |     |             assertApproxEqAbs(yieldExtB, yieldExtBAfter, 1, SWAP_01_02);
 29 |     |         }
 30 |     |     }
 31 |     | 
 32 | *   |     function invariant_SWAP_02() internal returns (bool) {
 33 | *   |         fl.eq(states[1].swapFacilityBalanceOfM0, 0, SWAP_02);
 34 |     |     }
 35 |     | 
 36 | *   |     function invariant_SWAP_03() internal returns (bool) {
 37 | *   |         for (uint256 i = 0; i < USERS.length; i++) {
 38 | *   |             fl.eq(
 39 | *   |                 states[0].actorStates[USERS[i]].totalM0Balance,
 40 | *   |                 states[1].actorStates[USERS[i]].totalM0Balance,
 41 | *   |                 SWAP_03
 42 |     |             );
 43 |     |         }
 44 |     |     }
 45 |     | 
 46 |     |     function invariant_SWAP_04(SwapInTokenParams memory params) internal returns (bool) {
 47 |     |         fl.gte(
 48 |     |             states[1].actorStates[currentActor].totalM0Balance - params.minAmountOut, //received amount of M0 should be greater or equal than slippage
 49 |     |             states[0].actorStates[currentActor].totalM0Balance,
 50 |     |             SWAP_04
 51 |     |         );
 52 |     |     }
 53 |     | 
 54 |     |     function invariant_SWAP_05(SwapOutTokenParams memory params) internal returns (bool) {
 55 |     |         fl.gte(
 56 |     |             states[1].actorStates[currentActor].usdcBalance,
 57 |     |             states[0].actorStates[currentActor].usdcBalance + params.minAmountOut,
 58 |     |             SWAP_05
 59 |     |         );
 60 |     |     }
 61 |     | }
 62 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/properties/RevertHandler.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./PropertiesBase.sol";
   5 |     | // import { SafeTransferLib } from "solady/utils/SafeTransferLib.sol";
   6 |     | 
   7 |     | abstract contract RevertHandler is PropertiesBase {
   8 | *   |     function invariant_ERR(bytes memory returnData) internal {
   9 |     |         // Handle empty reverts
  10 | *   |         if (returnData.length == 0) {
  11 | *   |             if (CATCH_EMPTY_REVERTS) {
  12 | *r  |                 fl.t(false, "Empty revert data not allowed");
  13 |     |             } else {
  14 |     |                 fl.t(true, "Revert data is empty, allowed by config");
  15 |     |             }
  16 |     | 
  17 |     |             return;
  18 |     |         }
  19 |     | 
  20 | *   |         bytes4 returnedError;
  21 |     |         assembly {
  22 | *   |             returnedError := mload(add(returnData, 0x20))
  23 |     |         }
  24 |     | 
  25 |     |         // Handle Panic errors
  26 | *   |         if (returnedError == bytes4(keccak256("Panic(uint256)"))) {
  27 |     |             _handlePanic(returnData);
  28 |     |             return;
  29 |     |         }
  30 |     | 
  31 |     |         // Handle Error(string) errors
  32 | *   |         if (returnedError == bytes4(keccak256("Error(string)"))) {
  33 |     |             _handleError(returnData);
  34 |     |             return;
  35 |     |         }
  36 |     | 
  37 |     |         // Handle custom protocol errors
  38 | *   |         _handleCustomError(returnData);
  39 |     |     }
  40 |     | 
  41 |     |     function _getAllowedPanicCodes() internal pure virtual returns (uint256[] memory) {
  42 |     |         uint256[] memory panicCodes = new uint256[](3);
  43 |     |         panicCodes[0] = PANIC_ENUM_OUT_OF_BOUNDS;
  44 |     |         panicCodes[1] = PANIC_POP_EMPTY_ARRAY;
  45 |     |         panicCodes[2] = PANIC_ARRAY_OUT_OF_BOUNDS;
  46 |     |         return panicCodes;
  47 |     |     }
  48 |     | 
  49 |     |     function _getAllowedCustomErrors() internal pure virtual returns (bytes4[] memory) {
  50 |     |         bytes4[] memory allowedErrors = new bytes4[](1);
  51 |     |         // Uncomment to allow empty reverts:
  52 |     |         allowedErrors[0] = bytes4(abi.encode(""));
  53 |     |         return allowedErrors;
  54 |     |     }
  55 |     | 
  56 |     |     function _handleSoladyError(bytes memory returnData) private {
  57 |     |         bytes4 returnedError;
  58 |     |         assembly {
  59 |     |             returnedError := mload(add(returnData, 0x20))
  60 |     |         }
  61 |     | 
  62 |     |         fl.errAllow(returnedError, _getAllowedSoladyERC20Error(), ERR_01);
  63 |     |     }
  64 |     | 
  65 |     |     function _getAllowedSoladyERC20Error() internal pure virtual returns (bytes4[] memory) {
  66 |     |         bytes4[] memory allowedErrors = new bytes4[](0);
  67 |     |         // allowedErrors[0] = SafeTransferLib.ETHTransferFailed.selector;
  68 |     |         // allowedErrors[1] = SafeTransferLib.TransferFromFailed.selector;
  69 |     |         // allowedErrors[2] = SafeTransferLib.TransferFailed.selector;
  70 |     |         // allowedErrors[3] = SafeTransferLib.ApproveFailed.selector;
  71 |     |         // allowedErrors[4] = SafeTransferLib.Permit2Failed.selector;
  72 |     |         // allowedErrors[5] = SafeTransferLib.Permit2AmountOverflow.selector;
  73 |     |         // allowedErrors[6] = bytes4(0x82b42900); //unauthorized selector
  74 |     | 
  75 |     |         return allowedErrors;
  76 |     |     }
  77 |     | 
  78 |     |     function _isAllowedERC20Error(bytes memory returnData) internal pure virtual returns (bool) {
  79 |     |         bytes[] memory allowedErrors = new bytes[](9);
  80 |     |         allowedErrors[0] = INSUFFICIENT_ALLOWANCE;
  81 |     |         allowedErrors[1] = TRANSFER_FROM_ZERO;
  82 |     |         allowedErrors[2] = TRANSFER_TO_ZERO;
  83 |     |         allowedErrors[3] = APPROVE_TO_ZERO;
  84 |     |         allowedErrors[4] = MINT_TO_ZERO;
  85 |     |         allowedErrors[5] = BURN_FROM_ZERO;
  86 |     |         allowedErrors[6] = DECREASED_ALLOWANCE;
  87 |     |         allowedErrors[7] = BURN_EXCEEDS_BALANCE;
  88 |     |         allowedErrors[8] = EXCEEDS_BALANCE_ERROR;
  89 |     | 
  90 |     |         for (uint256 i = 0; i < allowedErrors.length; i++) {
  91 |     |             if (keccak256(returnData) == keccak256(allowedErrors[i])) {
  92 |     |                 return true;
  93 |     |             }
  94 |     |         }
  95 |     |         return false;
  96 |     |     }
  97 |     | 
  98 |     |     function _isAllowedFoundryERC20Error(bytes memory returnData) internal virtual returns (bool) {
  99 |     |         bytes memory ADDITION_OVERFLOW = abi.encodeWithSelector(
 100 |     |             bytes4(keccak256("Error(string)")),
 101 |     |             "ERC20: addition overflow"
 102 |     |         );
 103 |     | 
 104 |     |         bytes[] memory allowedErrors = new bytes[](1);
 105 |     |         allowedErrors[0] = ADDITION_OVERFLOW;
 106 |     | 
 107 |     |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 108 |     |             if (keccak256(returnData) == keccak256(allowedErrors[i])) {
 109 |     |                 return true;
 110 |     |             }
 111 |     |         }
 112 |     |         return false;
 113 |     |     }
 114 |     | 
 115 |     |     function _handlePanic(bytes memory returnData) private {
 116 |     |         uint256 panicCode = _extractPanicCode(returnData);
 117 |     |         uint256[] memory allowedCodes = _getAllowedPanicCodes();
 118 |     |         bool isAllowed = false;
 119 |     | 
 120 |     |         for (uint256 i = 0; i < allowedCodes.length; i++) {
 121 |     |             if (panicCode == allowedCodes[i]) {
 122 |     |                 isAllowed = true;
 123 |     |                 break;
 124 |     |             }
 125 |     |         }
 126 |     | 
 127 |     |         fl.log("Panic code", bytes32(panicCode));
 128 |     |         if (!isAllowed) {
 129 |     |             fl.t(false, "Disallowed Panic code encountered!");
 130 |     |         }
 131 |     |     }
 132 |     | 
 133 |     |     function _handleError(bytes memory returnData) private {
 134 |     |         string memory revertMsg = _extractRevertMessage(returnData);
 135 |     |         fl.log("Error(string) revert returnData: ", revertMsg);
 136 |     | 
 137 |     |         if (_isAllowedERC20Error(returnData)) {
 138 |     |             fl.log("ERC20 error encountered", revertMsg);
 139 |     |             return;
 140 |     |         }
 141 |     | 
 142 |     |         if (_isAllowedFoundryERC20Error(returnData)) {
 143 |     |             fl.log("Foundry MockERC20 error encountered", revertMsg);
 144 |     |             return;
 145 |     |         }
 146 |     | 
 147 |     |         if (CATCH_REQUIRE_REVERT) {
 148 |     |             fl.t(false, revertMsg);
 149 |     |         }
 150 |     |     }
 151 |     | 
 152 | *   |     function _handleCustomError(bytes memory returnData) private {
 153 | *   |         bytes4 returnedError;
 154 |     |         assembly {
 155 | *   |             returnedError := mload(add(returnData, 0x20))
 156 |     |         }
 157 |     | 
 158 | *   |         fl.log("Custom protocol error returnData: ", _extractRevertMessage(returnData));
 159 | *   |         fl.errAllow(returnedError, _getAllowedCustomErrors(), ERR_01);
 160 |     |     }
 161 |     | 
 162 |     |     function _extractPanicCode(bytes memory revertData) private returns (uint256) {
 163 |     |         fl.log("REVERT DATA LENGTH", revertData.length);
 164 |     |         if (revertData.length < 36) {
 165 |     |             fl.t(false, "Unexpected revert data length for panic code");
 166 |     |             return 0;
 167 |     |         }
 168 |     | 
 169 |     |         uint256 panicCode;
 170 |     |         assembly {
 171 |     |             panicCode := mload(add(revertData, 36))
 172 |     |         }
 173 |     |         return panicCode;
 174 |     |     }
 175 |     | 
 176 | *   |     function _extractRevertMessage(bytes memory _returnData) private returns (string memory) {
 177 |     |         // If data is too short or not properly formatted, return a default message
 178 | *   |         if (_returnData.length < 4) {
 179 |     |             return "Invalid error data";
 180 |     |         }
 181 |     | 
 182 |     |         // Try-catch block to handle non-decodeable data
 183 | *   |         try this._decodeErrorMessage(_returnData) returns (string memory message) {
 184 |     |             return message;
 185 |     |         } catch {
 186 | *   |             return string(abi.encodePacked("Non-decodeable error: 0x", FuzzLibString.toHexString(_returnData)));
 187 |     |         }
 188 |     |     }
 189 |     | 
 190 |     |     // Helper function to safely decode error messages
 191 | *   |     function _decodeErrorMessage(bytes memory _data) external pure returns (string memory) {
 192 |     |         // Skip the error selector (first 4 bytes)
 193 | *   |         bytes memory strBytes = new bytes(_data.length - 4);
 194 | *   |         for (uint256 i = 4; i < _data.length; i++) {
 195 | *   |             strBytes[i - 4] = _data[i];
 196 |     |         }
 197 | *   |         return abi.decode(strBytes, (string));
 198 |     |     }
 199 |     | }
 200 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/utils/FunctionCalls.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
   5 |     | import "../helpers/FuzzStorageVariables.sol";
   6 |     | import { IERC20 } from "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";
   7 |     | import { MEarnerManager } from "src/projects/earnerManager/MEarnerManager.sol";
   8 |     | import { MYieldFee } from "src/projects/yieldToAllWithFee/MYieldFee.sol";
   9 |     | import { SwapFacility } from "src/swap/SwapFacility.sol";
  10 |     | import { MExtension } from "src/MExtension.sol";
  11 |     | import { MToken } from "test/fuzzing/mocks/MToken.sol";
  12 |     | import { IUniswapV3SwapAdapter } from "src/swap/UniswapV3SwapAdapter.sol";
  13 |     | import { IMExtension } from "src/interfaces/IMExtension.sol";
  14 |     | import { JMIExtension } from "src/projects/jmi/JMIExtension.sol";
  15 |     | import { Pausable } from "src/components/pausable/Pausable.sol";
  16 |     | import { Freezable } from "src/components/freezable/Freezable.sol";
  17 |     | 
  18 |     | contract FunctionCalls is FuzzBase, FuzzStorageVariables {
  19 |     |     // MToken function calls
  20 |     |     event StartEarningCall();
  21 |     |     event StopEarningCall();
  22 |     | 
  23 |     |     // MYieldToOne function calls
  24 |     |     event ClaimYieldCall(address instance);
  25 |     |     event SetYieldRecipientCall(address instance, address yieldRecipient);
  26 |     |     event EnableEarningCall(address instance);
  27 |     |     event DisableEarningCall(address instance);
  28 |     |     event ApproveCall(address instance, address spender, uint256 amount);
  29 |     |     event TransferCall(address instance, address to, uint256 amount);
  30 |     |     event TransferFromCall(address instance, address from, address to, uint256 amount);
  31 |     |     event WrapCall(address instance, address recipient, uint256 amount);
  32 |     |     event UnwrapCall(address instance, address recipient, uint256 amount);
  33 |     | 
  34 |     |     // Madmin function calls
  35 |     |     event SetAccountInfoCall(address instance, address account, bool status, uint16 feeRate);
  36 |     |     event SetAccountInfoBatchCall(address instance, address[] accounts, bool[] statuses, uint16[] feeRates);
  37 |     |     event SetFeeRecipientCall(address instance, address feeRecipient);
  38 |     |     event ClaimForCall(address instance, address account);
  39 |     | 
  40 |     |     // MYieldFee function calls
  41 |     |     event ClaimYieldForCall(address instance, address account);
  42 |     |     event ClaimFeeCall(address instance);
  43 |     |     event UpdateIndexCall(address instance);
  44 |     |     event SetFeeRateCall(address instance, uint16 feeRate);
  45 |     |     event SetClaimRecipientCall(address instance, address account, address claimRecipient);
  46 |     | 
  47 |     |     // SwapFacility function calls
  48 |     |     event SwapCall(address instance, address extensionIn, address extensionOut, uint256 amount, address recipient);
  49 |     |     event SwapInMCall(address instance, address extensionOut, uint256 amount, address recipient);
  50 |     |     event SwapOutMCall(address instance, address extensionIn, uint256 amount, address recipient);
  51 |     |     event SwapInMWithPermitVRSCall(
  52 |     |         address instance,
  53 |     |         address extensionOut,
  54 |     |         uint256 amount,
  55 |     |         address recipient,
  56 |     |         uint256 deadline,
  57 |     |         uint8 v,
  58 |     |         bytes32 r,
  59 |     |         bytes32 s
  60 |     |     );
  61 |     |     event SwapInMWithPermitSignatureCall(
  62 |     |         address instance,
  63 |     |         address extensionOut,
  64 |     |         uint256 amount,
  65 |     |         address recipient,
  66 |     |         uint256 deadline,
  67 |     |         bytes signature
  68 |     |     );
  69 |     |     event SwapInTokenCall(
  70 |     |         address instance,
  71 |     |         address tokenIn,
  72 |     |         uint256 amountIn,
  73 |     |         address extensionOut,
  74 |     |         uint256 minAmountOut,
  75 |     |         address recipient,
  76 |     |         bytes path
  77 |     |     );
  78 |     |     event SwapOutTokenCall(
  79 |     |         address instance,
  80 |     |         address extensionIn,
  81 |     |         uint256 amountIn,
  82 |     |         address tokenOut,
  83 |     |         uint256 minAmountOut,
  84 |     |         address recipient,
  85 |     |         bytes path
  86 |     |     );
  87 |     | 
  88 |     |     // MToken function calls
  89 |     |     event MintCall(address account, uint256 amount);
  90 |     | 
  91 |     |     // JMI Extension function calls
  92 |     |     event WrapAssetCall(address instance, address asset, address recipient, uint256 amount);
  93 |     |     event ReplaceAssetWithMCall(address instance, address asset, address recipient, uint256 amount);
  94 |     |     event SetAssetCapCall(address instance, address asset, uint256 cap);
  95 |     | 
  96 |     |     // Pausable function calls
  97 |     |     event PauseCall(address instance);
  98 |     |     event UnpauseCall(address instance);
  99 |     | 
 100 |     |     // Freezable function calls
 101 |     |     event FreezeCall(address instance, address account);
 102 |     |     event UnfreezeCall(address instance, address account);
 103 |     | 
 104 |     |     // MYieldToOne function implementations
 105 | *   |     function _claimYieldCall(address instance) internal returns (bool success, bytes memory returnData) {
 106 | *   |         emit ClaimYieldCall(instance);
 107 | *   |         vm.prank(currentActor);
 108 | *   |         (success, returnData) = address(instance).call(abi.encodeWithSelector(MYieldToOne.claimYield.selector));
 109 |     |     }
 110 |     | 
 111 | *   |     function _setYieldRecipientCall(
 112 |     |         address instance,
 113 |     |         address yieldRecipient
 114 | *   |     ) internal returns (bool success, bytes memory returnData) {
 115 | *   |         emit SetYieldRecipientCall(instance, yieldRecipient);
 116 | *   |         vm.prank(yieldRecipientManager);
 117 | *   |         (success, returnData) = address(instance).call(
 118 | *   |             abi.encodeWithSelector(MYieldToOne.setYieldRecipient.selector, yieldRecipient)
 119 |     |         );
 120 |     |     }
 121 |     | 
 122 | *   |     function _approveCall(
 123 |     |         address instance,
 124 |     |         address spender,
 125 |     |         uint256 amount
 126 | *   |     ) internal returns (bool success, bytes memory returnData) {
 127 | *   |         emit ApproveCall(instance, spender, amount);
 128 | *   |         vm.prank(currentActor);
 129 | *   |         (success, returnData) = address(instance).call(
 130 | *   |             abi.encodeWithSelector(IERC20.approve.selector, spender, amount)
 131 |     |         );
 132 |     |     }
 133 |     | 
 134 | *   |     function _transferCall(
 135 |     |         address instance,
 136 |     |         address to,
 137 |     |         uint256 amount
 138 | *   |     ) internal returns (bool success, bytes memory returnData) {
 139 | *   |         emit TransferCall(instance, to, amount);
 140 | *   |         vm.prank(currentActor);
 141 | *   |         (success, returnData) = address(instance).call(abi.encodeWithSelector(IERC20.transfer.selector, to, amount));
 142 |     |     }
 143 |     | 
 144 | *   |     function _transferFromCall(
 145 |     |         address instance,
 146 |     |         address from,
 147 |     |         address to,
 148 |     |         uint256 amount
 149 | *   |     ) internal returns (bool success, bytes memory returnData) {
 150 | *   |         emit TransferFromCall(instance, from, to, amount);
 151 | *   |         vm.prank(currentActor);
 152 | *   |         (success, returnData) = address(instance).call(
 153 | *   |             abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)
 154 |     |         );
 155 |     |     }
 156 |     | 
 157 |     |     function _wrapCall(
 158 |     |         address instance,
 159 |     |         address recipient,
 160 |     |         uint256 amount
 161 |     |     ) internal returns (bool success, bytes memory returnData) {
 162 |     |         emit WrapCall(instance, recipient, amount);
 163 |     |         vm.prank(currentActor);
 164 |     |         (success, returnData) = address(instance).call(
 165 |     |             abi.encodeWithSelector(MExtension.wrap.selector, recipient, amount)
 166 |     |         );
 167 |     |     }
 168 |     | 
 169 |     |     function _unwrapCall(
 170 |     |         address instance,
 171 |     |         address recipient,
 172 |     |         uint256 amount
 173 |     |     ) internal returns (bool success, bytes memory returnData) {
 174 |     |         emit UnwrapCall(instance, recipient, amount);
 175 |     |         vm.prank(currentActor);
 176 |     |         (success, returnData) = address(instance).call(
 177 |     |             abi.encodeWithSelector(MExtension.unwrap.selector, recipient, amount)
 178 |     |         );
 179 |     |     }
 180 |     | 
 181 |     |     // Madmin function implementations
 182 | *   |     function _setAccountInfoCall(
 183 |     |         address instance,
 184 |     |         address account,
 185 |     |         bool status,
 186 |     |         uint16 feeRate
 187 | *   |     ) internal returns (bool success, bytes memory returnData) {
 188 | *   |         emit SetAccountInfoCall(instance, account, status, feeRate);
 189 | *   |         vm.prank(admin);
 190 | *   |         (success, returnData) = address(instance).call(
 191 | *   |             abi.encodeWithSelector(bytes4(keccak256("setAccountInfo(address,bool,uint16)")), account, status, feeRate)
 192 |     |         );
 193 |     |     }
 194 |     | 
 195 | *   |     function _setFeeRecipientCall(
 196 |     |         address instance,
 197 |     |         address feeRecipient
 198 | *   |     ) internal returns (bool success, bytes memory returnData) {
 199 | *   |         emit SetFeeRecipientCall(instance, feeRecipient);
 200 | *   |         vm.prank(admin);
 201 | *   |         (success, returnData) = address(instance).call(
 202 | *   |             abi.encodeWithSelector(MEarnerManager.setFeeRecipient.selector, feeRecipient)
 203 |     |         );
 204 |     |     }
 205 |     | 
 206 | *   |     function _setFeeRecipientCall_MYieldFee(
 207 |     |         address instance,
 208 |     |         address feeRecipient
 209 | *   |     ) internal returns (bool success, bytes memory returnData) {
 210 | *   |         emit SetFeeRecipientCall(instance, feeRecipient);
 211 | *   |         vm.prank(admin);
 212 | *   |         (success, returnData) = address(instance).call(
 213 | *   |             abi.encodeWithSelector(MEarnerManager.setFeeRecipient.selector, feeRecipient)
 214 |     |         );
 215 |     |     }
 216 |     | 
 217 | *   |     function _claimForCall(address instance, address account) internal returns (bool success, bytes memory returnData) {
 218 | *   |         emit ClaimForCall(instance, account);
 219 | *   |         vm.prank(currentActor);
 220 | *   |         (success, returnData) = address(instance).call(
 221 | *   |             abi.encodeWithSelector(bytes4(keccak256("claimFor(address)")), account)
 222 |     |         );
 223 |     |     }
 224 |     | 
 225 |     |     // MYieldFee function implementations
 226 | *   |     function _claimYieldForCall(
 227 |     |         address instance,
 228 |     |         address account
 229 | *   |     ) internal returns (bool success, bytes memory returnData) {
 230 | *   |         emit ClaimYieldForCall(instance, account);
 231 | *   |         vm.prank(currentActor);
 232 | *   |         (success, returnData) = address(instance).call(
 233 | *   |             abi.encodeWithSelector(MYieldFee.claimYieldFor.selector, account)
 234 |     |         );
 235 |     |     }
 236 |     | 
 237 | *   |     function _claimFeeCall(address instance) internal returns (bool success, bytes memory returnData) {
 238 | *   |         emit ClaimFeeCall(instance);
 239 | *   |         vm.prank(currentActor);
 240 | *   |         (success, returnData) = address(instance).call(abi.encodeWithSelector(MYieldFee.claimFee.selector));
 241 |     |     }
 242 |     | 
 243 | *   |     function _updateIndexCall(address instance) internal returns (bool success, bytes memory returnData) {
 244 | *   |         emit UpdateIndexCall(instance);
 245 | *   |         vm.prank(currentActor);
 246 | *   |         (success, returnData) = address(instance).call(abi.encodeWithSelector(MYieldFee.updateIndex.selector));
 247 |     |     }
 248 |     | 
 249 | *   |     function _setFeeRateCall(
 250 |     |         address instance,
 251 |     |         uint16 feeRate
 252 | *   |     ) internal returns (bool success, bytes memory returnData) {
 253 | *   |         emit SetFeeRateCall(instance, feeRate);
 254 | *   |         vm.prank(admin);
 255 | *   |         (success, returnData) = address(instance).call(abi.encodeWithSelector(MYieldFee.setFeeRate.selector, feeRate));
 256 |     |     }
 257 |     | 
 258 | *   |     function _setClaimRecipientCall(
 259 |     |         address instance,
 260 |     |         address account,
 261 |     |         address claimRecipient
 262 | *   |     ) internal returns (bool success, bytes memory returnData) {
 263 | *   |         emit SetClaimRecipientCall(instance, account, claimRecipient);
 264 | *   |         vm.prank(admin);
 265 | *   |         (success, returnData) = address(instance).call(
 266 | *   |             abi.encodeWithSelector(MYieldFee.setClaimRecipient.selector, account, claimRecipient)
 267 |     |         );
 268 |     |     }
 269 |     | 
 270 |     |     // SwapFacility function implementations
 271 | *   |     function _swapCall(
 272 |     |         address instance,
 273 |     |         address extensionIn,
 274 |     |         address extensionOut,
 275 |     |         uint256 amount,
 276 |     |         address recipient
 277 | *   |     ) internal returns (bool success, bytes memory returnData) {
 278 | *   |         emit SwapCall(instance, extensionIn, extensionOut, amount, recipient);
 279 | *   |         vm.prank(currentActor);
 280 | *   |         (success, returnData) = address(instance).call(
 281 | *   |             abi.encodeWithSelector(SwapFacility.swap.selector, extensionIn, extensionOut, amount, recipient)
 282 |     |         );
 283 |     |     }
 284 |     | 
 285 | *   |     function _swapInMCall(
 286 |     |         address instance,
 287 |     |         address extensionOut,
 288 |     |         uint256 amount,
 289 |     |         address recipient
 290 | *   |     ) internal returns (bool success, bytes memory returnData) {
 291 | *   |         emit SwapInMCall(instance, extensionOut, amount, recipient);
 292 | *   |         vm.prank(currentActor);
 293 | *   |         (success, returnData) = address(instance).call(
 294 | *   |             abi.encodeWithSelector(SwapFacility.swapInM.selector, extensionOut, amount, recipient)
 295 |     |         );
 296 |     |     }
 297 |     | 
 298 | *   |     function _swapOutMCall(
 299 |     |         address instance,
 300 |     |         address extensionIn,
 301 |     |         uint256 amount,
 302 |     |         address recipient
 303 | *   |     ) internal returns (bool success, bytes memory returnData) {
 304 | *   |         emit SwapOutMCall(instance, extensionIn, amount, recipient);
 305 | *   |         vm.prank(currentActor);
 306 | *   |         (success, returnData) = address(instance).call(
 307 | *   |             abi.encodeWithSelector(SwapFacility.swapOutM.selector, extensionIn, amount, recipient)
 308 |     |         );
 309 |     |     }
 310 |     | 
 311 |     |     function _swapInMWithPermitVRSCall(
 312 |     |         address instance,
 313 |     |         address extensionOut,
 314 |     |         uint256 amount,
 315 |     |         address recipient,
 316 |     |         uint256 deadline,
 317 |     |         uint8 v,
 318 |     |         bytes32 r,
 319 |     |         bytes32 s
 320 |     |     ) internal returns (bool success, bytes memory returnData) {
 321 |     |         emit SwapInMWithPermitVRSCall(instance, extensionOut, amount, recipient, deadline, v, r, s);
 322 |     |         vm.prank(currentActor);
 323 |     |         (success, returnData) = address(instance).call(
 324 |     |             abi.encodeWithSelector(
 325 |     |                 bytes4(keccak256("swapInMWithPermit(address,uint256,address,uint256,uint8,bytes32,bytes32)")),
 326 |     |                 extensionOut,
 327 |     |                 amount,
 328 |     |                 recipient,
 329 |     |                 deadline,
 330 |     |                 v,
 331 |     |                 r,
 332 |     |                 s
 333 |     |             )
 334 |     |         );
 335 |     |     }
 336 |     | 
 337 |     |     function _swapInMWithPermitSignatureCall(
 338 |     |         address instance,
 339 |     |         address extensionOut,
 340 |     |         uint256 amount,
 341 |     |         address recipient,
 342 |     |         uint256 deadline,
 343 |     |         bytes memory signature
 344 |     |     ) internal returns (bool success, bytes memory returnData) {
 345 |     |         emit SwapInMWithPermitSignatureCall(instance, extensionOut, amount, recipient, deadline, signature);
 346 |     |         vm.prank(currentActor);
 347 |     |         (success, returnData) = address(instance).call(
 348 |     |             abi.encodeWithSelector(
 349 |     |                 bytes4(keccak256("swapInMWithPermit(address,uint256,address,uint256,bytes)")),
 350 |     |                 extensionOut,
 351 |     |                 amount,
 352 |     |                 recipient,
 353 |     |                 deadline,
 354 |     |                 signature
 355 |     |             )
 356 |     |         );
 357 |     |     }
 358 |     | 
 359 | *   |     function _swapInTokenCall(
 360 |     |         address instance,
 361 |     |         address tokenIn,
 362 |     |         uint256 amountIn,
 363 |     |         address extensionOut,
 364 |     |         uint256 minAmountOut,
 365 |     |         address recipient,
 366 |     |         bytes memory path
 367 | *   |     ) internal returns (bool success, bytes memory returnData) {
 368 | *   |         emit SwapInTokenCall(instance, tokenIn, amountIn, extensionOut, minAmountOut, recipient, path);
 369 | *   |         vm.prank(currentActor);
 370 | *   |         (success, returnData) = address(instance).call(
 371 | *   |             abi.encodeWithSelector(
 372 | *   |                 IUniswapV3SwapAdapter.swapIn.selector,
 373 | *   |                 tokenIn,
 374 | *   |                 amountIn,
 375 | *   |                 extensionOut,
 376 | *   |                 minAmountOut,
 377 | *   |                 recipient,
 378 | *   |                 path
 379 |     |             )
 380 |     |         );
 381 |     |     }
 382 |     | 
 383 | *   |     function _swapOutTokenCall(
 384 |     |         address instance,
 385 |     |         address extensionIn,
 386 |     |         uint256 amountIn,
 387 |     |         address tokenOut,
 388 |     |         uint256 minAmountOut,
 389 |     |         address recipient,
 390 |     |         bytes memory path
 391 | *   |     ) internal returns (bool success, bytes memory returnData) {
 392 | *   |         emit SwapOutTokenCall(instance, extensionIn, amountIn, tokenOut, minAmountOut, recipient, path);
 393 | *   |         vm.prank(currentActor);
 394 | *   |         (success, returnData) = address(instance).call(
 395 | *   |             abi.encodeWithSelector(
 396 | *   |                 IUniswapV3SwapAdapter.swapOut.selector,
 397 | *   |                 extensionIn,
 398 | *   |                 amountIn,
 399 | *   |                 tokenOut,
 400 | *   |                 minAmountOut,
 401 | *   |                 recipient,
 402 | *   |                 path
 403 |     |             )
 404 |     |         );
 405 |     |     }
 406 |     | 
 407 |     |     function _mintCall(address account, uint256 amount) internal returns (bool success, bytes memory returnData) {
 408 |     |         emit MintCall(account, amount);
 409 |     |         vm.prank(address(this));
 410 |     |         (success, returnData) = address(mToken).call(abi.encodeWithSelector(MToken.mint.selector, account, amount));
 411 |     |     }
 412 |     | 
 413 |     |     function _startEarningCall(address account) internal returns (bool success, bytes memory returnData) {
 414 |     |         emit StartEarningCall();
 415 |     |         vm.prank(currentActor);
 416 |     |         (success, returnData) = address(mToken).call(abi.encodeWithSelector(MToken.startEarning.selector, account));
 417 |     |     }
 418 |     | 
 419 |     |     function _stopEarningCall(address account) internal returns (bool success, bytes memory returnData) {
 420 |     |         emit StopEarningCall();
 421 |     |         vm.prank(currentActor);
 422 |     |         (success, returnData) = address(mToken).call(
 423 |     |             abi.encodeWithSelector(bytes4(keccak256("stopEarning(address)")), account)
 424 |     |         );
 425 |     |     }
 426 |     | 
 427 | *   |     function _enableEarningCall(address instance) internal returns (bool success, bytes memory returnData) {
 428 | *   |         emit EnableEarningCall(instance);
 429 |     |         // vm.prank(currentActor);
 430 | *   |         (success, returnData) = address(instance).call(abi.encodeWithSelector(IMExtension.enableEarning.selector));
 431 |     |     }
 432 |     | 
 433 | *   |     function _disableEarningCall(address instance) internal returns (bool success, bytes memory returnData) {
 434 | *   |         emit DisableEarningCall(instance);
 435 |     |         // vm.prank(currentActor);
 436 | *   |         (success, returnData) = address(instance).call(abi.encodeWithSelector(IMExtension.disableEarning.selector));
 437 |     |     }
 438 |     | 
 439 |     |     // JMI Extension function implementations
 440 |     |     function _wrapAssetCall(
 441 |     |         address instance,
 442 |     |         address asset,
 443 |     |         address recipient,
 444 |     |         uint256 amount
 445 |     |     ) internal returns (bool success, bytes memory returnData) {
 446 |     |         emit WrapAssetCall(instance, asset, recipient, amount);
 447 |     |         vm.prank(address(swapFacility));
 448 |     |         (success, returnData) = address(instance).call(
 449 |     |             abi.encodeWithSelector(JMIExtension.wrap.selector, asset, recipient, amount)
 450 |     |         );
 451 |     |     }
 452 |     | 
 453 |     |     function _replaceAssetWithMCall(
 454 |     |         address instance,
 455 |     |         address asset,
 456 |     |         address recipient,
 457 |     |         uint256 amount
 458 |     |     ) internal returns (bool success, bytes memory returnData) {
 459 |     |         emit ReplaceAssetWithMCall(instance, asset, recipient, amount);
 460 |     |         vm.prank(address(swapFacility));
 461 |     |         (success, returnData) = address(instance).call(
 462 |     |             abi.encodeWithSelector(JMIExtension.replaceAssetWithM.selector, asset, recipient, amount)
 463 |     |         );
 464 |     |     }
 465 |     | 
 466 |     |     function _setAssetCapCall(
 467 |     |         address instance,
 468 |     |         address asset,
 469 |     |         uint256 cap
 470 |     |     ) internal returns (bool success, bytes memory returnData) {
 471 |     |         emit SetAssetCapCall(instance, asset, cap);
 472 |     |         vm.prank(assetCapManager);
 473 |     |         (success, returnData) = address(instance).call(
 474 |     |             abi.encodeWithSelector(JMIExtension.setAssetCap.selector, asset, cap)
 475 |     |         );
 476 |     |     }
 477 |     | 
 478 |     |     // Pausable function implementations
 479 |     |     function _pauseCall(address instance) internal returns (bool success, bytes memory returnData) {
 480 |     |         emit PauseCall(instance);
 481 |     |         vm.prank(pauser);
 482 |     |         (success, returnData) = address(instance).call(abi.encodeWithSelector(Pausable.pause.selector));
 483 |     |     }
 484 |     | 
 485 |     |     function _unpauseCall(address instance) internal returns (bool success, bytes memory returnData) {
 486 |     |         emit UnpauseCall(instance);
 487 |     |         vm.prank(pauser);
 488 |     |         (success, returnData) = address(instance).call(abi.encodeWithSelector(Pausable.unpause.selector));
 489 |     |     }
 490 |     | 
 491 |     |     // Freezable function implementations
 492 |     |     function _freezeCall(
 493 |     |         address instance,
 494 |     |         address account
 495 |     |     ) internal returns (bool success, bytes memory returnData) {
 496 |     |         emit FreezeCall(instance, account);
 497 |     |         vm.prank(freezeManager);
 498 |     |         (success, returnData) = address(instance).call(
 499 |     |             abi.encodeWithSelector(Freezable.freeze.selector, account)
 500 |     |         );
 501 |     |     }
 502 |     | 
 503 |     |     function _unfreezeCall(
 504 |     |         address instance,
 505 |     |         address account
 506 |     |     ) internal returns (bool success, bytes memory returnData) {
 507 |     |         emit UnfreezeCall(instance, account);
 508 |     |         vm.prank(freezeManager);
 509 |     |         (success, returnData) = address(instance).call(
 510 |     |             abi.encodeWithSelector(Freezable.unfreeze.selector, account)
 511 |     |         );
 512 |     |     }
 513 |     | }
 514 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/utils/FuzzActors.sol
  1 |     | // SPDX-License-Identifier: UNTITLED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
  5 |     | import "forge-std/Test.sol";
  6 |     | 
  7 |     | contract FuzzActors is FuzzBase, Test {
  8 |     |     address internal constant owner = address(0xfffff);
  9 |     | 
 10 | *   |     address internal admin = address(this);
 11 | *   |     address internal blacklistManager = address(this);
 12 | *   |     address internal freezeManager = address(this);
 13 | *   |     address internal pauser = address(this);
 14 | *   |     address internal yieldRecipient = address(this);
 15 | *   |     address internal yieldRecipientManager = address(this);
 16 |     | 
 17 | *   |     address internal feeRecipient = address(this);
 18 | *   |     address internal yieldFeeManager = address(this);
 19 | *   |     address internal claimRecipientManager = address(this);
 20 | *   |     address internal earnerManager = address(this);
 21 | *   |     address internal assetCapManager = address(this);
 22 |     | 
 23 | *   |     address internal constant USER1 = address(0x10000);
 24 | *   |     address internal constant USER2 = address(0x20000);
 25 | *   |     address internal constant USER3 = address(0x30000);
 26 |     | 
 27 | *   |     address[] internal USERS = [USER1, USER2, USER3];
 28 |     | }
 29 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/fuzzing/utils/FuzzConstants.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | contract FuzzConstants {
  5 |     |     // ==============================================================
  6 |     |     // ERC20 v4.9 ERRORS
  7 |     |     // ==============================================================
  8 |     |     bytes internal constant EXCEEDS_BALANCE_ERROR =
  9 |     |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: transfer amount exceeds balance");
 10 |     |     bytes internal constant INSUFFICIENT_ALLOWANCE =
 11 |     |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: insufficient allowance");
 12 |     |     bytes internal constant TRANSFER_FROM_ZERO =
 13 |     |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: transfer from the zero address");
 14 |     |     bytes internal constant TRANSFER_TO_ZERO =
 15 |     |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: transfer to the zero address");
 16 |     |     bytes internal constant APPROVE_TO_ZERO =
 17 |     |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: approve to the zero address");
 18 |     |     bytes internal constant MINT_TO_ZERO =
 19 |     |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: mint to the zero address");
 20 |     |     bytes internal constant BURN_FROM_ZERO =
 21 |     |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: burn from the zero address");
 22 |     |     bytes internal constant DECREASED_ALLOWANCE =
 23 |     |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: decreased allowance below zero");
 24 |     |     bytes internal constant BURN_EXCEEDS_BALANCE =
 25 |     |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: burn amount exceeds balance");
 26 |     | 
 27 |     |     // ==============================================================
 28 |     |     // PANIC CODES
 29 |     |     // ==============================================================
 30 |     |     uint256 internal constant PANIC_GENERAL = 0x00;
 31 |     |     uint256 internal constant PANIC_ASSERT = 0x01;
 32 |     |     uint256 internal constant PANIC_ARITHMETIC = 0x11;
 33 |     |     uint256 internal constant PANIC_DIVISION_BY_ZERO = 0x12;
 34 |     |     uint256 internal constant PANIC_ENUM_OUT_OF_BOUNDS = 0x21;
 35 |     |     uint256 internal constant PANIC_STORAGE_BYTES_ARRAY_ENCODING = 0x22;
 36 |     |     uint256 internal constant PANIC_POP_EMPTY_ARRAY = 0x31;
 37 |     |     uint256 internal constant PANIC_ARRAY_OUT_OF_BOUNDS = 0x32;
 38 |     |     uint256 internal constant PANIC_ALLOC_TOO_MUCH_MEMORY = 0x41;
 39 |     |     uint256 internal constant PANIC_ZERO_INIT_INTERNAL_FUNCTION = 0x51;
 40 |     | }
 41 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/harness/MEarnerManagerHarness.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | 
  3 |     | pragma solidity 0.8.26;
  4 |     | 
  5 |     | import { MEarnerManager } from "../../src/projects/earnerManager/MEarnerManager.sol";
  6 |     | 
  7 | *   | contract MEarnerManagerHarness is MEarnerManager {
  8 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
  9 | *   |     constructor(address mToken, address swapFacility) MEarnerManager(mToken, swapFacility) {}
 10 |     | 
 11 | *   |     function initialize(
 12 |     |         string memory name,
 13 |     |         string memory symbol,
 14 |     |         address admin,
 15 |     |         address earnerManager,
 16 |     |         address feeRecipient_
 17 |     |     ) public override initializer {
 18 | *   |         super.initialize(name, symbol, admin, earnerManager, feeRecipient_);
 19 |     |     }
 20 |     | 
 21 | *   |     function setAccountOf(
 22 |     |         address account,
 23 |     |         uint256 balance,
 24 |     |         uint112 principal,
 25 |     |         bool isWhitelisted,
 26 |     |         uint16 feeRate
 27 | *   |     ) external {
 28 | *   |         MEarnerManagerStorageStruct storage $ = _getMEarnerManagerStorageLocation();
 29 |     | 
 30 | *   |         $.accounts[account].balance = balance;
 31 | *   |         $.accounts[account].principal = principal;
 32 | *   |         $.accounts[account].isWhitelisted = isWhitelisted;
 33 | *   |         $.accounts[account].feeRate = feeRate;
 34 |     |     }
 35 |     | 
 36 |     |     function setTotalSupply(uint256 totalSupply_) external {
 37 |     |         _getMEarnerManagerStorageLocation().totalSupply = totalSupply_;
 38 |     |     }
 39 |     | 
 40 |     |     function setTotalPrincipal(uint112 totalPrincipal_) external {
 41 |     |         _getMEarnerManagerStorageLocation().totalPrincipal = totalPrincipal_;
 42 |     |     }
 43 |     | 
 44 |     |     function setWasEarningEnabled(bool wasEarningEnabled_) external {
 45 |     |         _getMEarnerManagerStorageLocation().wasEarningEnabled = wasEarningEnabled_;
 46 |     |     }
 47 |     | }
 48 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/harness/MYieldFeeHarness.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | 
  3 |     | pragma solidity 0.8.26;
  4 |     | 
  5 |     | import { MYieldFee } from "../../src/projects/yieldToAllWithFee/MYieldFee.sol";
  6 |     | 
  7 | *   | contract MYieldFeeHarness is MYieldFee {
  8 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
  9 | *   |     constructor(address mToken, address swapFacility) MYieldFee(mToken, swapFacility) {}
 10 |     | 
 11 | *   |     function initialize(
 12 |     |         string memory name,
 13 |     |         string memory symbol,
 14 |     |         uint16 feeRate,
 15 |     |         address feeRecipient,
 16 |     |         address admin,
 17 |     |         address feeManager,
 18 |     |         address claimRecipientManager
 19 |     |     ) public override initializer {
 20 | *   |         super.initialize(name, symbol, feeRate, feeRecipient, admin, feeManager, claimRecipientManager);
 21 |     |     }
 22 |     | 
 23 |     |     function latestEarnerRateAccrualTimestamp() external view returns (uint40) {
 24 |     |         return _latestEarnerRateAccrualTimestamp();
 25 |     |     }
 26 |     | 
 27 |     |     function currentEarnerRate() external view returns (uint32) {
 28 |     |         return _currentEarnerRate();
 29 |     |     }
 30 |     | 
 31 |     |     function setAccountOf(address account, uint256 balance, uint112 principal) external {
 32 |     |         MYieldFeeStorageStruct storage $ = _getMYieldFeeStorageLocation();
 33 |     | 
 34 |     |         $.balanceOf[account] = balance;
 35 |     |         $.principalOf[account] = principal;
 36 |     |     }
 37 |     | 
 38 |     |     function setIsEarningEnabled(bool isEarningEnabled_) external {
 39 |     |         _getMYieldFeeStorageLocation().isEarningEnabled = isEarningEnabled_;
 40 |     |     }
 41 |     | 
 42 |     |     function setLatestIndex(uint256 latestIndex_) external {
 43 |     |         _getMYieldFeeStorageLocation().latestIndex = uint128(latestIndex_);
 44 |     |     }
 45 |     | 
 46 |     |     function setLatestRate(uint256 latestRate_) external {
 47 |     |         _getMYieldFeeStorageLocation().latestRate = uint32(latestRate_);
 48 |     |     }
 49 |     | 
 50 |     |     function setLatestUpdateTimestamp(uint256 latestUpdateTimestamp_) external {
 51 |     |         _getMYieldFeeStorageLocation().latestUpdateTimestamp = uint40(latestUpdateTimestamp_);
 52 |     |     }
 53 |     | 
 54 |     |     function setTotalSupply(uint256 totalSupply_) external {
 55 |     |         _getMYieldFeeStorageLocation().totalSupply = totalSupply_;
 56 |     |     }
 57 |     | 
 58 |     |     function setTotalPrincipal(uint112 totalPrincipal_) external {
 59 |     |         _getMYieldFeeStorageLocation().totalPrincipal = totalPrincipal_;
 60 |     |     }
 61 |     | }
 62 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/utils/Helpers.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | 
  3 |     | pragma solidity 0.8.26;
  4 |     | 
  5 |     | import { UIntMath } from "../../lib/common/src/libs/UIntMath.sol";
  6 |     | 
  7 |     | contract Helpers {
  8 |     |     uint16 public constant ONE_HUNDRED_PERCENT = 10_000;
  9 |     | 
 10 |     |     function _getEarnerRate(uint32 mEarnerRate, uint32 feeRate) internal pure returns (uint32) {
 11 |     |         return UIntMath.safe32((uint256(ONE_HUNDRED_PERCENT - feeRate) * mEarnerRate) / ONE_HUNDRED_PERCENT);
 12 |     |     }
 13 |     | 
 14 |     |     function _getYieldFee(uint256 yield, uint16 feeRate) internal pure returns (uint256) {
 15 |     |         return yield == 0 ? 0 : (yield * feeRate) / ONE_HUNDRED_PERCENT;
 16 |     |     }
 17 |     | }
 18 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/test/utils/Mocks.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | 
   3 |     | pragma solidity 0.8.26;
   4 |     | 
   5 |     | import {
   6 |     |     Initializable
   7 |     | } from "../../lib/common/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol";
   8 |     | 
   9 |     | import { ISwapFacility } from "../../src/swap/interfaces/ISwapFacility.sol";
  10 |     | 
  11 |     | contract MockM {
  12 |     |     uint128 public currentIndex;
  13 |     |     uint32 public earnerRate;
  14 |     |     uint128 public latestIndex;
  15 |     |     uint40 public latestUpdateTimestamp;
  16 |     | 
  17 |     |     error InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
  18 |     | 
  19 |     |     mapping(address account => uint256 balance) public balanceOf;
  20 |     |     mapping(address account => bool isEarning) public isEarning;
  21 |     |     mapping(address => mapping(address => uint256)) public allowance;
  22 |     | 
  23 |     |     function permit(
  24 |     |         address owner,
  25 |     |         address spender,
  26 |     |         uint256 value,
  27 |     |         uint256 deadline,
  28 |     |         uint8 v,
  29 |     |         bytes32 r,
  30 |     |         bytes32 s
  31 |     |     ) external {}
  32 |     | 
  33 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) external {}
  34 |     | 
  35 |     |     function approve(address spender, uint256 amount) public virtual returns (bool) {
  36 |     |         allowance[msg.sender][spender] = amount;
  37 |     | 
  38 |     |         return true;
  39 |     |     }
  40 |     | 
  41 |     |     function transfer(address recipient, uint256 amount) public returns (bool) {
  42 |     |         balanceOf[msg.sender] -= amount;
  43 |     |         balanceOf[recipient] += amount;
  44 |     | 
  45 |     |         return true;
  46 |     |     }
  47 |     | 
  48 |     |     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {
  49 |     |         balanceOf[sender] -= amount;
  50 |     |         balanceOf[recipient] += amount;
  51 |     | 
  52 |     |         return true;
  53 |     |     }
  54 |     | 
  55 |     |     function setBalanceOf(address account, uint256 balance) external {
  56 |     |         balanceOf[account] = balance;
  57 |     |     }
  58 |     | 
  59 |     |     function setCurrentIndex(uint128 currentIndex_) external {
  60 |     |         currentIndex = currentIndex_;
  61 |     |     }
  62 |     | 
  63 |     |     function setEarnerRate(uint256 earnerRate_) external {
  64 |     |         earnerRate = uint32(earnerRate_);
  65 |     |     }
  66 |     | 
  67 |     |     function setLatestIndex(uint128 latestIndex_) external {
  68 |     |         latestIndex = latestIndex_;
  69 |     |     }
  70 |     | 
  71 |     |     function setLatestUpdateTimestamp(uint256 timestamp) external {
  72 |     |         latestUpdateTimestamp = uint40(timestamp);
  73 |     |     }
  74 |     | 
  75 |     |     function setIsEarning(address account, bool isEarning_) external {
  76 |     |         isEarning[account] = isEarning_;
  77 |     |     }
  78 |     | 
  79 |     |     function startEarning() external {
  80 |     |         isEarning[msg.sender] = true;
  81 |     |     }
  82 |     | 
  83 |     |     function stopEarning(address account) external {
  84 |     |         isEarning[account] = false;
  85 |     |     }
  86 |     | }
  87 |     | 
  88 | *   | contract MockRateOracle {
  89 |     |     uint32 public earnerRate;
  90 |     | 
  91 |     |     function setEarnerRate(uint32 rate) external {
  92 |     |         earnerRate = rate;
  93 |     |     }
  94 |     | }
  95 |     | 
  96 |     | contract MockRegistrar {
  97 |     |     bytes32 public constant EARNERS_LIST_NAME = "earners";
  98 |     | 
  99 |     |     mapping(bytes32 key => bytes32 value) internal _values;
 100 |     | 
 101 |     |     mapping(bytes32 listName => mapping(address account => bool contains)) public listContains;
 102 |     | 
 103 |     |     function get(bytes32 key) external view returns (bytes32 value) {
 104 |     |         return _values[key];
 105 |     |     }
 106 |     | 
 107 |     |     function set(bytes32 key, bytes32 value) external {
 108 |     |         _values[key] = value;
 109 |     |     }
 110 |     | 
 111 |     |     function setEarner(address account, bool contains) external {
 112 |     |         listContains[EARNERS_LIST_NAME][account] = contains;
 113 |     |     }
 114 |     | }
 115 |     | 
 116 |     | abstract contract MockERC20 {
 117 |     |     event Transfer(address indexed from, address indexed to, uint256 amount);
 118 |     |     event Approval(address indexed owner, address indexed spender, uint256 amount);
 119 |     | 
 120 |     |     string public name;
 121 |     |     string public symbol;
 122 |     |     uint8 public immutable decimals;
 123 |     |     uint256 public totalSupply;
 124 |     |     mapping(address => uint256) public balanceOf;
 125 |     |     mapping(address => mapping(address => uint256)) public allowance;
 126 |     | 
 127 |     |     constructor(string memory name_, string memory symbol_, uint8 decimals_) {
 128 |     |         name = name_;
 129 |     |         symbol = symbol_;
 130 |     |         decimals = decimals_;
 131 |     |     }
 132 |     | 
 133 |     |     function approve(address spender, uint256 amount) public virtual returns (bool) {
 134 |     |         allowance[msg.sender][spender] = amount;
 135 |     | 
 136 |     |         emit Approval(msg.sender, spender, amount);
 137 |     | 
 138 |     |         return true;
 139 |     |     }
 140 |     | 
 141 |     |     function transfer(address to, uint256 amount) public virtual returns (bool) {
 142 |     |         balanceOf[msg.sender] -= amount;
 143 |     | 
 144 |     |         unchecked {
 145 |     |             balanceOf[to] += amount;
 146 |     |         }
 147 |     | 
 148 |     |         emit Transfer(msg.sender, to, amount);
 149 |     | 
 150 |     |         return true;
 151 |     |     }
 152 |     | 
 153 |     |     function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {
 154 |     |         uint256 allowed = allowance[from][msg.sender];
 155 |     | 
 156 |     |         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;
 157 |     | 
 158 |     |         balanceOf[from] -= amount;
 159 |     | 
 160 |     |         unchecked {
 161 |     |             balanceOf[to] += amount;
 162 |     |         }
 163 |     | 
 164 |     |         emit Transfer(from, to, amount);
 165 |     | 
 166 |     |         return true;
 167 |     |     }
 168 |     | 
 169 |     |     function _mint(address to, uint256 amount) internal virtual {
 170 |     |         totalSupply += amount;
 171 |     | 
 172 |     |         unchecked {
 173 |     |             balanceOf[to] += amount;
 174 |     |         }
 175 |     | 
 176 |     |         emit Transfer(address(0), to, amount);
 177 |     |     }
 178 |     | 
 179 |     |     function _burn(address from, uint256 amount) internal virtual {
 180 |     |         balanceOf[from] -= amount;
 181 |     | 
 182 |     |         unchecked {
 183 |     |             totalSupply -= amount;
 184 |     |         }
 185 |     | 
 186 |     |         emit Transfer(from, address(0), amount);
 187 |     |     }
 188 |     | }
 189 |     | 
 190 |     | contract MockMExtension is MockERC20 {
 191 |     |     MockM public mToken;
 192 |     |     address public swapFacility;
 193 |     | 
 194 |     |     constructor(address mToken_, address swapFacility_) MockERC20("MockMExtension", "MME", 6) {
 195 |     |         mToken = MockM(mToken_);
 196 |     |         swapFacility = swapFacility_;
 197 |     |     }
 198 |     | 
 199 |     |     function wrap(address recipient, uint256 amount) external {
 200 |     |         uint256 startingBalance = mToken.balanceOf(address(this));
 201 |     |         mToken.transferFrom(msg.sender, address(this), amount);
 202 |     |         _mint(recipient, uint240(mToken.balanceOf(address(this)) - startingBalance));
 203 |     |     }
 204 |     | 
 205 |     |     function unwrap(address recipient, uint256 amount) external {
 206 |     |         _burn(msg.sender, amount);
 207 |     |         mToken.transfer(msg.sender, amount);
 208 |     |     }
 209 |     | }
 210 |     | 
 211 |     | contract MExtensionUpgrade is Initializable {
 212 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
 213 |     |     constructor() {
 214 |     |         _disableInitializers();
 215 |     |     }
 216 |     | 
 217 |     |     function bar() external pure returns (uint256) {
 218 |     |         return 1;
 219 |     |     }
 220 |     | }
 221 |     | 
 222 |     | contract MockSwapFacility {
 223 |     |     address public msgSender;
 224 |     | 
 225 |     |     function setMsgSender(address msgSender_) external {
 226 |     |         msgSender = msgSender_;
 227 |     |     }
 228 |     | }
 229 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/mocks/WETH.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | /**
   3 |     |  *Submitted for verification at Etherscan.io on 2017-12-12
   4 |     |  */
   5 |     | 
   6 |     | // Copyright (C) 2015, 2016, 2017 Dapphub
   7 |     | 
   8 |     | // This program is free software: you can redistribute it and/or modify
   9 |     | // it under the terms of the GNU General Public License as published by
  10 |     | // the Free Software Foundation, either version 3 of the License, or
  11 |     | // (at your option) any later version.
  12 |     | 
  13 |     | // This program is distributed in the hope that it will be useful,
  14 |     | // but WITHOUT ANY WARRANTY; without even the implied warranty of
  15 |     | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  16 |     | // GNU General Public License for more details.
  17 |     | 
  18 |     | // You should have received a copy of the GNU General Public License
  19 |     | // along with this program.  If not, see <http://www.gnu.org/licenses/>.
  20 |     | 
  21 |     | pragma solidity ^0.8.13;
  22 |     | 
  23 | *   | contract WETH9 {
  24 | *   |     string public name = "Wrapped Ether";
  25 | *   |     string public symbol = "WETH";
  26 | *   |     uint8 public decimals = 18;
  27 |     | 
  28 |     |     event Approval(address indexed src, address indexed guy, uint wad);
  29 |     |     event Transfer(address indexed src, address indexed dst, uint wad);
  30 |     |     event Deposit(address indexed dst, uint wad);
  31 |     |     event Withdrawal(address indexed src, uint wad);
  32 |     | 
  33 |     |     mapping(address => uint) public balanceOf;
  34 |     |     mapping(address => mapping(address => uint)) public allowance;
  35 |     | 
  36 |     |     receive() external payable {
  37 |     |         deposit();
  38 |     |     }
  39 |     | 
  40 | *   |     function deposit() public payable {
  41 | *   |         balanceOf[msg.sender] += msg.value;
  42 | *   |         emit Deposit(msg.sender, msg.value);
  43 |     |     }
  44 |     | 
  45 |     |     function withdraw(uint wad) public {
  46 |     |         require(balanceOf[msg.sender] >= wad);
  47 |     |         balanceOf[msg.sender] -= wad;
  48 |     |         msg.sender.call{ value: wad }("");
  49 |     |         emit Withdrawal(msg.sender, wad);
  50 |     |     }
  51 |     | 
  52 |     |     function totalSupply() public view returns (uint) {
  53 |     |         return address(this).balance;
  54 |     |     }
  55 |     | 
  56 | *   |     function approve(address guy, uint wad) public returns (bool) {
  57 | *   |         allowance[msg.sender][guy] = wad;
  58 | *   |         emit Approval(msg.sender, guy, wad);
  59 | *   |         return true;
  60 |     |     }
  61 |     | 
  62 |     |     function transfer(address dst, uint wad) public returns (bool) {
  63 |     |         return transferFrom(msg.sender, dst, wad);
  64 |     |     }
  65 |     | 
  66 |     |     function transferFrom(address src, address dst, uint wad) public returns (bool) {
  67 |     |         require(balanceOf[src] >= wad);
  68 |     | 
  69 |     |         if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {
  70 |     |             require(allowance[src][msg.sender] >= wad);
  71 |     |             allowance[src][msg.sender] -= wad;
  72 |     |         }
  73 |     | 
  74 |     |         balanceOf[src] -= wad;
  75 |     |         balanceOf[dst] += wad;
  76 |     | 
  77 |     |         emit Transfer(src, dst, wad);
  78 |     | 
  79 |     |         return true;
  80 |     |     }
  81 |     | }
  82 |     | 
  83 |     | /*
  84 |     |                     GNU GENERAL PUBLIC LICENSE
  85 |     |                        Version 3, 29 June 2007
  86 |     | 
  87 |     |  Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
  88 |     |  Everyone is permitted to copy and distribute verbatim copies
  89 |     |  of this license document, but changing it is not allowed.
  90 |     | 
  91 |     |                             Preamble
  92 |     | 
  93 |     |   The GNU General Public License is a free, copyleft license for
  94 |     | software and other kinds of works.
  95 |     | 
  96 |     |   The licenses for most software and other practical works are designed
  97 |     | to take away your freedom to share and change the works.  By contrast,
  98 |     | the GNU General Public License is intended to guarantee your freedom to
  99 |     | share and change all versions of a program--to make sure it remains free
 100 |     | software for all its users.  We, the Free Software Foundation, use the
 101 |     | GNU General Public License for most of our software; it applies also to
 102 |     | any other work released this way by its authors.  You can apply it to
 103 |     | your programs, too.
 104 |     | 
 105 |     |   When we speak of free software, we are referring to freedom, not
 106 |     | price.  Our General Public Licenses are designed to make sure that you
 107 |     | have the freedom to distribute copies of free software (and charge for
 108 |     | them if you wish), that you receive source code or can get it if you
 109 |     | want it, that you can change the software or use pieces of it in new
 110 |     | free programs, and that you know you can do these things.
 111 |     | 
 112 |     |   To protect your rights, we need to prevent others from denying you
 113 |     | these rights or asking you to surrender the rights.  Therefore, you have
 114 |     | certain responsibilities if you distribute copies of the software, or if
 115 |     | you modify it: responsibilities to respect the freedom of others.
 116 |     | 
 117 |     |   For example, if you distribute copies of such a program, whether
 118 |     | gratis or for a fee, you must pass on to the recipients the same
 119 |     | freedoms that you received.  You must make sure that they, too, receive
 120 |     | or can get the source code.  And you must show them these terms so they
 121 |     | know their rights.
 122 |     | 
 123 |     |   Developers that use the GNU GPL protect your rights with two steps:
 124 |     | (1) assert copyright on the software, and (2) offer you this License
 125 |     | giving you legal permission to copy, distribute and/or modify it.
 126 |     | 
 127 |     |   For the developers' and authors' protection, the GPL clearly explains
 128 |     | that there is no warranty for this free software.  For both users' and
 129 |     | authors' sake, the GPL requires that modified versions be marked as
 130 |     | changed, so that their problems will not be attributed erroneously to
 131 |     | authors of previous versions.
 132 |     | 
 133 |     |   Some devices are designed to deny users access to install or run
 134 |     | modified versions of the software inside them, although the manufacturer
 135 |     | can do so.  This is fundamentally incompatible with the aim of
 136 |     | protecting users' freedom to change the software.  The systematic
 137 |     | pattern of such abuse occurs in the area of products for individuals to
 138 |     | use, which is precisely where it is most unacceptable.  Therefore, we
 139 |     | have designed this version of the GPL to prohibit the practice for those
 140 |     | products.  If such problems arise substantially in other domains, we
 141 |     | stand ready to extend this provision to those domains in future versions
 142 |     | of the GPL, as needed to protect the freedom of users.
 143 |     | 
 144 |     |   Finally, every program is threatened constantly by software patents.
 145 |     | States should not allow patents to restrict development and use of
 146 |     | software on general-purpose computers, but in those that do, we wish to
 147 |     | avoid the special danger that patents applied to a free program could
 148 |     | make it effectively proprietary.  To prevent this, the GPL assures that
 149 |     | patents cannot be used to render the program non-free.
 150 |     | 
 151 |     |   The precise terms and conditions for copying, distribution and
 152 |     | modification follow.
 153 |     | 
 154 |     |                        TERMS AND CONDITIONS
 155 |     | 
 156 |     |   0. Definitions.
 157 |     | 
 158 |     |   "This License" refers to version 3 of the GNU General Public License.
 159 |     | 
 160 |     |   "Copyright" also means copyright-like laws that apply to other kinds of
 161 |     | works, such as semiconductor masks.
 162 |     | 
 163 |     |   "The Program" refers to any copyrightable work licensed under this
 164 |     | License.  Each licensee is addressed as "you".  "Licensees" and
 165 |     | "recipients" may be individuals or organizations.
 166 |     | 
 167 |     |   To "modify" a work means to copy from or adapt all or part of the work
 168 |     | in a fashion requiring copyright permission, other than the making of an
 169 |     | exact copy.  The resulting work is called a "modified version" of the
 170 |     | earlier work or a work "based on" the earlier work.
 171 |     | 
 172 |     |   A "covered work" means either the unmodified Program or a work based
 173 |     | on the Program.
 174 |     | 
 175 |     |   To "propagate" a work means to do anything with it that, without
 176 |     | permission, would make you directly or secondarily liable for
 177 |     | infringement under applicable copyright law, except executing it on a
 178 |     | computer or modifying a private copy.  Propagation includes copying,
 179 |     | distribution (with or without modification), making available to the
 180 |     | public, and in some countries other activities as well.
 181 |     | 
 182 |     |   To "convey" a work means any kind of propagation that enables other
 183 |     | parties to make or receive copies.  Mere interaction with a user through
 184 |     | a computer network, with no transfer of a copy, is not conveying.
 185 |     | 
 186 |     |   An interactive user interface displays "Appropriate Legal Notices"
 187 |     | to the extent that it includes a convenient and prominently visible
 188 |     | feature that (1) displays an appropriate copyright notice, and (2)
 189 |     | tells the user that there is no warranty for the work (except to the
 190 |     | extent that warranties are provided), that licensees may convey the
 191 |     | work under this License, and how to view a copy of this License.  If
 192 |     | the interface presents a list of user commands or options, such as a
 193 |     | menu, a prominent item in the list meets this criterion.
 194 |     | 
 195 |     |   1. Source Code.
 196 |     | 
 197 |     |   The "source code" for a work means the preferred form of the work
 198 |     | for making modifications to it.  "Object code" means any non-source
 199 |     | form of a work.
 200 |     | 
 201 |     |   A "Standard Interface" means an interface that either is an official
 202 |     | standard defined by a recognized standards body, or, in the case of
 203 |     | interfaces specified for a particular programming language, one that
 204 |     | is widely used among developers working in that language.
 205 |     | 
 206 |     |   The "System Libraries" of an executable work include anything, other
 207 |     | than the work as a whole, that (a) is included in the normal form of
 208 |     | packaging a Major Component, but which is not part of that Major
 209 |     | Component, and (b) serves only to enable use of the work with that
 210 |     | Major Component, or to implement a Standard Interface for which an
 211 |     | implementation is available to the public in source code form.  A
 212 |     | "Major Component", in this context, means a major essential component
 213 |     | (kernel, window system, and so on) of the specific operating system
 214 |     | (if any) on which the executable work runs, or a compiler used to
 215 |     | produce the work, or an object code interpreter used to run it.
 216 |     | 
 217 |     |   The "Corresponding Source" for a work in object code form means all
 218 |     | the source code needed to generate, install, and (for an executable
 219 |     | work) run the object code and to modify the work, including scripts to
 220 |     | control those activities.  However, it does not include the work's
 221 |     | System Libraries, or general-purpose tools or generally available free
 222 |     | programs which are used unmodified in performing those activities but
 223 |     | which are not part of the work.  For example, Corresponding Source
 224 |     | includes interface definition files associated with source files for
 225 |     | the work, and the source code for shared libraries and dynamically
 226 |     | linked subprograms that the work is specifically designed to require,
 227 |     | such as by intimate data communication or control flow between those
 228 |     | subprograms and other parts of the work.
 229 |     | 
 230 |     |   The Corresponding Source need not include anything that users
 231 |     | can regenerate automatically from other parts of the Corresponding
 232 |     | Source.
 233 |     | 
 234 |     |   The Corresponding Source for a work in source code form is that
 235 |     | same work.
 236 |     | 
 237 |     |   2. Basic Permissions.
 238 |     | 
 239 |     |   All rights granted under this License are granted for the term of
 240 |     | copyright on the Program, and are irrevocable provided the stated
 241 |     | conditions are met.  This License explicitly affirms your unlimited
 242 |     | permission to run the unmodified Program.  The output from running a
 243 |     | covered work is covered by this License only if the output, given its
 244 |     | content, constitutes a covered work.  This License acknowledges your
 245 |     | rights of fair use or other equivalent, as provided by copyright law.
 246 |     | 
 247 |     |   You may make, run and propagate covered works that you do not
 248 |     | convey, without conditions so long as your license otherwise remains
 249 |     | in force.  You may convey covered works to others for the sole purpose
 250 |     | of having them make modifications exclusively for you, or provide you
 251 |     | with facilities for running those works, provided that you comply with
 252 |     | the terms of this License in conveying all material for which you do
 253 |     | not control copyright.  Those thus making or running the covered works
 254 |     | for you must do so exclusively on your behalf, under your direction
 255 |     | and control, on terms that prohibit them from making any copies of
 256 |     | your copyrighted material outside their relationship with you.
 257 |     | 
 258 |     |   Conveying under any other circumstances is permitted solely under
 259 |     | the conditions stated below.  Sublicensing is not allowed; section 10
 260 |     | makes it unnecessary.
 261 |     | 
 262 |     |   3. Protecting Users' Legal Rights From Anti-Circumvention Law.
 263 |     | 
 264 |     |   No covered work shall be deemed part of an effective technological
 265 |     | measure under any applicable law fulfilling obligations under article
 266 |     | 11 of the WIPO copyright treaty adopted on 20 December 1996, or
 267 |     | similar laws prohibiting or restricting circumvention of such
 268 |     | measures.
 269 |     | 
 270 |     |   When you convey a covered work, you waive any legal power to forbid
 271 |     | circumvention of technological measures to the extent such circumvention
 272 |     | is effected by exercising rights under this License with respect to
 273 |     | the covered work, and you disclaim any intention to limit operation or
 274 |     | modification of the work as a means of enforcing, against the work's
 275 |     | users, your or third parties' legal rights to forbid circumvention of
 276 |     | technological measures.
 277 |     | 
 278 |     |   4. Conveying Verbatim Copies.
 279 |     | 
 280 |     |   You may convey verbatim copies of the Program's source code as you
 281 |     | receive it, in any medium, provided that you conspicuously and
 282 |     | appropriately publish on each copy an appropriate copyright notice;
 283 |     | keep intact all notices stating that this License and any
 284 |     | non-permissive terms added in accord with section 7 apply to the code;
 285 |     | keep intact all notices of the absence of any warranty; and give all
 286 |     | recipients a copy of this License along with the Program.
 287 |     | 
 288 |     |   You may charge any price or no price for each copy that you convey,
 289 |     | and you may offer support or warranty protection for a fee.
 290 |     | 
 291 |     |   5. Conveying Modified Source Versions.
 292 |     | 
 293 |     |   You may convey a work based on the Program, or the modifications to
 294 |     | produce it from the Program, in the form of source code under the
 295 |     | terms of section 4, provided that you also meet all of these conditions:
 296 |     | 
 297 |     |     a) The work must carry prominent notices stating that you modified
 298 |     |     it, and giving a relevant date.
 299 |     | 
 300 |     |     b) The work must carry prominent notices stating that it is
 301 |     |     released under this License and any conditions added under section
 302 |     |     7.  This requirement modifies the requirement in section 4 to
 303 |     |     "keep intact all notices".
 304 |     | 
 305 |     |     c) You must license the entire work, as a whole, under this
 306 |     |     License to anyone who comes into possession of a copy.  This
 307 |     |     License will therefore apply, along with any applicable section 7
 308 |     |     additional terms, to the whole of the work, and all its parts,
 309 |     |     regardless of how they are packaged.  This License gives no
 310 |     |     permission to license the work in any other way, but it does not
 311 |     |     invalidate such permission if you have separately received it.
 312 |     | 
 313 |     |     d) If the work has interactive user interfaces, each must display
 314 |     |     Appropriate Legal Notices; however, if the Program has interactive
 315 |     |     interfaces that do not display Appropriate Legal Notices, your
 316 |     |     work need not make them do so.
 317 |     | 
 318 |     |   A compilation of a covered work with other separate and independent
 319 |     | works, which are not by their nature extensions of the covered work,
 320 |     | and which are not combined with it such as to form a larger program,
 321 |     | in or on a volume of a storage or distribution medium, is called an
 322 |     | "aggregate" if the compilation and its resulting copyright are not
 323 |     | used to limit the access or legal rights of the compilation's users
 324 |     | beyond what the individual works permit.  Inclusion of a covered work
 325 |     | in an aggregate does not cause this License to apply to the other
 326 |     | parts of the aggregate.
 327 |     | 
 328 |     |   6. Conveying Non-Source Forms.
 329 |     | 
 330 |     |   You may convey a covered work in object code form under the terms
 331 |     | of sections 4 and 5, provided that you also convey the
 332 |     | machine-readable Corresponding Source under the terms of this License,
 333 |     | in one of these ways:
 334 |     | 
 335 |     |     a) Convey the object code in, or embodied in, a physical product
 336 |     |     (including a physical distribution medium), accompanied by the
 337 |     |     Corresponding Source fixed on a durable physical medium
 338 |     |     customarily used for software interchange.
 339 |     | 
 340 |     |     b) Convey the object code in, or embodied in, a physical product
 341 |     |     (including a physical distribution medium), accompanied by a
 342 |     |     written offer, valid for at least three years and valid for as
 343 |     |     long as you offer spare parts or customer support for that product
 344 |     |     model, to give anyone who possesses the object code either (1) a
 345 |     |     copy of the Corresponding Source for all the software in the
 346 |     |     product that is covered by this License, on a durable physical
 347 |     |     medium customarily used for software interchange, for a price no
 348 |     |     more than your reasonable cost of physically performing this
 349 |     |     conveying of source, or (2) access to copy the
 350 |     |     Corresponding Source from a network server at no charge.
 351 |     | 
 352 |     |     c) Convey individual copies of the object code with a copy of the
 353 |     |     written offer to provide the Corresponding Source.  This
 354 |     |     alternative is allowed only occasionally and noncommercially, and
 355 |     |     only if you received the object code with such an offer, in accord
 356 |     |     with subsection 6b.
 357 |     | 
 358 |     |     d) Convey the object code by offering access from a designated
 359 |     |     place (gratis or for a charge), and offer equivalent access to the
 360 |     |     Corresponding Source in the same way through the same place at no
 361 |     |     further charge.  You need not require recipients to copy the
 362 |     |     Corresponding Source along with the object code.  If the place to
 363 |     |     copy the object code is a network server, the Corresponding Source
 364 |     |     may be on a different server (operated by you or a third party)
 365 |     |     that supports equivalent copying facilities, provided you maintain
 366 |     |     clear directions next to the object code saying where to find the
 367 |     |     Corresponding Source.  Regardless of what server hosts the
 368 |     |     Corresponding Source, you remain obligated to ensure that it is
 369 |     |     available for as long as needed to satisfy these requirements.
 370 |     | 
 371 |     |     e) Convey the object code using peer-to-peer transmission, provided
 372 |     |     you inform other peers where the object code and Corresponding
 373 |     |     Source of the work are being offered to the general public at no
 374 |     |     charge under subsection 6d.
 375 |     | 
 376 |     |   A separable portion of the object code, whose source code is excluded
 377 |     | from the Corresponding Source as a System Library, need not be
 378 |     | included in conveying the object code work.
 379 |     | 
 380 |     |   A "User Product" is either (1) a "consumer product", which means any
 381 |     | tangible personal property which is normally used for personal, family,
 382 |     | or household purposes, or (2) anything designed or sold for incorporation
 383 |     | into a dwelling.  In determining whether a product is a consumer product,
 384 |     | doubtful cases shall be resolved in favor of coverage.  For a particular
 385 |     | product received by a particular user, "normally used" refers to a
 386 |     | typical or common use of that class of product, regardless of the status
 387 |     | of the particular user or of the way in which the particular user
 388 |     | actually uses, or expects or is expected to use, the product.  A product
 389 |     | is a consumer product regardless of whether the product has substantial
 390 |     | commercial, industrial or non-consumer uses, unless such uses represent
 391 |     | the only significant mode of use of the product.
 392 |     | 
 393 |     |   "Installation Information" for a User Product means any methods,
 394 |     | procedures, authorization keys, or other information required to install
 395 |     | and execute modified versions of a covered work in that User Product from
 396 |     | a modified version of its Corresponding Source.  The information must
 397 |     | suffice to ensure that the continued functioning of the modified object
 398 |     | code is in no case prevented or interfered with solely because
 399 |     | modification has been made.
 400 |     | 
 401 |     |   If you convey an object code work under this section in, or with, or
 402 |     | specifically for use in, a User Product, and the conveying occurs as
 403 |     | part of a transaction in which the right of possession and use of the
 404 |     | User Product is transferred to the recipient in perpetuity or for a
 405 |     | fixed term (regardless of how the transaction is characterized), the
 406 |     | Corresponding Source conveyed under this section must be accompanied
 407 |     | by the Installation Information.  But this requirement does not apply
 408 |     | if neither you nor any third party retains the ability to install
 409 |     | modified object code on the User Product (for example, the work has
 410 |     | been installed in ROM).
 411 |     | 
 412 |     |   The requirement to provide Installation Information does not include a
 413 |     | requirement to continue to provide support service, warranty, or updates
 414 |     | for a work that has been modified or installed by the recipient, or for
 415 |     | the User Product in which it has been modified or installed.  Access to a
 416 |     | network may be denied when the modification itself materially and
 417 |     | adversely affects the operation of the network or violates the rules and
 418 |     | protocols for communication across the network.
 419 |     | 
 420 |     |   Corresponding Source conveyed, and Installation Information provided,
 421 |     | in accord with this section must be in a format that is publicly
 422 |     | documented (and with an implementation available to the public in
 423 |     | source code form), and must require no special password or key for
 424 |     | unpacking, reading or copying.
 425 |     | 
 426 |     |   7. Additional Terms.
 427 |     | 
 428 |     |   "Additional permissions" are terms that supplement the terms of this
 429 |     | License by making exceptions from one or more of its conditions.
 430 |     | Additional permissions that are applicable to the entire Program shall
 431 |     | be treated as though they were included in this License, to the extent
 432 |     | that they are valid under applicable law.  If additional permissions
 433 |     | apply only to part of the Program, that part may be used separately
 434 |     | under those permissions, but the entire Program remains governed by
 435 |     | this License without regard to the additional permissions.
 436 |     | 
 437 |     |   When you convey a copy of a covered work, you may at your option
 438 |     | remove any additional permissions from that copy, or from any part of
 439 |     | it.  (Additional permissions may be written to require their own
 440 |     | removal in certain cases when you modify the work.)  You may place
 441 |     | additional permissions on material, added by you to a covered work,
 442 |     | for which you have or can give appropriate copyright permission.
 443 |     | 
 444 |     |   Notwithstanding any other provision of this License, for material you
 445 |     | add to a covered work, you may (if authorized by the copyright holders of
 446 |     | that material) supplement the terms of this License with terms:
 447 |     | 
 448 |     |     a) Disclaiming warranty or limiting liability differently from the
 449 |     |     terms of sections 15 and 16 of this License; or
 450 |     | 
 451 |     |     b) Requiring preservation of specified reasonable legal notices or
 452 |     |     author attributions in that material or in the Appropriate Legal
 453 |     |     Notices displayed by works containing it; or
 454 |     | 
 455 |     |     c) Prohibiting misrepresentation of the origin of that material, or
 456 |     |     requiring that modified versions of such material be marked in
 457 |     |     reasonable ways as different from the original version; or
 458 |     | 
 459 |     |     d) Limiting the use for publicity purposes of names of licensors or
 460 |     |     authors of the material; or
 461 |     | 
 462 |     |     e) Declining to grant rights under trademark law for use of some
 463 |     |     trade names, trademarks, or service marks; or
 464 |     | 
 465 |     |     f) Requiring indemnification of licensors and authors of that
 466 |     |     material by anyone who conveys the material (or modified versions of
 467 |     |     it) with contractual assumptions of liability to the recipient, for
 468 |     |     any liability that these contractual assumptions directly impose on
 469 |     |     those licensors and authors.
 470 |     | 
 471 |     |   All other non-permissive additional terms are considered "further
 472 |     | restrictions" within the meaning of section 10.  If the Program as you
 473 |     | received it, or any part of it, contains a notice stating that it is
 474 |     | governed by this License along with a term that is a further
 475 |     | restriction, you may remove that term.  If a license document contains
 476 |     | a further restriction but permits relicensing or conveying under this
 477 |     | License, you may add to a covered work material governed by the terms
 478 |     | of that license document, provided that the further restriction does
 479 |     | not survive such relicensing or conveying.
 480 |     | 
 481 |     |   If you add terms to a covered work in accord with this section, you
 482 |     | must place, in the relevant source files, a statement of the
 483 |     | additional terms that apply to those files, or a notice indicating
 484 |     | where to find the applicable terms.
 485 |     | 
 486 |     |   Additional terms, permissive or non-permissive, may be stated in the
 487 |     | form of a separately written license, or stated as exceptions;
 488 |     | the above requirements apply either way.
 489 |     | 
 490 |     |   8. Termination.
 491 |     | 
 492 |     |   You may not propagate or modify a covered work except as expressly
 493 |     | provided under this License.  Any attempt otherwise to propagate or
 494 |     | modify it is void, and will automatically terminate your rights under
 495 |     | this License (including any patent licenses granted under the third
 496 |     | paragraph of section 11).
 497 |     | 
 498 |     |   However, if you cease all violation of this License, then your
 499 |     | license from a particular copyright holder is reinstated (a)
 500 |     | provisionally, unless and until the copyright holder explicitly and
 501 |     | finally terminates your license, and (b) permanently, if the copyright
 502 |     | holder fails to notify you of the violation by some reasonable means
 503 |     | prior to 60 days after the cessation.
 504 |     | 
 505 |     |   Moreover, your license from a particular copyright holder is
 506 |     | reinstated permanently if the copyright holder notifies you of the
 507 |     | violation by some reasonable means, this is the first time you have
 508 |     | received notice of violation of this License (for any work) from that
 509 |     | copyright holder, and you cure the violation prior to 30 days after
 510 |     | your receipt of the notice.
 511 |     | 
 512 |     |   Termination of your rights under this section does not terminate the
 513 |     | licenses of parties who have received copies or rights from you under
 514 |     | this License.  If your rights have been terminated and not permanently
 515 |     | reinstated, you do not qualify to receive new licenses for the same
 516 |     | material under section 10.
 517 |     | 
 518 |     |   9. Acceptance Not Required for Having Copies.
 519 |     | 
 520 |     |   You are not required to accept this License in order to receive or
 521 |     | run a copy of the Program.  Ancillary propagation of a covered work
 522 |     | occurring solely as a consequence of using peer-to-peer transmission
 523 |     | to receive a copy likewise does not require acceptance.  However,
 524 |     | nothing other than this License grants you permission to propagate or
 525 |     | modify any covered work.  These actions infringe copyright if you do
 526 |     | not accept this License.  Therefore, by modifying or propagating a
 527 |     | covered work, you indicate your acceptance of this License to do so.
 528 |     | 
 529 |     |   10. Automatic Licensing of Downstream Recipients.
 530 |     | 
 531 |     |   Each time you convey a covered work, the recipient automatically
 532 |     | receives a license from the original licensors, to run, modify and
 533 |     | propagate that work, subject to this License.  You are not responsible
 534 |     | for enforcing compliance by third parties with this License.
 535 |     | 
 536 |     |   An "entity transaction" is a transaction transferring control of an
 537 |     | organization, or substantially all assets of one, or subdividing an
 538 |     | organization, or merging organizations.  If propagation of a covered
 539 |     | work results from an entity transaction, each party to that
 540 |     | transaction who receives a copy of the work also receives whatever
 541 |     | licenses to the work the party's predecessor in interest had or could
 542 |     | give under the previous paragraph, plus a right to possession of the
 543 |     | Corresponding Source of the work from the predecessor in interest, if
 544 |     | the predecessor has it or can get it with reasonable efforts.
 545 |     | 
 546 |     |   You may not impose any further restrictions on the exercise of the
 547 |     | rights granted or affirmed under this License.  For example, you may
 548 |     | not impose a license fee, royalty, or other charge for exercise of
 549 |     | rights granted under this License, and you may not initiate litigation
 550 |     | (including a cross-claim or counterclaim in a lawsuit) alleging that
 551 |     | any patent claim is infringed by making, using, selling, offering for
 552 |     | sale, or importing the Program or any portion of it.
 553 |     | 
 554 |     |   11. Patents.
 555 |     | 
 556 |     |   A "contributor" is a copyright holder who authorizes use under this
 557 |     | License of the Program or a work on which the Program is based.  The
 558 |     | work thus licensed is called the contributor's "contributor version".
 559 |     | 
 560 |     |   A contributor's "essential patent claims" are all patent claims
 561 |     | owned or controlled by the contributor, whether already acquired or
 562 |     | hereafter acquired, that would be infringed by some manner, permitted
 563 |     | by this License, of making, using, or selling its contributor version,
 564 |     | but do not include claims that would be infringed only as a
 565 |     | consequence of further modification of the contributor version.  For
 566 |     | purposes of this definition, "control" includes the right to grant
 567 |     | patent sublicenses in a manner consistent with the requirements of
 568 |     | this License.
 569 |     | 
 570 |     |   Each contributor grants you a non-exclusive, worldwide, royalty-free
 571 |     | patent license under the contributor's essential patent claims, to
 572 |     | make, use, sell, offer for sale, import and otherwise run, modify and
 573 |     | propagate the contents of its contributor version.
 574 |     | 
 575 |     |   In the following three paragraphs, a "patent license" is any express
 576 |     | agreement or commitment, however denominated, not to enforce a patent
 577 |     | (such as an express permission to practice a patent or covenant not to
 578 |     | sue for patent infringement).  To "grant" such a patent license to a
 579 |     | party means to make such an agreement or commitment not to enforce a
 580 |     | patent against the party.
 581 |     | 
 582 |     |   If you convey a covered work, knowingly relying on a patent license,
 583 |     | and the Corresponding Source of the work is not available for anyone
 584 |     | to copy, free of charge and under the terms of this License, through a
 585 |     | publicly available network server or other readily accessible means,
 586 |     | then you must either (1) cause the Corresponding Source to be so
 587 |     | available, or (2) arrange to deprive yourself of the benefit of the
 588 |     | patent license for this particular work, or (3) arrange, in a manner
 589 |     | consistent with the requirements of this License, to extend the patent
 590 |     | license to downstream recipients.  "Knowingly relying" means you have
 591 |     | actual knowledge that, but for the patent license, your conveying the
 592 |     | covered work in a country, or your recipient's use of the covered work
 593 |     | in a country, would infringe one or more identifiable patents in that
 594 |     | country that you have reason to believe are valid.
 595 |     | 
 596 |     |   If, pursuant to or in connection with a single transaction or
 597 |     | arrangement, you convey, or propagate by procuring conveyance of, a
 598 |     | covered work, and grant a patent license to some of the parties
 599 |     | receiving the covered work authorizing them to use, propagate, modify
 600 |     | or convey a specific copy of the covered work, then the patent license
 601 |     | you grant is automatically extended to all recipients of the covered
 602 |     | work and works based on it.
 603 |     | 
 604 |     |   A patent license is "discriminatory" if it does not include within
 605 |     | the scope of its coverage, prohibits the exercise of, or is
 606 |     | conditioned on the non-exercise of one or more of the rights that are
 607 |     | specifically granted under this License.  You may not convey a covered
 608 |     | work if you are a party to an arrangement with a third party that is
 609 |     | in the business of distributing software, under which you make payment
 610 |     | to the third party based on the extent of your activity of conveying
 611 |     | the work, and under which the third party grants, to any of the
 612 |     | parties who would receive the covered work from you, a discriminatory
 613 |     | patent license (a) in connection with copies of the covered work
 614 |     | conveyed by you (or copies made from those copies), or (b) primarily
 615 |     | for and in connection with specific products or compilations that
 616 |     | contain the covered work, unless you entered into that arrangement,
 617 |     | or that patent license was granted, prior to 28 March 2007.
 618 |     | 
 619 |     |   Nothing in this License shall be construed as excluding or limiting
 620 |     | any implied license or other defenses to infringement that may
 621 |     | otherwise be available to you under applicable patent law.
 622 |     | 
 623 |     |   12. No Surrender of Others' Freedom.
 624 |     | 
 625 |     |   If conditions are imposed on you (whether by court order, agreement or
 626 |     | otherwise) that contradict the conditions of this License, they do not
 627 |     | excuse you from the conditions of this License.  If you cannot convey a
 628 |     | covered work so as to satisfy simultaneously your obligations under this
 629 |     | License and any other pertinent obligations, then as a consequence you may
 630 |     | not convey it at all.  For example, if you agree to terms that obligate you
 631 |     | to collect a royalty for further conveying from those to whom you convey
 632 |     | the Program, the only way you could satisfy both those terms and this
 633 |     | License would be to refrain entirely from conveying the Program.
 634 |     | 
 635 |     |   13. Use with the GNU Affero General Public License.
 636 |     | 
 637 |     |   Notwithstanding any other provision of this License, you have
 638 |     | permission to link or combine any covered work with a work licensed
 639 |     | under version 3 of the GNU Affero General Public License into a single
 640 |     | combined work, and to convey the resulting work.  The terms of this
 641 |     | License will continue to apply to the part which is the covered work,
 642 |     | but the special requirements of the GNU Affero General Public License,
 643 |     | section 13, concerning interaction through a network will apply to the
 644 |     | combination as such.
 645 |     | 
 646 |     |   14. Revised Versions of this License.
 647 |     | 
 648 |     |   The Free Software Foundation may publish revised and/or new versions of
 649 |     | the GNU General Public License from time to time.  Such new versions will
 650 |     | be similar in spirit to the present version, but may differ in detail to
 651 |     | address new problems or concerns.
 652 |     | 
 653 |     |   Each version is given a distinguishing version number.  If the
 654 |     | Program specifies that a certain numbered version of the GNU General
 655 |     | Public License "or any later version" applies to it, you have the
 656 |     | option of following the terms and conditions either of that numbered
 657 |     | version or of any later version published by the Free Software
 658 |     | Foundation.  If the Program does not specify a version number of the
 659 |     | GNU General Public License, you may choose any version ever published
 660 |     | by the Free Software Foundation.
 661 |     | 
 662 |     |   If the Program specifies that a proxy can decide which future
 663 |     | versions of the GNU General Public License can be used, that proxy's
 664 |     | public statement of acceptance of a version permanently authorizes you
 665 |     | to choose that version for the Program.
 666 |     | 
 667 |     |   Later license versions may give you additional or different
 668 |     | permissions.  However, no additional obligations are imposed on any
 669 |     | author or copyright holder as a result of your choosing to follow a
 670 |     | later version.
 671 |     | 
 672 |     |   15. Disclaimer of Warranty.
 673 |     | 
 674 |     |   THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
 675 |     | APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
 676 |     | HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
 677 |     | OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
 678 |     | THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 679 |     | PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
 680 |     | IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
 681 |     | ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
 682 |     | 
 683 |     |   16. Limitation of Liability.
 684 |     | 
 685 |     |   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 686 |     | WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
 687 |     | THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
 688 |     | GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
 689 |     | USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
 690 |     | DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
 691 |     | PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
 692 |     | EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
 693 |     | SUCH DAMAGES.
 694 |     | 
 695 |     |   17. Interpretation of Sections 15 and 16.
 696 |     | 
 697 |     |   If the disclaimer of warranty and limitation of liability provided
 698 |     | above cannot be given local legal effect according to their terms,
 699 |     | reviewing courts shall apply local law that most closely approximates
 700 |     | an absolute waiver of all civil liability in connection with the
 701 |     | Program, unless a warranty or assumption of liability accompanies a
 702 |     | copy of the Program in return for a fee.
 703 |     | 
 704 |     |                      END OF TERMS AND CONDITIONS
 705 |     | 
 706 |     |             How to Apply These Terms to Your New Programs
 707 |     | 
 708 |     |   If you develop a new program, and you want it to be of the greatest
 709 |     | possible use to the public, the best way to achieve this is to make it
 710 |     | free software which everyone can redistribute and change under these terms.
 711 |     | 
 712 |     |   To do so, attach the following notices to the program.  It is safest
 713 |     | to attach them to the start of each source file to most effectively
 714 |     | state the exclusion of warranty; and each file should have at least
 715 |     | the "copyright" line and a pointer to where the full notice is found.
 716 |     | 
 717 |     |     <one line to give the program's name and a brief idea of what it does.>
 718 |     |     Copyright (C) <year>  <name of author>
 719 |     | 
 720 |     |     This program is free software: you can redistribute it and/or modify
 721 |     |     it under the terms of the GNU General Public License as published by
 722 |     |     the Free Software Foundation, either version 3 of the License, or
 723 |     |     (at your option) any later version.
 724 |     | 
 725 |     |     This program is distributed in the hope that it will be useful,
 726 |     |     but WITHOUT ANY WARRANTY; without even the implied warranty of
 727 |     |     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 728 |     |     GNU General Public License for more details.
 729 |     | 
 730 |     |     You should have received a copy of the GNU General Public License
 731 |     |     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 732 |     | 
 733 |     | Also add information on how to contact you by electronic and paper mail.
 734 |     | 
 735 |     |   If the program does terminal interaction, make it output a short
 736 |     | notice like this when it starts in an interactive mode:
 737 |     | 
 738 |     |     <program>  Copyright (C) <year>  <name of author>
 739 |     |     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
 740 |     |     This is free software, and you are welcome to redistribute it
 741 |     |     under certain conditions; type `show c' for details.
 742 |     | 
 743 |     | The hypothetical commands `show w' and `show c' should show the appropriate
 744 |     | parts of the General Public License.  Of course, your program's commands
 745 |     | might be different; for a GUI interface, you would use an "about box".
 746 |     | 
 747 |     |   You should also get your employer (if you work as a programmer) or school,
 748 |     | if any, to sign a "copyright disclaimer" for the program, if necessary.
 749 |     | For more information on this, and how to apply and follow the GNU GPL, see
 750 |     | <http://www.gnu.org/licenses/>.
 751 |     | 
 752 |     |   The GNU General Public License does not permit incorporating your program
 753 |     | into proprietary programs.  If your program is a subroutine library, you
 754 |     | may consider it more useful to permit linking proprietary applications with
 755 |     | the library.  If this is what you want to do, use the GNU Lesser General
 756 |     | Public License instead of this License.  But first, please read
 757 |     | <http://www.gnu.org/philosophy/why-not-lgpl.html>.
 758 |     | 
 759 |     | */
 760 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/NoDelegateCall.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.8.12;
  3 |     | 
  4 |     | /// @title Prevents delegatecall to a contract
  5 |     | /// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract
  6 |     | /// @dev    Changed pragma to >=0.8.12
  7 |     | abstract contract NoDelegateCall {
  8 |     |     /// @dev The original address of this contract
  9 |     |     address private immutable original;
 10 |     | 
 11 |     |     constructor() {
 12 |     |         // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.
 13 |     |         // In other words, this variable won't change when it's checked at runtime.
 14 | *   |         original = address(this);
 15 |     |     }
 16 |     | 
 17 |     |     /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,
 18 |     |     ///     and the use of immutable means the address bytes are copied in every place the modifier is used.
 19 | *   |     function checkNotDelegateCall() private view {
 20 | *   |         require(address(this) == original);
 21 |     |     }
 22 |     | 
 23 |     |     /// @notice Prevents delegatecall into the modified method
 24 |     |     modifier noDelegateCall() {
 25 | *   |         checkNotDelegateCall();
 26 |     |         _;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/UniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.8.12;
  3 |     | 
  4 |     | import {IUniswapV3Factory} from
  5 |     |     "./interfaces/IUniswapV3Factory.sol";
  6 |     | 
  7 |     | import {UniswapV3PoolDeployer} from "./UniswapV3PoolDeployer.sol";
  8 |     | import {NoDelegateCall} from "./NoDelegateCall.sol";
  9 |     | import {UniswapV3Pool} from "./UniswapV3Pool.sol";
 10 |     | 
 11 |     | /// @title Canonical Uniswap V3 factory
 12 |     | /// @notice Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees
 13 |     | /// @dev    Changed pragma to >=0.8.12
 14 | *   | contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall {
 15 |     |     /// @inheritdoc IUniswapV3Factory
 16 |     |     address public override owner;
 17 |     | 
 18 |     |     /// @inheritdoc IUniswapV3Factory
 19 |     |     mapping(uint24 => int24) public override feeAmountTickSpacing;
 20 |     |     /// @inheritdoc IUniswapV3Factory
 21 | *   |     mapping(address => mapping(address => mapping(uint24 => address))) public override getPool;
 22 |     | 
 23 | *   |     constructor() {
 24 | *   |         owner = msg.sender;
 25 | *   |         emit OwnerChanged(address(0), msg.sender);
 26 |     | 
 27 | *   |         feeAmountTickSpacing[500] = 10;
 28 | *   |         emit FeeAmountEnabled(500, 10);
 29 | *   |         feeAmountTickSpacing[3000] = 60;
 30 | *   |         emit FeeAmountEnabled(3000, 60);
 31 | *   |         feeAmountTickSpacing[10_000] = 200;
 32 | *   |         emit FeeAmountEnabled(10_000, 200);
 33 |     |     }
 34 |     | 
 35 |     |     /// @inheritdoc IUniswapV3Factory
 36 | *   |     function createPool(
 37 |     |         address tokenA,
 38 |     |         address tokenB,
 39 |     |         uint24 fee
 40 | *   |     ) external override noDelegateCall returns (address pool) {
 41 | *   |         require(tokenA != tokenB);
 42 | *   |         (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
 43 | *   |         require(token0 != address(0));
 44 | *   |         int24 tickSpacing = feeAmountTickSpacing[fee];
 45 | *   |         require(tickSpacing != 0);
 46 | *   |         require(getPool[token0][token1][fee] == address(0));
 47 | *   |         pool = deploy(address(this), token0, token1, fee, tickSpacing);
 48 | *   |         getPool[token0][token1][fee] = pool;
 49 |     |         // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses
 50 | *   |         getPool[token1][token0][fee] = pool;
 51 | *   |         emit PoolCreated(token0, token1, fee, tickSpacing, pool);
 52 |     |     }
 53 |     | 
 54 |     |     /// @inheritdoc IUniswapV3Factory
 55 |     |     function setOwner(address _owner) external override {
 56 |     |         require(msg.sender == owner);
 57 |     |         emit OwnerChanged(owner, _owner);
 58 |     |         owner = _owner;
 59 |     |     }
 60 |     | 
 61 |     |     /// @inheritdoc IUniswapV3Factory
 62 | *   |     function enableFeeAmount(uint24 fee, int24 tickSpacing) public override {
 63 | *   |         require(msg.sender == owner);
 64 | *   |         require(fee < 1_000_000);
 65 |     |         // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that
 66 |     |         // TickBitmap#nextInitializedTickWithinOneWord overflows int24 container from a valid tick
 67 |     |         // 16384 ticks represents a >5x price change with ticks of 1 bips
 68 | *   |         require(tickSpacing > 0 && tickSpacing < 16_384);
 69 | *   |         require(feeAmountTickSpacing[fee] == 0);
 70 |     | 
 71 | *   |         feeAmountTickSpacing[fee] = tickSpacing;
 72 | *   |         emit FeeAmountEnabled(fee, tickSpacing);
 73 |     |     }
 74 |     | }
 75 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/UniswapV3Pool.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./interfaces/IUniswapV3Pool.sol";
   5 |     | 
   6 |     | import "./NoDelegateCall.sol";
   7 |     | 
   8 |     | import "./libraries/LowGasSafeMath.sol";
   9 |     | import "./libraries/SafeCast.sol";
  10 |     | import "./libraries/Tick.sol";
  11 |     | import "./libraries/TickBitmap.sol";
  12 |     | import "./libraries/Position.sol";
  13 |     | import "./libraries/Oracle.sol";
  14 |     | 
  15 |     | import "./libraries/FullMath.sol";
  16 |     | import "./libraries/FixedPoint128.sol";
  17 |     | import "./libraries/TransferHelper.sol";
  18 |     | import "./libraries/TickMath.sol";
  19 |     | import "./libraries/LiquidityMath.sol";
  20 |     | import "./libraries/SqrtPriceMath.sol";
  21 |     | import "./libraries/SwapMath.sol";
  22 |     | 
  23 |     | import "./interfaces/IUniswapV3PoolDeployer.sol";
  24 |     | import "./interfaces/IUniswapV3Factory.sol";
  25 |     | import "./interfaces/IERC20Minimal.sol";
  26 |     | import "./interfaces/callback/IUniswapV3MintCallback.sol";
  27 |     | import "./interfaces/callback/IUniswapV3SwapCallback.sol";
  28 |     | import "./interfaces/callback/IUniswapV3FlashCallback.sol";
  29 |     | 
  30 | *   | contract UniswapV3Pool is IUniswapV3Pool, NoDelegateCall {
  31 |     |     using LowGasSafeMath for uint256;
  32 |     |     using LowGasSafeMath for int256;
  33 |     |     using SafeCast for uint256;
  34 |     |     using SafeCast for int256;
  35 |     |     using Tick for mapping(int24 => Tick.Info);
  36 |     |     using TickBitmap for mapping(int16 => uint256);
  37 |     |     using Position for mapping(bytes32 => Position.Info);
  38 |     |     using Position for Position.Info;
  39 |     |     using Oracle for Oracle.Observation[65535];
  40 |     | 
  41 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  42 |     |     address public immutable override factory;
  43 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  44 | *   |     address public immutable override token0;
  45 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  46 | *   |     address public immutable override token1;
  47 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  48 |     |     uint24 public immutable override fee;
  49 |     | 
  50 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  51 | *   |     int24 public immutable override tickSpacing;
  52 |     | 
  53 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  54 |     |     uint128 public immutable override maxLiquidityPerTick;
  55 |     | 
  56 |     |     struct Slot0 {
  57 |     |         // the current price
  58 |     |         uint160 sqrtPriceX96;
  59 |     |         // the current tick
  60 |     |         int24 tick;
  61 |     |         // the most-recently updated index of the observations array
  62 |     |         uint16 observationIndex;
  63 |     |         // the current maximum number of observations that are being stored
  64 |     |         uint16 observationCardinality;
  65 |     |         // the next maximum number of observations to store, triggered in observations.write
  66 |     |         uint16 observationCardinalityNext;
  67 |     |         // the current protocol fee as a percentage of the swap fee taken on withdrawal
  68 |     |         // represented as an integer denominator (1/x)%
  69 |     |         uint8 feeProtocol;
  70 |     |         // whether the pool is locked
  71 |     |         bool unlocked;
  72 |     |     }
  73 |     |     /// @inheritdoc IUniswapV3PoolState
  74 | *   |     Slot0 public override slot0;
  75 |     | 
  76 |     |     /// @inheritdoc IUniswapV3PoolState
  77 |     |     uint256 public override feeGrowthGlobal0X128;
  78 |     |     /// @inheritdoc IUniswapV3PoolState
  79 |     |     uint256 public override feeGrowthGlobal1X128;
  80 |     | 
  81 |     |     // accumulated protocol fees in token0/token1 units
  82 |     |     struct ProtocolFees {
  83 |     |         uint128 token0;
  84 |     |         uint128 token1;
  85 |     |     }
  86 |     |     /// @inheritdoc IUniswapV3PoolState
  87 |     |     ProtocolFees public override protocolFees;
  88 |     | 
  89 |     |     /// @inheritdoc IUniswapV3PoolState
  90 | *   |     uint128 public override liquidity;
  91 |     | 
  92 |     |     /// @inheritdoc IUniswapV3PoolState
  93 |     |     mapping(int24 => Tick.Info) public override ticks;
  94 |     |     /// @inheritdoc IUniswapV3PoolState
  95 |     |     mapping(int16 => uint256) public override tickBitmap;
  96 |     |     /// @inheritdoc IUniswapV3PoolState
  97 | *   |     mapping(bytes32 => Position.Info) public override positions;
  98 |     |     /// @inheritdoc IUniswapV3PoolState
  99 |     |     Oracle.Observation[65535] public override observations;
 100 |     | 
 101 |     |     /// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance
 102 |     |     /// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because
 103 |     |     /// we use balance checks to determine the payment status of interactions such as mint, swap and flash.
 104 |     |     modifier lock() {
 105 | *   |         require(slot0.unlocked, "LOK");
 106 | *   |         slot0.unlocked = false;
 107 |     |         _;
 108 | *   |         slot0.unlocked = true;
 109 |     |     }
 110 |     | 
 111 |     |     /// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()
 112 |     |     modifier onlyFactoryOwner() {
 113 |     |         require(msg.sender == IUniswapV3Factory(factory).owner());
 114 |     |         _;
 115 |     |     }
 116 |     | 
 117 | *   |     constructor() {
 118 | *   |         int24 _tickSpacing;
 119 | *   |         (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();
 120 | *   |         tickSpacing = _tickSpacing;
 121 |     | 
 122 | *   |         maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);
 123 |     |     }
 124 |     | 
 125 |     |     /// @dev Common checks for valid tick inputs.
 126 | *   |     function checkTicks(int24 tickLower, int24 tickUpper) private pure {
 127 | *   |         require(tickLower < tickUpper, "TLU");
 128 | *   |         require(tickLower >= TickMath.MIN_TICK, "TLM");
 129 | *   |         require(tickUpper <= TickMath.MAX_TICK, "TUM");
 130 |     |     }
 131 |     | 
 132 |     |     /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.
 133 | *   |     function _blockTimestamp() internal view virtual returns (uint32) {
 134 | *   |         return uint32(block.timestamp); // truncation is desired
 135 |     |     }
 136 |     | 
 137 |     |     /// @dev Get the pool's balance of token0
 138 |     |     /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
 139 |     |     /// check
 140 | *   |     function balance0() private view returns (uint256) {
 141 | *   |         (bool success, bytes memory data) = token0.staticcall(
 142 | *   |             abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))
 143 |     |         );
 144 | *   |         require(success && data.length >= 32);
 145 | *   |         return abi.decode(data, (uint256));
 146 |     |     }
 147 |     | 
 148 |     |     /// @dev Get the pool's balance of token1
 149 |     |     /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
 150 |     |     /// check
 151 | *   |     function balance1() private view returns (uint256) {
 152 | *   |         (bool success, bytes memory data) = token1.staticcall(
 153 | *   |             abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))
 154 |     |         );
 155 | *   |         require(success && data.length >= 32);
 156 | *   |         return abi.decode(data, (uint256));
 157 |     |     }
 158 |     | 
 159 |     |     /// @inheritdoc IUniswapV3PoolDerivedState
 160 |     |     function snapshotCumulativesInside(
 161 |     |         int24 tickLower,
 162 |     |         int24 tickUpper
 163 |     |     )
 164 |     |         external
 165 |     |         view
 166 |     |         override
 167 |     |         noDelegateCall
 168 |     |         returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside)
 169 |     |     {
 170 |     |         checkTicks(tickLower, tickUpper);
 171 |     | 
 172 |     |         int56 tickCumulativeLower;
 173 |     |         int56 tickCumulativeUpper;
 174 |     |         uint160 secondsPerLiquidityOutsideLowerX128;
 175 |     |         uint160 secondsPerLiquidityOutsideUpperX128;
 176 |     |         uint32 secondsOutsideLower;
 177 |     |         uint32 secondsOutsideUpper;
 178 |     | 
 179 |     |         {
 180 |     |             Tick.Info storage lower = ticks[tickLower];
 181 |     |             Tick.Info storage upper = ticks[tickUpper];
 182 |     |             bool initializedLower;
 183 |     |             (tickCumulativeLower, secondsPerLiquidityOutsideLowerX128, secondsOutsideLower, initializedLower) = (
 184 |     |                 lower.tickCumulativeOutside,
 185 |     |                 lower.secondsPerLiquidityOutsideX128,
 186 |     |                 lower.secondsOutside,
 187 |     |                 lower.initialized
 188 |     |             );
 189 |     |             require(initializedLower);
 190 |     | 
 191 |     |             bool initializedUpper;
 192 |     |             (tickCumulativeUpper, secondsPerLiquidityOutsideUpperX128, secondsOutsideUpper, initializedUpper) = (
 193 |     |                 upper.tickCumulativeOutside,
 194 |     |                 upper.secondsPerLiquidityOutsideX128,
 195 |     |                 upper.secondsOutside,
 196 |     |                 upper.initialized
 197 |     |             );
 198 |     |             require(initializedUpper);
 199 |     |         }
 200 |     | 
 201 |     |         Slot0 memory _slot0 = slot0;
 202 |     | 
 203 |     |         if (_slot0.tick < tickLower) {
 204 |     |             return (
 205 |     |                 tickCumulativeLower - tickCumulativeUpper,
 206 |     |                 secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128,
 207 |     |                 secondsOutsideLower - secondsOutsideUpper
 208 |     |             );
 209 |     |         } else if (_slot0.tick < tickUpper) {
 210 |     |             uint32 time = _blockTimestamp();
 211 |     |             (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(
 212 |     |                 time,
 213 |     |                 0,
 214 |     |                 _slot0.tick,
 215 |     |                 _slot0.observationIndex,
 216 |     |                 liquidity,
 217 |     |                 _slot0.observationCardinality
 218 |     |             );
 219 |     |             return (
 220 |     |                 tickCumulative - tickCumulativeLower - tickCumulativeUpper,
 221 |     |                 secondsPerLiquidityCumulativeX128 -
 222 |     |                     secondsPerLiquidityOutsideLowerX128 -
 223 |     |                     secondsPerLiquidityOutsideUpperX128,
 224 |     |                 time - secondsOutsideLower - secondsOutsideUpper
 225 |     |             );
 226 |     |         } else {
 227 |     |             return (
 228 |     |                 tickCumulativeUpper - tickCumulativeLower,
 229 |     |                 secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128,
 230 |     |                 secondsOutsideUpper - secondsOutsideLower
 231 |     |             );
 232 |     |         }
 233 |     |     }
 234 |     | 
 235 |     |     /// @inheritdoc IUniswapV3PoolDerivedState
 236 |     |     function observe(
 237 |     |         uint32[] calldata secondsAgos
 238 |     |     )
 239 |     |         external
 240 |     |         view
 241 |     |         override
 242 |     |         noDelegateCall
 243 |     |         returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)
 244 |     |     {
 245 |     |         return
 246 |     |             observations.observe(
 247 |     |                 _blockTimestamp(),
 248 |     |                 secondsAgos,
 249 |     |                 slot0.tick,
 250 |     |                 slot0.observationIndex,
 251 |     |                 liquidity,
 252 |     |                 slot0.observationCardinality
 253 |     |             );
 254 |     |     }
 255 |     | 
 256 |     |     /// @inheritdoc IUniswapV3PoolActions
 257 |     |     function increaseObservationCardinalityNext(
 258 |     |         uint16 observationCardinalityNext
 259 |     |     ) external override lock noDelegateCall {
 260 |     |         uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event
 261 |     |         uint16 observationCardinalityNextNew = observations.grow(
 262 |     |             observationCardinalityNextOld,
 263 |     |             observationCardinalityNext
 264 |     |         );
 265 |     |         slot0.observationCardinalityNext = observationCardinalityNextNew;
 266 |     |         if (observationCardinalityNextOld != observationCardinalityNextNew)
 267 |     |             emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);
 268 |     |     }
 269 |     | 
 270 |     |     /// @inheritdoc IUniswapV3PoolActions
 271 |     |     /// @dev not locked because it initializes unlocked
 272 | *   |     function initialize(uint160 sqrtPriceX96) external override {
 273 | *   |         require(slot0.sqrtPriceX96 == 0, "AI");
 274 |     | 
 275 | *   |         int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);
 276 |     | 
 277 | *   |         (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());
 278 |     | 
 279 | *   |         slot0 = Slot0({
 280 | *   |             sqrtPriceX96: sqrtPriceX96,
 281 | *   |             tick: tick,
 282 | *   |             observationIndex: 0,
 283 | *   |             observationCardinality: cardinality,
 284 | *   |             observationCardinalityNext: cardinalityNext,
 285 | *   |             feeProtocol: 0,
 286 | *   |             unlocked: true
 287 |     |         });
 288 |     | 
 289 | *   |         emit Initialize(sqrtPriceX96, tick);
 290 |     |     }
 291 |     | 
 292 |     |     struct ModifyPositionParams {
 293 |     |         // the address that owns the position
 294 |     |         address owner;
 295 |     |         // the lower and upper tick of the position
 296 |     |         int24 tickLower;
 297 |     |         int24 tickUpper;
 298 |     |         // any change in liquidity
 299 |     |         int128 liquidityDelta;
 300 |     |     }
 301 |     | 
 302 |     |     event Message(string a);
 303 |     |     event MessageUint160(string a, uint160 b);
 304 |     |     event MessageUint128(string a, int128 b);
 305 |     | 
 306 |     |     /// @dev Effect some changes to a position
 307 |     |     /// @param params the position details and the change to the position's liquidity to effect
 308 |     |     /// @return position a storage pointer referencing the position with the given owner and tick range
 309 |     |     /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient
 310 |     |     /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient
 311 | *   |     function _modifyPosition(
 312 |     |         ModifyPositionParams memory params
 313 | *   |     ) private noDelegateCall returns (Position.Info storage position, int256 amount0, int256 amount1) {
 314 | *   |         checkTicks(params.tickLower, params.tickUpper);
 315 |     | 
 316 | *   |         Slot0 memory _slot0 = slot0; // SLOAD for gas optimization
 317 |     | 
 318 | *   |         emit Message("HERE");
 319 | *   |         position = _updatePosition(
 320 | *   |             params.owner,
 321 | *   |             params.tickLower,
 322 | *   |             params.tickUpper,
 323 | *   |             params.liquidityDelta,
 324 | *   |             _slot0.tick
 325 |     |         );
 326 | *   |         emit Message("HERE1");
 327 | *   |         if (params.liquidityDelta != 0) {
 328 | *   |             if (_slot0.tick < params.tickLower) {
 329 |     |                 // current tick is below the passed range; liquidity can only become in range by crossing from left to
 330 |     |                 // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
 331 |     |                 // emit Message("HERE2");
 332 |     |                 amount0 = SqrtPriceMath.getAmount0Delta(
 333 |     |                     TickMath.getSqrtRatioAtTick(params.tickLower),
 334 |     |                     TickMath.getSqrtRatioAtTick(params.tickUpper),
 335 |     |                     params.liquidityDelta
 336 |     |                 );
 337 |     |                 // emit Message("HERE3");
 338 | *   |             } else if (_slot0.tick < params.tickUpper) {
 339 |     |                 // emit Message("HERE4");
 340 |     |                 // current tick is inside the passed range
 341 | *   |                 uint128 liquidityBefore = liquidity; // SLOAD for gas optimization
 342 |     | 
 343 |     |                 // write an oracle entry
 344 | *   |                 (slot0.observationIndex, slot0.observationCardinality) = observations.write(
 345 | *   |                     _slot0.observationIndex,
 346 | *   |                     _blockTimestamp(),
 347 | *   |                     _slot0.tick,
 348 | *   |                     liquidityBefore,
 349 | *   |                     _slot0.observationCardinality,
 350 | *   |                     _slot0.observationCardinalityNext
 351 |     |                 );
 352 |     |                 // emit Message("HERE4a");
 353 | *   |                 emit MessageUint160("sqrtA", _slot0.sqrtPriceX96);
 354 | *   |                 emit MessageUint160("sqrtB", TickMath.getSqrtRatioAtTick(params.tickUpper));
 355 | *   |                 emit MessageUint128("liquidity", params.liquidityDelta);
 356 | *   |                 amount0 = SqrtPriceMath.getAmount0Delta(
 357 | *   |                     _slot0.sqrtPriceX96,
 358 | *   |                     TickMath.getSqrtRatioAtTick(params.tickUpper),
 359 | *   |                     params.liquidityDelta
 360 |     |                 );
 361 |     |                 // emit Message("HERE4b");
 362 | *   |                 amount1 = SqrtPriceMath.getAmount1Delta(
 363 | *   |                     TickMath.getSqrtRatioAtTick(params.tickLower),
 364 | *   |                     _slot0.sqrtPriceX96,
 365 | *   |                     params.liquidityDelta
 366 |     |                 );
 367 |     |                 // emit Message("HERE4c");
 368 |     | 
 369 | *   |                 liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);
 370 |     |                 // emit Message("HERE5");
 371 |     |             } else {
 372 |     |                 // current tick is above the passed range; liquidity can only become in range by crossing from right to
 373 |     |                 // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
 374 |     |                 // emit Message("HERE6");
 375 |     |                 amount1 = SqrtPriceMath.getAmount1Delta(
 376 |     |                     TickMath.getSqrtRatioAtTick(params.tickLower),
 377 |     |                     TickMath.getSqrtRatioAtTick(params.tickUpper),
 378 |     |                     params.liquidityDelta
 379 |     |                 );
 380 |     |                 // emit Message("HERE7");
 381 |     |             }
 382 |     |         }
 383 |     |         // emit Message("HERE8");
 384 |     |     }
 385 |     | 
 386 |     |     /// @dev Gets and updates a position with the given liquidity delta
 387 |     |     /// @param owner the owner of the position
 388 |     |     /// @param tickLower the lower tick of the position's tick range
 389 |     |     /// @param tickUpper the upper tick of the position's tick range
 390 |     |     /// @param tick the current tick, passed to avoid sloads
 391 | *   |     function _updatePosition(
 392 |     |         address owner,
 393 |     |         int24 tickLower,
 394 |     |         int24 tickUpper,
 395 |     |         int128 liquidityDelta,
 396 |     |         int24 tick
 397 | *   |     ) private returns (Position.Info storage position) {
 398 | *   |         position = positions.get(owner, tickLower, tickUpper);
 399 |     | 
 400 | *   |         uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization
 401 | *   |         uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization
 402 |     | 
 403 |     |         // if we need to update the ticks, do it
 404 | *   |         bool flippedLower;
 405 | *   |         bool flippedUpper;
 406 | *   |         if (liquidityDelta != 0) {
 407 | *   |             uint32 time = _blockTimestamp();
 408 | *   |             (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(
 409 | *   |                 time,
 410 | *   |                 0,
 411 | *   |                 slot0.tick,
 412 | *   |                 slot0.observationIndex,
 413 | *   |                 liquidity,
 414 | *   |                 slot0.observationCardinality
 415 |     |             );
 416 |     | 
 417 | *   |             flippedLower = ticks.update(
 418 | *   |                 tickLower,
 419 | *   |                 tick,
 420 | *   |                 liquidityDelta,
 421 | *   |                 _feeGrowthGlobal0X128,
 422 | *   |                 _feeGrowthGlobal1X128,
 423 | *   |                 secondsPerLiquidityCumulativeX128,
 424 | *   |                 tickCumulative,
 425 | *   |                 time,
 426 | *   |                 false,
 427 | *   |                 maxLiquidityPerTick
 428 |     |             );
 429 | *   |             flippedUpper = ticks.update(
 430 | *   |                 tickUpper,
 431 | *   |                 tick,
 432 | *   |                 liquidityDelta,
 433 | *   |                 _feeGrowthGlobal0X128,
 434 | *   |                 _feeGrowthGlobal1X128,
 435 | *   |                 secondsPerLiquidityCumulativeX128,
 436 | *   |                 tickCumulative,
 437 | *   |                 time,
 438 | *   |                 true,
 439 | *   |                 maxLiquidityPerTick
 440 |     |             );
 441 |     | 
 442 | *   |             if (flippedLower) {
 443 | *   |                 tickBitmap.flipTick(tickLower, tickSpacing);
 444 |     |             }
 445 | *   |             if (flippedUpper) {
 446 | *   |                 tickBitmap.flipTick(tickUpper, tickSpacing);
 447 |     |             }
 448 |     |         }
 449 |     | 
 450 | *   |         (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks.getFeeGrowthInside(
 451 | *   |             tickLower,
 452 | *   |             tickUpper,
 453 | *   |             tick,
 454 | *   |             _feeGrowthGlobal0X128,
 455 | *   |             _feeGrowthGlobal1X128
 456 |     |         );
 457 |     | 
 458 | *   |         position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);
 459 |     | 
 460 |     |         // clear any tick data that is no longer needed
 461 | *   |         if (liquidityDelta < 0) {
 462 |     |             if (flippedLower) {
 463 |     |                 ticks.clear(tickLower);
 464 |     |             }
 465 |     |             if (flippedUpper) {
 466 |     |                 ticks.clear(tickUpper);
 467 |     |             }
 468 |     |         }
 469 |     |     }
 470 |     | 
 471 |     |     /// @inheritdoc IUniswapV3PoolActions
 472 |     |     /// @dev noDelegateCall is applied indirectly via _modifyPosition
 473 | *   |     function mint(
 474 |     |         address recipient,
 475 |     |         int24 tickLower,
 476 |     |         int24 tickUpper,
 477 |     |         uint128 amount,
 478 |     |         bytes calldata data
 479 | *   |     ) external override lock returns (uint256 amount0, uint256 amount1) {
 480 | *   |         require(amount > 0);
 481 | *   |         (, int256 amount0Int, int256 amount1Int) = _modifyPosition(
 482 | *   |             ModifyPositionParams({
 483 | *   |                 owner: recipient,
 484 | *   |                 tickLower: tickLower,
 485 | *   |                 tickUpper: tickUpper,
 486 | *   |                 liquidityDelta: int256(int128(amount)).toInt128()
 487 |     |             })
 488 |     |         );
 489 |     | 
 490 | *   |         amount0 = uint256(amount0Int);
 491 | *   |         amount1 = uint256(amount1Int);
 492 |     | 
 493 | *   |         uint256 balance0Before;
 494 | *   |         uint256 balance1Before;
 495 | *   |         if (amount0 > 0) balance0Before = balance0();
 496 | *   |         if (amount1 > 0) balance1Before = balance1();
 497 | *   |         IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);
 498 | *   |         if (amount0 > 0) require(balance0Before.add(amount0) <= balance0(), "M0");
 499 | *   |         if (amount1 > 0) require(balance1Before.add(amount1) <= balance1(), "M1");
 500 |     | 
 501 | *   |         emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);
 502 |     |     }
 503 |     | 
 504 |     |     /// @inheritdoc IUniswapV3PoolActions
 505 |     |     function collect(
 506 |     |         address recipient,
 507 |     |         int24 tickLower,
 508 |     |         int24 tickUpper,
 509 |     |         uint128 amount0Requested,
 510 |     |         uint128 amount1Requested
 511 |     |     ) external override lock returns (uint128 amount0, uint128 amount1) {
 512 |     |         // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}
 513 |     |         Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);
 514 |     | 
 515 |     |         amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;
 516 |     |         amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;
 517 |     | 
 518 |     |         if (amount0 > 0) {
 519 |     |             position.tokensOwed0 -= amount0;
 520 |     |             TransferHelper.safeTransfer(token0, recipient, amount0);
 521 |     |         }
 522 |     |         if (amount1 > 0) {
 523 |     |             position.tokensOwed1 -= amount1;
 524 |     |             TransferHelper.safeTransfer(token1, recipient, amount1);
 525 |     |         }
 526 |     | 
 527 |     |         emit Collect(msg.sender, recipient, tickLower, tickUpper, amount0, amount1);
 528 |     |     }
 529 |     | 
 530 |     |     /// @inheritdoc IUniswapV3PoolActions
 531 |     |     /// @dev noDelegateCall is applied indirectly via _modifyPosition
 532 |     |     function burn(
 533 |     |         int24 tickLower,
 534 |     |         int24 tickUpper,
 535 |     |         uint128 amount
 536 |     |     ) external override lock returns (uint256 amount0, uint256 amount1) {
 537 |     |         (Position.Info storage position, int256 amount0Int, int256 amount1Int) = _modifyPosition(
 538 |     |             ModifyPositionParams({
 539 |     |                 owner: msg.sender,
 540 |     |                 tickLower: tickLower,
 541 |     |                 tickUpper: tickUpper,
 542 |     |                 liquidityDelta: -int256(int128(amount)).toInt128()
 543 |     |             })
 544 |     |         );
 545 |     | 
 546 |     |         amount0 = uint256(-amount0Int);
 547 |     |         amount1 = uint256(-amount1Int);
 548 |     | 
 549 |     |         if (amount0 > 0 || amount1 > 0) {
 550 |     |             (position.tokensOwed0, position.tokensOwed1) = (
 551 |     |                 position.tokensOwed0 + uint128(amount0),
 552 |     |                 position.tokensOwed1 + uint128(amount1)
 553 |     |             );
 554 |     |         }
 555 |     | 
 556 |     |         emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);
 557 |     |     }
 558 |     | 
 559 |     |     struct SwapCache {
 560 |     |         // the protocol fee for the input token
 561 |     |         uint8 feeProtocol;
 562 |     |         // liquidity at the beginning of the swap
 563 |     |         uint128 liquidityStart;
 564 |     |         // the timestamp of the current block
 565 |     |         uint32 blockTimestamp;
 566 |     |         // the current value of the tick accumulator, computed only if we cross an initialized tick
 567 |     |         int56 tickCumulative;
 568 |     |         // the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick
 569 |     |         uint160 secondsPerLiquidityCumulativeX128;
 570 |     |         // whether we've computed and cached the above two accumulators
 571 |     |         bool computedLatestObservation;
 572 |     |     }
 573 |     | 
 574 |     |     // the top level state of the swap, the results of which are recorded in storage at the end
 575 |     |     struct SwapState {
 576 |     |         // the amount remaining to be swapped in/out of the input/output asset
 577 |     |         int256 amountSpecifiedRemaining;
 578 |     |         // the amount already swapped out/in of the output/input asset
 579 |     |         int256 amountCalculated;
 580 |     |         // current sqrt(price)
 581 |     |         uint160 sqrtPriceX96;
 582 |     |         // the tick associated with the current price
 583 |     |         int24 tick;
 584 |     |         // the global fee growth of the input token
 585 |     |         uint256 feeGrowthGlobalX128;
 586 |     |         // amount of input token paid as protocol fee
 587 |     |         uint128 protocolFee;
 588 |     |         // the current liquidity in range
 589 |     |         uint128 liquidity;
 590 |     |     }
 591 |     | 
 592 |     |     struct StepComputations {
 593 |     |         // the price at the beginning of the step
 594 |     |         uint160 sqrtPriceStartX96;
 595 |     |         // the next tick to swap to from the current tick in the swap direction
 596 |     |         int24 tickNext;
 597 |     |         // whether tickNext is initialized or not
 598 |     |         bool initialized;
 599 |     |         // sqrt(price) for the next tick (1/0)
 600 |     |         uint160 sqrtPriceNextX96;
 601 |     |         // how much is being swapped in in this step
 602 |     |         uint256 amountIn;
 603 |     |         // how much is being swapped out
 604 |     |         uint256 amountOut;
 605 |     |         // how much fee is being paid in
 606 |     |         uint256 feeAmount;
 607 |     |     }
 608 |     | 
 609 |     |     /// @inheritdoc IUniswapV3PoolActions
 610 |     |     function swap(
 611 |     |         address recipient,
 612 |     |         bool zeroForOne,
 613 |     |         int256 amountSpecified,
 614 |     |         uint160 sqrtPriceLimitX96,
 615 |     |         bytes calldata data
 616 |     |     ) external override noDelegateCall returns (int256 amount0, int256 amount1) {
 617 |     |         emit Message("start swap");
 618 |     |         require(amountSpecified != 0, "AS");
 619 |     | 
 620 |     |         Slot0 memory slot0Start = slot0;
 621 |     | 
 622 |     |         require(slot0Start.unlocked, "LOK");
 623 |     |         require(
 624 |     |             zeroForOne
 625 |     |                 ? sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO
 626 |     |                 : sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,
 627 |     |             "SPL"
 628 |     |         );
 629 |     | 
 630 |     |         slot0.unlocked = false;
 631 |     | 
 632 |     |         SwapCache memory cache = SwapCache({
 633 |     |             liquidityStart: liquidity,
 634 |     |             blockTimestamp: _blockTimestamp(),
 635 |     |             feeProtocol: zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol >> 4),
 636 |     |             secondsPerLiquidityCumulativeX128: 0,
 637 |     |             tickCumulative: 0,
 638 |     |             computedLatestObservation: false
 639 |     |         });
 640 |     | 
 641 |     |         bool exactInput = amountSpecified > 0;
 642 |     | 
 643 |     |         SwapState memory state = SwapState({
 644 |     |             amountSpecifiedRemaining: amountSpecified,
 645 |     |             amountCalculated: 0,
 646 |     |             sqrtPriceX96: slot0Start.sqrtPriceX96,
 647 |     |             tick: slot0Start.tick,
 648 |     |             feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,
 649 |     |             protocolFee: 0,
 650 |     |             liquidity: cache.liquidityStart
 651 |     |         });
 652 |     | 
 653 |     |         // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit
 654 |     |         StepComputations memory step; //NOTE: changed by fuzzer, encountered memory leak in echidna
 655 |     |         while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {
 656 |     |             step.sqrtPriceStartX96 = state.sqrtPriceX96;
 657 |     | 
 658 |     |             (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(
 659 |     |                 state.tick,
 660 |     |                 tickSpacing,
 661 |     |                 zeroForOne
 662 |     |             );
 663 |     | 
 664 |     |             // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds
 665 |     |             if (step.tickNext < TickMath.MIN_TICK) {
 666 |     |                 step.tickNext = TickMath.MIN_TICK;
 667 |     |             } else if (step.tickNext > TickMath.MAX_TICK) {
 668 |     |                 step.tickNext = TickMath.MAX_TICK;
 669 |     |             }
 670 |     | 
 671 |     |             // get the price for the next tick
 672 |     |             step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);
 673 |     | 
 674 |     |             // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted
 675 |     |             (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(
 676 |     |                 state.sqrtPriceX96,
 677 |     |                 (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96)
 678 |     |                     ? sqrtPriceLimitX96
 679 |     |                     : step.sqrtPriceNextX96,
 680 |     |                 state.liquidity,
 681 |     |                 state.amountSpecifiedRemaining,
 682 |     |                 fee
 683 |     |             );
 684 |     | 
 685 |     |             if (exactInput) {
 686 |     |                 state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();
 687 |     |                 state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());
 688 |     |             } else {
 689 |     |                 state.amountSpecifiedRemaining += step.amountOut.toInt256();
 690 |     |                 state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());
 691 |     |             }
 692 |     | 
 693 |     |             // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee
 694 |     |             if (cache.feeProtocol > 0) {
 695 |     |                 uint256 delta = step.feeAmount / cache.feeProtocol;
 696 |     |                 step.feeAmount -= delta;
 697 |     |                 state.protocolFee += uint128(delta);
 698 |     |             }
 699 |     | 
 700 |     |             // update global fee tracker
 701 |     |             if (state.liquidity > 0)
 702 |     |                 state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);
 703 |     | 
 704 |     |             // shift tick if we reached the next price
 705 |     |             if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {
 706 |     |                 // if the tick is initialized, run the tick transition
 707 |     |                 if (step.initialized) {
 708 |     |                     // check for the placeholder value, which we replace with the actual value the first time the swap
 709 |     |                     // crosses an initialized tick
 710 |     |                     if (!cache.computedLatestObservation) {
 711 |     |                         (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observations.observeSingle(
 712 |     |                             cache.blockTimestamp,
 713 |     |                             0,
 714 |     |                             slot0Start.tick,
 715 |     |                             slot0Start.observationIndex,
 716 |     |                             cache.liquidityStart,
 717 |     |                             slot0Start.observationCardinality
 718 |     |                         );
 719 |     |                         cache.computedLatestObservation = true;
 720 |     |                     }
 721 |     |                     int128 liquidityNet = ticks.cross(
 722 |     |                         step.tickNext,
 723 |     |                         (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),
 724 |     |                         (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128),
 725 |     |                         cache.secondsPerLiquidityCumulativeX128,
 726 |     |                         cache.tickCumulative,
 727 |     |                         cache.blockTimestamp
 728 |     |                     );
 729 |     |                     // if we're moving leftward, we interpret liquidityNet as the opposite sign
 730 |     |                     // safe because liquidityNet cannot be type(int128).min
 731 |     |                     if (zeroForOne) liquidityNet = -liquidityNet;
 732 |     | 
 733 |     |                     state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
 734 |     |                 }
 735 |     | 
 736 |     |                 state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
 737 |     |             } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {
 738 |     |                 // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
 739 |     |                 state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
 740 |     |             }
 741 |     |         }
 742 |     | 
 743 |     |         // update tick and write an oracle entry if the tick change
 744 |     |         if (state.tick != slot0Start.tick) {
 745 |     |             (uint16 observationIndex, uint16 observationCardinality) = observations.write(
 746 |     |                 slot0Start.observationIndex,
 747 |     |                 cache.blockTimestamp,
 748 |     |                 slot0Start.tick,
 749 |     |                 cache.liquidityStart,
 750 |     |                 slot0Start.observationCardinality,
 751 |     |                 slot0Start.observationCardinalityNext
 752 |     |             );
 753 |     |             (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) = (
 754 |     |                 state.sqrtPriceX96,
 755 |     |                 state.tick,
 756 |     |                 observationIndex,
 757 |     |                 observationCardinality
 758 |     |             );
 759 |     |         } else {
 760 |     |             // otherwise just update the price
 761 |     |             slot0.sqrtPriceX96 = state.sqrtPriceX96;
 762 |     |         }
 763 |     | 
 764 |     |         // update liquidity if it changed
 765 |     |         if (cache.liquidityStart != state.liquidity) liquidity = state.liquidity;
 766 |     | 
 767 |     |         // update fee growth global and, if necessary, protocol fees
 768 |     |         // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees
 769 |     |         if (zeroForOne) {
 770 |     |             feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;
 771 |     |             if (state.protocolFee > 0) protocolFees.token0 += state.protocolFee;
 772 |     |         } else {
 773 |     |             feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;
 774 |     |             if (state.protocolFee > 0) protocolFees.token1 += state.protocolFee;
 775 |     |         }
 776 |     | 
 777 |     |         (amount0, amount1) = zeroForOne == exactInput
 778 |     |             ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)
 779 |     |             : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);
 780 |     | 
 781 |     |         // do the transfers and collect payment
 782 |     |         if (zeroForOne) {
 783 |     |             if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));
 784 |     | 
 785 |     |             uint256 balance0Before = balance0();
 786 |     |             IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);
 787 |     |             require(balance0Before.add(uint256(amount0)) <= balance0(), "IIA");
 788 |     |         } else {
 789 |     |             if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));
 790 |     | 
 791 |     |             uint256 balance1Before = balance1();
 792 |     |             IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);
 793 |     |             require(balance1Before.add(uint256(amount1)) <= balance1(), "IIA");
 794 |     |         }
 795 |     | 
 796 |     |         emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);
 797 |     |         slot0.unlocked = true;
 798 |     |     }
 799 |     | 
 800 |     |     /// @inheritdoc IUniswapV3PoolActions
 801 |     |     function flash(
 802 |     |         address recipient,
 803 |     |         uint256 amount0,
 804 |     |         uint256 amount1,
 805 |     |         bytes calldata data
 806 |     |     ) external override lock noDelegateCall {
 807 |     |         uint128 _liquidity = liquidity;
 808 |     |         require(_liquidity > 0, "L");
 809 |     | 
 810 |     |         uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);
 811 |     |         uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);
 812 |     |         uint256 balance0Before = balance0();
 813 |     |         uint256 balance1Before = balance1();
 814 |     | 
 815 |     |         if (amount0 > 0) TransferHelper.safeTransfer(token0, recipient, amount0);
 816 |     |         if (amount1 > 0) TransferHelper.safeTransfer(token1, recipient, amount1);
 817 |     | 
 818 |     |         IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);
 819 |     | 
 820 |     |         uint256 balance0After = balance0();
 821 |     |         uint256 balance1After = balance1();
 822 |     | 
 823 |     |         require(balance0Before.add(fee0) <= balance0After, "F0");
 824 |     |         require(balance1Before.add(fee1) <= balance1After, "F1");
 825 |     | 
 826 |     |         // sub is safe because we know balanceAfter is gt balanceBefore by at least fee
 827 |     |         uint256 paid0 = balance0After - balance0Before;
 828 |     |         uint256 paid1 = balance1After - balance1Before;
 829 |     | 
 830 |     |         if (paid0 > 0) {
 831 |     |             uint8 feeProtocol0 = slot0.feeProtocol % 16;
 832 |     |             uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;
 833 |     |             if (uint128(fees0) > 0) protocolFees.token0 += uint128(fees0);
 834 |     |             feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - fees0, FixedPoint128.Q128, _liquidity);
 835 |     |         }
 836 |     |         if (paid1 > 0) {
 837 |     |             uint8 feeProtocol1 = slot0.feeProtocol >> 4;
 838 |     |             uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;
 839 |     |             if (uint128(fees1) > 0) protocolFees.token1 += uint128(fees1);
 840 |     |             feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - fees1, FixedPoint128.Q128, _liquidity);
 841 |     |         }
 842 |     | 
 843 |     |         emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);
 844 |     |     }
 845 |     | 
 846 |     |     /// @inheritdoc IUniswapV3PoolOwnerActions
 847 |     |     function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external override lock onlyFactoryOwner {
 848 |     |         require(
 849 |     |             (feeProtocol0 == 0 || (feeProtocol0 >= 4 && feeProtocol0 <= 10)) &&
 850 |     |                 (feeProtocol1 == 0 || (feeProtocol1 >= 4 && feeProtocol1 <= 10))
 851 |     |         );
 852 |     |         uint8 feeProtocolOld = slot0.feeProtocol;
 853 |     |         slot0.feeProtocol = feeProtocol0 + (feeProtocol1 << 4);
 854 |     |         emit SetFeeProtocol(feeProtocolOld % 16, feeProtocolOld >> 4, feeProtocol0, feeProtocol1);
 855 |     |     }
 856 |     | 
 857 |     |     /// @inheritdoc IUniswapV3PoolOwnerActions
 858 |     |     function collectProtocol(
 859 |     |         address recipient,
 860 |     |         uint128 amount0Requested,
 861 |     |         uint128 amount1Requested
 862 |     |     ) external override lock onlyFactoryOwner returns (uint128 amount0, uint128 amount1) {
 863 |     |         amount0 = amount0Requested > protocolFees.token0 ? protocolFees.token0 : amount0Requested;
 864 |     |         amount1 = amount1Requested > protocolFees.token1 ? protocolFees.token1 : amount1Requested;
 865 |     | 
 866 |     |         if (amount0 > 0) {
 867 |     |             if (amount0 == protocolFees.token0) amount0--; // ensure that the slot is not cleared, for gas savings
 868 |     |             protocolFees.token0 -= amount0;
 869 |     |             TransferHelper.safeTransfer(token0, recipient, amount0);
 870 |     |         }
 871 |     |         if (amount1 > 0) {
 872 |     |             if (amount1 == protocolFees.token1) amount1--; // ensure that the slot is not cleared, for gas savings
 873 |     |             protocolFees.token1 -= amount1;
 874 |     |             TransferHelper.safeTransfer(token1, recipient, amount1);
 875 |     |         }
 876 |     | 
 877 |     |         emit CollectProtocol(msg.sender, recipient, amount0, amount1);
 878 |     |     }
 879 |     | }
 880 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/UniswapV3PoolDeployer.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.8.12;
  3 |     | 
  4 |     | import { IUniswapV3PoolDeployer } from "./interfaces/IUniswapV3PoolDeployer.sol";
  5 |     | 
  6 |     | import { UniswapV3Pool } from "./UniswapV3Pool.sol";
  7 |     | 
  8 |     | /// @dev    Changed pragma to >=0.8.12
  9 |     | contract UniswapV3PoolDeployer is IUniswapV3PoolDeployer {
 10 |     |     struct Parameters {
 11 |     |         address factory;
 12 |     |         address token0;
 13 |     |         address token1;
 14 |     |         uint24 fee;
 15 |     |         int24 tickSpacing;
 16 |     |     }
 17 |     | 
 18 |     |     /// @inheritdoc IUniswapV3PoolDeployer
 19 | *   |     Parameters public override parameters;
 20 |     | 
 21 |     |     /// @dev Deploys a pool with the given parameters by transiently setting the parameters storage slot and then
 22 |     |     /// clearing it after deploying the pool.
 23 |     |     /// @param factory The contract address of the Uniswap V3 factory
 24 |     |     /// @param token0 The first token of the pool by address sort order
 25 |     |     /// @param token1 The second token of the pool by address sort order
 26 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 27 |     |     /// @param tickSpacing The spacing between usable ticks
 28 | *   |     function deploy(
 29 |     |         address factory,
 30 |     |         address token0,
 31 |     |         address token1,
 32 |     |         uint24 fee,
 33 |     |         int24 tickSpacing
 34 | *   |     ) internal returns (address pool) {
 35 | *   |         parameters = Parameters({
 36 | *   |             factory: factory,
 37 | *   |             token0: token0,
 38 | *   |             token1: token1,
 39 | *   |             fee: fee,
 40 | *   |             tickSpacing: tickSpacing
 41 |     |         });
 42 | *   |         pool = address(new UniswapV3Pool{ salt: keccak256(abi.encode(token0, token1, fee)) }());
 43 | *   |         delete parameters;
 44 |     |     }
 45 |     | }
 46 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/IERC20Minimal.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Minimal ERC20 interface for Uniswap
  5 |     | /// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3
  6 |     | interface IERC20Minimal {
  7 |     |     /// @notice Returns the balance of a token
  8 |     |     /// @param account The account for which to look up the number of tokens it has, i.e. its balance
  9 |     |     /// @return The number of tokens held by the account
 10 |     |     function balanceOf(address account) external view returns (uint256);
 11 |     | 
 12 |     |     /// @notice Transfers the amount of token from the `msg.sender` to the recipient
 13 |     |     /// @param recipient The account that will receive the amount transferred
 14 |     |     /// @param amount The number of tokens to send from the sender to the recipient
 15 |     |     /// @return Returns true for a successful transfer, false for an unsuccessful transfer
 16 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 17 |     | 
 18 |     |     /// @notice Returns the current allowance given to a spender by an owner
 19 |     |     /// @param owner The account of the token owner
 20 |     |     /// @param spender The account of the token spender
 21 |     |     /// @return The current allowance granted by `owner` to `spender`
 22 |     |     function allowance(address owner, address spender) external view returns (uint256);
 23 |     | 
 24 |     |     /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`
 25 |     |     /// @param spender The account which will be allowed to spend a given amount of the owners tokens
 26 |     |     /// @param amount The amount of tokens allowed to be used by `spender`
 27 |     |     /// @return Returns true for a successful approval, false for unsuccessful
 28 |     |     function approve(address spender, uint256 amount) external returns (bool);
 29 |     | 
 30 |     |     /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`
 31 |     |     /// @param sender The account from which the transfer will be initiated
 32 |     |     /// @param recipient The recipient of the transfer
 33 |     |     /// @param amount The amount of the transfer
 34 |     |     /// @return Returns true for a successful transfer, false for unsuccessful
 35 |     |     function transferFrom(
 36 |     |         address sender,
 37 |     |         address recipient,
 38 |     |         uint256 amount
 39 |     |     ) external returns (bool);
 40 |     | 
 41 |     |     /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.
 42 |     |     /// @param from The account from which the tokens were sent, i.e. the balance decreased
 43 |     |     /// @param to The account to which the tokens were sent, i.e. the balance increased
 44 |     |     /// @param value The amount of tokens that were transferred
 45 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 46 |     | 
 47 |     |     /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.
 48 |     |     /// @param owner The account that approved spending of its tokens
 49 |     |     /// @param spender The account for which the spending allowance was modified
 50 |     |     /// @param value The new allowance from the owner to the spender
 51 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 52 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/IUniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title The interface for the Uniswap V3 Factory
  5 |     | /// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
  6 |     | interface IUniswapV3Factory {
  7 |     |     /// @notice Emitted when the owner of the factory is changed
  8 |     |     /// @param oldOwner The owner before the owner was changed
  9 |     |     /// @param newOwner The owner after the owner was changed
 10 |     |     event OwnerChanged(address indexed oldOwner, address indexed newOwner);
 11 |     | 
 12 |     |     /// @notice Emitted when a pool is created
 13 |     |     /// @param token0 The first token of the pool by address sort order
 14 |     |     /// @param token1 The second token of the pool by address sort order
 15 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 16 |     |     /// @param tickSpacing The minimum number of ticks between initialized ticks
 17 |     |     /// @param pool The address of the created pool
 18 |     |     event PoolCreated(
 19 |     |         address indexed token0,
 20 |     |         address indexed token1,
 21 |     |         uint24 indexed fee,
 22 |     |         int24 tickSpacing,
 23 |     |         address pool
 24 |     |     );
 25 |     | 
 26 |     |     /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
 27 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip
 28 |     |     /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
 29 |     |     event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
 30 |     | 
 31 |     |     /// @notice Returns the current owner of the factory
 32 |     |     /// @dev Can be changed by the current owner via setOwner
 33 |     |     /// @return The address of the factory owner
 34 |     |     function owner() external view returns (address);
 35 |     | 
 36 |     |     /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
 37 |     |     /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
 38 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
 39 |     |     /// @return The tick spacing
 40 |     |     function feeAmountTickSpacing(uint24 fee) external view returns (int24);
 41 |     | 
 42 |     |     /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
 43 |     |     /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
 44 |     |     /// @param tokenA The contract address of either token0 or token1
 45 |     |     /// @param tokenB The contract address of the other token
 46 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 47 |     |     /// @return pool The pool address
 48 |     |     function getPool(
 49 |     |         address tokenA,
 50 |     |         address tokenB,
 51 |     |         uint24 fee
 52 |     |     ) external view returns (address pool);
 53 |     | 
 54 |     |     /// @notice Creates a pool for the given two tokens and fee
 55 |     |     /// @param tokenA One of the two tokens in the desired pool
 56 |     |     /// @param tokenB The other of the two tokens in the desired pool
 57 |     |     /// @param fee The desired fee for the pool
 58 |     |     /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
 59 |     |     /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
 60 |     |     /// are invalid.
 61 |     |     /// @return pool The address of the newly created pool
 62 |     |     function createPool(
 63 |     |         address tokenA,
 64 |     |         address tokenB,
 65 |     |         uint24 fee
 66 |     |     ) external returns (address pool);
 67 |     | 
 68 |     |     /// @notice Updates the owner of the factory
 69 |     |     /// @dev Must be called by the current owner
 70 |     |     /// @param _owner The new owner of the factory
 71 |     |     function setOwner(address _owner) external;
 72 |     | 
 73 |     |     /// @notice Enables a fee amount with the given tickSpacing
 74 |     |     /// @dev Fee amounts may never be removed once enabled
 75 |     |     /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
 76 |     |     /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
 77 |     |     function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
 78 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/IUniswapV3Pool.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import './pool/IUniswapV3PoolImmutables.sol';
  5 |     | import './pool/IUniswapV3PoolState.sol';
  6 |     | import './pool/IUniswapV3PoolDerivedState.sol';
  7 |     | import './pool/IUniswapV3PoolActions.sol';
  8 |     | import './pool/IUniswapV3PoolOwnerActions.sol';
  9 |     | import './pool/IUniswapV3PoolEvents.sol';
 10 |     | 
 11 |     | /// @title The interface for a Uniswap V3 Pool
 12 |     | /// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
 13 |     | /// to the ERC20 specification
 14 |     | /// @dev The pool interface is broken up into many smaller pieces
 15 |     | interface IUniswapV3Pool is
 16 |     |     IUniswapV3PoolImmutables,
 17 |     |     IUniswapV3PoolState,
 18 |     |     IUniswapV3PoolDerivedState,
 19 |     |     IUniswapV3PoolActions,
 20 |     |     IUniswapV3PoolOwnerActions,
 21 |     |     IUniswapV3PoolEvents
 22 |     | {
 23 |     | 
 24 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/IUniswapV3PoolDeployer.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title An interface for a contract that is capable of deploying Uniswap V3 Pools
  5 |     | /// @notice A contract that constructs a pool must implement this to pass arguments to the pool
  6 |     | /// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash
  7 |     | /// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain
  8 |     | interface IUniswapV3PoolDeployer {
  9 |     |     /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.
 10 |     |     /// @dev Called by the pool constructor to fetch the parameters of the pool
 11 |     |     /// Returns factory The factory address
 12 |     |     /// Returns token0 The first token of the pool by address sort order
 13 |     |     /// Returns token1 The second token of the pool by address sort order
 14 |     |     /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 15 |     |     /// Returns tickSpacing The minimum number of ticks between initialized ticks
 16 |     |     function parameters()
 17 |     |         external
 18 |     |         view
 19 |     |         returns (
 20 |     |             address factory,
 21 |     |             address token0,
 22 |     |             address token1,
 23 |     |             uint24 fee,
 24 |     |             int24 tickSpacing
 25 |     |         );
 26 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/callback/IUniswapV3FlashCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#flash
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface
  6 |     | interface IUniswapV3FlashCallback {
  7 |     |     /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.
  8 |     |     /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// @param fee0 The fee amount in token0 due to the pool by the end of the flash
 11 |     |     /// @param fee1 The fee amount in token1 due to the pool by the end of the flash
 12 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call
 13 |     |     function uniswapV3FlashCallback(
 14 |     |         uint256 fee0,
 15 |     |         uint256 fee1,
 16 |     |         bytes calldata data
 17 |     |     ) external;
 18 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/callback/IUniswapV3MintCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#mint
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface
  6 |     | interface IUniswapV3MintCallback {
  7 |     |     /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity
 11 |     |     /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity
 12 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call
 13 |     |     function uniswapV3MintCallback(
 14 |     |         uint256 amount0Owed,
 15 |     |         uint256 amount1Owed,
 16 |     |         bytes calldata data
 17 |     |     ) external;
 18 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/callback/IUniswapV3SwapCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#swap
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface
  6 |     | interface IUniswapV3SwapCallback {
  7 |     |     /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the swap.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
 11 |     |     /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by
 12 |     |     /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.
 13 |     |     /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by
 14 |     |     /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.
 15 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call
 16 |     |     function uniswapV3SwapCallback(
 17 |     |         int256 amount0Delta,
 18 |     |         int256 amount1Delta,
 19 |     |         bytes calldata data
 20 |     |     ) external;
 21 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/pool/IUniswapV3PoolActions.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @title Permissionless pool actions
   5 |     | /// @notice Contains pool methods that can be called by anyone
   6 |     | interface IUniswapV3PoolActions {
   7 |     |     /// @notice Sets the initial price for the pool
   8 |     |     /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value
   9 |     |     /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96
  10 |     |     function initialize(uint160 sqrtPriceX96) external;
  11 |     | 
  12 |     |     /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
  13 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
  14 |     |     /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
  15 |     |     /// on tickLower, tickUpper, the amount of liquidity, and the current price.
  16 |     |     /// @param recipient The address for which the liquidity will be created
  17 |     |     /// @param tickLower The lower tick of the position in which to add liquidity
  18 |     |     /// @param tickUpper The upper tick of the position in which to add liquidity
  19 |     |     /// @param amount The amount of liquidity to mint
  20 |     |     /// @param data Any data that should be passed through to the callback
  21 |     |     /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
  22 |     |     /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
  23 |     |     function mint(
  24 |     |         address recipient,
  25 |     |         int24 tickLower,
  26 |     |         int24 tickUpper,
  27 |     |         uint128 amount,
  28 |     |         bytes calldata data
  29 |     |     ) external returns (uint256 amount0, uint256 amount1);
  30 |     | 
  31 |     |     /// @notice Collects tokens owed to a position
  32 |     |     /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
  33 |     |     /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
  34 |     |     /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
  35 |     |     /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
  36 |     |     /// @param recipient The address which should receive the fees collected
  37 |     |     /// @param tickLower The lower tick of the position for which to collect fees
  38 |     |     /// @param tickUpper The upper tick of the position for which to collect fees
  39 |     |     /// @param amount0Requested How much token0 should be withdrawn from the fees owed
  40 |     |     /// @param amount1Requested How much token1 should be withdrawn from the fees owed
  41 |     |     /// @return amount0 The amount of fees collected in token0
  42 |     |     /// @return amount1 The amount of fees collected in token1
  43 |     |     function collect(
  44 |     |         address recipient,
  45 |     |         int24 tickLower,
  46 |     |         int24 tickUpper,
  47 |     |         uint128 amount0Requested,
  48 |     |         uint128 amount1Requested
  49 |     |     ) external returns (uint128 amount0, uint128 amount1);
  50 |     | 
  51 |     |     /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
  52 |     |     /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
  53 |     |     /// @dev Fees must be collected separately via a call to #collect
  54 |     |     /// @param tickLower The lower tick of the position for which to burn liquidity
  55 |     |     /// @param tickUpper The upper tick of the position for which to burn liquidity
  56 |     |     /// @param amount How much liquidity to burn
  57 |     |     /// @return amount0 The amount of token0 sent to the recipient
  58 |     |     /// @return amount1 The amount of token1 sent to the recipient
  59 |     |     function burn(
  60 |     |         int24 tickLower,
  61 |     |         int24 tickUpper,
  62 |     |         uint128 amount
  63 |     |     ) external returns (uint256 amount0, uint256 amount1);
  64 |     | 
  65 |     |     /// @notice Swap token0 for token1, or token1 for token0
  66 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
  67 |     |     /// @param recipient The address to receive the output of the swap
  68 |     |     /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
  69 |     |     /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
  70 |     |     /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
  71 |     |     /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
  72 |     |     /// @param data Any data to be passed through to the callback
  73 |     |     /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
  74 |     |     /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
  75 |     |     function swap(
  76 |     |         address recipient,
  77 |     |         bool zeroForOne,
  78 |     |         int256 amountSpecified,
  79 |     |         uint160 sqrtPriceLimitX96,
  80 |     |         bytes calldata data
  81 |     |     ) external returns (int256 amount0, int256 amount1);
  82 |     | 
  83 |     |     /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback
  84 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
  85 |     |     /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
  86 |     |     /// with 0 amount{0,1} and sending the donation amount(s) from the callback
  87 |     |     /// @param recipient The address which will receive the token0 and token1 amounts
  88 |     |     /// @param amount0 The amount of token0 to send
  89 |     |     /// @param amount1 The amount of token1 to send
  90 |     |     /// @param data Any data to be passed through to the callback
  91 |     |     function flash(
  92 |     |         address recipient,
  93 |     |         uint256 amount0,
  94 |     |         uint256 amount1,
  95 |     |         bytes calldata data
  96 |     |     ) external;
  97 |     | 
  98 |     |     /// @notice Increase the maximum number of price and liquidity observations that this pool will store
  99 |     |     /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
 100 |     |     /// the input observationCardinalityNext.
 101 |     |     /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
 102 |     |     function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
 103 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/pool/IUniswapV3PoolDerivedState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Pool state that is not stored
  5 |     | /// @notice Contains view functions to provide information about the pool that is computed rather than stored on the
  6 |     | /// blockchain. The functions here may have variable gas costs.
  7 |     | interface IUniswapV3PoolDerivedState {
  8 |     |     /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
  9 |     |     /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
 10 |     |     /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
 11 |     |     /// you must call it with secondsAgos = [3600, 0].
 12 |     |     /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
 13 |     |     /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
 14 |     |     /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
 15 |     |     /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
 16 |     |     /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
 17 |     |     /// timestamp
 18 |     |     function observe(uint32[] calldata secondsAgos)
 19 |     |         external
 20 |     |         view
 21 |     |         returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
 22 |     | 
 23 |     |     /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range
 24 |     |     /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.
 25 |     |     /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first
 26 |     |     /// snapshot is taken and the second snapshot is taken.
 27 |     |     /// @param tickLower The lower tick of the range
 28 |     |     /// @param tickUpper The upper tick of the range
 29 |     |     /// @return tickCumulativeInside The snapshot of the tick accumulator for the range
 30 |     |     /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range
 31 |     |     /// @return secondsInside The snapshot of seconds per liquidity for the range
 32 |     |     function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
 33 |     |         external
 34 |     |         view
 35 |     |         returns (
 36 |     |             int56 tickCumulativeInside,
 37 |     |             uint160 secondsPerLiquidityInsideX128,
 38 |     |             uint32 secondsInside
 39 |     |         );
 40 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/pool/IUniswapV3PoolEvents.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @title Events emitted by a pool
   5 |     | /// @notice Contains all events emitted by the pool
   6 |     | interface IUniswapV3PoolEvents {
   7 |     |     /// @notice Emitted exactly once by a pool when #initialize is first called on the pool
   8 |     |     /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize
   9 |     |     /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96
  10 |     |     /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool
  11 |     |     event Initialize(uint160 sqrtPriceX96, int24 tick);
  12 |     | 
  13 |     |     /// @notice Emitted when liquidity is minted for a given position
  14 |     |     /// @param sender The address that minted the liquidity
  15 |     |     /// @param owner The owner of the position and recipient of any minted liquidity
  16 |     |     /// @param tickLower The lower tick of the position
  17 |     |     /// @param tickUpper The upper tick of the position
  18 |     |     /// @param amount The amount of liquidity minted to the position range
  19 |     |     /// @param amount0 How much token0 was required for the minted liquidity
  20 |     |     /// @param amount1 How much token1 was required for the minted liquidity
  21 |     |     event Mint(
  22 |     |         address sender,
  23 |     |         address indexed owner,
  24 |     |         int24 indexed tickLower,
  25 |     |         int24 indexed tickUpper,
  26 |     |         uint128 amount,
  27 |     |         uint256 amount0,
  28 |     |         uint256 amount1
  29 |     |     );
  30 |     | 
  31 |     |     /// @notice Emitted when fees are collected by the owner of a position
  32 |     |     /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees
  33 |     |     /// @param owner The owner of the position for which fees are collected
  34 |     |     /// @param tickLower The lower tick of the position
  35 |     |     /// @param tickUpper The upper tick of the position
  36 |     |     /// @param amount0 The amount of token0 fees collected
  37 |     |     /// @param amount1 The amount of token1 fees collected
  38 |     |     event Collect(
  39 |     |         address indexed owner,
  40 |     |         address recipient,
  41 |     |         int24 indexed tickLower,
  42 |     |         int24 indexed tickUpper,
  43 |     |         uint128 amount0,
  44 |     |         uint128 amount1
  45 |     |     );
  46 |     | 
  47 |     |     /// @notice Emitted when a position's liquidity is removed
  48 |     |     /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect
  49 |     |     /// @param owner The owner of the position for which liquidity is removed
  50 |     |     /// @param tickLower The lower tick of the position
  51 |     |     /// @param tickUpper The upper tick of the position
  52 |     |     /// @param amount The amount of liquidity to remove
  53 |     |     /// @param amount0 The amount of token0 withdrawn
  54 |     |     /// @param amount1 The amount of token1 withdrawn
  55 |     |     event Burn(
  56 |     |         address indexed owner,
  57 |     |         int24 indexed tickLower,
  58 |     |         int24 indexed tickUpper,
  59 |     |         uint128 amount,
  60 |     |         uint256 amount0,
  61 |     |         uint256 amount1
  62 |     |     );
  63 |     | 
  64 |     |     /// @notice Emitted by the pool for any swaps between token0 and token1
  65 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  66 |     |     /// @param recipient The address that received the output of the swap
  67 |     |     /// @param amount0 The delta of the token0 balance of the pool
  68 |     |     /// @param amount1 The delta of the token1 balance of the pool
  69 |     |     /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96
  70 |     |     /// @param liquidity The liquidity of the pool after the swap
  71 |     |     /// @param tick The log base 1.0001 of price of the pool after the swap
  72 |     |     event Swap(
  73 |     |         address indexed sender,
  74 |     |         address indexed recipient,
  75 |     |         int256 amount0,
  76 |     |         int256 amount1,
  77 |     |         uint160 sqrtPriceX96,
  78 |     |         uint128 liquidity,
  79 |     |         int24 tick
  80 |     |     );
  81 |     | 
  82 |     |     /// @notice Emitted by the pool for any flashes of token0/token1
  83 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  84 |     |     /// @param recipient The address that received the tokens from flash
  85 |     |     /// @param amount0 The amount of token0 that was flashed
  86 |     |     /// @param amount1 The amount of token1 that was flashed
  87 |     |     /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee
  88 |     |     /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee
  89 |     |     event Flash(
  90 |     |         address indexed sender,
  91 |     |         address indexed recipient,
  92 |     |         uint256 amount0,
  93 |     |         uint256 amount1,
  94 |     |         uint256 paid0,
  95 |     |         uint256 paid1
  96 |     |     );
  97 |     | 
  98 |     |     /// @notice Emitted by the pool for increases to the number of observations that can be stored
  99 |     |     /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index
 100 |     |     /// just before a mint/swap/burn.
 101 |     |     /// @param observationCardinalityNextOld The previous value of the next observation cardinality
 102 |     |     /// @param observationCardinalityNextNew The updated value of the next observation cardinality
 103 |     |     event IncreaseObservationCardinalityNext(
 104 |     |         uint16 observationCardinalityNextOld,
 105 |     |         uint16 observationCardinalityNextNew
 106 |     |     );
 107 |     | 
 108 |     |     /// @notice Emitted when the protocol fee is changed by the pool
 109 |     |     /// @param feeProtocol0Old The previous value of the token0 protocol fee
 110 |     |     /// @param feeProtocol1Old The previous value of the token1 protocol fee
 111 |     |     /// @param feeProtocol0New The updated value of the token0 protocol fee
 112 |     |     /// @param feeProtocol1New The updated value of the token1 protocol fee
 113 |     |     event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
 114 |     | 
 115 |     |     /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner
 116 |     |     /// @param sender The address that collects the protocol fees
 117 |     |     /// @param recipient The address that receives the collected protocol fees
 118 |     |     /// @param amount0 The amount of token0 protocol fees that is withdrawn
 119 |     |     /// @param amount0 The amount of token1 protocol fees that is withdrawn
 120 |     |     event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
 121 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/pool/IUniswapV3PoolImmutables.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Pool state that never changes
  5 |     | /// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
  6 |     | interface IUniswapV3PoolImmutables {
  7 |     |     /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
  8 |     |     /// @return The contract address
  9 |     |     function factory() external view returns (address);
 10 |     | 
 11 |     |     /// @notice The first of the two tokens of the pool, sorted by address
 12 |     |     /// @return The token contract address
 13 |     |     function token0() external view returns (address);
 14 |     | 
 15 |     |     /// @notice The second of the two tokens of the pool, sorted by address
 16 |     |     /// @return The token contract address
 17 |     |     function token1() external view returns (address);
 18 |     | 
 19 |     |     /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
 20 |     |     /// @return The fee
 21 |     |     function fee() external view returns (uint24);
 22 |     | 
 23 |     |     /// @notice The pool tick spacing
 24 |     |     /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
 25 |     |     /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
 26 |     |     /// This value is an int24 to avoid casting even though it is always positive.
 27 |     |     /// @return The tick spacing
 28 |     |     function tickSpacing() external view returns (int24);
 29 |     | 
 30 |     |     /// @notice The maximum amount of position liquidity that can use any tick in the range
 31 |     |     /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
 32 |     |     /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
 33 |     |     /// @return The max amount of liquidity per tick
 34 |     |     function maxLiquidityPerTick() external view returns (uint128);
 35 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/pool/IUniswapV3PoolOwnerActions.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Permissioned pool actions
  5 |     | /// @notice Contains pool methods that may only be called by the factory owner
  6 |     | interface IUniswapV3PoolOwnerActions {
  7 |     |     /// @notice Set the denominator of the protocol's % share of the fees
  8 |     |     /// @param feeProtocol0 new protocol fee for token0 of the pool
  9 |     |     /// @param feeProtocol1 new protocol fee for token1 of the pool
 10 |     |     function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
 11 |     | 
 12 |     |     /// @notice Collect the protocol fee accrued to the pool
 13 |     |     /// @param recipient The address to which collected protocol fees should be sent
 14 |     |     /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1
 15 |     |     /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0
 16 |     |     /// @return amount0 The protocol fee collected in token0
 17 |     |     /// @return amount1 The protocol fee collected in token1
 18 |     |     function collectProtocol(
 19 |     |         address recipient,
 20 |     |         uint128 amount0Requested,
 21 |     |         uint128 amount1Requested
 22 |     |     ) external returns (uint128 amount0, uint128 amount1);
 23 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/interfaces/pool/IUniswapV3PoolState.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @title Pool state that can change
   5 |     | /// @notice These methods compose the pool's state, and can change with any frequency including multiple times
   6 |     | /// per transaction
   7 |     | interface IUniswapV3PoolState {
   8 |     |     /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
   9 |     |     /// when accessed externally.
  10 |     |     /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
  11 |     |     /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
  12 |     |     /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
  13 |     |     /// boundary.
  14 |     |     /// observationIndex The index of the last oracle observation that was written,
  15 |     |     /// observationCardinality The current maximum number of observations stored in the pool,
  16 |     |     /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
  17 |     |     /// feeProtocol The protocol fee for both tokens of the pool.
  18 |     |     /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
  19 |     |     /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
  20 |     |     /// unlocked Whether the pool is currently locked to reentrancy
  21 |     |     function slot0()
  22 |     |         external
  23 |     |         view
  24 |     |         returns (
  25 |     |             uint160 sqrtPriceX96,
  26 |     |             int24 tick,
  27 |     |             uint16 observationIndex,
  28 |     |             uint16 observationCardinality,
  29 |     |             uint16 observationCardinalityNext,
  30 |     |             uint8 feeProtocol,
  31 |     |             bool unlocked
  32 |     |         );
  33 |     | 
  34 |     |     /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
  35 |     |     /// @dev This value can overflow the uint256
  36 |     |     function feeGrowthGlobal0X128() external view returns (uint256);
  37 |     | 
  38 |     |     /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
  39 |     |     /// @dev This value can overflow the uint256
  40 |     |     function feeGrowthGlobal1X128() external view returns (uint256);
  41 |     | 
  42 |     |     /// @notice The amounts of token0 and token1 that are owed to the protocol
  43 |     |     /// @dev Protocol fees will never exceed uint128 max in either token
  44 |     |     function protocolFees() external view returns (uint128 token0, uint128 token1);
  45 |     | 
  46 |     |     /// @notice The currently in range liquidity available to the pool
  47 |     |     /// @dev This value has no relationship to the total liquidity across all ticks
  48 |     |     function liquidity() external view returns (uint128);
  49 |     | 
  50 |     |     /// @notice Look up information about a specific tick in the pool
  51 |     |     /// @param tick The tick to look up
  52 |     |     /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
  53 |     |     /// tick upper,
  54 |     |     /// liquidityNet how much liquidity changes when the pool price crosses the tick,
  55 |     |     /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
  56 |     |     /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
  57 |     |     /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
  58 |     |     /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
  59 |     |     /// secondsOutside the seconds spent on the other side of the tick from the current tick,
  60 |     |     /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
  61 |     |     /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
  62 |     |     /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
  63 |     |     /// a specific position.
  64 |     |     function ticks(int24 tick)
  65 |     |         external
  66 |     |         view
  67 |     |         returns (
  68 |     |             uint128 liquidityGross,
  69 |     |             int128 liquidityNet,
  70 |     |             uint256 feeGrowthOutside0X128,
  71 |     |             uint256 feeGrowthOutside1X128,
  72 |     |             int56 tickCumulativeOutside,
  73 |     |             uint160 secondsPerLiquidityOutsideX128,
  74 |     |             uint32 secondsOutside,
  75 |     |             bool initialized
  76 |     |         );
  77 |     | 
  78 |     |     /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
  79 |     |     function tickBitmap(int16 wordPosition) external view returns (uint256);
  80 |     | 
  81 |     |     /// @notice Returns the information about a position by the position's key
  82 |     |     /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
  83 |     |     /// @return _liquidity The amount of liquidity in the position,
  84 |     |     /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
  85 |     |     /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
  86 |     |     /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
  87 |     |     /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
  88 |     |     function positions(bytes32 key)
  89 |     |         external
  90 |     |         view
  91 |     |         returns (
  92 |     |             uint128 _liquidity,
  93 |     |             uint256 feeGrowthInside0LastX128,
  94 |     |             uint256 feeGrowthInside1LastX128,
  95 |     |             uint128 tokensOwed0,
  96 |     |             uint128 tokensOwed1
  97 |     |         );
  98 |     | 
  99 |     |     /// @notice Returns data about a specific observation index
 100 |     |     /// @param index The element of the observations array to fetch
 101 |     |     /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
 102 |     |     /// ago, rather than at a specific index in the array.
 103 |     |     /// @return blockTimestamp The timestamp of the observation,
 104 |     |     /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
 105 |     |     /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
 106 |     |     /// Returns initialized whether the observation has been initialized and the values are safe to use
 107 |     |     function observations(uint256 index)
 108 |     |         external
 109 |     |         view
 110 |     |         returns (
 111 |     |             uint32 blockTimestamp,
 112 |     |             int56 tickCumulative,
 113 |     |             uint160 secondsPerLiquidityCumulativeX128,
 114 |     |             bool initialized
 115 |     |         );
 116 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/BitMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title BitMath
  5 |     | /// @dev This library provides functionality for computing bit properties of an unsigned integer
  6 |     | library BitMath {
  7 |     |     /// @notice Returns the index of the most significant bit of the number,
  8 |     |     ///     where the least significant bit is at index 0 and the most significant bit is at index 255
  9 |     |     /// @dev The function satisfies the property:
 10 |     |     ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)
 11 |     |     /// @param x the value for which to compute the most significant bit, must be greater than 0
 12 |     |     /// @return r the index of the most significant bit
 13 |     |     function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {
 14 |     |         require(x > 0);
 15 |     | 
 16 |     |         if (x >= 0x100000000000000000000000000000000) {
 17 |     |             x >>= 128;
 18 |     |             r += 128;
 19 |     |         }
 20 |     |         if (x >= 0x10000000000000000) {
 21 |     |             x >>= 64;
 22 |     |             r += 64;
 23 |     |         }
 24 |     |         if (x >= 0x100000000) {
 25 |     |             x >>= 32;
 26 |     |             r += 32;
 27 |     |         }
 28 |     |         if (x >= 0x10000) {
 29 |     |             x >>= 16;
 30 |     |             r += 16;
 31 |     |         }
 32 |     |         if (x >= 0x100) {
 33 |     |             x >>= 8;
 34 |     |             r += 8;
 35 |     |         }
 36 |     |         if (x >= 0x10) {
 37 |     |             x >>= 4;
 38 |     |             r += 4;
 39 |     |         }
 40 |     |         if (x >= 0x4) {
 41 |     |             x >>= 2;
 42 |     |             r += 2;
 43 |     |         }
 44 |     |         if (x >= 0x2) r += 1;
 45 |     |     }
 46 |     | 
 47 |     |     /// @notice Returns the index of the least significant bit of the number,
 48 |     |     ///     where the least significant bit is at index 0 and the most significant bit is at index 255
 49 |     |     /// @dev The function satisfies the property:
 50 |     |     ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)
 51 |     |     /// @param x the value for which to compute the least significant bit, must be greater than 0
 52 |     |     /// @return r the index of the least significant bit
 53 |     |     function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {
 54 |     |         require(x > 0);
 55 |     | 
 56 |     |         r = 255;
 57 |     |         if (x & type(uint128).max > 0) {
 58 |     |             r -= 128;
 59 |     |         } else {
 60 |     |             x >>= 128;
 61 |     |         }
 62 |     |         if (x & type(uint64).max > 0) {
 63 |     |             r -= 64;
 64 |     |         } else {
 65 |     |             x >>= 64;
 66 |     |         }
 67 |     |         if (x & type(uint32).max > 0) {
 68 |     |             r -= 32;
 69 |     |         } else {
 70 |     |             x >>= 32;
 71 |     |         }
 72 |     |         if (x & type(uint16).max > 0) {
 73 |     |             r -= 16;
 74 |     |         } else {
 75 |     |             x >>= 16;
 76 |     |         }
 77 |     |         if (x & type(uint8).max > 0) {
 78 |     |             r -= 8;
 79 |     |         } else {
 80 |     |             x >>= 8;
 81 |     |         }
 82 |     |         if (x & 0xf > 0) {
 83 |     |             r -= 4;
 84 |     |         } else {
 85 |     |             x >>= 4;
 86 |     |         }
 87 |     |         if (x & 0x3 > 0) {
 88 |     |             r -= 2;
 89 |     |         } else {
 90 |     |             x >>= 2;
 91 |     |         }
 92 |     |         if (x & 0x1 > 0) r -= 1;
 93 |     |     }
 94 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/FixedPoint128.sol
 1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
 2 |     | pragma solidity >=0.8.0;
 3 |     | 
 4 |     | /// @title FixedPoint128
 5 |     | /// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
 6 |     | library FixedPoint128 {
 7 | *   |     uint256 internal constant Q128 = 0x100000000000000000000000000000000;
 8 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/FixedPoint96.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.4.0;
  3 |     | 
  4 |     | /// @title FixedPoint96
  5 |     | /// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
  6 |     | /// @dev Used in SqrtPriceMath.sol
  7 |     | library FixedPoint96 {
  8 | *   |     uint8 internal constant RESOLUTION = 96;
  9 | *   |     uint256 internal constant Q96 = 0x1000000000000000000000000;
 10 |     | }
 11 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/FullMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | /// @title Contains 512-bit math functions
   5 |     | /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
   6 |     | /// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
   7 |     | library FullMath {
   8 |     |     /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
   9 |     |     /// @param a The multiplicand
  10 |     |     /// @param b The multiplier
  11 |     |     /// @param denominator The divisor
  12 |     |     /// @return result The 256-bit result
  13 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
  14 | *   |     function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {
  15 |     |         unchecked {
  16 |     |             // 512-bit multiply [prod1 prod0] = a * b
  17 |     |             // Compute the product mod 2**256 and mod 2**256 - 1
  18 |     |             // then use the Chinese Remainder Theorem to reconstruct
  19 |     |             // the 512 bit result. The result is stored in two 256
  20 |     |             // variables such that product = prod1 * 2**256 + prod0
  21 | *   |             uint256 prod0; // Least significant 256 bits of the product
  22 | *   |             uint256 prod1; // Most significant 256 bits of the product
  23 | *   |             assembly {
  24 | *   |                 let mm := mulmod(a, b, not(0))
  25 | *   |                 prod0 := mul(a, b)
  26 | *   |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  27 |     |             }
  28 |     | 
  29 |     |             // Handle non-overflow cases, 256 by 256 division
  30 | *   |             if (prod1 == 0) {
  31 | *   |                 require(denominator > 0);
  32 |     |                 assembly {
  33 | *   |                     result := div(prod0, denominator)
  34 |     |                 }
  35 | *   |                 return result;
  36 |     |             }
  37 |     | 
  38 |     |             // Make sure the result is less than 2**256.
  39 |     |             // Also prevents denominator == 0
  40 | *   |             require(denominator > prod1);
  41 |     | 
  42 |     |             ///////////////////////////////////////////////
  43 |     |             // 512 by 256 division.
  44 |     |             ///////////////////////////////////////////////
  45 |     | 
  46 |     |             // Make division exact by subtracting the remainder from [prod1 prod0]
  47 |     |             // Compute remainder using mulmod
  48 | *   |             uint256 remainder;
  49 |     |             assembly {
  50 | *   |                 remainder := mulmod(a, b, denominator)
  51 |     |             }
  52 |     |             // Subtract 256 bit number from 512 bit number
  53 |     |             assembly {
  54 | *   |                 prod1 := sub(prod1, gt(remainder, prod0))
  55 | *   |                 prod0 := sub(prod0, remainder)
  56 |     |             }
  57 |     | 
  58 |     |             // Factor powers of two out of denominator
  59 |     |             // Compute largest power of two divisor of denominator.
  60 |     |             // Always >= 1.
  61 | *   |             uint256 twos = (0 - denominator) & denominator;
  62 |     |             // Divide denominator by power of two
  63 |     |             assembly {
  64 | *   |                 denominator := div(denominator, twos)
  65 |     |             }
  66 |     | 
  67 |     |             // Divide [prod1 prod0] by the factors of two
  68 |     |             assembly {
  69 | *   |                 prod0 := div(prod0, twos)
  70 |     |             }
  71 |     |             // Shift in bits from prod1 into prod0. For this we need
  72 |     |             // to flip `twos` such that it is 2**256 / twos.
  73 |     |             // If twos is zero, then it becomes one
  74 |     |             assembly {
  75 | *   |                 twos := add(div(sub(0, twos), twos), 1)
  76 |     |             }
  77 | *   |             prod0 |= prod1 * twos;
  78 |     | 
  79 |     |             // Invert denominator mod 2**256
  80 |     |             // Now that denominator is an odd number, it has an inverse
  81 |     |             // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  82 |     |             // Compute the inverse by starting with a seed that is correct
  83 |     |             // correct for four bits. That is, denominator * inv = 1 mod 2**4
  84 | *   |             uint256 inv = (3 * denominator) ^ 2;
  85 |     |             // Now use Newton-Raphson iteration to improve the precision.
  86 |     |             // Thanks to Hensel's lifting lemma, this also works in modular
  87 |     |             // arithmetic, doubling the correct bits in each step.
  88 | *   |             inv *= 2 - denominator * inv; // inverse mod 2**8
  89 | *   |             inv *= 2 - denominator * inv; // inverse mod 2**16
  90 | *   |             inv *= 2 - denominator * inv; // inverse mod 2**32
  91 | *   |             inv *= 2 - denominator * inv; // inverse mod 2**64
  92 | *   |             inv *= 2 - denominator * inv; // inverse mod 2**128
  93 | *   |             inv *= 2 - denominator * inv; // inverse mod 2**256
  94 |     | 
  95 |     |             // Because the division is now exact we can divide by multiplying
  96 |     |             // with the modular inverse of denominator. This will give us the
  97 |     |             // correct result modulo 2**256. Since the precoditions guarantee
  98 |     |             // that the outcome is less than 2**256, this is the final result.
  99 |     |             // We don't need to compute the high bits of the result and prod1
 100 |     |             // is no longer required.
 101 | *   |             result = prod0 * inv;
 102 | *   |             return result;
 103 |     |         }
 104 |     |     }
 105 |     | 
 106 |     |     /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
 107 |     |     /// @param a The multiplicand
 108 |     |     /// @param b The multiplier
 109 |     |     /// @param denominator The divisor
 110 |     |     /// @return result The 256-bit result
 111 | *   |     function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {
 112 |     |         unchecked {
 113 | *   |             result = mulDiv(a, b, denominator);
 114 | *   |             if (mulmod(a, b, denominator) > 0) {
 115 | *   |                 require(result < type(uint256).max);
 116 | *   |                 result++;
 117 |     |             }
 118 |     |         }
 119 |     |     }
 120 |     | }
 121 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/LiquidityMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Math library for liquidity
  5 |     | library LiquidityMath {
  6 |     |     /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows
  7 |     |     /// @param x The liquidity before change
  8 |     |     /// @param y The delta by which liquidity should be changed
  9 |     |     /// @return z The liquidity delta
 10 | *   |     function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {
 11 | *   |         if (y < 0) {
 12 |     |             require((z = x - uint128(-y)) < x, 'LS');
 13 |     |         } else {
 14 | *   |             require((z = x + uint128(y)) >= x, 'LA');
 15 |     |         }
 16 |     |     }
 17 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/LowGasSafeMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Optimized overflow and underflow safe math operations
  5 |     | /// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost
  6 |     | library LowGasSafeMath {
  7 |     |     /// @notice Returns x + y, reverts if sum overflows uint256
  8 |     |     /// @param x The augend
  9 |     |     /// @param y The addend
 10 |     |     /// @return z The sum of x and y
 11 | *   |     function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
 12 | *   |         require((z = x + y) >= x);
 13 |     |     }
 14 |     | 
 15 |     |     /// @notice Returns x - y, reverts if underflows
 16 |     |     /// @param x The minuend
 17 |     |     /// @param y The subtrahend
 18 |     |     /// @return z The difference of x and y
 19 |     |     function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
 20 |     |         require((z = x - y) <= x);
 21 |     |     }
 22 |     | 
 23 |     |     /// @notice Returns x * y, reverts if overflows
 24 |     |     /// @param x The multiplicand
 25 |     |     /// @param y The multiplier
 26 |     |     /// @return z The product of x and y
 27 |     |     function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
 28 |     |         require(x == 0 || (z = x * y) / x == y);
 29 |     |     }
 30 |     | 
 31 |     |     /// @notice Returns x + y, reverts if overflows or underflows
 32 |     |     /// @param x The augend
 33 |     |     /// @param y The addend
 34 |     |     /// @return z The sum of x and y
 35 | *   |     function add(int256 x, int256 y) internal pure returns (int256 z) {
 36 | *   |         require((z = x + y) >= x == (y >= 0));
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Returns x - y, reverts if overflows or underflows
 40 |     |     /// @param x The minuend
 41 |     |     /// @param y The subtrahend
 42 |     |     /// @return z The difference of x and y
 43 | *   |     function sub(int256 x, int256 y) internal pure returns (int256 z) {
 44 | *   |         require((z = x - y) <= x == (y >= 0));
 45 |     |     }
 46 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/Oracle.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @title Oracle
   5 |     | /// @notice Provides price and liquidity data useful for a wide variety of system designs
   6 |     | /// @dev Instances of stored oracle data, "observations", are collected in the oracle array
   7 |     | /// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the
   8 |     | /// maximum length of the oracle array. New slots will be added when the array is fully populated.
   9 |     | /// Observations are overwritten when the full length of the oracle array is populated.
  10 |     | /// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()
  11 |     | library Oracle {
  12 |     |     struct Observation {
  13 |     |         // the block timestamp of the observation
  14 |     |         uint32 blockTimestamp;
  15 |     |         // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
  16 |     |         int56 tickCumulative;
  17 |     |         // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
  18 |     |         uint160 secondsPerLiquidityCumulativeX128;
  19 |     |         // whether or not the observation is initialized
  20 |     |         bool initialized;
  21 |     |     }
  22 |     | 
  23 |     |     /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values
  24 |     |     /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows
  25 |     |     /// @param last The specified observation to be transformed
  26 |     |     /// @param blockTimestamp The timestamp of the new observation
  27 |     |     /// @param tick The active tick at the time of the new observation
  28 |     |     /// @param liquidity The total in-range liquidity at the time of the new observation
  29 |     |     /// @return Observation The newly populated observation
  30 | *   |     function transform(
  31 |     |         Observation memory last,
  32 |     |         uint32 blockTimestamp,
  33 |     |         int24 tick,
  34 |     |         uint128 liquidity
  35 | *   |     ) private pure returns (Observation memory) {
  36 | *   |         uint32 delta = blockTimestamp - last.blockTimestamp;
  37 | *   |         return
  38 | *   |             Observation({
  39 | *   |                 blockTimestamp: blockTimestamp,
  40 | *   |                 tickCumulative: last.tickCumulative + int56(tick) * int56(int32(delta)),
  41 | *   |                 secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +
  42 | *   |                     ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),
  43 | *   |                 initialized: true
  44 |     |             });
  45 |     |     }
  46 |     | 
  47 |     |     /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array
  48 |     |     /// @param self The stored oracle array
  49 |     |     /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32
  50 |     |     /// @return cardinality The number of populated elements in the oracle array
  51 |     |     /// @return cardinalityNext The new length of the oracle array, independent of population
  52 | *   |     function initialize(Observation[65535] storage self, uint32 time)
  53 |     |         internal
  54 | *   |         returns (uint16 cardinality, uint16 cardinalityNext)
  55 |     |     {
  56 | *   |         self[0] = Observation({
  57 | *   |             blockTimestamp: time,
  58 | *   |             tickCumulative: 0,
  59 | *   |             secondsPerLiquidityCumulativeX128: 0,
  60 | *   |             initialized: true
  61 |     |         });
  62 | *   |         return (1, 1);
  63 |     |     }
  64 |     | 
  65 |     |     /// @notice Writes an oracle observation to the array
  66 |     |     /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.
  67 |     |     /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality
  68 |     |     /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.
  69 |     |     /// @param self The stored oracle array
  70 |     |     /// @param index The index of the observation that was most recently written to the observations array
  71 |     |     /// @param blockTimestamp The timestamp of the new observation
  72 |     |     /// @param tick The active tick at the time of the new observation
  73 |     |     /// @param liquidity The total in-range liquidity at the time of the new observation
  74 |     |     /// @param cardinality The number of populated elements in the oracle array
  75 |     |     /// @param cardinalityNext The new length of the oracle array, independent of population
  76 |     |     /// @return indexUpdated The new index of the most recently written element in the oracle array
  77 |     |     /// @return cardinalityUpdated The new cardinality of the oracle array
  78 | *   |     function write(
  79 |     |         Observation[65535] storage self,
  80 |     |         uint16 index,
  81 |     |         uint32 blockTimestamp,
  82 |     |         int24 tick,
  83 |     |         uint128 liquidity,
  84 |     |         uint16 cardinality,
  85 |     |         uint16 cardinalityNext
  86 | *   |     ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {
  87 | *   |         Observation memory last = self[index];
  88 |     | 
  89 |     |         // early return if we've already written an observation this block
  90 | *   |         if (last.blockTimestamp == blockTimestamp) return (index, cardinality);
  91 |     | 
  92 |     |         // if the conditions are right, we can bump the cardinality
  93 | *   |         if (cardinalityNext > cardinality && index == (cardinality - 1)) {
  94 |     |             cardinalityUpdated = cardinalityNext;
  95 |     |         } else {
  96 | *   |             cardinalityUpdated = cardinality;
  97 |     |         }
  98 |     | 
  99 | *   |         indexUpdated = (index + 1) % cardinalityUpdated;
 100 | *   |         self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);
 101 |     |     }
 102 |     | 
 103 |     |     /// @notice Prepares the oracle array to store up to `next` observations
 104 |     |     /// @param self The stored oracle array
 105 |     |     /// @param current The current next cardinality of the oracle array
 106 |     |     /// @param next The proposed next cardinality which will be populated in the oracle array
 107 |     |     /// @return next The next cardinality which will be populated in the oracle array
 108 |     |     function grow(
 109 |     |         Observation[65535] storage self,
 110 |     |         uint16 current,
 111 |     |         uint16 next
 112 |     |     ) internal returns (uint16) {
 113 |     |         require(current > 0, 'I');
 114 |     |         // no-op if the passed next value isn't greater than the current next value
 115 |     |         if (next <= current) return current;
 116 |     |         // store in each slot to prevent fresh SSTOREs in swaps
 117 |     |         // this data will not be used because the initialized boolean is still false
 118 |     |         for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;
 119 |     |         return next;
 120 |     |     }
 121 |     | 
 122 |     |     /// @notice comparator for 32-bit timestamps
 123 |     |     /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time
 124 |     |     /// @param time A timestamp truncated to 32 bits
 125 |     |     /// @param a A comparison timestamp from which to determine the relative position of `time`
 126 |     |     /// @param b From which to determine the relative position of `time`
 127 |     |     /// @return bool Whether `a` is chronologically <= `b`
 128 |     |     function lte(
 129 |     |         uint32 time,
 130 |     |         uint32 a,
 131 |     |         uint32 b
 132 |     |     ) private pure returns (bool) {
 133 |     |         // if there hasn't been overflow, no need to adjust
 134 |     |         if (a <= time && b <= time) return a <= b;
 135 |     | 
 136 |     |         uint256 aAdjusted = a > time ? a : a + 2**32;
 137 |     |         uint256 bAdjusted = b > time ? b : b + 2**32;
 138 |     | 
 139 |     |         return aAdjusted <= bAdjusted;
 140 |     |     }
 141 |     | 
 142 |     |     /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
 143 |     |     /// The result may be the same observation, or adjacent observations.
 144 |     |     /// @dev The answer must be contained in the array, used when the target is located within the stored observation
 145 |     |     /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation
 146 |     |     /// @param self The stored oracle array
 147 |     |     /// @param time The current block.timestamp
 148 |     |     /// @param target The timestamp at which the reserved observation should be for
 149 |     |     /// @param index The index of the observation that was most recently written to the observations array
 150 |     |     /// @param cardinality The number of populated elements in the oracle array
 151 |     |     /// @return beforeOrAt The observation recorded before, or at, the target
 152 |     |     /// @return atOrAfter The observation recorded at, or after, the target
 153 |     |     function binarySearch(
 154 |     |         Observation[65535] storage self,
 155 |     |         uint32 time,
 156 |     |         uint32 target,
 157 |     |         uint16 index,
 158 |     |         uint16 cardinality
 159 |     |     ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
 160 |     |         uint256 l = (index + 1) % cardinality; // oldest observation
 161 |     |         uint256 r = l + cardinality - 1; // newest observation
 162 |     |         uint256 i;
 163 |     |         while (true) {
 164 |     |             i = (l + r) / 2;
 165 |     | 
 166 |     |             beforeOrAt = self[i % cardinality];
 167 |     | 
 168 |     |             // we've landed on an uninitialized tick, keep searching higher (more recently)
 169 |     |             if (!beforeOrAt.initialized) {
 170 |     |                 l = i + 1;
 171 |     |                 continue;
 172 |     |             }
 173 |     | 
 174 |     |             atOrAfter = self[(i + 1) % cardinality];
 175 |     | 
 176 |     |             bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);
 177 |     | 
 178 |     |             // check if we've found the answer!
 179 |     |             if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;
 180 |     | 
 181 |     |             if (!targetAtOrAfter) r = i - 1;
 182 |     |             else l = i + 1;
 183 |     |         }
 184 |     |     }
 185 |     | 
 186 |     |     /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied
 187 |     |     /// @dev Assumes there is at least 1 initialized observation.
 188 |     |     /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.
 189 |     |     /// @param self The stored oracle array
 190 |     |     /// @param time The current block.timestamp
 191 |     |     /// @param target The timestamp at which the reserved observation should be for
 192 |     |     /// @param tick The active tick at the time of the returned or simulated observation
 193 |     |     /// @param index The index of the observation that was most recently written to the observations array
 194 |     |     /// @param liquidity The total pool liquidity at the time of the call
 195 |     |     /// @param cardinality The number of populated elements in the oracle array
 196 |     |     /// @return beforeOrAt The observation which occurred at, or before, the given timestamp
 197 |     |     /// @return atOrAfter The observation which occurred at, or after, the given timestamp
 198 |     |     function getSurroundingObservations(
 199 |     |         Observation[65535] storage self,
 200 |     |         uint32 time,
 201 |     |         uint32 target,
 202 |     |         int24 tick,
 203 |     |         uint16 index,
 204 |     |         uint128 liquidity,
 205 |     |         uint16 cardinality
 206 |     |     ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
 207 |     |         // optimistically set before to the newest observation
 208 |     |         beforeOrAt = self[index];
 209 |     | 
 210 |     |         // if the target is chronologically at or after the newest observation, we can early return
 211 |     |         if (lte(time, beforeOrAt.blockTimestamp, target)) {
 212 |     |             if (beforeOrAt.blockTimestamp == target) {
 213 |     |                 // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
 214 |     |                 return (beforeOrAt, atOrAfter);
 215 |     |             } else {
 216 |     |                 // otherwise, we need to transform
 217 |     |                 return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));
 218 |     |             }
 219 |     |         }
 220 |     | 
 221 |     |         // now, set before to the oldest observation
 222 |     |         beforeOrAt = self[(index + 1) % cardinality];
 223 |     |         if (!beforeOrAt.initialized) beforeOrAt = self[0];
 224 |     | 
 225 |     |         // ensure that the target is chronologically at or after the oldest observation
 226 |     |         require(lte(time, beforeOrAt.blockTimestamp, target), 'OLD');
 227 |     | 
 228 |     |         // if we've reached this point, we have to binary search
 229 |     |         return binarySearch(self, time, target, index, cardinality);
 230 |     |     }
 231 |     | 
 232 |     |     /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.
 233 |     |     /// 0 may be passed as `secondsAgo' to return the current cumulative values.
 234 |     |     /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values
 235 |     |     /// at exactly the timestamp between the two observations.
 236 |     |     /// @param self The stored oracle array
 237 |     |     /// @param time The current block timestamp
 238 |     |     /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation
 239 |     |     /// @param tick The current tick
 240 |     |     /// @param index The index of the observation that was most recently written to the observations array
 241 |     |     /// @param liquidity The current in-range pool liquidity
 242 |     |     /// @param cardinality The number of populated elements in the oracle array
 243 |     |     /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`
 244 |     |     /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`
 245 | *   |     function observeSingle(
 246 |     |         Observation[65535] storage self,
 247 |     |         uint32 time,
 248 |     |         uint32 secondsAgo,
 249 |     |         int24 tick,
 250 |     |         uint16 index,
 251 |     |         uint128 liquidity,
 252 |     |         uint16 cardinality
 253 | *   |     ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {
 254 | *   |         if (secondsAgo == 0) {
 255 | *   |             Observation memory last = self[index];
 256 | *   |             if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);
 257 | *   |             return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);
 258 |     |         }
 259 |     | 
 260 |     |         uint32 target = time - secondsAgo;
 261 |     | 
 262 |     |         (Observation memory beforeOrAt, Observation memory atOrAfter) =
 263 |     |             getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);
 264 |     | 
 265 |     |         if (target == beforeOrAt.blockTimestamp) {
 266 |     |             // we're at the left boundary
 267 |     |             return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);
 268 |     |         } else if (target == atOrAfter.blockTimestamp) {
 269 |     |             // we're at the right boundary
 270 |     |             return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);
 271 |     |         } else {
 272 |     |             // we're in the middle
 273 |     |             uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;
 274 |     |             uint32 targetDelta = target - beforeOrAt.blockTimestamp;
 275 |     |             return (
 276 |     |                 beforeOrAt.tickCumulative +
 277 |     |                     ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(int32(observationTimeDelta))) *
 278 |     |                     int56(int32(targetDelta)),
 279 |     |                 beforeOrAt.secondsPerLiquidityCumulativeX128 +
 280 |     |                     uint160(
 281 |     |                         (uint256(
 282 |     |                             atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128
 283 |     |                         ) * targetDelta) / observationTimeDelta
 284 |     |                     )
 285 |     |             );
 286 |     |         }
 287 |     |     }
 288 |     | 
 289 |     |     /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`
 290 |     |     /// @dev Reverts if `secondsAgos` > oldest observation
 291 |     |     /// @param self The stored oracle array
 292 |     |     /// @param time The current block.timestamp
 293 |     |     /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation
 294 |     |     /// @param tick The current tick
 295 |     |     /// @param index The index of the observation that was most recently written to the observations array
 296 |     |     /// @param liquidity The current in-range pool liquidity
 297 |     |     /// @param cardinality The number of populated elements in the oracle array
 298 |     |     /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`
 299 |     |     /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`
 300 |     |     function observe(
 301 |     |         Observation[65535] storage self,
 302 |     |         uint32 time,
 303 |     |         uint32[] memory secondsAgos,
 304 |     |         int24 tick,
 305 |     |         uint16 index,
 306 |     |         uint128 liquidity,
 307 |     |         uint16 cardinality
 308 |     |     ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {
 309 |     |         require(cardinality > 0, 'I');
 310 |     | 
 311 |     |         tickCumulatives = new int56[](secondsAgos.length);
 312 |     |         secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);
 313 |     |         for (uint256 i = 0; i < secondsAgos.length; i++) {
 314 |     |             (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(
 315 |     |                 self,
 316 |     |                 time,
 317 |     |                 secondsAgos[i],
 318 |     |                 tick,
 319 |     |                 index,
 320 |     |                 liquidity,
 321 |     |                 cardinality
 322 |     |             );
 323 |     |         }
 324 |     |     }
 325 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/Position.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import './FullMath.sol';
  5 |     | import './FixedPoint128.sol';
  6 |     | import './LiquidityMath.sol';
  7 |     | 
  8 |     | /// @title Position
  9 |     | /// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary
 10 |     | /// @dev Positions store additional state for tracking fees owed to the position
 11 |     | library Position {
 12 |     |     // info stored for each user's position
 13 |     |     struct Info {
 14 |     |         // the amount of liquidity owned by this position
 15 |     |         uint128 liquidity;
 16 |     |         // fee growth per unit of liquidity as of the last update to liquidity or fees owed
 17 |     |         uint256 feeGrowthInside0LastX128;
 18 |     |         uint256 feeGrowthInside1LastX128;
 19 |     |         // the fees owed to the position owner in token0/token1
 20 |     |         uint128 tokensOwed0;
 21 |     |         uint128 tokensOwed1;
 22 |     |     }
 23 |     | 
 24 |     |     /// @notice Returns the Info struct of a position, given an owner and position boundaries
 25 |     |     /// @param self The mapping containing all user positions
 26 |     |     /// @param owner The address of the position owner
 27 |     |     /// @param tickLower The lower tick boundary of the position
 28 |     |     /// @param tickUpper The upper tick boundary of the position
 29 |     |     /// @return position The position info struct of the given owners' position
 30 | *   |     function get(
 31 |     |         mapping(bytes32 => Info) storage self,
 32 |     |         address owner,
 33 |     |         int24 tickLower,
 34 |     |         int24 tickUpper
 35 | *   |     ) internal view returns (Position.Info storage position) {
 36 | *   |         position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Credits accumulated fees to a user's position
 40 |     |     /// @param self The individual position to update
 41 |     |     /// @param liquidityDelta The change in pool liquidity as a result of the position update
 42 |     |     /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
 43 |     |     /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
 44 | *   |     function update(
 45 |     |         Info storage self,
 46 |     |         int128 liquidityDelta,
 47 |     |         uint256 feeGrowthInside0X128,
 48 |     |         uint256 feeGrowthInside1X128
 49 | *   |     ) internal {
 50 | *   |         Info memory _self = self;
 51 |     | 
 52 | *   |         uint128 liquidityNext;
 53 | *   |         if (liquidityDelta == 0) {
 54 |     |             require(_self.liquidity > 0, 'NP'); // disallow pokes for 0 liquidity positions
 55 |     |             liquidityNext = _self.liquidity;
 56 |     |         } else {
 57 | *   |             liquidityNext = LiquidityMath.addDelta(_self.liquidity, liquidityDelta);
 58 |     |         }
 59 |     | 
 60 |     |         // calculate accumulated fees
 61 | *   |         uint128 tokensOwed0 =
 62 |     |             uint128(
 63 | *   |                 FullMath.mulDiv(
 64 | *   |                     feeGrowthInside0X128 - _self.feeGrowthInside0LastX128,
 65 | *   |                     _self.liquidity,
 66 |     |                     FixedPoint128.Q128
 67 |     |                 )
 68 |     |             );
 69 | *   |         uint128 tokensOwed1 =
 70 |     |             uint128(
 71 | *   |                 FullMath.mulDiv(
 72 | *   |                     feeGrowthInside1X128 - _self.feeGrowthInside1LastX128,
 73 | *   |                     _self.liquidity,
 74 |     |                     FixedPoint128.Q128
 75 |     |                 )
 76 |     |             );
 77 |     | 
 78 |     |         // update the position
 79 | *   |         if (liquidityDelta != 0) self.liquidity = liquidityNext;
 80 | *   |         self.feeGrowthInside0LastX128 = feeGrowthInside0X128;
 81 | *   |         self.feeGrowthInside1LastX128 = feeGrowthInside1X128;
 82 | *   |         if (tokensOwed0 > 0 || tokensOwed1 > 0) {
 83 |     |             // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
 84 |     |             self.tokensOwed0 += tokensOwed0;
 85 |     |             self.tokensOwed1 += tokensOwed1;
 86 |     |         }
 87 |     |     }
 88 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/SafeCast.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Safe casting methods
  5 |     | /// @notice Contains methods for safely casting between types
  6 |     | library SafeCast {
  7 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
  8 |     |     /// @param y The uint256 to be downcasted
  9 |     |     /// @return z The downcasted integer, now type uint160
 10 |     |     function toUint160(uint256 y) internal pure returns (uint160 z) {
 11 |     |         require((z = uint160(y)) == y);
 12 |     |     }
 13 |     | 
 14 |     |     /// @notice Cast a int256 to a int128, revert on overflow or underflow
 15 |     |     /// @param y The int256 to be downcasted
 16 |     |     /// @return z The downcasted integer, now type int128
 17 | *   |     function toInt128(int256 y) internal pure returns (int128 z) {
 18 | *   |         require((z = int128(y)) == y);
 19 |     |     }
 20 |     | 
 21 |     |     /// @notice Cast a uint256 to a int256, revert on overflow
 22 |     |     /// @param y The uint256 to be casted
 23 |     |     /// @return z The casted integer, now type int256
 24 | *   |     function toInt256(uint256 y) internal pure returns (int256 z) {
 25 | *   |         require(y < 2**255);
 26 | *   |         z = int256(y);
 27 |     |     }
 28 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/SqrtPriceMath.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import './LowGasSafeMath.sol';
   5 |     | import './SafeCast.sol';
   6 |     | 
   7 |     | import './FullMath.sol';
   8 |     | import './UnsafeMath.sol';
   9 |     | import './FixedPoint96.sol';
  10 |     | 
  11 |     | /// @title Functions based on Q64.96 sqrt price and liquidity
  12 |     | /// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas
  13 |     | library SqrtPriceMath {
  14 |     |     using LowGasSafeMath for uint256;
  15 |     |     using SafeCast for uint256;
  16 |     | 
  17 |     |     /// @notice Gets the next sqrt price given a delta of token0
  18 |     |     /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least
  19 |     |     /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the
  20 |     |     /// price less in order to not send too much output.
  21 |     |     /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),
  22 |     |     /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).
  23 |     |     /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta
  24 |     |     /// @param liquidity The amount of usable liquidity
  25 |     |     /// @param amount How much of token0 to add or remove from virtual reserves
  26 |     |     /// @param add Whether to add or remove the amount of token0
  27 |     |     /// @return The price after adding or removing amount, depending on add
  28 |     |     function getNextSqrtPriceFromAmount0RoundingUp(
  29 |     |         uint160 sqrtPX96,
  30 |     |         uint128 liquidity,
  31 |     |         uint256 amount,
  32 |     |         bool add
  33 |     |     ) internal pure returns (uint160) {
  34 |     |         // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price
  35 |     |         if (amount == 0) return sqrtPX96;
  36 |     |         uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
  37 |     | 
  38 |     |         if (add) {
  39 |     |             uint256 product;
  40 |     |             if ((product = amount * sqrtPX96) / amount == sqrtPX96) {
  41 |     |                 uint256 denominator = numerator1 + product;
  42 |     |                 if (denominator >= numerator1)
  43 |     |                     // always fits in 160 bits
  44 |     |                     return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));
  45 |     |             }
  46 |     | 
  47 |     |             return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));
  48 |     |         } else {
  49 |     |             uint256 product;
  50 |     |             // if the product overflows, we know the denominator underflows
  51 |     |             // in addition, we must check that the denominator does not underflow
  52 |     |             require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);
  53 |     |             uint256 denominator = numerator1 - product;
  54 |     |             return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     /// @notice Gets the next sqrt price given a delta of token1
  59 |     |     /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least
  60 |     |     /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the
  61 |     |     /// price less in order to not send too much output.
  62 |     |     /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity
  63 |     |     /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta
  64 |     |     /// @param liquidity The amount of usable liquidity
  65 |     |     /// @param amount How much of token1 to add, or remove, from virtual reserves
  66 |     |     /// @param add Whether to add, or remove, the amount of token1
  67 |     |     /// @return The price after adding or removing `amount`
  68 |     |     function getNextSqrtPriceFromAmount1RoundingDown(
  69 |     |         uint160 sqrtPX96,
  70 |     |         uint128 liquidity,
  71 |     |         uint256 amount,
  72 |     |         bool add
  73 |     |     ) internal pure returns (uint160) {
  74 |     |         // if we're adding (subtracting), rounding down requires rounding the quotient down (up)
  75 |     |         // in both cases, avoid a mulDiv for most inputs
  76 |     |         if (add) {
  77 |     |             uint256 quotient =
  78 |     |                 (
  79 |     |                     amount <= type(uint160).max
  80 |     |                         ? (amount << FixedPoint96.RESOLUTION) / liquidity
  81 |     |                         : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)
  82 |     |                 );
  83 |     | 
  84 |     |             return uint256(sqrtPX96).add(quotient).toUint160();
  85 |     |         } else {
  86 |     |             uint256 quotient =
  87 |     |                 (
  88 |     |                     amount <= type(uint160).max
  89 |     |                         ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)
  90 |     |                         : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)
  91 |     |                 );
  92 |     | 
  93 |     |             require(sqrtPX96 > quotient);
  94 |     |             // always fits 160 bits
  95 |     |             return uint160(sqrtPX96 - quotient);
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /// @notice Gets the next sqrt price given an input amount of token0 or token1
 100 |     |     /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds
 101 |     |     /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount
 102 |     |     /// @param liquidity The amount of usable liquidity
 103 |     |     /// @param amountIn How much of token0, or token1, is being swapped in
 104 |     |     /// @param zeroForOne Whether the amount in is token0 or token1
 105 |     |     /// @return sqrtQX96 The price after adding the input amount to token0 or token1
 106 |     |     function getNextSqrtPriceFromInput(
 107 |     |         uint160 sqrtPX96,
 108 |     |         uint128 liquidity,
 109 |     |         uint256 amountIn,
 110 |     |         bool zeroForOne
 111 |     |     ) internal pure returns (uint160 sqrtQX96) {
 112 |     |         require(sqrtPX96 > 0);
 113 |     |         require(liquidity > 0);
 114 |     | 
 115 |     |         // round to make sure that we don't pass the target price
 116 |     |         return
 117 |     |             zeroForOne
 118 |     |                 ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)
 119 |     |                 : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);
 120 |     |     }
 121 |     | 
 122 |     |     /// @notice Gets the next sqrt price given an output amount of token0 or token1
 123 |     |     /// @dev Throws if price or liquidity are 0 or the next price is out of bounds
 124 |     |     /// @param sqrtPX96 The starting price before accounting for the output amount
 125 |     |     /// @param liquidity The amount of usable liquidity
 126 |     |     /// @param amountOut How much of token0, or token1, is being swapped out
 127 |     |     /// @param zeroForOne Whether the amount out is token0 or token1
 128 |     |     /// @return sqrtQX96 The price after removing the output amount of token0 or token1
 129 |     |     function getNextSqrtPriceFromOutput(
 130 |     |         uint160 sqrtPX96,
 131 |     |         uint128 liquidity,
 132 |     |         uint256 amountOut,
 133 |     |         bool zeroForOne
 134 |     |     ) internal pure returns (uint160 sqrtQX96) {
 135 |     |         require(sqrtPX96 > 0);
 136 |     |         require(liquidity > 0);
 137 |     | 
 138 |     |         // round to make sure that we pass the target price
 139 |     |         return
 140 |     |             zeroForOne
 141 |     |                 ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)
 142 |     |                 : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);
 143 |     |     }
 144 |     |     
 145 |     |     event Message(string a);
 146 |     |     event MessageUint160(string a, uint160 b);
 147 |     |     event MessageUint256(string a, uint256 b);
 148 |     | 
 149 |     | 
 150 |     |     /// @notice Gets the amount0 delta between two prices
 151 |     |     /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),
 152 |     |     /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))
 153 |     |     /// @param sqrtRatioAX96 A sqrt price
 154 |     |     /// @param sqrtRatioBX96 Another sqrt price
 155 |     |     /// @param liquidity The amount of usable liquidity
 156 |     |     /// @param roundUp Whether to round the amount up or down
 157 |     |     /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices
 158 | *   |     function getAmount0Delta(
 159 |     |         uint160 sqrtRatioAX96,
 160 |     |         uint160 sqrtRatioBX96,
 161 |     |         uint128 liquidity,
 162 |     |         bool roundUp
 163 | *   |     ) internal returns (uint256 amount0) {
 164 | *   |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 165 |     | 
 166 | *   |         emit Message("HERE9");
 167 | *   |         uint256 numerator1;
 168 |     |         unchecked {
 169 | *   |             numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
 170 |     |         }
 171 | *   |         emit MessageUint256("numerator1", numerator1);
 172 | *   |         uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;
 173 | *   |         emit MessageUint256("numerator2", numerator2);
 174 | *   |         require(sqrtRatioAX96 > 0);
 175 |     | 
 176 | *   |         return
 177 | *   |             roundUp
 178 | *   |                 ? UnsafeMath.divRoundingUp(
 179 | *   |                     FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),
 180 | *   |                     sqrtRatioAX96
 181 |     |                 )
 182 |     |                 : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;
 183 |     |     }
 184 |     | 
 185 |     |     /// @notice Gets the amount1 delta between two prices
 186 |     |     /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))
 187 |     |     /// @param sqrtRatioAX96 A sqrt price
 188 |     |     /// @param sqrtRatioBX96 Another sqrt price
 189 |     |     /// @param liquidity The amount of usable liquidity
 190 |     |     /// @param roundUp Whether to round the amount up, or down
 191 |     |     /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices
 192 | *   |     function getAmount1Delta(
 193 |     |         uint160 sqrtRatioAX96,
 194 |     |         uint160 sqrtRatioBX96,
 195 |     |         uint128 liquidity,
 196 |     |         bool roundUp
 197 | *   |     ) internal pure returns (uint256 amount1) {
 198 | *   |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 199 |     | 
 200 | *   |         return
 201 | *   |             roundUp
 202 | *   |                 ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)
 203 |     |                 : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
 204 |     |     }
 205 |     | 
 206 |     |     /// @notice Helper that gets signed token0 delta
 207 |     |     /// @param sqrtRatioAX96 A sqrt price
 208 |     |     /// @param sqrtRatioBX96 Another sqrt price
 209 |     |     /// @param liquidity The change in liquidity for which to compute the amount0 delta
 210 |     |     /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices
 211 | *   |     function getAmount0Delta(
 212 |     |         uint160 sqrtRatioAX96,
 213 |     |         uint160 sqrtRatioBX96,
 214 |     |         int128 liquidity
 215 | *   |     ) internal  returns (int256 amount0) {
 216 | *   |         return
 217 | *   |             liquidity < 0
 218 |     |                 ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()
 219 | *   |                 : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
 220 |     |     }
 221 |     | 
 222 |     |     /// @notice Helper that gets signed token1 delta
 223 |     |     /// @param sqrtRatioAX96 A sqrt price
 224 |     |     /// @param sqrtRatioBX96 Another sqrt price
 225 |     |     /// @param liquidity The change in liquidity for which to compute the amount1 delta
 226 |     |     /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices
 227 | *   |     function getAmount1Delta(
 228 |     |         uint160 sqrtRatioAX96,
 229 |     |         uint160 sqrtRatioBX96,
 230 |     |         int128 liquidity
 231 | *   |     ) internal pure returns (int256 amount1) {
 232 | *   |         return
 233 | *   |             liquidity < 0
 234 |     |                 ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()
 235 | *   |                 : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
 236 |     |     }
 237 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/SwapMath.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import './FullMath.sol';
  5 |     | import './SqrtPriceMath.sol';
  6 |     | 
  7 |     | /// @title Computes the result of a swap within ticks
  8 |     | /// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.
  9 |     | library SwapMath {
 10 |     |     /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap
 11 |     |     /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive
 12 |     |     /// @param sqrtRatioCurrentX96 The current sqrt price of the pool
 13 |     |     /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred
 14 |     |     /// @param liquidity The usable liquidity
 15 |     |     /// @param amountRemaining How much input or output amount is remaining to be swapped in/out
 16 |     |     /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip
 17 |     |     /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target
 18 |     |     /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap
 19 |     |     /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap
 20 |     |     /// @return feeAmount The amount of input that will be taken as a fee
 21 |     |     function computeSwapStep(
 22 |     |         uint160 sqrtRatioCurrentX96,
 23 |     |         uint160 sqrtRatioTargetX96,
 24 |     |         uint128 liquidity,
 25 |     |         int256 amountRemaining,
 26 |     |         uint24 feePips
 27 |     |     )
 28 |     |         internal
 29 |     |         returns (
 30 |     |             uint160 sqrtRatioNextX96,
 31 |     |             uint256 amountIn,
 32 |     |             uint256 amountOut,
 33 |     |             uint256 feeAmount
 34 |     |         )
 35 |     |     {
 36 |     |         bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;
 37 |     |         bool exactIn = amountRemaining >= 0;
 38 |     | 
 39 |     |         if (exactIn) {
 40 |     |             uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);
 41 |     |             amountIn = zeroForOne
 42 |     |                 ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)
 43 |     |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);
 44 |     |             if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;
 45 |     |             else
 46 |     |                 sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(
 47 |     |                     sqrtRatioCurrentX96,
 48 |     |                     liquidity,
 49 |     |                     amountRemainingLessFee,
 50 |     |                     zeroForOne
 51 |     |                 );
 52 |     |         } else {
 53 |     |             amountOut = zeroForOne
 54 |     |                 ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)
 55 |     |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);
 56 |     |             if (uint256(-amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;
 57 |     |             else
 58 |     |                 sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(
 59 |     |                     sqrtRatioCurrentX96,
 60 |     |                     liquidity,
 61 |     |                     uint256(-amountRemaining),
 62 |     |                     zeroForOne
 63 |     |                 );
 64 |     |         }
 65 |     | 
 66 |     |         bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;
 67 |     | 
 68 |     |         // get the input/output amounts
 69 |     |         if (zeroForOne) {
 70 |     |             amountIn = max && exactIn
 71 |     |                 ? amountIn
 72 |     |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);
 73 |     |             amountOut = max && !exactIn
 74 |     |                 ? amountOut
 75 |     |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);
 76 |     |         } else {
 77 |     |             amountIn = max && exactIn
 78 |     |                 ? amountIn
 79 |     |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);
 80 |     |             amountOut = max && !exactIn
 81 |     |                 ? amountOut
 82 |     |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);
 83 |     |         }
 84 |     | 
 85 |     |         // cap the output amount to not exceed the remaining output amount
 86 |     |         if (!exactIn && amountOut > uint256(-amountRemaining)) {
 87 |     |             amountOut = uint256(-amountRemaining);
 88 |     |         }
 89 |     | 
 90 |     |         if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {
 91 |     |             // we didn't reach the target, so take the remainder of the maximum input as fee
 92 |     |             feeAmount = uint256(amountRemaining) - amountIn;
 93 |     |         } else {
 94 |     |             feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);
 95 |     |         }
 96 |     |     }
 97 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/Tick.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import './LowGasSafeMath.sol';
   5 |     | import './SafeCast.sol';
   6 |     | 
   7 |     | import './TickMath.sol';
   8 |     | import './LiquidityMath.sol';
   9 |     | 
  10 |     | /// @title Tick
  11 |     | /// @notice Contains functions for managing tick processes and relevant calculations
  12 |     | library Tick {
  13 |     |     using LowGasSafeMath for int256;
  14 |     |     using SafeCast for int256;
  15 |     | 
  16 |     |     // info stored for each initialized individual tick
  17 |     |     struct Info {
  18 |     |         // the total position liquidity that references this tick
  19 |     |         uint128 liquidityGross;
  20 |     |         // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
  21 |     |         int128 liquidityNet;
  22 |     |         // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
  23 |     |         // only has relative meaning, not absolute  the value depends on when the tick is initialized
  24 |     |         uint256 feeGrowthOutside0X128;
  25 |     |         uint256 feeGrowthOutside1X128;
  26 |     |         // the cumulative tick value on the other side of the tick
  27 |     |         int56 tickCumulativeOutside;
  28 |     |         // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
  29 |     |         // only has relative meaning, not absolute  the value depends on when the tick is initialized
  30 |     |         uint160 secondsPerLiquidityOutsideX128;
  31 |     |         // the seconds spent on the other side of the tick (relative to the current tick)
  32 |     |         // only has relative meaning, not absolute  the value depends on when the tick is initialized
  33 |     |         uint32 secondsOutside;
  34 |     |         // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0
  35 |     |         // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks
  36 |     |         bool initialized;
  37 |     |     }
  38 |     | 
  39 |     |     /// @notice Derives max liquidity per tick from given tick spacing
  40 |     |     /// @dev Executed within the pool constructor
  41 |     |     /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`
  42 |     |     ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...
  43 |     |     /// @return The max liquidity per tick
  44 | *   |     function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {
  45 | *   |         int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;
  46 | *   |         int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;
  47 | *   |         uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;
  48 | *   |         return type(uint128).max / numTicks;
  49 |     |     }
  50 |     | 
  51 |     |     /// @notice Retrieves fee growth data
  52 |     |     /// @param self The mapping containing all tick information for initialized ticks
  53 |     |     /// @param tickLower The lower tick boundary of the position
  54 |     |     /// @param tickUpper The upper tick boundary of the position
  55 |     |     /// @param tickCurrent The current tick
  56 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
  57 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
  58 |     |     /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
  59 |     |     /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
  60 | *   |     function getFeeGrowthInside(
  61 |     |         mapping(int24 => Tick.Info) storage self,
  62 |     |         int24 tickLower,
  63 |     |         int24 tickUpper,
  64 |     |         int24 tickCurrent,
  65 |     |         uint256 feeGrowthGlobal0X128,
  66 |     |         uint256 feeGrowthGlobal1X128
  67 | *   |     ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {
  68 | *   |         Info storage lower = self[tickLower];
  69 | *   |         Info storage upper = self[tickUpper];
  70 |     | 
  71 |     |         // calculate fee growth below
  72 | *   |         uint256 feeGrowthBelow0X128;
  73 | *   |         uint256 feeGrowthBelow1X128;
  74 | *   |         if (tickCurrent >= tickLower) {
  75 | *   |             feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;
  76 | *   |             feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;
  77 |     |         } else {
  78 |     |             feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;
  79 |     |             feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;
  80 |     |         }
  81 |     | 
  82 |     |         // calculate fee growth above
  83 | *   |         uint256 feeGrowthAbove0X128;
  84 | *   |         uint256 feeGrowthAbove1X128;
  85 | *   |         if (tickCurrent < tickUpper) {
  86 | *   |             feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;
  87 | *   |             feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;
  88 |     |         } else {
  89 |     |             feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;
  90 |     |             feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;
  91 |     |         }
  92 |     | 
  93 | *   |         feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;
  94 | *   |         feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;
  95 |     |     }
  96 |     | 
  97 |     |     /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa
  98 |     |     /// @param self The mapping containing all tick information for initialized ticks
  99 |     |     /// @param tick The tick that will be updated
 100 |     |     /// @param tickCurrent The current tick
 101 |     |     /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)
 102 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
 103 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
 104 |     |     /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool
 105 |     |     /// @param tickCumulative The tick * time elapsed since the pool was first initialized
 106 |     |     /// @param time The current block timestamp cast to a uint32
 107 |     |     /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick
 108 |     |     /// @param maxLiquidity The maximum liquidity allocation for a single tick
 109 |     |     /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa
 110 | *   |     function update(
 111 |     |         mapping(int24 => Tick.Info) storage self,
 112 |     |         int24 tick,
 113 |     |         int24 tickCurrent,
 114 |     |         int128 liquidityDelta,
 115 |     |         uint256 feeGrowthGlobal0X128,
 116 |     |         uint256 feeGrowthGlobal1X128,
 117 |     |         uint160 secondsPerLiquidityCumulativeX128,
 118 |     |         int56 tickCumulative,
 119 |     |         uint32 time,
 120 |     |         bool upper,
 121 |     |         uint128 maxLiquidity
 122 | *   |     ) internal returns (bool flipped) {
 123 | *   |         Tick.Info storage info = self[tick];
 124 |     | 
 125 | *   |         uint128 liquidityGrossBefore = info.liquidityGross;
 126 | *   |         uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);
 127 |     | 
 128 | *   |         require(liquidityGrossAfter <= maxLiquidity, 'LO');
 129 |     | 
 130 | *   |         flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);
 131 |     | 
 132 | *   |         if (liquidityGrossBefore == 0) {
 133 |     |             // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
 134 | *   |             if (tick <= tickCurrent) {
 135 | *   |                 info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;
 136 | *   |                 info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;
 137 | *   |                 info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;
 138 | *   |                 info.tickCumulativeOutside = tickCumulative;
 139 | *   |                 info.secondsOutside = time;
 140 |     |             }
 141 | *   |             info.initialized = true;
 142 |     |         }
 143 |     | 
 144 | *   |         info.liquidityGross = liquidityGrossAfter;
 145 |     | 
 146 |     |         // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)
 147 | *   |         info.liquidityNet = upper
 148 | *   |             ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()
 149 | *   |             : int256(info.liquidityNet).add(liquidityDelta).toInt128();
 150 |     |     }
 151 |     | 
 152 |     |     /// @notice Clears tick data
 153 |     |     /// @param self The mapping containing all initialized tick information for initialized ticks
 154 |     |     /// @param tick The tick that will be cleared
 155 |     |     function clear(mapping(int24 => Tick.Info) storage self, int24 tick) internal {
 156 |     |         delete self[tick];
 157 |     |     }
 158 |     | 
 159 |     |     /// @notice Transitions to next tick as needed by price movement
 160 |     |     /// @param self The mapping containing all tick information for initialized ticks
 161 |     |     /// @param tick The destination tick of the transition
 162 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
 163 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
 164 |     |     /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity
 165 |     |     /// @param tickCumulative The tick * time elapsed since the pool was first initialized
 166 |     |     /// @param time The current block.timestamp
 167 |     |     /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)
 168 |     |     function cross(
 169 |     |         mapping(int24 => Tick.Info) storage self,
 170 |     |         int24 tick,
 171 |     |         uint256 feeGrowthGlobal0X128,
 172 |     |         uint256 feeGrowthGlobal1X128,
 173 |     |         uint160 secondsPerLiquidityCumulativeX128,
 174 |     |         int56 tickCumulative,
 175 |     |         uint32 time
 176 |     |     ) internal returns (int128 liquidityNet) {
 177 |     |         Tick.Info storage info = self[tick];
 178 |     |         info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;
 179 |     |         info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;
 180 |     |         info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128 - info.secondsPerLiquidityOutsideX128;
 181 |     |         info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;
 182 |     |         info.secondsOutside = time - info.secondsOutside;
 183 |     |         liquidityNet = info.liquidityNet;
 184 |     |     }
 185 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/TickBitmap.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import './BitMath.sol';
  5 |     | 
  6 |     | /// @title Packed tick initialized state library
  7 |     | /// @notice Stores a packed mapping of tick index to its initialized state
  8 |     | /// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.
  9 |     | library TickBitmap {
 10 |     |     /// @notice Computes the position in the mapping where the initialized bit for a tick lives
 11 |     |     /// @param tick The tick for which to compute the position
 12 |     |     /// @return wordPos The key in the mapping containing the word in which the bit is stored
 13 |     |     /// @return bitPos The bit position in the word where the flag is stored
 14 | *   |     function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {
 15 | *   |         wordPos = int16(tick >> 8);
 16 | *   |         bitPos = uint8(uint24(tick % 256));
 17 |     |     }
 18 |     | 
 19 |     |     /// @notice Flips the initialized state for a given tick from false to true, or vice versa
 20 |     |     /// @param self The mapping in which to flip the tick
 21 |     |     /// @param tick The tick to flip
 22 |     |     /// @param tickSpacing The spacing between usable ticks
 23 | *   |     function flipTick(
 24 |     |         mapping(int16 => uint256) storage self,
 25 |     |         int24 tick,
 26 |     |         int24 tickSpacing
 27 | *   |     ) internal {
 28 | *   |         require(tick % tickSpacing == 0); // ensure that the tick is spaced
 29 | *   |         (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);
 30 | *   |         uint256 mask = 1 << bitPos;
 31 | *   |         self[wordPos] ^= mask;
 32 |     |     }
 33 |     | 
 34 |     |     /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either
 35 |     |     /// to the left (less than or equal to) or right (greater than) of the given tick
 36 |     |     /// @param self The mapping in which to compute the next initialized tick
 37 |     |     /// @param tick The starting tick
 38 |     |     /// @param tickSpacing The spacing between usable ticks
 39 |     |     /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)
 40 |     |     /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick
 41 |     |     /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks
 42 |     |     function nextInitializedTickWithinOneWord(
 43 |     |         mapping(int16 => uint256) storage self,
 44 |     |         int24 tick,
 45 |     |         int24 tickSpacing,
 46 |     |         bool lte
 47 |     |     ) internal view returns (int24 next, bool initialized) {
 48 |     |         int24 compressed = tick / tickSpacing;
 49 |     |         if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity
 50 |     | 
 51 |     |         if (lte) {
 52 |     |             (int16 wordPos, uint8 bitPos) = position(compressed);
 53 |     |             // all the 1s at or to the right of the current bitPos
 54 |     |             uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);
 55 |     |             uint256 masked = self[wordPos] & mask;
 56 |     | 
 57 |     |             // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word
 58 |     |             initialized = masked != 0;
 59 |     |             // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
 60 |     |             next = initialized
 61 |     |                 ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing
 62 |     |                 : (compressed - int24(uint24(bitPos))) * tickSpacing;
 63 |     |         } else {
 64 |     |             // start from the word of the next tick, since the current tick state doesn't matter
 65 |     |             (int16 wordPos, uint8 bitPos) = position(compressed + 1);
 66 |     |             // all the 1s at or to the left of the bitPos
 67 |     |             uint256 mask = ~((1 << bitPos) - 1);
 68 |     |             uint256 masked = self[wordPos] & mask;
 69 |     | 
 70 |     |             // if there are no initialized ticks to the left of the current tick, return leftmost in the word
 71 |     |             initialized = masked != 0;
 72 |     |             // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
 73 |     |             next = initialized
 74 |     |                 ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing
 75 |     |                 : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;
 76 |     |         }
 77 |     |     }
 78 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/TickMath.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @title Math library for computing sqrt prices from ticks and vice versa
   5 |     | /// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
   6 |     | /// prices between 2**-128 and 2**128
   7 |     | library TickMath {
   8 |     |     /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
   9 | *   |     int24 internal constant MIN_TICK = -887272;
  10 |     |     /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
  11 | *   |     int24 internal constant MAX_TICK = -MIN_TICK;
  12 |     | 
  13 |     |     /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
  14 | *   |     uint160 internal constant MIN_SQRT_RATIO = 4295128739;
  15 |     |     /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
  16 | *   |     uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
  17 |     | 
  18 |     |     /// @notice Calculates sqrt(1.0001^tick) * 2^96
  19 |     |     /// @dev Throws if |tick| > max tick
  20 |     |     /// @param tick The input tick for the above formula
  21 |     |     /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
  22 |     |     /// at the given tick
  23 | *   |     function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
  24 | *   |         uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
  25 | *   |         require(absTick <= uint256(uint24(MAX_TICK)), 'T');
  26 |     | 
  27 | *   |         uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
  28 | *   |         if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
  29 | *   |         if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
  30 | *   |         if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
  31 | *   |         if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
  32 | *   |         if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
  33 | *   |         if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
  34 | *   |         if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
  35 | *   |         if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
  36 | *   |         if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
  37 | *   |         if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
  38 | *   |         if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
  39 | *   |         if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
  40 | *   |         if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
  41 | *   |         if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
  42 | *   |         if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
  43 | *   |         if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
  44 | *   |         if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
  45 | *   |         if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
  46 | *   |         if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
  47 |     | 
  48 | *   |         if (tick > 0) ratio = type(uint256).max / ratio;
  49 |     | 
  50 |     |         // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
  51 |     |         // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
  52 |     |         // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
  53 | *   |         sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
  54 |     |     }
  55 |     | 
  56 |     |     /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
  57 |     |     /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
  58 |     |     /// ever return.
  59 |     |     /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
  60 |     |     /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
  61 | *   |     function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
  62 |     |         // second inequality must be < because the price can never reach the price at the max tick
  63 | *   |         require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
  64 | *   |         uint256 ratio = uint256(sqrtPriceX96) << 32;
  65 |     | 
  66 | *   |         uint256 r = ratio;
  67 | *   |         uint256 msb = 0;
  68 |     | 
  69 | *   |         assembly {
  70 | *   |             let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
  71 | *   |             msb := or(msb, f)
  72 | *   |             r := shr(f, r)
  73 |     |         }
  74 | *   |         assembly {
  75 | *   |             let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
  76 | *   |             msb := or(msb, f)
  77 | *   |             r := shr(f, r)
  78 |     |         }
  79 | *   |         assembly {
  80 | *   |             let f := shl(5, gt(r, 0xFFFFFFFF))
  81 | *   |             msb := or(msb, f)
  82 | *   |             r := shr(f, r)
  83 |     |         }
  84 | *   |         assembly {
  85 | *   |             let f := shl(4, gt(r, 0xFFFF))
  86 | *   |             msb := or(msb, f)
  87 | *   |             r := shr(f, r)
  88 |     |         }
  89 | *   |         assembly {
  90 | *   |             let f := shl(3, gt(r, 0xFF))
  91 | *   |             msb := or(msb, f)
  92 | *   |             r := shr(f, r)
  93 |     |         }
  94 | *   |         assembly {
  95 | *   |             let f := shl(2, gt(r, 0xF))
  96 | *   |             msb := or(msb, f)
  97 | *   |             r := shr(f, r)
  98 |     |         }
  99 | *   |         assembly {
 100 | *   |             let f := shl(1, gt(r, 0x3))
 101 | *   |             msb := or(msb, f)
 102 | *   |             r := shr(f, r)
 103 |     |         }
 104 | *   |         assembly {
 105 | *   |             let f := gt(r, 0x1)
 106 | *   |             msb := or(msb, f)
 107 |     |         }
 108 |     | 
 109 | *   |         if (msb >= 128) r = ratio >> (msb - 127);
 110 |     |         else r = ratio << (127 - msb);
 111 |     | 
 112 | *   |         int256 log_2 = (int256(msb) - 128) << 64;
 113 |     | 
 114 | *   |         assembly {
 115 | *   |             r := shr(127, mul(r, r))
 116 | *   |             let f := shr(128, r)
 117 | *   |             log_2 := or(log_2, shl(63, f))
 118 | *   |             r := shr(f, r)
 119 |     |         }
 120 | *   |         assembly {
 121 | *   |             r := shr(127, mul(r, r))
 122 | *   |             let f := shr(128, r)
 123 | *   |             log_2 := or(log_2, shl(62, f))
 124 | *   |             r := shr(f, r)
 125 |     |         }
 126 | *   |         assembly {
 127 | *   |             r := shr(127, mul(r, r))
 128 | *   |             let f := shr(128, r)
 129 | *   |             log_2 := or(log_2, shl(61, f))
 130 | *   |             r := shr(f, r)
 131 |     |         }
 132 | *   |         assembly {
 133 | *   |             r := shr(127, mul(r, r))
 134 | *   |             let f := shr(128, r)
 135 | *   |             log_2 := or(log_2, shl(60, f))
 136 | *   |             r := shr(f, r)
 137 |     |         }
 138 | *   |         assembly {
 139 | *   |             r := shr(127, mul(r, r))
 140 | *   |             let f := shr(128, r)
 141 | *   |             log_2 := or(log_2, shl(59, f))
 142 | *   |             r := shr(f, r)
 143 |     |         }
 144 | *   |         assembly {
 145 | *   |             r := shr(127, mul(r, r))
 146 | *   |             let f := shr(128, r)
 147 | *   |             log_2 := or(log_2, shl(58, f))
 148 | *   |             r := shr(f, r)
 149 |     |         }
 150 | *   |         assembly {
 151 | *   |             r := shr(127, mul(r, r))
 152 | *   |             let f := shr(128, r)
 153 | *   |             log_2 := or(log_2, shl(57, f))
 154 | *   |             r := shr(f, r)
 155 |     |         }
 156 | *   |         assembly {
 157 | *   |             r := shr(127, mul(r, r))
 158 | *   |             let f := shr(128, r)
 159 | *   |             log_2 := or(log_2, shl(56, f))
 160 | *   |             r := shr(f, r)
 161 |     |         }
 162 | *   |         assembly {
 163 | *   |             r := shr(127, mul(r, r))
 164 | *   |             let f := shr(128, r)
 165 | *   |             log_2 := or(log_2, shl(55, f))
 166 | *   |             r := shr(f, r)
 167 |     |         }
 168 | *   |         assembly {
 169 | *   |             r := shr(127, mul(r, r))
 170 | *   |             let f := shr(128, r)
 171 | *   |             log_2 := or(log_2, shl(54, f))
 172 | *   |             r := shr(f, r)
 173 |     |         }
 174 | *   |         assembly {
 175 | *   |             r := shr(127, mul(r, r))
 176 | *   |             let f := shr(128, r)
 177 | *   |             log_2 := or(log_2, shl(53, f))
 178 | *   |             r := shr(f, r)
 179 |     |         }
 180 | *   |         assembly {
 181 | *   |             r := shr(127, mul(r, r))
 182 | *   |             let f := shr(128, r)
 183 | *   |             log_2 := or(log_2, shl(52, f))
 184 | *   |             r := shr(f, r)
 185 |     |         }
 186 | *   |         assembly {
 187 | *   |             r := shr(127, mul(r, r))
 188 | *   |             let f := shr(128, r)
 189 | *   |             log_2 := or(log_2, shl(51, f))
 190 | *   |             r := shr(f, r)
 191 |     |         }
 192 | *   |         assembly {
 193 | *   |             r := shr(127, mul(r, r))
 194 | *   |             let f := shr(128, r)
 195 | *   |             log_2 := or(log_2, shl(50, f))
 196 |     |         }
 197 |     | 
 198 | *   |         int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number
 199 |     | 
 200 | *   |         int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
 201 | *   |         int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
 202 |     | 
 203 | *   |         tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
 204 |     |     }
 205 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/TransferHelper.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | library TransferHelper {
  7 |     |     /// @notice Transfers tokens from the targeted address to the given destination
  8 |     |     /// @notice Errors with 'STF' if transfer fails
  9 |     |     /// @param token The contract address of the token to be transferred
 10 |     |     /// @param from The originating address from which the tokens will be transferred
 11 |     |     /// @param to The destination address of the transfer
 12 |     |     /// @param value The amount to be transferred
 13 |     |     function safeTransferFrom(address token, address from, address to, uint256 value) internal {
 14 |     |         (bool success, bytes memory data) = token.call(
 15 |     |             abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)
 16 |     |         );
 17 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "STF");
 18 |     |     }
 19 |     | 
 20 |     |     /// @notice Transfers tokens from msg.sender to a recipient
 21 |     |     /// @dev Errors with ST if transfer fails
 22 |     |     /// @param token The contract address of the token which will be transferred
 23 |     |     /// @param to The recipient of the transfer
 24 |     |     /// @param value The value of the transfer
 25 |     |     function safeTransfer(address token, address to, uint256 value) internal {
 26 |     |         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
 27 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "ST");
 28 |     |     }
 29 |     | 
 30 |     |     /// @notice Approves the stipulated contract to spend the given allowance in the given token
 31 |     |     /// @dev Errors with 'SA' if transfer fails
 32 |     |     /// @param token The contract address of the token to be approved
 33 |     |     /// @param to The target of the approval
 34 |     |     /// @param value The amount of the given token the target will be allowed to spend
 35 |     |     function safeApprove(address token, address to, uint256 value) internal {
 36 |     |         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));
 37 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "SA");
 38 |     |     }
 39 |     | 
 40 |     |     /// @notice Transfers ETH to the recipient address
 41 |     |     /// @dev Fails with `STE`
 42 |     |     /// @param to The destination of the transfer
 43 |     |     /// @param value The value to be transferred
 44 |     |     function safeTransferETH(address to, uint256 value) internal {
 45 |     |         (bool success, ) = to.call{ value: value }(new bytes(0));
 46 |     |         require(success, "STE");
 47 |     |     }
 48 |     | }
 49 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-core/libraries/UnsafeMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Math functions that do not check inputs or outputs
  5 |     | /// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks
  6 |     | library UnsafeMath {
  7 |     |     /// @notice Returns ceil(x / y)
  8 |     |     /// @dev division by 0 has unspecified behavior, and must be checked externally
  9 |     |     /// @param x The dividend
 10 |     |     /// @param y The divisor
 11 |     |     /// @return z The quotient, ceil(x / y)
 12 | *   |     function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
 13 |     |         assembly {
 14 | *   |             z := add(div(x, y), gt(mod(x, y), 0))
 15 |     |         }
 16 |     |     }
 17 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/NonfungiblePositionManager.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | pragma abicoder v2;
   4 |     | 
   5 |     | import "v3-core/interfaces/IUniswapV3Pool.sol";
   6 |     | import "v3-core/libraries/FixedPoint128.sol";
   7 |     | import "v3-core/libraries/FullMath.sol";
   8 |     | 
   9 |     | import "./interfaces/INonfungiblePositionManager.sol";
  10 |     | import "./interfaces/INonfungibleTokenPositionDescriptor.sol";
  11 |     | import "./libraries/PositionKey.sol";
  12 |     | import "./libraries/PoolAddress.sol";
  13 |     | import "./base/LiquidityManagement.sol";
  14 |     | import "./base/PeripheryImmutableState.sol";
  15 |     | import "./base/Multicall.sol";
  16 |     | import "./base/ERC721Permit.sol";
  17 |     | import "./base/PeripheryValidation.sol";
  18 |     | import "./base/SelfPermit.sol";
  19 |     | import "./base/PoolInitializer.sol";
  20 |     | 
  21 |     | /// @title NFT positions
  22 |     | /// @notice Wraps Uniswap V3 positions in the ERC721 non-fungible token interface
  23 | *   | contract NonfungiblePositionManager is
  24 |     |     INonfungiblePositionManager,
  25 |     |     Multicall,
  26 |     |     ERC721Permit,
  27 |     |     PeripheryImmutableState,
  28 |     |     PoolInitializer,
  29 |     |     LiquidityManagement,
  30 |     |     PeripheryValidation,
  31 |     |     SelfPermit
  32 |     | {
  33 |     |     // details about the uniswap position
  34 |     |     struct Position {
  35 |     |         // the nonce for permits
  36 |     |         uint96 nonce;
  37 |     |         // the address that is approved for spending this token
  38 |     |         address operator;
  39 |     |         // the ID of the pool with which this token is connected
  40 |     |         uint80 poolId;
  41 |     |         // the tick range of the position
  42 |     |         int24 tickLower;
  43 |     |         int24 tickUpper;
  44 |     |         // the liquidity of the position
  45 |     |         uint128 liquidity;
  46 |     |         // the fee growth of the aggregate position as of the last action on the individual position
  47 |     |         uint256 feeGrowthInside0LastX128;
  48 |     |         uint256 feeGrowthInside1LastX128;
  49 |     |         // how many uncollected tokens are owed to the position, as of the last computation
  50 |     |         uint128 tokensOwed0;
  51 |     |         uint128 tokensOwed1;
  52 |     |     }
  53 |     | 
  54 |     |     /// @dev IDs of pools assigned by this contract
  55 |     |     mapping(address => uint80) private _poolIds;
  56 |     | 
  57 |     |     /// @dev Pool keys by pool ID, to save on SSTOREs for position data
  58 |     |     mapping(uint80 => PoolAddress.PoolKey) private _poolIdToPoolKey;
  59 |     | 
  60 |     |     /// @dev The token ID position data
  61 |     |     mapping(uint256 => Position) private _positions;
  62 |     | 
  63 |     |     /// @dev The ID of the next token that will be minted. Skips 0
  64 | *   |     uint176 private _nextId = 1;
  65 |     |     /// @dev The ID of the next pool that is used for the first time. Skips 0
  66 | *   |     uint80 private _nextPoolId = 1;
  67 |     | 
  68 |     |     /// @dev The address of the token descriptor contract, which handles generating token URIs for position tokens
  69 |     |     address private immutable _tokenDescriptor;
  70 |     | 
  71 | *   |     constructor(
  72 |     |         address _factory,
  73 |     |         address _WETH9,
  74 |     |         address _tokenDescriptor_
  75 | *   |     ) ERC721Permit("Uniswap V3 Positions NFT-V1", "UNI-V3-POS", "1") PeripheryImmutableState(_factory, _WETH9) {
  76 | *   |         _tokenDescriptor = _tokenDescriptor_;
  77 |     |     }
  78 |     | 
  79 |     |     /// @inheritdoc INonfungiblePositionManager
  80 |     |     function positions(
  81 |     |         uint256 tokenId
  82 |     |     )
  83 |     |         external
  84 |     |         view
  85 |     |         override
  86 |     |         returns (
  87 |     |             uint96 nonce,
  88 |     |             address operator,
  89 |     |             address token0,
  90 |     |             address token1,
  91 |     |             uint24 fee,
  92 |     |             int24 tickLower,
  93 |     |             int24 tickUpper,
  94 |     |             uint128 liquidity,
  95 |     |             uint256 feeGrowthInside0LastX128,
  96 |     |             uint256 feeGrowthInside1LastX128,
  97 |     |             uint128 tokensOwed0,
  98 |     |             uint128 tokensOwed1
  99 |     |         )
 100 |     |     {
 101 |     |         Position memory position = _positions[tokenId];
 102 |     |         require(position.poolId != 0, "Invalid token ID");
 103 |     |         PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];
 104 |     |         return (
 105 |     |             position.nonce,
 106 |     |             position.operator,
 107 |     |             poolKey.token0,
 108 |     |             poolKey.token1,
 109 |     |             poolKey.fee,
 110 |     |             position.tickLower,
 111 |     |             position.tickUpper,
 112 |     |             position.liquidity,
 113 |     |             position.feeGrowthInside0LastX128,
 114 |     |             position.feeGrowthInside1LastX128,
 115 |     |             position.tokensOwed0,
 116 |     |             position.tokensOwed1
 117 |     |         );
 118 |     |     }
 119 |     | 
 120 |     |     /// @dev Caches a pool key
 121 | *   |     function cachePoolKey(address pool, PoolAddress.PoolKey memory poolKey) private returns (uint80 poolId) {
 122 | *   |         poolId = _poolIds[pool];
 123 | *   |         if (poolId == 0) {
 124 | *   |             _poolIds[pool] = (poolId = _nextPoolId++);
 125 | *   |             _poolIdToPoolKey[poolId] = poolKey;
 126 |     |         }
 127 |     |     }
 128 |     | 
 129 |     |     /// @inheritdoc INonfungiblePositionManager
 130 | *   |     function mint(
 131 |     |         MintParams calldata params
 132 |     |     )
 133 |     |         external
 134 |     |         payable
 135 |     |         override
 136 | *   |         checkDeadline(params.deadline)
 137 | *   |         returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)
 138 | *   |     {
 139 | *   |         IUniswapV3Pool pool;
 140 | *   |         (liquidity, amount0, amount1, pool) = addLiquidity(
 141 | *   |             AddLiquidityParams({
 142 | *   |                 token0: params.token0,
 143 | *   |                 token1: params.token1,
 144 | *   |                 fee: params.fee,
 145 | *   |                 recipient: address(this),
 146 | *   |                 tickLower: params.tickLower,
 147 | *   |                 tickUpper: params.tickUpper,
 148 | *   |                 amount0Desired: params.amount0Desired,
 149 | *   |                 amount1Desired: params.amount1Desired,
 150 | *   |                 amount0Min: params.amount0Min,
 151 | *   |                 amount1Min: params.amount1Min
 152 |     |             })
 153 |     |         );
 154 |     | 
 155 | *   |         _mint(params.recipient, (tokenId = _nextId++));
 156 |     | 
 157 | *   |         bytes32 positionKey = PositionKey.compute(address(this), params.tickLower, params.tickUpper);
 158 | *   |         (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey);
 159 |     | 
 160 |     |         // idempotent set
 161 | *   |         uint80 poolId = cachePoolKey(
 162 | *   |             address(pool),
 163 | *   |             PoolAddress.PoolKey({ token0: params.token0, token1: params.token1, fee: params.fee })
 164 |     |         );
 165 |     | 
 166 | *   |         _positions[tokenId] = Position({
 167 | *   |             nonce: 0,
 168 | *   |             operator: address(0),
 169 | *   |             poolId: poolId,
 170 | *   |             tickLower: params.tickLower,
 171 | *   |             tickUpper: params.tickUpper,
 172 | *   |             liquidity: liquidity,
 173 | *   |             feeGrowthInside0LastX128: feeGrowthInside0LastX128,
 174 | *   |             feeGrowthInside1LastX128: feeGrowthInside1LastX128,
 175 | *   |             tokensOwed0: 0,
 176 | *   |             tokensOwed1: 0
 177 |     |         });
 178 |     | 
 179 | *   |         emit IncreaseLiquidity(tokenId, liquidity, amount0, amount1);
 180 |     |     }
 181 |     | 
 182 |     |     modifier isAuthorizedForToken(uint256 tokenId) {
 183 |     |         require(_isApprovedOrOwner(msg.sender, tokenId), "Not approved");
 184 |     |         _;
 185 |     |     }
 186 |     | 
 187 |     |     function tokenURI(uint256 tokenId) public view override(ERC721, IERC721Metadata) returns (string memory) {
 188 |     |         require(_exists(tokenId));
 189 |     |         return INonfungibleTokenPositionDescriptor(_tokenDescriptor).tokenURI(this, tokenId);
 190 |     |     }
 191 |     | 
 192 |     |     // save bytecode by removing implementation of unused method
 193 |     |     function baseURI() public pure returns (string memory) {}
 194 |     | 
 195 |     |     /// @inheritdoc INonfungiblePositionManager
 196 |     |     function increaseLiquidity(
 197 |     |         IncreaseLiquidityParams calldata params
 198 |     |     )
 199 |     |         external
 200 |     |         payable
 201 |     |         override
 202 |     |         checkDeadline(params.deadline)
 203 |     |         returns (uint128 liquidity, uint256 amount0, uint256 amount1)
 204 |     |     {
 205 |     |         Position storage position = _positions[params.tokenId];
 206 |     | 
 207 |     |         PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];
 208 |     | 
 209 |     |         IUniswapV3Pool pool;
 210 |     |         (liquidity, amount0, amount1, pool) = addLiquidity(
 211 |     |             AddLiquidityParams({
 212 |     |                 token0: poolKey.token0,
 213 |     |                 token1: poolKey.token1,
 214 |     |                 fee: poolKey.fee,
 215 |     |                 tickLower: position.tickLower,
 216 |     |                 tickUpper: position.tickUpper,
 217 |     |                 amount0Desired: params.amount0Desired,
 218 |     |                 amount1Desired: params.amount1Desired,
 219 |     |                 amount0Min: params.amount0Min,
 220 |     |                 amount1Min: params.amount1Min,
 221 |     |                 recipient: address(this)
 222 |     |             })
 223 |     |         );
 224 |     | 
 225 |     |         bytes32 positionKey = PositionKey.compute(address(this), position.tickLower, position.tickUpper);
 226 |     | 
 227 |     |         // this is now updated to the current transaction
 228 |     |         (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey);
 229 |     | 
 230 |     |         position.tokensOwed0 += uint128(
 231 |     |             FullMath.mulDiv(
 232 |     |                 feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,
 233 |     |                 position.liquidity,
 234 |     |                 FixedPoint128.Q128
 235 |     |             )
 236 |     |         );
 237 |     |         position.tokensOwed1 += uint128(
 238 |     |             FullMath.mulDiv(
 239 |     |                 feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,
 240 |     |                 position.liquidity,
 241 |     |                 FixedPoint128.Q128
 242 |     |             )
 243 |     |         );
 244 |     | 
 245 |     |         position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;
 246 |     |         position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;
 247 |     |         position.liquidity += liquidity;
 248 |     | 
 249 |     |         emit IncreaseLiquidity(params.tokenId, liquidity, amount0, amount1);
 250 |     |     }
 251 |     | 
 252 |     |     /// @inheritdoc INonfungiblePositionManager
 253 |     |     function decreaseLiquidity(
 254 |     |         DecreaseLiquidityParams calldata params
 255 |     |     )
 256 |     |         external
 257 |     |         payable
 258 |     |         override
 259 |     |         isAuthorizedForToken(params.tokenId)
 260 |     |         checkDeadline(params.deadline)
 261 |     |         returns (uint256 amount0, uint256 amount1)
 262 |     |     {
 263 |     |         require(params.liquidity > 0);
 264 |     |         Position storage position = _positions[params.tokenId];
 265 |     | 
 266 |     |         uint128 positionLiquidity = position.liquidity;
 267 |     |         require(positionLiquidity >= params.liquidity);
 268 |     | 
 269 |     |         PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];
 270 |     |         IUniswapV3Pool pool = IUniswapV3Pool(
 271 |     |             IUniswapV3Factory(factory).getPool(poolKey.token0, poolKey.token1, poolKey.fee)
 272 |     |         );
 273 |     |         (amount0, amount1) = pool.burn(position.tickLower, position.tickUpper, params.liquidity);
 274 |     | 
 275 |     |         require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, "Price slippage check");
 276 |     | 
 277 |     |         bytes32 positionKey = PositionKey.compute(address(this), position.tickLower, position.tickUpper);
 278 |     |         // this is now updated to the current transaction
 279 |     |         (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey);
 280 |     | 
 281 |     |         position.tokensOwed0 +=
 282 |     |             uint128(amount0) +
 283 |     |             uint128(
 284 |     |                 FullMath.mulDiv(
 285 |     |                     feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,
 286 |     |                     positionLiquidity,
 287 |     |                     FixedPoint128.Q128
 288 |     |                 )
 289 |     |             );
 290 |     |         position.tokensOwed1 +=
 291 |     |             uint128(amount1) +
 292 |     |             uint128(
 293 |     |                 FullMath.mulDiv(
 294 |     |                     feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,
 295 |     |                     positionLiquidity,
 296 |     |                     FixedPoint128.Q128
 297 |     |                 )
 298 |     |             );
 299 |     | 
 300 |     |         position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;
 301 |     |         position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;
 302 |     |         // subtraction is safe because we checked positionLiquidity is gte params.liquidity
 303 |     |         position.liquidity = positionLiquidity - params.liquidity;
 304 |     | 
 305 |     |         emit DecreaseLiquidity(params.tokenId, params.liquidity, amount0, amount1);
 306 |     |     }
 307 |     | 
 308 |     |     /// @inheritdoc INonfungiblePositionManager
 309 |     |     function collect(
 310 |     |         CollectParams calldata params
 311 |     |     ) external payable override isAuthorizedForToken(params.tokenId) returns (uint256 amount0, uint256 amount1) {
 312 |     |         require(params.amount0Max > 0 || params.amount1Max > 0);
 313 |     |         // allow collecting to the nft position manager address with address 0
 314 |     |         address recipient = params.recipient == address(0) ? address(this) : params.recipient;
 315 |     | 
 316 |     |         Position storage position = _positions[params.tokenId];
 317 |     | 
 318 |     |         PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];
 319 |     | 
 320 |     |         IUniswapV3Pool pool = IUniswapV3Pool(
 321 |     |             IUniswapV3Factory(factory).getPool(poolKey.token0, poolKey.token1, poolKey.fee)
 322 |     |         );
 323 |     | 
 324 |     |         (uint128 tokensOwed0, uint128 tokensOwed1) = (position.tokensOwed0, position.tokensOwed1);
 325 |     | 
 326 |     |         // trigger an update of the position fees owed and fee growth snapshots if it has any liquidity
 327 |     |         if (position.liquidity > 0) {
 328 |     |             pool.burn(position.tickLower, position.tickUpper, 0);
 329 |     |             (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(
 330 |     |                 PositionKey.compute(address(this), position.tickLower, position.tickUpper)
 331 |     |             );
 332 |     | 
 333 |     |             tokensOwed0 += uint128(
 334 |     |                 FullMath.mulDiv(
 335 |     |                     feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,
 336 |     |                     position.liquidity,
 337 |     |                     FixedPoint128.Q128
 338 |     |                 )
 339 |     |             );
 340 |     |             tokensOwed1 += uint128(
 341 |     |                 FullMath.mulDiv(
 342 |     |                     feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,
 343 |     |                     position.liquidity,
 344 |     |                     FixedPoint128.Q128
 345 |     |                 )
 346 |     |             );
 347 |     | 
 348 |     |             position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;
 349 |     |             position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;
 350 |     |         }
 351 |     | 
 352 |     |         // compute the arguments to give to the pool#collect method
 353 |     |         (uint128 amount0Collect, uint128 amount1Collect) = (
 354 |     |             params.amount0Max > tokensOwed0 ? tokensOwed0 : params.amount0Max,
 355 |     |             params.amount1Max > tokensOwed1 ? tokensOwed1 : params.amount1Max
 356 |     |         );
 357 |     | 
 358 |     |         // the actual amounts collected are returned
 359 |     |         (amount0, amount1) = pool.collect(
 360 |     |             recipient,
 361 |     |             position.tickLower,
 362 |     |             position.tickUpper,
 363 |     |             amount0Collect,
 364 |     |             amount1Collect
 365 |     |         );
 366 |     | 
 367 |     |         // sometimes there will be a few less wei than expected due to rounding down in core, but we just subtract the full amount expected
 368 |     |         // instead of the actual amount so we can burn the token
 369 |     |         (position.tokensOwed0, position.tokensOwed1) = (tokensOwed0 - amount0Collect, tokensOwed1 - amount1Collect);
 370 |     | 
 371 |     |         emit Collect(params.tokenId, recipient, amount0Collect, amount1Collect);
 372 |     |     }
 373 |     | 
 374 |     |     /// @inheritdoc INonfungiblePositionManager
 375 |     |     function burn(uint256 tokenId) external payable override isAuthorizedForToken(tokenId) {
 376 |     |         Position storage position = _positions[tokenId];
 377 |     |         require(position.liquidity == 0 && position.tokensOwed0 == 0 && position.tokensOwed1 == 0, "Not cleared");
 378 |     |         delete _positions[tokenId];
 379 |     |         _burn(tokenId);
 380 |     |     }
 381 |     | 
 382 |     |     function _getAndIncrementNonce(uint256 tokenId) internal override returns (uint256) {
 383 |     |         return uint256(_positions[tokenId].nonce++);
 384 |     |     }
 385 |     | 
 386 |     |     /// @inheritdoc IERC721
 387 |     |     function getApproved(uint256 tokenId) public view override(ERC721, IERC721) returns (address) {
 388 |     |         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
 389 |     | 
 390 |     |         return _positions[tokenId].operator;
 391 |     |     }
 392 |     | 
 393 |     |     /// @dev Overrides _approve to use the operator in the position, which is packed with the position permit nonce
 394 |     |     function _approve(address to, uint256 tokenId) internal override(ERC721) {
 395 |     |         _positions[tokenId].operator = to;
 396 |     |         emit Approval(ownerOf(tokenId), to, tokenId);
 397 |     |     }
 398 |     | }
 399 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/SwapRouter02.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import "./base/SelfPermit.sol";
  6 |     | import "./base/PeripheryImmutableState.sol";
  7 |     | 
  8 |     | import "./interfaces/ISwapRouter02.sol";
  9 |     | import "./V2SwapRouter.sol";
 10 |     | import "./V3SwapRouter.sol";
 11 |     | import "uniswapv3/v3-periphery/base/ApproveAndCall.sol";
 12 |     | import "uniswapv3/v3-periphery/base/MulticallExtended.sol";
 13 |     | 
 14 |     | /// @title Uniswap V2 and V3 Swap Router
 15 |     | // contract SwapRouter02 is ISwapRouter02, V2SwapRouter, V3SwapRouter, ApproveAndCall, MulticallExtended, SelfPermit {
 16 | *   | contract SwapRouter02 is V3SwapRouter, ApproveAndCall, MulticallExtended, SelfPermit {
 17 | *   |     constructor(
 18 |     |         address _factoryV2,
 19 |     |         address factoryV3,
 20 |     |         address _positionManager,
 21 |     |         address _WETH9
 22 | *   |     ) ImmutableState(_factoryV2, _positionManager) PeripheryImmutableState(factoryV3, _WETH9) {}
 23 |     | }
 24 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/V2SwapRouter.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | // import "./libraries/LowGasSafeMath.sol";
  6 |     | // import "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";
  7 |     | 
  8 |     | // import "./interfaces/IV2SwapRouter.sol";
  9 |     | // import "./base/ImmutableState.sol";
 10 |     | // import "./base/PeripheryPaymentsWithFeeExtended.sol";
 11 |     | // import "./libraries/Constants.sol";
 12 |     | // import "./libraries/UniswapV2Library.sol";
 13 |     | 
 14 |     | // /// @title Uniswap V2 Swap Router
 15 |     | // /// @notice Router for stateless execution of swaps against Uniswap V2
 16 |     | // abstract contract V2SwapRouter is IV2SwapRouter, ImmutableState, PeripheryPaymentsWithFeeExtended {
 17 |     | //     using LowGasSafeMath for uint256;
 18 |     | 
 19 |     | //     // supports fee-on-transfer tokens
 20 |     | //     // requires the initial amount to have already been sent to the first pair
 21 |     | //     function _swap(address[] memory path, address _to) private {
 22 |     | //         for (uint256 i; i < path.length - 1; i++) {
 23 |     | //             (address input, address output) = (path[i], path[i + 1]);
 24 |     | //             (address token0, ) = UniswapV2Library.sortTokens(input, output);
 25 |     | //             IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factoryV2, input, output));
 26 |     | //             uint256 amountInput;
 27 |     | //             uint256 amountOutput;
 28 |     | //             // scope to avoid stack too deep errors
 29 |     | //             {
 30 |     | //                 (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();
 31 |     | //                 (uint256 reserveInput, uint256 reserveOutput) = input == token0
 32 |     | //                     ? (reserve0, reserve1)
 33 |     | //                     : (reserve1, reserve0);
 34 |     | //                 amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);
 35 |     | //                 amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);
 36 |     | //             }
 37 |     | //             (uint256 amount0Out, uint256 amount1Out) = input == token0
 38 |     | //                 ? (uint256(0), amountOutput)
 39 |     | //                 : (amountOutput, uint256(0));
 40 |     | //             address to = i < path.length - 2 ? UniswapV2Library.pairFor(factoryV2, output, path[i + 2]) : _to;
 41 |     | //             pair.swap(amount0Out, amount1Out, to, new bytes(0));
 42 |     | //         }
 43 |     | //     }
 44 |     | 
 45 |     | //     /// @inheritdoc IV2SwapRouter
 46 |     | //     function swapExactTokensForTokens(
 47 |     | //         uint256 amountIn,
 48 |     | //         uint256 amountOutMin,
 49 |     | //         address[] calldata path,
 50 |     | //         address to
 51 |     | //     ) external payable override returns (uint256 amountOut) {
 52 |     | //         // use amountIn == Constants.CONTRACT_BALANCE as a flag to swap the entire balance of the contract
 53 |     | //         bool hasAlreadyPaid;
 54 |     | //         if (amountIn == Constants.CONTRACT_BALANCE) {
 55 |     | //             hasAlreadyPaid = true;
 56 |     | //             amountIn = IERC20(path[0]).balanceOf(address(this));
 57 |     | //         }
 58 |     | 
 59 |     | //         pay(
 60 |     | //             path[0],
 61 |     | //             hasAlreadyPaid ? address(this) : msg.sender,
 62 |     | //             UniswapV2Library.pairFor(factoryV2, path[0], path[1]),
 63 |     | //             amountIn
 64 |     | //         );
 65 |     | 
 66 |     | //         // find and replace to addresses
 67 |     | //         if (to == Constants.MSG_SENDER) to = msg.sender;
 68 |     | //         else if (to == Constants.ADDRESS_THIS) to = address(this);
 69 |     | 
 70 |     | //         uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
 71 |     | 
 72 |     | //         _swap(path, to);
 73 |     | 
 74 |     | //         amountOut = IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore);
 75 |     | //         require(amountOut >= amountOutMin, "Too little received");
 76 |     | //     }
 77 |     | 
 78 |     | //     /// @inheritdoc IV2SwapRouter
 79 |     | //     function swapTokensForExactTokens(
 80 |     | //         uint256 amountOut,
 81 |     | //         uint256 amountInMax,
 82 |     | //         address[] calldata path,
 83 |     | //         address to
 84 |     | //     ) external payable override returns (uint256 amountIn) {
 85 |     | //         amountIn = UniswapV2Library.getAmountsIn(factoryV2, amountOut, path)[0];
 86 |     | //         require(amountIn <= amountInMax, "Too much requested");
 87 |     | 
 88 |     | //         pay(path[0], msg.sender, UniswapV2Library.pairFor(factoryV2, path[0], path[1]), amountIn);
 89 |     | 
 90 |     | //         // find and replace to addresses
 91 |     | //         if (to == Constants.MSG_SENDER) to = msg.sender;
 92 |     | //         else if (to == Constants.ADDRESS_THIS) to = address(this);
 93 |     | 
 94 |     | //         _swap(path, to);
 95 |     | //     }
 96 |     | // }
 97 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/V3SwapRouter.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity ^0.8.0;
   3 |     | pragma abicoder v2;
   4 |     | 
   5 |     | import "uniswapv3/v3-core/libraries/SafeCast.sol";
   6 |     | import "uniswapv3/v3-core/libraries/TickMath.sol";
   7 |     | import "uniswapv3/v3-core/interfaces/IUniswapV3Pool.sol";
   8 |     | import "./libraries/Path.sol";
   9 |     | import "./libraries/PoolAddress.sol";
  10 |     | import "./libraries/CallbackValidation.sol";
  11 |     | import "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";
  12 |     | 
  13 |     | import "uniswapv3/v3-periphery/interfaces/IV3SwapRouter.sol";
  14 |     | import "uniswapv3/v3-periphery/base/PeripheryPaymentsWithFee.sol";
  15 |     | import "uniswapv3/v3-periphery/base/OracleSlippage.sol";
  16 |     | import "./libraries/Constants.sol";
  17 |     | import { PeripheryPaymentsWithFeeExtended } from "uniswapv3/v3-periphery/base/PeripheryPaymentsWithFeeExtended.sol";
  18 |     | 
  19 |     | import "forge-std/console.sol";
  20 |     | 
  21 |     | /// @title Uniswap V3 Swap Router
  22 |     | /// @notice Router for stateless execution of swaps against Uniswap V3
  23 |     | abstract contract V3SwapRouter is IV3SwapRouter, PeripheryPaymentsWithFeeExtended, OracleSlippage {
  24 |     |     using Path for bytes;
  25 |     |     using SafeCast for uint256;
  26 |     | 
  27 |     |     error V3InvalidSwap();
  28 |     | 
  29 |     |     /// @dev Used as the placeholder value for amountInCached, because the computed amount in for an exact output swap
  30 |     |     /// can never actually be this value
  31 | *   |     uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;
  32 |     | 
  33 |     |     /// @dev Transient storage variable used for returning the computed amount in for an exact output swap.
  34 | *   |     uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;
  35 |     | 
  36 |     |     /// @dev Returns the pool for the given token pair and fee. The pool contract may or may not exist.
  37 | *   |     function getPool(address tokenA, address tokenB, uint24 fee) public view returns (IUniswapV3Pool) {
  38 | *   |         console.log("factory", factory);
  39 | *   |         return IUniswapV3Pool(PoolAddress.computeAddress(factory, PoolAddress.getPoolKey(tokenA, tokenB, fee)));
  40 |     |     }
  41 |     | 
  42 |     |     struct SwapCallbackData {
  43 |     |         bytes path;
  44 |     |         address payer;
  45 |     |     }
  46 |     | 
  47 |     |     /// @inheritdoc IUniswapV3SwapCallback
  48 |     |     function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {
  49 |     |         if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); // swaps entirely within 0-liquidity regions are not supported
  50 |     |         SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));
  51 |     |         (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();
  52 |     |         CallbackValidation.verifyCallback(factory, tokenIn, tokenOut, fee);
  53 |     | 
  54 |     |         (bool isExactInput, uint256 amountToPay) = amount0Delta > 0
  55 |     |             ? (tokenIn < tokenOut, uint256(amount0Delta))
  56 |     |             : (tokenOut < tokenIn, uint256(amount1Delta));
  57 |     | 
  58 |     |         if (isExactInput) {
  59 |     |             pay(tokenIn, data.payer, msg.sender, amountToPay);
  60 |     |         } else {
  61 |     |             // either initiate the next swap or pay
  62 |     |             if (data.path.hasMultiplePools()) {
  63 |     |                 data.path = data.path.skipToken();
  64 |     |                 exactOutputInternal(amountToPay, msg.sender, 0, data);
  65 |     |             } else {
  66 |     |                 amountInCached = amountToPay;
  67 |     |                 // note that because exact output swaps are executed in reverse order, tokenOut is actually tokenIn
  68 |     |                 pay(tokenOut, data.payer, msg.sender, amountToPay);
  69 |     |             }
  70 |     |         }
  71 |     |     }
  72 |     | 
  73 |     |     /// @dev Performs a single exact input swap
  74 | *   |     function exactInputInternal(
  75 |     |         uint256 amountIn,
  76 |     |         address recipient,
  77 |     |         uint160 sqrtPriceLimitX96,
  78 |     |         SwapCallbackData memory data
  79 | *   |     ) private returns (uint256 amountOut) {
  80 |     |         // find and replace recipient addresses
  81 | *   |         if (recipient == Constants.MSG_SENDER) recipient = msg.sender;
  82 | *   |         else if (recipient == Constants.ADDRESS_THIS) recipient = address(this);
  83 |     | 
  84 | *   |         (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();
  85 |     | 
  86 | *   |         bool zeroForOne = tokenIn < tokenOut;
  87 |     | 
  88 | *   |         console.log("tokenIn", tokenIn);
  89 | *   |         console.log("tokenOut", tokenOut);
  90 | *   |         console.log("fee", fee);
  91 | *   |         console.log("pool", address(getPool(tokenIn, tokenOut, fee)));
  92 |     | 
  93 | *   |         (int256 amount0, int256 amount1) = getPool(tokenIn, tokenOut, fee).swap(
  94 | *   |             recipient,
  95 | *   |             zeroForOne,
  96 | *   |             amountIn.toInt256(),
  97 | *   |             sqrtPriceLimitX96 == 0
  98 | *   |                 ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)
  99 |     |                 : sqrtPriceLimitX96,
 100 | *   |             abi.encode(data)
 101 |     |         );
 102 |     | 
 103 |     |         return uint256(-(zeroForOne ? amount1 : amount0));
 104 |     |     }
 105 |     | 
 106 |     |     /// @inheritdoc IV3SwapRouter
 107 | *   |     function exactInputSingle(
 108 |     |         ExactInputSingleParams memory params
 109 | *   |     ) external payable override returns (uint256 amountOut) {
 110 |     |         // use amountIn == Constants.CONTRACT_BALANCE as a flag to swap the entire balance of the contract
 111 | *   |         bool hasAlreadyPaid;
 112 | *   |         if (params.amountIn == Constants.CONTRACT_BALANCE) {
 113 |     |             hasAlreadyPaid = true;
 114 |     |             params.amountIn = IERC20(params.tokenIn).balanceOf(address(this));
 115 |     |         }
 116 |     | 
 117 | *   |         amountOut = exactInputInternal(
 118 | *   |             params.amountIn,
 119 | *   |             params.recipient,
 120 | *   |             params.sqrtPriceLimitX96,
 121 | *   |             SwapCallbackData({
 122 | *   |                 path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut),
 123 | *   |                 payer: hasAlreadyPaid ? address(this) : msg.sender
 124 |     |             })
 125 |     |         );
 126 |     |         require(amountOut >= params.amountOutMinimum, "Too little received");
 127 |     |     }
 128 |     | 
 129 |     |     /// @inheritdoc IV3SwapRouter
 130 | *   |     function exactInput(ExactInputParams memory params) external payable override returns (uint256 amountOut) {
 131 |     |         // use amountIn == Constants.CONTRACT_BALANCE as a flag to swap the entire balance of the contract
 132 | *   |         bool hasAlreadyPaid;
 133 | *   |         if (params.amountIn == Constants.CONTRACT_BALANCE) {
 134 |     |             hasAlreadyPaid = true;
 135 |     |             (address tokenIn, , ) = params.path.decodeFirstPool();
 136 |     |             params.amountIn = IERC20(tokenIn).balanceOf(address(this));
 137 |     |         }
 138 |     | 
 139 | *   |         address payer = hasAlreadyPaid ? address(this) : msg.sender;
 140 |     | 
 141 | *   |         while (true) {
 142 | *   |             bool hasMultiplePools = params.path.hasMultiplePools();
 143 |     | 
 144 |     |             // the outputs of prior swaps become the inputs to subsequent ones
 145 | *   |             params.amountIn = exactInputInternal(
 146 | *   |                 params.amountIn,
 147 | *   |                 hasMultiplePools ? address(this) : params.recipient, // for intermediate swaps, this contract custodies
 148 | *   |                 0,
 149 | *   |                 SwapCallbackData({
 150 | *   |                     path: params.path.getFirstPool(), // only the first pool in the path is necessary
 151 | *   |                     payer: payer
 152 |     |                 })
 153 |     |             );
 154 |     | 
 155 |     |             // decide whether to continue or terminate
 156 |     |             if (hasMultiplePools) {
 157 |     |                 payer = address(this);
 158 |     |                 params.path = params.path.skipToken();
 159 |     |             } else {
 160 |     |                 amountOut = params.amountIn;
 161 |     |                 break;
 162 |     |             }
 163 |     |         }
 164 |     | 
 165 |     |         require(amountOut >= params.amountOutMinimum, "Too little received");
 166 |     |     }
 167 |     | 
 168 |     |     /// @dev Performs a single exact output swap
 169 |     |     function exactOutputInternal(
 170 |     |         uint256 amountOut,
 171 |     |         address recipient,
 172 |     |         uint160 sqrtPriceLimitX96,
 173 |     |         SwapCallbackData memory data
 174 |     |     ) private returns (uint256 amountIn) {
 175 |     |         // find and replace recipient addresses
 176 |     |         if (recipient == Constants.MSG_SENDER) recipient = msg.sender;
 177 |     |         else if (recipient == Constants.ADDRESS_THIS) recipient = address(this);
 178 |     | 
 179 |     |         (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();
 180 |     | 
 181 |     |         bool zeroForOne = tokenIn < tokenOut;
 182 |     | 
 183 |     |         (int256 amount0Delta, int256 amount1Delta) = getPool(tokenIn, tokenOut, fee).swap(
 184 |     |             recipient,
 185 |     |             zeroForOne,
 186 |     |             -amountOut.toInt256(),
 187 |     |             sqrtPriceLimitX96 == 0
 188 |     |                 ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)
 189 |     |                 : sqrtPriceLimitX96,
 190 |     |             abi.encode(data)
 191 |     |         );
 192 |     | 
 193 |     |         uint256 amountOutReceived;
 194 |     |         (amountIn, amountOutReceived) = zeroForOne
 195 |     |             ? (uint256(amount0Delta), uint256(-amount1Delta))
 196 |     |             : (uint256(amount1Delta), uint256(-amount0Delta));
 197 |     |         // it's technically possible to not receive the full output amount,
 198 |     |         // so if no price limit has been specified, require this possibility away
 199 |     |         if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);
 200 |     |     }
 201 |     | 
 202 |     |     /// @inheritdoc IV3SwapRouter
 203 |     |     function exactOutputSingle(
 204 |     |         ExactOutputSingleParams calldata params
 205 |     |     ) external payable override returns (uint256 amountIn) {
 206 |     |         // avoid an SLOAD by using the swap return data
 207 |     |         amountIn = exactOutputInternal(
 208 |     |             params.amountOut,
 209 |     |             params.recipient,
 210 |     |             params.sqrtPriceLimitX96,
 211 |     |             SwapCallbackData({ path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender })
 212 |     |         );
 213 |     | 
 214 |     |         require(amountIn <= params.amountInMaximum, "Too much requested");
 215 |     |         // has to be reset even though we don't use it in the single hop case
 216 |     |         amountInCached = DEFAULT_AMOUNT_IN_CACHED;
 217 |     |     }
 218 |     | 
 219 |     |     /// @inheritdoc IV3SwapRouter
 220 |     |     function exactOutput(ExactOutputParams calldata params) external payable override returns (uint256 amountIn) {
 221 |     |         exactOutputInternal(
 222 |     |             params.amountOut,
 223 |     |             params.recipient,
 224 |     |             0,
 225 |     |             SwapCallbackData({ path: params.path, payer: msg.sender })
 226 |     |         );
 227 |     | 
 228 |     |         amountIn = amountInCached;
 229 |     |         require(amountIn <= params.amountInMaximum, "Too much requested");
 230 |     |         amountInCached = DEFAULT_AMOUNT_IN_CACHED;
 231 |     |     }
 232 |     | }
 233 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/ApproveAndCall.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity ^0.8.0;
   3 |     | pragma abicoder v2;
   4 |     | 
   5 |     | import "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";
   6 |     | import "uniswapv3/v3-periphery/interfaces/INonfungiblePositionManager.sol";
   7 |     | 
   8 |     | import "../interfaces/IApproveAndCall.sol";
   9 |     | import "./ImmutableState.sol";
  10 |     | 
  11 |     | /// @title Approve and Call
  12 |     | /// @notice Allows callers to approve the Uniswap V3 position manager from this contract,
  13 |     | /// for any token, and then make calls into the position manager
  14 |     | abstract contract ApproveAndCall is IApproveAndCall, ImmutableState {
  15 |     |     function tryApprove(address token, uint256 amount) private returns (bool) {
  16 |     |         (bool success, bytes memory data) = token.call(
  17 |     |             abi.encodeWithSelector(IERC20.approve.selector, positionManager, amount)
  18 |     |         );
  19 |     |         return success && (data.length == 0 || abi.decode(data, (bool)));
  20 |     |     }
  21 |     | 
  22 |     |     /// @inheritdoc IApproveAndCall
  23 |     |     function getApprovalType(address token, uint256 amount) external override returns (ApprovalType) {
  24 |     |         // check existing approval
  25 |     |         if (IERC20(token).allowance(address(this), positionManager) >= amount) return ApprovalType.NOT_REQUIRED;
  26 |     | 
  27 |     |         // try type(uint256).max / type(uint256).max - 1
  28 |     |         if (tryApprove(token, type(uint256).max)) return ApprovalType.MAX;
  29 |     |         if (tryApprove(token, type(uint256).max - 1)) return ApprovalType.MAX_MINUS_ONE;
  30 |     | 
  31 |     |         // set approval to 0 (must succeed)
  32 |     |         require(tryApprove(token, 0));
  33 |     | 
  34 |     |         // try type(uint256).max / type(uint256).max - 1
  35 |     |         if (tryApprove(token, type(uint256).max)) return ApprovalType.ZERO_THEN_MAX;
  36 |     |         if (tryApprove(token, type(uint256).max - 1)) return ApprovalType.ZERO_THEN_MAX_MINUS_ONE;
  37 |     | 
  38 |     |         revert();
  39 |     |     }
  40 |     | 
  41 |     |     /// @inheritdoc IApproveAndCall
  42 |     |     function approveMax(address token) external payable override {
  43 |     |         require(tryApprove(token, type(uint256).max));
  44 |     |     }
  45 |     | 
  46 |     |     /// @inheritdoc IApproveAndCall
  47 |     |     function approveMaxMinusOne(address token) external payable override {
  48 |     |         require(tryApprove(token, type(uint256).max - 1));
  49 |     |     }
  50 |     | 
  51 |     |     /// @inheritdoc IApproveAndCall
  52 |     |     function approveZeroThenMax(address token) external payable override {
  53 |     |         require(tryApprove(token, 0));
  54 |     |         require(tryApprove(token, type(uint256).max));
  55 |     |     }
  56 |     | 
  57 |     |     /// @inheritdoc IApproveAndCall
  58 |     |     function approveZeroThenMaxMinusOne(address token) external payable override {
  59 |     |         require(tryApprove(token, 0));
  60 |     |         require(tryApprove(token, type(uint256).max - 1));
  61 |     |     }
  62 |     | 
  63 |     |     /// @inheritdoc IApproveAndCall
  64 |     |     function callPositionManager(bytes memory data) public payable override returns (bytes memory result) {
  65 |     |         bool success;
  66 |     |         (success, result) = positionManager.call(data);
  67 |     | 
  68 |     |         if (!success) {
  69 |     |             // Next 5 lines from https://ethereum.stackexchange.com/a/83577
  70 |     |             if (result.length < 68) revert();
  71 |     |             assembly {
  72 |     |                 result := add(result, 0x04)
  73 |     |             }
  74 |     |             revert(abi.decode(result, (string)));
  75 |     |         }
  76 |     |     }
  77 |     | 
  78 |     |     function balanceOf(address token) private view returns (uint256) {
  79 |     |         return IERC20(token).balanceOf(address(this));
  80 |     |     }
  81 |     | 
  82 |     |     /// @inheritdoc IApproveAndCall
  83 |     |     function mint(MintParams calldata params) external payable override returns (bytes memory result) {
  84 |     |         return
  85 |     |             callPositionManager(
  86 |     |                 abi.encodeWithSelector(
  87 |     |                     INonfungiblePositionManager.mint.selector,
  88 |     |                     INonfungiblePositionManager.MintParams({
  89 |     |                         token0: params.token0,
  90 |     |                         token1: params.token1,
  91 |     |                         fee: params.fee,
  92 |     |                         tickLower: params.tickLower,
  93 |     |                         tickUpper: params.tickUpper,
  94 |     |                         amount0Desired: balanceOf(params.token0),
  95 |     |                         amount1Desired: balanceOf(params.token1),
  96 |     |                         amount0Min: params.amount0Min,
  97 |     |                         amount1Min: params.amount1Min,
  98 |     |                         recipient: params.recipient,
  99 |     |                         deadline: type(uint256).max // deadline should be checked via multicall
 100 |     |                     })
 101 |     |                 )
 102 |     |             );
 103 |     |     }
 104 |     | 
 105 |     |     /// @inheritdoc IApproveAndCall
 106 |     |     function increaseLiquidity(
 107 |     |         IncreaseLiquidityParams calldata params
 108 |     |     ) external payable override returns (bytes memory result) {
 109 |     |         return
 110 |     |             callPositionManager(
 111 |     |                 abi.encodeWithSelector(
 112 |     |                     INonfungiblePositionManager.increaseLiquidity.selector,
 113 |     |                     INonfungiblePositionManager.IncreaseLiquidityParams({
 114 |     |                         tokenId: params.tokenId,
 115 |     |                         amount0Desired: balanceOf(params.token0),
 116 |     |                         amount1Desired: balanceOf(params.token1),
 117 |     |                         amount0Min: params.amount0Min,
 118 |     |                         amount1Min: params.amount1Min,
 119 |     |                         deadline: type(uint256).max // deadline should be checked via multicall
 120 |     |                     })
 121 |     |                 )
 122 |     |             );
 123 |     |     }
 124 |     | }
 125 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/BlockTimestamp.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Function for getting block timestamp
  5 |     | /// @dev Base contract that is overridden for tests
  6 |     | abstract contract BlockTimestamp {
  7 |     |     /// @dev Method that exists purely to be overridden for tests
  8 |     |     /// @return The current block timestamp
  9 | *   |     function _blockTimestamp() internal view virtual returns (uint256) {
 10 | *   |         return block.timestamp;
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/ERC721Permit.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts-v4/token/ERC721/extensions/ERC721Enumerable.sol";
  5 |     | import "@openzeppelin/contracts-v4/utils/Address.sol";
  6 |     | 
  7 |     | import "../libraries/ChainId.sol";
  8 |     | import "../interfaces/external/IERC1271.sol";
  9 |     | import "../interfaces/IERC721Permit.sol";
 10 |     | import "./BlockTimestamp.sol";
 11 |     | 
 12 |     | /// @title ERC721 with permit
 13 |     | /// @notice Nonfungible tokens that support an approve via signature, i.e. permit
 14 |     | abstract contract ERC721Permit is BlockTimestamp, ERC721Enumerable, IERC721Permit {
 15 |     |     /// @dev Gets the current nonce for a token ID and then increments it, returning the original value
 16 |     |     function _getAndIncrementNonce(uint256 tokenId) internal virtual returns (uint256);
 17 |     | 
 18 |     |     /// @dev The hash of the name used in the permit signature verification
 19 |     |     bytes32 private immutable nameHash;
 20 |     | 
 21 |     |     /// @dev The hash of the version string used in the permit signature verification
 22 |     |     bytes32 private immutable versionHash;
 23 |     | 
 24 |     |     /// @notice Computes the nameHash and versionHash
 25 | *   |     constructor(string memory name_, string memory symbol_, string memory version_) ERC721(name_, symbol_) {
 26 | *   |         nameHash = keccak256(bytes(name_));
 27 | *   |         versionHash = keccak256(bytes(version_));
 28 |     |     }
 29 |     | 
 30 |     |     /// @inheritdoc IERC721Permit
 31 |     |     function DOMAIN_SEPARATOR() public view override returns (bytes32) {
 32 |     |         return
 33 |     |             keccak256(
 34 |     |                 abi.encode(
 35 |     |                     // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')
 36 |     |                     0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,
 37 |     |                     nameHash,
 38 |     |                     versionHash,
 39 |     |                     ChainId.get(),
 40 |     |                     address(this)
 41 |     |                 )
 42 |     |             );
 43 |     |     }
 44 |     | 
 45 |     |     /// @inheritdoc IERC721Permit
 46 |     |     /// @dev Value is equal to keccak256("Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)");
 47 |     |     bytes32 public constant override PERMIT_TYPEHASH =
 48 |     |         0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;
 49 |     | 
 50 |     |     /// @inheritdoc IERC721Permit
 51 |     |     function permit(
 52 |     |         address spender,
 53 |     |         uint256 tokenId,
 54 |     |         uint256 deadline,
 55 |     |         uint8 v,
 56 |     |         bytes32 r,
 57 |     |         bytes32 s
 58 |     |     ) external payable override {
 59 |     |         require(_blockTimestamp() <= deadline, "Permit expired");
 60 |     | 
 61 |     |         bytes32 digest = keccak256(
 62 |     |             abi.encodePacked(
 63 |     |                 "\x19\x01",
 64 |     |                 DOMAIN_SEPARATOR(),
 65 |     |                 keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, _getAndIncrementNonce(tokenId), deadline))
 66 |     |             )
 67 |     |         );
 68 |     |         address owner = ownerOf(tokenId);
 69 |     |         require(spender != owner, "ERC721Permit: approval to current owner");
 70 |     | 
 71 |     |         if (Address.isContract(owner)) {
 72 |     |             require(IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e, "Unauthorized");
 73 |     |         } else {
 74 |     |             address recoveredAddress = ecrecover(digest, v, r, s);
 75 |     |             require(recoveredAddress != address(0), "Invalid signature");
 76 |     |             require(recoveredAddress == owner, "Unauthorized");
 77 |     |         }
 78 |     | 
 79 |     |         _approve(spender, tokenId);
 80 |     |     }
 81 |     | }
 82 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/ImmutableState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../interfaces/IImmutableState.sol";
  5 |     | 
  6 |     | /// @title Immutable state
  7 |     | /// @notice Immutable state used by the swap router
  8 |     | abstract contract ImmutableState is IImmutableState {
  9 |     |     /// @inheritdoc IImmutableState
 10 |     |     address public immutable override factoryV2;
 11 |     |     /// @inheritdoc IImmutableState
 12 |     |     address public immutable override positionManager;
 13 |     | 
 14 | *   |     constructor(address _factoryV2, address _positionManager) {
 15 | *   |         factoryV2 = _factoryV2;
 16 | *   |         positionManager = _positionManager;
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/LiquidityManagement.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import 'v3-core/interfaces/IUniswapV3Factory.sol';
  6 |     | import 'v3-core/interfaces/callback/IUniswapV3MintCallback.sol';
  7 |     | import 'v3-core/libraries/TickMath.sol';
  8 |     | 
  9 |     | import '../libraries/PoolAddress.sol';
 10 |     | import '../libraries/CallbackValidation.sol';
 11 |     | import '../libraries/LiquidityAmounts.sol';
 12 |     | 
 13 |     | import './PeripheryPayments.sol';
 14 |     | import './PeripheryImmutableState.sol';
 15 |     | 
 16 |     | /// @title Liquidity management functions
 17 |     | /// @notice Internal functions for safely managing liquidity in Uniswap V3
 18 |     | abstract contract LiquidityManagement is IUniswapV3MintCallback, PeripheryImmutableState, PeripheryPayments {
 19 |     |     struct MintCallbackData {
 20 |     |         PoolAddress.PoolKey poolKey;
 21 |     |         address payer;
 22 |     |     }
 23 |     | 
 24 |     |     /// @inheritdoc IUniswapV3MintCallback
 25 | *   |     function uniswapV3MintCallback(
 26 |     |         uint256 amount0Owed,
 27 |     |         uint256 amount1Owed,
 28 |     |         bytes calldata data
 29 | *   |     ) external override {
 30 | *   |         MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));
 31 | *   |         CallbackValidation.verifyCallback(factory, decoded.poolKey);
 32 |     | 
 33 | *   |         if (amount0Owed > 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);
 34 | *   |         if (amount1Owed > 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);
 35 |     |     }
 36 |     | 
 37 |     |     struct AddLiquidityParams {
 38 |     |         address token0;
 39 |     |         address token1;
 40 |     |         uint24 fee;
 41 |     |         address recipient;
 42 |     |         int24 tickLower;
 43 |     |         int24 tickUpper;
 44 |     |         uint256 amount0Desired;
 45 |     |         uint256 amount1Desired;
 46 |     |         uint256 amount0Min;
 47 |     |         uint256 amount1Min;
 48 |     |     }
 49 |     | 
 50 |     |     /// @notice Add liquidity to an initialized pool
 51 | *   |     function addLiquidity(AddLiquidityParams memory params)
 52 |     |         internal
 53 |     |         returns (
 54 | *   |             uint128 liquidity,
 55 | *   |             uint256 amount0,
 56 | *   |             uint256 amount1,
 57 | *   |             IUniswapV3Pool pool
 58 |     |         )
 59 | *   |     {
 60 | *   |         PoolAddress.PoolKey memory poolKey = PoolAddress.PoolKey({
 61 | *   |             token0: params.token0,
 62 | *   |             token1: params.token1,
 63 | *   |             fee: params.fee
 64 |     |         });
 65 |     | 
 66 | *   |         pool = IUniswapV3Pool(IUniswapV3Factory(factory).getPool(poolKey.token0, poolKey.token1, poolKey.fee));
 67 |     | 
 68 |     |         // compute the liquidity amount
 69 | *   |         {
 70 | *   |             (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
 71 | *   |             uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(params.tickLower);
 72 | *   |             uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(params.tickUpper);
 73 |     | 
 74 | *   |             liquidity = LiquidityAmounts.getLiquidityForAmounts(
 75 | *   |                 sqrtPriceX96,
 76 | *   |                 sqrtRatioAX96,
 77 | *   |                 sqrtRatioBX96,
 78 | *   |                 params.amount0Desired,
 79 | *   |                 params.amount1Desired
 80 |     |             );
 81 |     |         }
 82 |     | 
 83 | *   |         (amount0, amount1) = pool.mint(
 84 | *   |             params.recipient,
 85 | *   |             params.tickLower,
 86 | *   |             params.tickUpper,
 87 | *   |             liquidity,
 88 | *   |             abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))
 89 |     |         );
 90 |     | 
 91 | *   |         require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, 'Price slippage check');
 92 |     |     }
 93 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/Multicall.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import "../interfaces/IMulticall.sol";
  6 |     | 
  7 |     | /// @title Multicall
  8 |     | /// @notice Enables calling multiple methods in a single call to the contract
  9 |     | abstract contract Multicall is IMulticall {
 10 |     |     /// @inheritdoc IMulticall
 11 |     |     function multicall(bytes[] calldata data)
 12 |     |         public
 13 |     |         payable
 14 |     |         override
 15 |     |         returns (bytes[] memory results)
 16 |     |     {
 17 |     |         results = new bytes[](data.length);
 18 |     |         for (uint256 i = 0; i < data.length; i++) {
 19 |     |             (bool success, bytes memory result) = address(this).delegatecall(data[i]);
 20 |     | 
 21 |     |             if (!success) {
 22 |     |                 // Next 5 lines from https://ethereum.stackexchange.com/a/83577
 23 |     |                 if (result.length < 68) revert();
 24 |     |                 assembly {
 25 |     |                     result := add(result, 0x04)
 26 |     |                 }
 27 |     |                 revert(abi.decode(result, (string)));
 28 |     |             }
 29 |     | 
 30 |     |             results[i] = result;
 31 |     |         }
 32 |     |     }
 33 |     | }
 34 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/MulticallExtended.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import "uniswapv3/v3-periphery/base/Multicall.sol";
  6 |     | 
  7 |     | import "uniswapv3/v3-periphery/interfaces/IMulticallExtended.sol";
  8 |     | import "uniswapv3/v3-periphery/base/PeripheryValidationExtended.sol";
  9 |     | 
 10 |     | /// @title Multicall
 11 |     | /// @notice Enables calling multiple methods in a single call to the contract
 12 |     | abstract contract MulticallExtended is IMulticallExtended, Multicall, PeripheryValidationExtended {
 13 |     |     /// @inheritdoc IMulticallExtended
 14 |     |     function multicall(
 15 |     |         uint256 deadline,
 16 |     |         bytes[] calldata data
 17 |     |     ) external payable override checkDeadline(deadline) returns (bytes[] memory) {
 18 |     |         return multicall(data);
 19 |     |     }
 20 |     | 
 21 |     |     /// @inheritdoc IMulticallExtended
 22 |     |     function multicall(
 23 |     |         bytes32 previousBlockhash,
 24 |     |         bytes[] calldata data
 25 |     |     ) external payable override checkPreviousBlockhash(previousBlockhash) returns (bytes[] memory) {
 26 |     |         return multicall(data);
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/OracleSlippage.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity ^0.8.0;
   3 |     | pragma abicoder v2;
   4 |     | 
   5 |     | import "../interfaces/IOracleSlippage.sol";
   6 |     | 
   7 |     | import "uniswapv3/v3-periphery/base/PeripheryImmutableState.sol";
   8 |     | import "uniswapv3/v3-periphery/base/BlockTimestamp.sol";
   9 |     | import "uniswapv3/v3-periphery/libraries/Path.sol";
  10 |     | import "uniswapv3/v3-periphery/libraries/PoolAddress.sol";
  11 |     | import "uniswapv3/v3-core/interfaces/IUniswapV3Pool.sol";
  12 |     | import "uniswapv3/v3-periphery/libraries/OracleLibrary.sol";
  13 |     | 
  14 |     | abstract contract OracleSlippage is IOracleSlippage, PeripheryImmutableState, BlockTimestamp {
  15 |     |     using Path for bytes;
  16 |     | 
  17 |     |     /// @dev Returns the tick as of the beginning of the current block, and as of right now, for the given pool.
  18 |     |     function getBlockStartingAndCurrentTick(
  19 |     |         IUniswapV3Pool pool
  20 |     |     ) internal view returns (int24 blockStartingTick, int24 currentTick) {
  21 |     |         uint16 observationIndex;
  22 |     |         uint16 observationCardinality;
  23 |     |         (, currentTick, observationIndex, observationCardinality, , , ) = pool.slot0();
  24 |     | 
  25 |     |         // 2 observations are needed to reliably calculate the block starting tick
  26 |     |         require(observationCardinality > 1, "NEO");
  27 |     | 
  28 |     |         // If the latest observation occurred in the past, then no tick-changing trades have happened in this block
  29 |     |         // therefore the tick in `slot0` is the same as at the beginning of the current block.
  30 |     |         // We don't need to check if this observation is initialized - it is guaranteed to be.
  31 |     |         (uint32 observationTimestamp, int56 tickCumulative, , ) = pool.observations(observationIndex);
  32 |     |         if (observationTimestamp != uint32(_blockTimestamp())) {
  33 |     |             blockStartingTick = currentTick;
  34 |     |         } else {
  35 |     |             uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;
  36 |     |             (uint32 prevObservationTimestamp, int56 prevTickCumulative, , bool prevInitialized) = pool.observations(
  37 |     |                 prevIndex
  38 |     |             );
  39 |     | 
  40 |     |             require(prevInitialized, "ONI");
  41 |     | 
  42 |     |             uint32 delta = observationTimestamp - prevObservationTimestamp;
  43 |     |             blockStartingTick = int24((tickCumulative - prevTickCumulative) / int56(int32(delta)));
  44 |     |         }
  45 |     |     }
  46 |     | 
  47 |     |     /// @dev Virtual function to get pool addresses that can be overridden in tests.
  48 |     |     function getPoolAddress(
  49 |     |         address tokenA,
  50 |     |         address tokenB,
  51 |     |         uint24 fee
  52 |     |     ) internal view virtual returns (IUniswapV3Pool pool) {
  53 |     |         pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, PoolAddress.getPoolKey(tokenA, tokenB, fee)));
  54 |     |     }
  55 |     | 
  56 |     |     /// @dev Returns the synthetic time-weighted average tick as of secondsAgo, as well as the current tick,
  57 |     |     /// for the given path. Returned synthetic ticks always represent tokenOut/tokenIn prices,
  58 |     |     /// meaning lower ticks are worse.
  59 |     |     function getSyntheticTicks(
  60 |     |         bytes memory path,
  61 |     |         uint32 secondsAgo
  62 |     |     ) internal view returns (int256 syntheticAverageTick, int256 syntheticCurrentTick) {
  63 |     |         bool lowerTicksAreWorse;
  64 |     | 
  65 |     |         uint256 numPools = path.numPools();
  66 |     |         address previousTokenIn;
  67 |     |         for (uint256 i = 0; i < numPools; i++) {
  68 |     |             // this assumes the path is sorted in swap order
  69 |     |             (address tokenIn, address tokenOut, uint24 fee) = path.decodeFirstPool();
  70 |     |             IUniswapV3Pool pool = getPoolAddress(tokenIn, tokenOut, fee);
  71 |     | 
  72 |     |             // get the average and current ticks for the current pool
  73 |     |             int256 averageTick;
  74 |     |             int256 currentTick;
  75 |     |             if (secondsAgo == 0) {
  76 |     |                 // we optimize for the secondsAgo == 0 case, i.e. since the beginning of the block
  77 |     |                 (averageTick, currentTick) = getBlockStartingAndCurrentTick(pool);
  78 |     |             } else {
  79 |     |                 (averageTick, ) = OracleLibrary.consult(address(pool), secondsAgo);
  80 |     |                 (, currentTick, , , , , ) = IUniswapV3Pool(pool).slot0();
  81 |     |             }
  82 |     | 
  83 |     |             if (i == numPools - 1) {
  84 |     |                 // if we're here, this is the last pool in the path, meaning tokenOut represents the
  85 |     |                 // destination token. so, if tokenIn < tokenOut, then tokenIn is token0 of the last pool,
  86 |     |                 // meaning the current running ticks are going to represent tokenOut/tokenIn prices.
  87 |     |                 // so, the lower these prices get, the worse of a price the swap will get
  88 |     |                 lowerTicksAreWorse = tokenIn < tokenOut;
  89 |     |             } else {
  90 |     |                 // if we're here, we need to iterate over the next pool in the path
  91 |     |                 path = path.skipToken();
  92 |     |                 previousTokenIn = tokenIn;
  93 |     |             }
  94 |     | 
  95 |     |             // accumulate the ticks derived from the current pool into the running synthetic ticks,
  96 |     |             // ensuring that intermediate tokens "cancel out"
  97 |     |             bool add = (i == 0) || (previousTokenIn < tokenIn ? tokenIn < tokenOut : tokenOut < tokenIn);
  98 |     |             if (add) {
  99 |     |                 syntheticAverageTick += averageTick;
 100 |     |                 syntheticCurrentTick += currentTick;
 101 |     |             } else {
 102 |     |                 syntheticAverageTick -= averageTick;
 103 |     |                 syntheticCurrentTick -= currentTick;
 104 |     |             }
 105 |     |         }
 106 |     | 
 107 |     |         // flip the sign of the ticks if necessary, to ensure that the lower ticks are always worse
 108 |     |         if (!lowerTicksAreWorse) {
 109 |     |             syntheticAverageTick *= -1;
 110 |     |             syntheticCurrentTick *= -1;
 111 |     |         }
 112 |     |     }
 113 |     | 
 114 |     |     /// @dev Cast a int256 to a int24, revert on overflow or underflow
 115 |     |     function toInt24(int256 y) private pure returns (int24 z) {
 116 |     |         require((z = int24(y)) == y);
 117 |     |     }
 118 |     | 
 119 |     |     /// @dev For each passed path, fetches the synthetic time-weighted average tick as of secondsAgo,
 120 |     |     /// as well as the current tick. Then, synthetic ticks from all paths are subjected to a weighted
 121 |     |     /// average, where the weights are the fraction of the total input amount allocated to each path.
 122 |     |     /// Returned synthetic ticks always represent tokenOut/tokenIn prices, meaning lower ticks are worse.
 123 |     |     /// Paths must all start and end in the same token.
 124 |     |     function getSyntheticTicks(
 125 |     |         bytes[] memory paths,
 126 |     |         uint128[] memory amounts,
 127 |     |         uint32 secondsAgo
 128 |     |     ) internal view returns (int256 averageSyntheticAverageTick, int256 averageSyntheticCurrentTick) {
 129 |     |         require(paths.length == amounts.length);
 130 |     | 
 131 |     |         OracleLibrary.WeightedTickData[] memory weightedSyntheticAverageTicks = new OracleLibrary.WeightedTickData[](
 132 |     |             paths.length
 133 |     |         );
 134 |     |         OracleLibrary.WeightedTickData[] memory weightedSyntheticCurrentTicks = new OracleLibrary.WeightedTickData[](
 135 |     |             paths.length
 136 |     |         );
 137 |     | 
 138 |     |         for (uint256 i = 0; i < paths.length; i++) {
 139 |     |             (int256 syntheticAverageTick, int256 syntheticCurrentTick) = getSyntheticTicks(paths[i], secondsAgo);
 140 |     |             weightedSyntheticAverageTicks[i].tick = toInt24(syntheticAverageTick);
 141 |     |             weightedSyntheticCurrentTicks[i].tick = toInt24(syntheticCurrentTick);
 142 |     |             weightedSyntheticAverageTicks[i].weight = amounts[i];
 143 |     |             weightedSyntheticCurrentTicks[i].weight = amounts[i];
 144 |     |         }
 145 |     | 
 146 |     |         averageSyntheticAverageTick = OracleLibrary.getWeightedArithmeticMeanTick(weightedSyntheticAverageTicks);
 147 |     |         averageSyntheticCurrentTick = OracleLibrary.getWeightedArithmeticMeanTick(weightedSyntheticCurrentTicks);
 148 |     |     }
 149 |     | 
 150 |     |     /// @inheritdoc IOracleSlippage
 151 |     |     function checkOracleSlippage(
 152 |     |         bytes memory path,
 153 |     |         uint24 maximumTickDivergence,
 154 |     |         uint32 secondsAgo
 155 |     |     ) external view override {
 156 |     |         (int256 syntheticAverageTick, int256 syntheticCurrentTick) = getSyntheticTicks(path, secondsAgo);
 157 |     |         require(syntheticAverageTick - syntheticCurrentTick < int256(int24(maximumTickDivergence)), "TD");
 158 |     |     }
 159 |     | 
 160 |     |     /// @inheritdoc IOracleSlippage
 161 |     |     function checkOracleSlippage(
 162 |     |         bytes[] memory paths,
 163 |     |         uint128[] memory amounts,
 164 |     |         uint24 maximumTickDivergence,
 165 |     |         uint32 secondsAgo
 166 |     |     ) external view override {
 167 |     |         (int256 averageSyntheticAverageTick, int256 averageSyntheticCurrentTick) = getSyntheticTicks(
 168 |     |             paths,
 169 |     |             amounts,
 170 |     |             secondsAgo
 171 |     |         );
 172 |     |         require(averageSyntheticAverageTick - averageSyntheticCurrentTick < int256(int24(maximumTickDivergence)), "TD");
 173 |     |     }
 174 |     | }
 175 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/PeripheryImmutableState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../interfaces/IPeripheryImmutableState.sol";
  5 |     | 
  6 |     | /// @title Immutable state
  7 |     | /// @notice Immutable state used by periphery contracts
  8 |     | abstract contract PeripheryImmutableState is IPeripheryImmutableState {
  9 |     |     /// @inheritdoc IPeripheryImmutableState
 10 |     |     address public immutable override factory;
 11 |     |     /// @inheritdoc IPeripheryImmutableState
 12 |     |     address public immutable override WETH9;
 13 |     | 
 14 | *   |     constructor(address _factory, address _WETH9) {
 15 | *   |         factory = _factory;
 16 | *   |         WETH9 = _WETH9;
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/PeripheryPayments.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | import "../interfaces/IPeripheryPayments.sol";
  7 |     | import "../interfaces/external/IWETH9.sol";
  8 |     | 
  9 |     | import "../libraries/TransferHelper.sol";
 10 |     | 
 11 |     | import "./PeripheryImmutableState.sol";
 12 |     | 
 13 |     | abstract contract PeripheryPayments is IPeripheryPayments, PeripheryImmutableState {
 14 |     |     receive() external payable {
 15 |     |         require(msg.sender == WETH9, "Not WETH9");
 16 |     |     }
 17 |     | 
 18 |     |     /// @inheritdoc IPeripheryPayments
 19 |     |     function unwrapWETH9(uint256 amountMinimum, address recipient) public payable override {
 20 |     |         uint256 balanceWETH9 = IWETH9(WETH9).balanceOf(address(this));
 21 |     |         require(balanceWETH9 >= amountMinimum, "Insufficient WETH9");
 22 |     | 
 23 |     |         if (balanceWETH9 > 0) {
 24 |     |             IWETH9(WETH9).withdraw(balanceWETH9);
 25 |     |             TransferHelper.safeTransferETH(recipient, balanceWETH9);
 26 |     |         }
 27 |     |     }
 28 |     | 
 29 |     |     /// @inheritdoc IPeripheryPayments
 30 |     |     function sweepToken(address token, uint256 amountMinimum, address recipient) public payable override {
 31 |     |         uint256 balanceToken = IERC20(token).balanceOf(address(this));
 32 |     |         require(balanceToken >= amountMinimum, "Insufficient token");
 33 |     | 
 34 |     |         if (balanceToken > 0) {
 35 |     |             TransferHelper.safeTransfer(token, recipient, balanceToken);
 36 |     |         }
 37 |     |     }
 38 |     | 
 39 |     |     /// @inheritdoc IPeripheryPayments
 40 |     |     function refundETH() external payable override {
 41 |     |         if (address(this).balance > 0) {
 42 |     |             TransferHelper.safeTransferETH(msg.sender, address(this).balance);
 43 |     |         }
 44 |     |     }
 45 |     | 
 46 |     |     /// @param token The token to pay
 47 |     |     /// @param payer The entity that must pay
 48 |     |     /// @param recipient The entity that will receive payment
 49 |     |     /// @param value The amount to pay
 50 | *   |     function pay(address token, address payer, address recipient, uint256 value) internal {
 51 | *   |         if (token == WETH9 && address(this).balance >= value) {
 52 |     |             // pay with WETH9
 53 |     |             IWETH9(WETH9).deposit{ value: value }(); // wrap only what is needed to pay
 54 |     |             IWETH9(WETH9).transfer(recipient, value);
 55 | *   |         } else if (payer == address(this)) {
 56 |     |             // pay with tokens already in the contract (for the exact input multihop case)
 57 |     |             TransferHelper.safeTransfer(token, recipient, value);
 58 |     |         } else {
 59 |     |             // pull payment
 60 | *   |             TransferHelper.safeTransferFrom(token, payer, recipient, value);
 61 |     |         }
 62 |     |     }
 63 |     | }
 64 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/PeripheryPaymentsExtended.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "uniswapv3/v3-periphery/base/PeripheryPayments.sol";
  5 |     | import "uniswapv3/v3-periphery/libraries/TransferHelper.sol";
  6 |     | 
  7 |     | import "uniswapv3/v3-periphery/interfaces/IPeripheryPaymentsExtended.sol";
  8 |     | 
  9 |     | abstract contract PeripheryPaymentsExtended is IPeripheryPaymentsExtended, PeripheryPayments {
 10 |     |     /// @inheritdoc IPeripheryPaymentsExtended
 11 |     |     function unwrapWETH9(uint256 amountMinimum) external payable override {
 12 |     |         unwrapWETH9(amountMinimum, msg.sender);
 13 |     |     }
 14 |     | 
 15 |     |     /// @inheritdoc IPeripheryPaymentsExtended
 16 |     |     function wrapETH(uint256 value) external payable override {
 17 |     |         IWETH9(WETH9).deposit{ value: value }();
 18 |     |     }
 19 |     | 
 20 |     |     /// @inheritdoc IPeripheryPaymentsExtended
 21 |     |     function sweepToken(address token, uint256 amountMinimum) external payable override {
 22 |     |         sweepToken(token, amountMinimum, msg.sender);
 23 |     |     }
 24 |     | 
 25 |     |     /// @inheritdoc IPeripheryPaymentsExtended
 26 |     |     function pull(address token, uint256 value) external payable override {
 27 |     |         TransferHelper.safeTransferFrom(token, msg.sender, address(this), value);
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/PeripheryPaymentsWithFee.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts-v4/token/ERC721/ERC721.sol";
  5 |     | import "../libraries/LowGasSafeMath.sol";
  6 |     | 
  7 |     | import "./PeripheryPayments.sol";
  8 |     | import "../interfaces/IPeripheryPaymentsWithFee.sol";
  9 |     | 
 10 |     | import "../interfaces/external/IWETH9.sol";
 11 |     | import "../libraries/TransferHelper.sol";
 12 |     | 
 13 |     | abstract contract PeripheryPaymentsWithFee is PeripheryPayments, IPeripheryPaymentsWithFee {
 14 |     |     using LowGasSafeMath for uint256;
 15 |     | 
 16 |     |     /// @inheritdoc IPeripheryPaymentsWithFee
 17 |     |     function unwrapWETH9WithFee(
 18 |     |         uint256 amountMinimum,
 19 |     |         address recipient,
 20 |     |         uint256 feeBips,
 21 |     |         address feeRecipient
 22 |     |     ) public payable override {
 23 |     |         require(feeBips > 0 && feeBips <= 100);
 24 |     | 
 25 |     |         uint256 balanceWETH9 = IWETH9(WETH9).balanceOf(address(this));
 26 |     |         require(balanceWETH9 >= amountMinimum, "Insufficient WETH9");
 27 |     | 
 28 |     |         if (balanceWETH9 > 0) {
 29 |     |             IWETH9(WETH9).withdraw(balanceWETH9);
 30 |     |             uint256 feeAmount = balanceWETH9.mul(feeBips) / 10_000;
 31 |     |             if (feeAmount > 0) TransferHelper.safeTransferETH(feeRecipient, feeAmount);
 32 |     |             TransferHelper.safeTransferETH(recipient, balanceWETH9 - feeAmount);
 33 |     |         }
 34 |     |     }
 35 |     | 
 36 |     |     /// @inheritdoc IPeripheryPaymentsWithFee
 37 |     |     function sweepTokenWithFee(
 38 |     |         address token,
 39 |     |         uint256 amountMinimum,
 40 |     |         address recipient,
 41 |     |         uint256 feeBips,
 42 |     |         address feeRecipient
 43 |     |     ) public payable override {
 44 |     |         require(feeBips > 0 && feeBips <= 100);
 45 |     | 
 46 |     |         uint256 balanceToken = IERC20(token).balanceOf(address(this));
 47 |     |         require(balanceToken >= amountMinimum, "Insufficient token");
 48 |     | 
 49 |     |         if (balanceToken > 0) {
 50 |     |             uint256 feeAmount = balanceToken.mul(feeBips) / 10_000;
 51 |     |             if (feeAmount > 0) TransferHelper.safeTransfer(token, feeRecipient, feeAmount);
 52 |     |             TransferHelper.safeTransfer(token, recipient, balanceToken - feeAmount);
 53 |     |         }
 54 |     |     }
 55 |     | }
 56 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/PeripheryPaymentsWithFeeExtended.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "uniswapv3/v3-periphery/base/PeripheryPaymentsWithFee.sol";
  5 |     | 
  6 |     | // import "uniswapv3/v3-periphery/interfaces/IPeripheryPaymentsWithFeeExtended.sol";
  7 |     | import "uniswapv3/v3-periphery/base/PeripheryPaymentsExtended.sol";
  8 |     | 
  9 |     | // IPeripheryPaymentsWithFeeExtended,
 10 |     | abstract contract PeripheryPaymentsWithFeeExtended is PeripheryPaymentsExtended, PeripheryPaymentsWithFee {
 11 |     |     function unwrapWETH9WithFee(uint256 amountMinimum, uint256 feeBips, address feeRecipient) external payable {
 12 |     |         unwrapWETH9WithFee(amountMinimum, msg.sender, feeBips, feeRecipient);
 13 |     |     }
 14 |     | 
 15 |     |     function sweepTokenWithFee(
 16 |     |         address token,
 17 |     |         uint256 amountMinimum,
 18 |     |         uint256 feeBips,
 19 |     |         address feeRecipient
 20 |     |     ) external payable {
 21 |     |         sweepTokenWithFee(token, amountMinimum, msg.sender, feeBips, feeRecipient);
 22 |     |     }
 23 |     | }
 24 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/PeripheryValidation.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./BlockTimestamp.sol";
  5 |     | 
  6 |     | abstract contract PeripheryValidation is BlockTimestamp {
  7 |     |     modifier checkDeadline(uint256 deadline) {
  8 | *   |         require(_blockTimestamp() <= deadline, "Transaction too old");
  9 |     |         _;
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/PeripheryValidationExtended.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "uniswapv3/v3-periphery/base/PeripheryValidation.sol";
  5 |     | 
  6 |     | abstract contract PeripheryValidationExtended is PeripheryValidation {
  7 |     |     modifier checkPreviousBlockhash(bytes32 previousBlockhash) {
  8 |     |         require(blockhash(block.number - 1) == previousBlockhash, "Blockhash");
  9 |     |         _;
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/PoolInitializer.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import 'v3-core/interfaces/IUniswapV3Factory.sol';
  5 |     | import 'v3-core/interfaces/IUniswapV3Pool.sol';
  6 |     | 
  7 |     | import './PeripheryImmutableState.sol';
  8 |     | import '../interfaces/IPoolInitializer.sol';
  9 |     | 
 10 |     | /// @title Creates and initializes V3 Pools
 11 |     | abstract contract PoolInitializer is IPoolInitializer, PeripheryImmutableState {
 12 |     |     /// @inheritdoc IPoolInitializer
 13 |     |     function createAndInitializePoolIfNecessary(
 14 |     |         address token0,
 15 |     |         address token1,
 16 |     |         uint24 fee,
 17 |     |         uint160 sqrtPriceX96
 18 |     |     ) external payable override returns (address pool) {
 19 |     |         require(token0 < token1);
 20 |     |         pool = IUniswapV3Factory(factory).getPool(token0, token1, fee);
 21 |     | 
 22 |     |         if (pool == address(0)) {
 23 |     |             pool = IUniswapV3Factory(factory).createPool(token0, token1, fee);
 24 |     |             IUniswapV3Pool(pool).initialize(sqrtPriceX96);
 25 |     |         } else {
 26 |     |             (uint160 sqrtPriceX96Existing, , , , , , ) = IUniswapV3Pool(pool).slot0();
 27 |     |             if (sqrtPriceX96Existing == 0) {
 28 |     |                 IUniswapV3Pool(pool).initialize(sqrtPriceX96);
 29 |     |             }
 30 |     |         }
 31 |     |     }
 32 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/base/SelfPermit.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";
  5 |     | import "@openzeppelin/contracts-v4/token/ERC20/extensions/IERC20Permit.sol";
  6 |     | 
  7 |     | import "../interfaces/ISelfPermit.sol";
  8 |     | import "../interfaces/external/IERC20PermitAllowed.sol";
  9 |     | 
 10 |     | /// @title Self Permit
 11 |     | /// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route
 12 |     | /// @dev These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function
 13 |     | /// that requires an approval in a single transaction.
 14 |     | abstract contract SelfPermit is ISelfPermit {
 15 |     |     /// @inheritdoc ISelfPermit
 16 |     |     function selfPermit(
 17 |     |         address token,
 18 |     |         uint256 value,
 19 |     |         uint256 deadline,
 20 |     |         uint8 v,
 21 |     |         bytes32 r,
 22 |     |         bytes32 s
 23 |     |     ) public payable override {
 24 |     |         IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);
 25 |     |     }
 26 |     | 
 27 |     |     /// @inheritdoc ISelfPermit
 28 |     |     function selfPermitIfNecessary(
 29 |     |         address token,
 30 |     |         uint256 value,
 31 |     |         uint256 deadline,
 32 |     |         uint8 v,
 33 |     |         bytes32 r,
 34 |     |         bytes32 s
 35 |     |     ) external payable override {
 36 |     |         if (IERC20(token).allowance(msg.sender, address(this)) < value) {
 37 |     |             selfPermit(token, value, deadline, v, r, s);
 38 |     |         }
 39 |     |     }
 40 |     | 
 41 |     |     /// @inheritdoc ISelfPermit
 42 |     |     function selfPermitAllowed(
 43 |     |         address token,
 44 |     |         uint256 nonce,
 45 |     |         uint256 expiry,
 46 |     |         uint8 v,
 47 |     |         bytes32 r,
 48 |     |         bytes32 s
 49 |     |     ) public payable override {
 50 |     |         IERC20PermitAllowed(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);
 51 |     |     }
 52 |     | 
 53 |     |     /// @inheritdoc ISelfPermit
 54 |     |     function selfPermitAllowedIfNecessary(
 55 |     |         address token,
 56 |     |         uint256 nonce,
 57 |     |         uint256 expiry,
 58 |     |         uint8 v,
 59 |     |         bytes32 r,
 60 |     |         bytes32 s
 61 |     |     ) external payable override {
 62 |     |         if (IERC20(token).allowance(msg.sender, address(this)) < type(uint256).max) {
 63 |     |             selfPermitAllowed(token, nonce, expiry, v, r, s);
 64 |     |         }
 65 |     |     }
 66 |     | }
 67 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IApproveAndCall.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | interface IApproveAndCall {
  6 |     |     enum ApprovalType {
  7 |     |         NOT_REQUIRED,
  8 |     |         MAX,
  9 |     |         MAX_MINUS_ONE,
 10 |     |         ZERO_THEN_MAX,
 11 |     |         ZERO_THEN_MAX_MINUS_ONE
 12 |     |     }
 13 |     | 
 14 |     |     /// @dev Lens to be called off-chain to determine which (if any) of the relevant approval functions should be called
 15 |     |     /// @param token The token to approve
 16 |     |     /// @param amount The amount to approve
 17 |     |     /// @return The required approval type
 18 |     |     function getApprovalType(address token, uint256 amount) external returns (ApprovalType);
 19 |     | 
 20 |     |     /// @notice Approves a token for the maximum possible amount
 21 |     |     /// @param token The token to approve
 22 |     |     function approveMax(address token) external payable;
 23 |     | 
 24 |     |     /// @notice Approves a token for the maximum possible amount minus one
 25 |     |     /// @param token The token to approve
 26 |     |     function approveMaxMinusOne(address token) external payable;
 27 |     | 
 28 |     |     /// @notice Approves a token for zero, then the maximum possible amount
 29 |     |     /// @param token The token to approve
 30 |     |     function approveZeroThenMax(address token) external payable;
 31 |     | 
 32 |     |     /// @notice Approves a token for zero, then the maximum possible amount minus one
 33 |     |     /// @param token The token to approve
 34 |     |     function approveZeroThenMaxMinusOne(address token) external payable;
 35 |     | 
 36 |     |     /// @notice Calls the position manager with arbitrary calldata
 37 |     |     /// @param data Calldata to pass along to the position manager
 38 |     |     /// @return result The result from the call
 39 |     |     function callPositionManager(bytes memory data) external payable returns (bytes memory result);
 40 |     | 
 41 |     |     struct MintParams {
 42 |     |         address token0;
 43 |     |         address token1;
 44 |     |         uint24 fee;
 45 |     |         int24 tickLower;
 46 |     |         int24 tickUpper;
 47 |     |         uint256 amount0Min;
 48 |     |         uint256 amount1Min;
 49 |     |         address recipient;
 50 |     |     }
 51 |     | 
 52 |     |     /// @notice Calls the position manager's mint function
 53 |     |     /// @param params Calldata to pass along to the position manager
 54 |     |     /// @return result The result from the call
 55 |     |     function mint(MintParams calldata params) external payable returns (bytes memory result);
 56 |     | 
 57 |     |     struct IncreaseLiquidityParams {
 58 |     |         address token0;
 59 |     |         address token1;
 60 |     |         uint256 tokenId;
 61 |     |         uint256 amount0Min;
 62 |     |         uint256 amount1Min;
 63 |     |     }
 64 |     | 
 65 |     |     /// @notice Calls the position manager's increaseLiquidity function
 66 |     |     /// @param params Calldata to pass along to the position manager
 67 |     |     /// @return result The result from the call
 68 |     |     function increaseLiquidity(IncreaseLiquidityParams calldata params) external payable returns (bytes memory result);
 69 |     | }
 70 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IERC721Permit.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts-v4/token/ERC721/IERC721.sol";
  5 |     | 
  6 |     | /// @title ERC721 with permit
  7 |     | /// @notice Extension to ERC721 that includes a permit function for signature based approvals
  8 |     | interface IERC721Permit is IERC721 {
  9 |     |     /// @notice The permit typehash used in the permit signature
 10 |     |     /// @return The typehash for the permit
 11 |     |     function PERMIT_TYPEHASH() external pure returns (bytes32);
 12 |     | 
 13 |     |     /// @notice The domain separator used in the permit signature
 14 |     |     /// @return The domain seperator used in encoding of permit signature
 15 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 16 |     | 
 17 |     |     /// @notice Approve of a specific token ID for spending by spender via signature
 18 |     |     /// @param spender The account that is being approved
 19 |     |     /// @param tokenId The ID of the token that is being approved for spending
 20 |     |     /// @param deadline The deadline timestamp by which the call must be mined for the approve to work
 21 |     |     /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
 22 |     |     /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
 23 |     |     /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
 24 |     |     function permit(address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external payable;
 25 |     | }
 26 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IImmutableState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Immutable state
  5 |     | /// @notice Functions that return immutable state of the router
  6 |     | interface IImmutableState {
  7 |     |     /// @return Returns the address of the Uniswap V2 factory
  8 |     |     function factoryV2() external view returns (address);
  9 |     | 
 10 |     |     /// @return Returns the address of Uniswap V3 NFT position manager
 11 |     |     function positionManager() external view returns (address);
 12 |     | }
 13 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IMulticall.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | /// @title Multicall interface
  6 |     | /// @notice Enables calling multiple methods in a single call to the contract
  7 |     | interface IMulticall {
  8 |     |     /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed
  9 |     |     /// @dev The `msg.value` should not be trusted for any method callable from multicall.
 10 |     |     /// @param data The encoded function data for each of the calls to make to this contract
 11 |     |     /// @return results The results from each of the calls passed in via data
 12 |     |     function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);
 13 |     | }
 14 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IMulticallExtended.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import "./IMulticall.sol";
  6 |     | 
  7 |     | /// @title MulticallExtended interface
  8 |     | /// @notice Enables calling multiple methods in a single call to the contract with optional validation
  9 |     | interface IMulticallExtended is IMulticall {
 10 |     |     /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed
 11 |     |     /// @dev The `msg.value` should not be trusted for any method callable from multicall.
 12 |     |     /// @param deadline The time by which this function must be called before failing
 13 |     |     /// @param data The encoded function data for each of the calls to make to this contract
 14 |     |     /// @return results The results from each of the calls passed in via data
 15 |     |     function multicall(uint256 deadline, bytes[] calldata data) external payable returns (bytes[] memory results);
 16 |     | 
 17 |     |     /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed
 18 |     |     /// @dev The `msg.value` should not be trusted for any method callable from multicall.
 19 |     |     /// @param previousBlockhash The expected parent blockHash
 20 |     |     /// @param data The encoded function data for each of the calls to make to this contract
 21 |     |     /// @return results The results from each of the calls passed in via data
 22 |     |     function multicall(
 23 |     |         bytes32 previousBlockhash,
 24 |     |         bytes[] calldata data
 25 |     |     ) external payable returns (bytes[] memory results);
 26 |     | }
 27 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/INonfungiblePositionManager.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | pragma abicoder v2;
   4 |     | 
   5 |     | import "@openzeppelin/contracts-v4/token/ERC721/extensions/IERC721Metadata.sol";
   6 |     | import "@openzeppelin/contracts-v4/token/ERC721/extensions/IERC721Enumerable.sol";
   7 |     | 
   8 |     | import "./IPoolInitializer.sol";
   9 |     | import "./IERC721Permit.sol";
  10 |     | import "./IPeripheryPayments.sol";
  11 |     | import "./IPeripheryImmutableState.sol";
  12 |     | import "../libraries/PoolAddress.sol";
  13 |     | 
  14 |     | /// @title Non-fungible token for positions
  15 |     | /// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred
  16 |     | /// and authorized.
  17 |     | interface INonfungiblePositionManager is
  18 |     |     IPoolInitializer,
  19 |     |     IPeripheryPayments,
  20 |     |     IPeripheryImmutableState,
  21 |     |     IERC721Metadata,
  22 |     |     IERC721Enumerable,
  23 |     |     IERC721Permit
  24 |     | {
  25 |     |     /// @notice Emitted when liquidity is increased for a position NFT
  26 |     |     /// @dev Also emitted when a token is minted
  27 |     |     /// @param tokenId The ID of the token for which liquidity was increased
  28 |     |     /// @param liquidity The amount by which liquidity for the NFT position was increased
  29 |     |     /// @param amount0 The amount of token0 that was paid for the increase in liquidity
  30 |     |     /// @param amount1 The amount of token1 that was paid for the increase in liquidity
  31 |     |     event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
  32 |     |     /// @notice Emitted when liquidity is decreased for a position NFT
  33 |     |     /// @param tokenId The ID of the token for which liquidity was decreased
  34 |     |     /// @param liquidity The amount by which liquidity for the NFT position was decreased
  35 |     |     /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity
  36 |     |     /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity
  37 |     |     event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
  38 |     |     /// @notice Emitted when tokens are collected for a position NFT
  39 |     |     /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior
  40 |     |     /// @param tokenId The ID of the token for which underlying tokens were collected
  41 |     |     /// @param recipient The address of the account that received the collected tokens
  42 |     |     /// @param amount0 The amount of token0 owed to the position that was collected
  43 |     |     /// @param amount1 The amount of token1 owed to the position that was collected
  44 |     |     event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);
  45 |     | 
  46 |     |     /// @notice Returns the position information associated with a given token ID.
  47 |     |     /// @dev Throws if the token ID is not valid.
  48 |     |     /// @param tokenId The ID of the token that represents the position
  49 |     |     /// @return nonce The nonce for permits
  50 |     |     /// @return operator The address that is approved for spending
  51 |     |     /// @return token0 The address of the token0 for a specific pool
  52 |     |     /// @return token1 The address of the token1 for a specific pool
  53 |     |     /// @return fee The fee associated with the pool
  54 |     |     /// @return tickLower The lower end of the tick range for the position
  55 |     |     /// @return tickUpper The higher end of the tick range for the position
  56 |     |     /// @return liquidity The liquidity of the position
  57 |     |     /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position
  58 |     |     /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position
  59 |     |     /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation
  60 |     |     /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation
  61 |     |     function positions(
  62 |     |         uint256 tokenId
  63 |     |     )
  64 |     |         external
  65 |     |         view
  66 |     |         returns (
  67 |     |             uint96 nonce,
  68 |     |             address operator,
  69 |     |             address token0,
  70 |     |             address token1,
  71 |     |             uint24 fee,
  72 |     |             int24 tickLower,
  73 |     |             int24 tickUpper,
  74 |     |             uint128 liquidity,
  75 |     |             uint256 feeGrowthInside0LastX128,
  76 |     |             uint256 feeGrowthInside1LastX128,
  77 |     |             uint128 tokensOwed0,
  78 |     |             uint128 tokensOwed1
  79 |     |         );
  80 |     | 
  81 |     |     struct MintParams {
  82 |     |         address token0;
  83 |     |         address token1;
  84 |     |         uint24 fee;
  85 |     |         int24 tickLower;
  86 |     |         int24 tickUpper;
  87 |     |         uint256 amount0Desired;
  88 |     |         uint256 amount1Desired;
  89 |     |         uint256 amount0Min;
  90 |     |         uint256 amount1Min;
  91 |     |         address recipient;
  92 |     |         uint256 deadline;
  93 |     |     }
  94 |     | 
  95 |     |     /// @notice Creates a new position wrapped in a NFT
  96 |     |     /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
  97 |     |     /// a method does not exist, i.e. the pool is assumed to be initialized.
  98 |     |     /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata
  99 |     |     /// @return tokenId The ID of the token that represents the minted position
 100 |     |     /// @return liquidity The amount of liquidity for this position
 101 |     |     /// @return amount0 The amount of token0
 102 |     |     /// @return amount1 The amount of token1
 103 |     |     function mint(
 104 |     |         MintParams calldata params
 105 |     |     ) external payable returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
 106 |     | 
 107 |     |     struct IncreaseLiquidityParams {
 108 |     |         uint256 tokenId;
 109 |     |         uint256 amount0Desired;
 110 |     |         uint256 amount1Desired;
 111 |     |         uint256 amount0Min;
 112 |     |         uint256 amount1Min;
 113 |     |         uint256 deadline;
 114 |     |     }
 115 |     | 
 116 |     |     /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
 117 |     |     /// @param params tokenId The ID of the token for which liquidity is being increased,
 118 |     |     /// amount0Desired The desired amount of token0 to be spent,
 119 |     |     /// amount1Desired The desired amount of token1 to be spent,
 120 |     |     /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
 121 |     |     /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
 122 |     |     /// deadline The time by which the transaction must be included to effect the change
 123 |     |     /// @return liquidity The new liquidity amount as a result of the increase
 124 |     |     /// @return amount0 The amount of token0 to acheive resulting liquidity
 125 |     |     /// @return amount1 The amount of token1 to acheive resulting liquidity
 126 |     |     function increaseLiquidity(
 127 |     |         IncreaseLiquidityParams calldata params
 128 |     |     ) external payable returns (uint128 liquidity, uint256 amount0, uint256 amount1);
 129 |     | 
 130 |     |     struct DecreaseLiquidityParams {
 131 |     |         uint256 tokenId;
 132 |     |         uint128 liquidity;
 133 |     |         uint256 amount0Min;
 134 |     |         uint256 amount1Min;
 135 |     |         uint256 deadline;
 136 |     |     }
 137 |     | 
 138 |     |     /// @notice Decreases the amount of liquidity in a position and accounts it to the position
 139 |     |     /// @param params tokenId The ID of the token for which liquidity is being decreased,
 140 |     |     /// amount The amount by which liquidity will be decreased,
 141 |     |     /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
 142 |     |     /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
 143 |     |     /// deadline The time by which the transaction must be included to effect the change
 144 |     |     /// @return amount0 The amount of token0 accounted to the position's tokens owed
 145 |     |     /// @return amount1 The amount of token1 accounted to the position's tokens owed
 146 |     |     function decreaseLiquidity(
 147 |     |         DecreaseLiquidityParams calldata params
 148 |     |     ) external payable returns (uint256 amount0, uint256 amount1);
 149 |     | 
 150 |     |     struct CollectParams {
 151 |     |         uint256 tokenId;
 152 |     |         address recipient;
 153 |     |         uint128 amount0Max;
 154 |     |         uint128 amount1Max;
 155 |     |     }
 156 |     | 
 157 |     |     /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
 158 |     |     /// @param params tokenId The ID of the NFT for which tokens are being collected,
 159 |     |     /// recipient The account that should receive the tokens,
 160 |     |     /// amount0Max The maximum amount of token0 to collect,
 161 |     |     /// amount1Max The maximum amount of token1 to collect
 162 |     |     /// @return amount0 The amount of fees collected in token0
 163 |     |     /// @return amount1 The amount of fees collected in token1
 164 |     |     function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);
 165 |     | 
 166 |     |     /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
 167 |     |     /// must be collected first.
 168 |     |     /// @param tokenId The ID of the token that is being burned
 169 |     |     function burn(uint256 tokenId) external payable;
 170 |     | }
 171 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/INonfungibleTokenPositionDescriptor.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import './INonfungiblePositionManager.sol';
  5 |     | 
  6 |     | /// @title Describes position NFT tokens via URI
  7 |     | interface INonfungibleTokenPositionDescriptor {
  8 |     |     /// @notice Produces the URI describing a particular token ID for a position manager
  9 |     |     /// @dev Note this URI may be a data: URI with the JSON contents directly inlined
 10 |     |     /// @param positionManager The position manager for which to describe the token
 11 |     |     /// @param tokenId The ID of the token for which to produce a description, which may not be valid
 12 |     |     /// @return The URI of the ERC721-compliant metadata
 13 |     |     function tokenURI(INonfungiblePositionManager positionManager, uint256 tokenId)
 14 |     |         external
 15 |     |         view
 16 |     |         returns (string memory);
 17 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IOracleSlippage.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | /// @title OracleSlippage interface
  6 |     | /// @notice Enables slippage checks against oracle prices
  7 |     | interface IOracleSlippage {
  8 |     |     /// @notice Ensures that the current (synthetic) tick over the path is no worse than
  9 |     |     /// `maximumTickDivergence` ticks away from the average as of `secondsAgo`
 10 |     |     /// @param path The path to fetch prices over
 11 |     |     /// @param maximumTickDivergence The maximum number of ticks that the price can degrade by
 12 |     |     /// @param secondsAgo The number of seconds ago to compute oracle prices against
 13 |     |     function checkOracleSlippage(bytes memory path, uint24 maximumTickDivergence, uint32 secondsAgo) external view;
 14 |     | 
 15 |     |     /// @notice Ensures that the weighted average current (synthetic) tick over the path is no
 16 |     |     /// worse than `maximumTickDivergence` ticks away from the average as of `secondsAgo`
 17 |     |     /// @param paths The paths to fetch prices over
 18 |     |     /// @param amounts The weights for each entry in `paths`
 19 |     |     /// @param maximumTickDivergence The maximum number of ticks that the price can degrade by
 20 |     |     /// @param secondsAgo The number of seconds ago to compute oracle prices against
 21 |     |     function checkOracleSlippage(
 22 |     |         bytes[] memory paths,
 23 |     |         uint128[] memory amounts,
 24 |     |         uint24 maximumTickDivergence,
 25 |     |         uint32 secondsAgo
 26 |     |     ) external view;
 27 |     | }
 28 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IPeripheryImmutableState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Immutable state
  5 |     | /// @notice Functions that return immutable state of the router
  6 |     | interface IPeripheryImmutableState {
  7 |     |     /// @return Returns the address of the Uniswap V3 factory
  8 |     |     function factory() external view returns (address);
  9 |     | 
 10 |     |     /// @return Returns the address of WETH9
 11 |     |     function WETH9() external view returns (address);
 12 |     | }
 13 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IPeripheryPayments.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Periphery Payments
  5 |     | /// @notice Functions to ease deposits and withdrawals of ETH
  6 |     | interface IPeripheryPayments {
  7 |     |     /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.
  8 |     |     /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.
  9 |     |     /// @param amountMinimum The minimum amount of WETH9 to unwrap
 10 |     |     /// @param recipient The address receiving ETH
 11 |     |     function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;
 12 |     | 
 13 |     |     /// @notice Refunds any ETH balance held by this contract to the `msg.sender`
 14 |     |     /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps
 15 |     |     /// that use ether for the input amount
 16 |     |     function refundETH() external payable;
 17 |     | 
 18 |     |     /// @notice Transfers the full amount of a token held by this contract to recipient
 19 |     |     /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users
 20 |     |     /// @param token The contract address of the token which will be transferred to `recipient`
 21 |     |     /// @param amountMinimum The minimum amount of token required for a transfer
 22 |     |     /// @param recipient The destination address of the token
 23 |     |     function sweepToken(address token, uint256 amountMinimum, address recipient) external payable;
 24 |     | }
 25 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IPeripheryPaymentsExtended.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "uniswapv3/v3-periphery/interfaces/IPeripheryPayments.sol";
  5 |     | 
  6 |     | /// @title Periphery Payments Extended
  7 |     | /// @notice Functions to ease deposits and withdrawals of ETH and tokens
  8 |     | interface IPeripheryPaymentsExtended is IPeripheryPayments {
  9 |     |     /// @notice Unwraps the contract's WETH9 balance and sends it to msg.sender as ETH.
 10 |     |     /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.
 11 |     |     /// @param amountMinimum The minimum amount of WETH9 to unwrap
 12 |     |     function unwrapWETH9(uint256 amountMinimum) external payable;
 13 |     | 
 14 |     |     /// @notice Wraps the contract's ETH balance into WETH9
 15 |     |     /// @dev The resulting WETH9 is custodied by the router, thus will require further distribution
 16 |     |     /// @param value The amount of ETH to wrap
 17 |     |     function wrapETH(uint256 value) external payable;
 18 |     | 
 19 |     |     /// @notice Transfers the full amount of a token held by this contract to msg.sender
 20 |     |     /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users
 21 |     |     /// @param token The contract address of the token which will be transferred to msg.sender
 22 |     |     /// @param amountMinimum The minimum amount of token required for a transfer
 23 |     |     function sweepToken(address token, uint256 amountMinimum) external payable;
 24 |     | 
 25 |     |     /// @notice Transfers the specified amount of a token from the msg.sender to address(this)
 26 |     |     /// @param token The token to pull
 27 |     |     /// @param value The amount to pay
 28 |     |     function pull(address token, uint256 value) external payable;
 29 |     | }
 30 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IPeripheryPaymentsWithFee.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./IPeripheryPayments.sol";
  5 |     | 
  6 |     | /// @title Periphery Payments
  7 |     | /// @notice Functions to ease deposits and withdrawals of ETH
  8 |     | interface IPeripheryPaymentsWithFee is IPeripheryPayments {
  9 |     |     /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between
 10 |     |     /// 0 (exclusive), and 1 (inclusive) going to feeRecipient
 11 |     |     /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.
 12 |     |     function unwrapWETH9WithFee(
 13 |     |         uint256 amountMinimum,
 14 |     |         address recipient,
 15 |     |         uint256 feeBips,
 16 |     |         address feeRecipient
 17 |     |     ) external payable;
 18 |     | 
 19 |     |     /// @notice Transfers the full amount of a token held by this contract to recipient, with a percentage between
 20 |     |     /// 0 (exclusive) and 1 (inclusive) going to feeRecipient
 21 |     |     /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users
 22 |     |     function sweepTokenWithFee(
 23 |     |         address token,
 24 |     |         uint256 amountMinimum,
 25 |     |         address recipient,
 26 |     |         uint256 feeBips,
 27 |     |         address feeRecipient
 28 |     |     ) external payable;
 29 |     | }
 30 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IPoolInitializer.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | /// @title Creates and initializes V3 Pools
  6 |     | /// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that
  7 |     | /// require the pool to exist.
  8 |     | interface IPoolInitializer {
  9 |     |     /// @notice Creates a new pool if it does not exist, then initializes if not initialized
 10 |     |     /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool
 11 |     |     /// @param token0 The contract address of token0 of the pool
 12 |     |     /// @param token1 The contract address of token1 of the pool
 13 |     |     /// @param fee The fee amount of the v3 pool for the specified token pair
 14 |     |     /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value
 15 |     |     /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary
 16 |     |     function createAndInitializePoolIfNecessary(
 17 |     |         address token0,
 18 |     |         address token1,
 19 |     |         uint24 fee,
 20 |     |         uint160 sqrtPriceX96
 21 |     |     ) external payable returns (address pool);
 22 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/ISelfPermit.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Self Permit
  5 |     | /// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route
  6 |     | interface ISelfPermit {
  7 |     |     /// @notice Permits this contract to spend a given token from `msg.sender`
  8 |     |     /// @dev The `owner` is always msg.sender and the `spender` is always address(this).
  9 |     |     /// @param token The address of the token spent
 10 |     |     /// @param value The amount that can be spent of token
 11 |     |     /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp
 12 |     |     /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
 13 |     |     /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
 14 |     |     /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
 15 |     |     function selfPermit(
 16 |     |         address token,
 17 |     |         uint256 value,
 18 |     |         uint256 deadline,
 19 |     |         uint8 v,
 20 |     |         bytes32 r,
 21 |     |         bytes32 s
 22 |     |     ) external payable;
 23 |     | 
 24 |     |     /// @notice Permits this contract to spend a given token from `msg.sender`
 25 |     |     /// @dev The `owner` is always msg.sender and the `spender` is always address(this).
 26 |     |     /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit
 27 |     |     /// @param token The address of the token spent
 28 |     |     /// @param value The amount that can be spent of token
 29 |     |     /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp
 30 |     |     /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
 31 |     |     /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
 32 |     |     /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
 33 |     |     function selfPermitIfNecessary(
 34 |     |         address token,
 35 |     |         uint256 value,
 36 |     |         uint256 deadline,
 37 |     |         uint8 v,
 38 |     |         bytes32 r,
 39 |     |         bytes32 s
 40 |     |     ) external payable;
 41 |     | 
 42 |     |     /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter
 43 |     |     /// @dev The `owner` is always msg.sender and the `spender` is always address(this)
 44 |     |     /// @param token The address of the token spent
 45 |     |     /// @param nonce The current nonce of the owner
 46 |     |     /// @param expiry The timestamp at which the permit is no longer valid
 47 |     |     /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
 48 |     |     /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
 49 |     |     /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
 50 |     |     function selfPermitAllowed(
 51 |     |         address token,
 52 |     |         uint256 nonce,
 53 |     |         uint256 expiry,
 54 |     |         uint8 v,
 55 |     |         bytes32 r,
 56 |     |         bytes32 s
 57 |     |     ) external payable;
 58 |     | 
 59 |     |     /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter
 60 |     |     /// @dev The `owner` is always msg.sender and the `spender` is always address(this)
 61 |     |     /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.
 62 |     |     /// @param token The address of the token spent
 63 |     |     /// @param nonce The current nonce of the owner
 64 |     |     /// @param expiry The timestamp at which the permit is no longer valid
 65 |     |     /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
 66 |     |     /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
 67 |     |     /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
 68 |     |     function selfPermitAllowedIfNecessary(
 69 |     |         address token,
 70 |     |         uint256 nonce,
 71 |     |         uint256 expiry,
 72 |     |         uint8 v,
 73 |     |         bytes32 r,
 74 |     |         bytes32 s
 75 |     |     ) external payable;
 76 |     | }
 77 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/ISwapRouter02.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import "./ISelfPermit.sol";
  6 |     | 
  7 |     | import "./IV2SwapRouter.sol";
  8 |     | import "./IV3SwapRouter.sol";
  9 |     | import "./IApproveAndCall.sol";
 10 |     | import "./IMulticallExtended.sol";
 11 |     | 
 12 |     | /// @title Router token swapping functionality
 13 |     | interface ISwapRouter02 is IV2SwapRouter, IV3SwapRouter, IApproveAndCall, IMulticallExtended, ISelfPermit {}
 14 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IV2SwapRouter.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | /// @title Router token swapping functionality
  6 |     | /// @notice Functions for swapping tokens via Uniswap V2
  7 |     | interface IV2SwapRouter {
  8 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another token
  9 |     |     /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,
 10 |     |     /// and swap the entire amount, enabling contracts to send tokens before calling this function.
 11 |     |     /// @param amountIn The amount of token to swap
 12 |     |     /// @param amountOutMin The minimum amount of output that must be received
 13 |     |     /// @param path The ordered list of tokens to swap through
 14 |     |     /// @param to The recipient address
 15 |     |     /// @return amountOut The amount of the received token
 16 |     |     function swapExactTokensForTokens(
 17 |     |         uint256 amountIn,
 18 |     |         uint256 amountOutMin,
 19 |     |         address[] calldata path,
 20 |     |         address to
 21 |     |     ) external payable returns (uint256 amountOut);
 22 |     | 
 23 |     |     /// @notice Swaps as little as possible of one token for an exact amount of another token
 24 |     |     /// @param amountOut The amount of token to swap for
 25 |     |     /// @param amountInMax The maximum amount of input that the caller will pay
 26 |     |     /// @param path The ordered list of tokens to swap through
 27 |     |     /// @param to The recipient address
 28 |     |     /// @return amountIn The amount of token to pay
 29 |     |     function swapTokensForExactTokens(
 30 |     |         uint256 amountOut,
 31 |     |         uint256 amountInMax,
 32 |     |         address[] calldata path,
 33 |     |         address to
 34 |     |     ) external payable returns (uint256 amountIn);
 35 |     | }
 36 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/IV3SwapRouter.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import "uniswapv3/v3-core/interfaces/callback/IUniswapV3SwapCallback.sol";
  6 |     | 
  7 |     | /// @title Router token swapping functionality
  8 |     | /// @notice Functions for swapping tokens via Uniswap V3
  9 |     | interface IV3SwapRouter is IUniswapV3SwapCallback {
 10 |     |     struct ExactInputSingleParams {
 11 |     |         address tokenIn;
 12 |     |         address tokenOut;
 13 |     |         uint24 fee;
 14 |     |         address recipient;
 15 |     |         uint256 amountIn;
 16 |     |         uint256 amountOutMinimum;
 17 |     |         uint160 sqrtPriceLimitX96;
 18 |     |     }
 19 |     | 
 20 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another token
 21 |     |     /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,
 22 |     |     /// and swap the entire amount, enabling contracts to send tokens before calling this function.
 23 |     |     /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
 24 |     |     /// @return amountOut The amount of the received token
 25 |     |     function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
 26 |     | 
 27 |     |     struct ExactInputParams {
 28 |     |         bytes path;
 29 |     |         address recipient;
 30 |     |         uint256 amountIn;
 31 |     |         uint256 amountOutMinimum;
 32 |     |     }
 33 |     | 
 34 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
 35 |     |     /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,
 36 |     |     /// and swap the entire amount, enabling contracts to send tokens before calling this function.
 37 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
 38 |     |     /// @return amountOut The amount of the received token
 39 |     |     function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);
 40 |     | 
 41 |     |     struct ExactOutputSingleParams {
 42 |     |         address tokenIn;
 43 |     |         address tokenOut;
 44 |     |         uint24 fee;
 45 |     |         address recipient;
 46 |     |         uint256 amountOut;
 47 |     |         uint256 amountInMaximum;
 48 |     |         uint160 sqrtPriceLimitX96;
 49 |     |     }
 50 |     | 
 51 |     |     /// @notice Swaps as little as possible of one token for `amountOut` of another token
 52 |     |     /// that may remain in the router after the swap.
 53 |     |     /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
 54 |     |     /// @return amountIn The amount of the input token
 55 |     |     function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);
 56 |     | 
 57 |     |     struct ExactOutputParams {
 58 |     |         bytes path;
 59 |     |         address recipient;
 60 |     |         uint256 amountOut;
 61 |     |         uint256 amountInMaximum;
 62 |     |     }
 63 |     | 
 64 |     |     /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
 65 |     |     /// that may remain in the router after the swap.
 66 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
 67 |     |     /// @return amountIn The amount of the input token
 68 |     |     function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
 69 |     | }
 70 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/external/IERC1271.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Interface for verifying contract-based account signatures
  5 |     | /// @notice Interface that verifies provided signature for the data
  6 |     | /// @dev Interface defined by EIP-1271
  7 |     | interface IERC1271 {
  8 |     |     /// @notice Returns whether the provided signature is valid for the provided data
  9 |     |     /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.
 10 |     |     /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).
 11 |     |     /// MUST allow external calls.
 12 |     |     /// @param hash Hash of the data to be signed
 13 |     |     /// @param signature Signature byte array associated with _data
 14 |     |     /// @return magicValue The bytes4 magic value 0x1626ba7e
 15 |     |     function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);
 16 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/external/IERC20PermitAllowed.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Interface for permit
  5 |     | /// @notice Interface used by DAI/CHAI for permit
  6 |     | interface IERC20PermitAllowed {
  7 |     |     /// @notice Approve the spender to spend some tokens via the holder signature
  8 |     |     /// @dev This is the permit interface used by DAI and CHAI
  9 |     |     /// @param holder The address of the token holder, the token owner
 10 |     |     /// @param spender The address of the token spender
 11 |     |     /// @param nonce The holder's nonce, increases at each call to permit
 12 |     |     /// @param expiry The timestamp at which the permit is no longer valid
 13 |     |     /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0
 14 |     |     /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
 15 |     |     /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
 16 |     |     /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
 17 |     |     function permit(
 18 |     |         address holder,
 19 |     |         address spender,
 20 |     |         uint256 nonce,
 21 |     |         uint256 expiry,
 22 |     |         bool allowed,
 23 |     |         uint8 v,
 24 |     |         bytes32 r,
 25 |     |         bytes32 s
 26 |     |     ) external;
 27 |     | }
 28 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/interfaces/external/IWETH9.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | /// @title Interface for WETH9
  7 |     | interface IWETH9 is IERC20 {
  8 |     |     /// @notice Deposit ether to get wrapped ether
  9 |     |     function deposit() external payable;
 10 |     | 
 11 |     |     /// @notice Withdraw wrapped ether to get ether
 12 |     |     function withdraw(uint256) external;
 13 |     | }
 14 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/libraries/BytesLib.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | /*
   3 |     |  * @title Solidity Bytes Arrays Utils
   4 |     |  * @author Gonalo S <goncalo.sa@consensys.net>
   5 |     |  *
   6 |     |  * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.
   7 |     |  *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.
   8 |     |  */
   9 |     | pragma solidity ^0.8.0;
  10 |     | 
  11 |     | library BytesLib {
  12 | *   |     function slice(
  13 |     |         bytes memory _bytes,
  14 |     |         uint256 _start,
  15 |     |         uint256 _length
  16 | *   |     ) internal pure returns (bytes memory) {
  17 | *   |         require(_length + 31 >= _length, "slice_overflow");
  18 | *   |         require(_start + _length >= _start, "slice_overflow");
  19 | *   |         require(_bytes.length >= _start + _length, "slice_outOfBounds");
  20 |     | 
  21 | *   |         bytes memory tempBytes;
  22 |     | 
  23 |     |         assembly {
  24 | *   |             switch iszero(_length)
  25 | *   |             case 0 {
  26 |     |                 // Get a location of some free memory and store it in tempBytes as
  27 |     |                 // Solidity does for memory variables.
  28 | *   |                 tempBytes := mload(0x40)
  29 |     | 
  30 |     |                 // The first word of the slice result is potentially a partial
  31 |     |                 // word read from the original array. To read it, we calculate
  32 |     |                 // the length of that partial word and start copying that many
  33 |     |                 // bytes into the array. The first word we copy will start with
  34 |     |                 // data we don't care about, but the last `lengthmod` bytes will
  35 |     |                 // land at the beginning of the contents of the new array. When
  36 |     |                 // we're done copying, we overwrite the full first word with
  37 |     |                 // the actual length of the slice.
  38 | *   |                 let lengthmod := and(_length, 31)
  39 |     | 
  40 |     |                 // The multiplication in the next line is necessary
  41 |     |                 // because when slicing multiples of 32 bytes (lengthmod == 0)
  42 |     |                 // the following copy loop was copying the origin's length
  43 |     |                 // and then ending prematurely not copying everything it should.
  44 | *   |                 let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
  45 | *   |                 let end := add(mc, _length)
  46 |     | 
  47 | *   |                 for {
  48 |     |                     // The multiplication in the next line has the same exact purpose
  49 |     |                     // as the one above.
  50 | *   |                     let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
  51 | *   |                 } lt(mc, end) {
  52 | *   |                     mc := add(mc, 0x20)
  53 | *   |                     cc := add(cc, 0x20)
  54 | *   |                 } { mstore(mc, mload(cc)) }
  55 |     | 
  56 | *   |                 mstore(tempBytes, _length)
  57 |     | 
  58 |     |                 //update free-memory pointer
  59 |     |                 //allocating the array padded to 32 bytes like the compiler does now
  60 | *   |                 mstore(0x40, and(add(mc, 31), not(31)))
  61 |     |             }
  62 |     |             //if we want a zero-length slice let's just return a zero-length array
  63 |     |             default {
  64 |     |                 tempBytes := mload(0x40)
  65 |     |                 //zero out the 32 bytes slice we are about to return
  66 |     |                 //we need to do it because Solidity does not garbage collect
  67 |     |                 mstore(tempBytes, 0)
  68 |     | 
  69 |     |                 mstore(0x40, add(tempBytes, 0x20))
  70 |     |             }
  71 |     |         }
  72 |     | 
  73 | *   |         return tempBytes;
  74 |     |     }
  75 |     | 
  76 | *   |     function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {
  77 | *   |         require(_start + 20 >= _start, "toAddress_overflow");
  78 | *   |         require(_bytes.length >= _start + 20, "toAddress_outOfBounds");
  79 | *   |         address tempAddress;
  80 |     | 
  81 |     |         assembly {
  82 | *   |             tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)
  83 |     |         }
  84 |     | 
  85 | *   |         return tempAddress;
  86 |     |     }
  87 |     | 
  88 | *   |     function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {
  89 | *   |         require(_start + 3 >= _start, "toUint24_overflow");
  90 | *   |         require(_bytes.length >= _start + 3, "toUint24_outOfBounds");
  91 | *   |         uint24 tempUint;
  92 |     | 
  93 |     |         assembly {
  94 | *   |             tempUint := mload(add(add(_bytes, 0x3), _start))
  95 |     |         }
  96 |     | 
  97 | *   |         return tempUint;
  98 |     |     }
  99 |     | }
 100 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/libraries/CallbackValidation.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "v3-core/interfaces/IUniswapV3Pool.sol";
  5 |     | import "v3-core/interfaces/IUniswapV3Factory.sol";
  6 |     | import "./PoolAddress.sol";
  7 |     | 
  8 |     | /// @notice Provides validation for callbacks from Uniswap V3 Pools
  9 |     | library CallbackValidation {
 10 |     |     /// @notice Returns the address of a valid Uniswap V3 Pool
 11 |     |     /// @param factory The contract address of the Uniswap V3 factory
 12 |     |     /// @param tokenA The contract address of either token0 or token1
 13 |     |     /// @param tokenB The contract address of the other token
 14 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 15 |     |     /// @return pool The V3 pool contract address
 16 |     |     function verifyCallback(
 17 |     |         address factory,
 18 |     |         address tokenA,
 19 |     |         address tokenB,
 20 |     |         uint24 fee
 21 |     |     ) internal view returns (IUniswapV3Pool pool) {
 22 |     |         pool = IUniswapV3Pool(IUniswapV3Factory(factory).getPool(tokenA, tokenB, fee));
 23 |     |         require(msg.sender == address(pool));
 24 |     |     }
 25 |     | 
 26 |     |     /// @notice Returns the address of a valid Uniswap V3 Pool
 27 |     |     /// @param factory The contract address of the Uniswap V3 factory
 28 |     |     /// @param poolKey The identifying key of the V3 pool
 29 |     |     /// @return pool The V3 pool contract address
 30 | *   |     function verifyCallback(
 31 |     |         address factory,
 32 |     |         PoolAddress.PoolKey memory poolKey
 33 | *   |     ) internal view returns (IUniswapV3Pool pool) {
 34 | *   |         pool = IUniswapV3Pool(IUniswapV3Factory(factory).getPool(poolKey.token0, poolKey.token1, poolKey.fee));
 35 | *   |         require(msg.sender == address(pool));
 36 |     |     }
 37 |     | }
 38 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/libraries/ChainId.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Function for getting the current chain ID
  5 |     | library ChainId {
  6 |     |     /// @dev Gets the current chain ID
  7 |     |     /// @return chainId The current chain ID
  8 |     |     function get() internal view returns (uint256 chainId) {
  9 |     |         assembly {
 10 |     |             chainId := chainid()
 11 |     |         }
 12 |     |     }
 13 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/libraries/Constants.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Constant state
  5 |     | /// @notice Constant state used by the swap router
  6 |     | library Constants {
  7 |     |     /// @dev Used for identifying cases when this contract's balance of a token is to be used
  8 | *   |     uint256 internal constant CONTRACT_BALANCE = 0;
  9 |     | 
 10 |     |     /// @dev Used as a flag for identifying msg.sender, saves gas by sending more 0 bytes
 11 | *   |     address internal constant MSG_SENDER = address(1);
 12 |     | 
 13 |     |     /// @dev Used as a flag for identifying address(this), saves gas by sending more 0 bytes
 14 | *   |     address internal constant ADDRESS_THIS = address(2);
 15 |     | }
 16 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/libraries/LiquidityAmounts.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | import "v3-core/libraries/FullMath.sol";
   5 |     | import "v3-core/libraries/FixedPoint96.sol";
   6 |     | import { console } from "forge-std/console.sol";
   7 |     | 
   8 |     | /// @title Liquidity amount functions
   9 |     | /// @notice Provides functions for computing liquidity amounts from token amounts and prices
  10 |     | library LiquidityAmounts {
  11 |     |     /// @notice Downcasts uint256 to uint128
  12 |     |     /// @param x The uint258 to be downcasted
  13 |     |     /// @return y The passed value, downcasted to uint128
  14 | *   |     function toUint128(uint256 x) private pure returns (uint128 y) {
  15 | *   |         require((y = uint128(x)) == x);
  16 |     |     }
  17 |     | 
  18 |     |     /// @notice Computes the amount of liquidity received for a given amount of token0 and price range
  19 |     |     /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))
  20 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  21 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
  22 |     |     /// @param amount0 The amount0 being sent in
  23 |     |     /// @return liquidity The amount of returned liquidity
  24 | *   |     function getLiquidityForAmount0(
  25 |     |         uint160 sqrtRatioAX96,
  26 |     |         uint160 sqrtRatioBX96,
  27 |     |         uint256 amount0
  28 | *   |     ) internal pure returns (uint128 liquidity) {
  29 | *   |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  30 | *   |         uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
  31 |     |         unchecked {
  32 | *   |             return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
  33 |     |         }
  34 |     |     }
  35 |     | 
  36 |     |     /// @notice Computes the amount of liquidity received for a given amount of token1 and price range
  37 |     |     /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).
  38 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  39 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
  40 |     |     /// @param amount1 The amount1 being sent in
  41 |     |     /// @return liquidity The amount of returned liquidity
  42 | *   |     function getLiquidityForAmount1(
  43 |     |         uint160 sqrtRatioAX96,
  44 |     |         uint160 sqrtRatioBX96,
  45 |     |         uint256 amount1
  46 | *   |     ) internal pure returns (uint128 liquidity) {
  47 | *   |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  48 |     |         unchecked {
  49 | *   |             return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
  50 |     |         }
  51 |     |     }
  52 |     | 
  53 |     |     /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current
  54 |     |     /// pool prices and the prices at the tick boundaries
  55 |     |     /// @param sqrtRatioX96 A sqrt price representing the current pool prices
  56 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  57 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
  58 |     |     /// @param amount0 The amount of token0 being sent in
  59 |     |     /// @param amount1 The amount of token1 being sent in
  60 |     |     /// @return liquidity The maximum amount of liquidity received
  61 | *   |     function getLiquidityForAmounts(
  62 |     |         uint160 sqrtRatioX96,
  63 |     |         uint160 sqrtRatioAX96,
  64 |     |         uint160 sqrtRatioBX96,
  65 |     |         uint256 amount0,
  66 |     |         uint256 amount1
  67 | *   |     ) internal pure returns (uint128 liquidity) {
  68 | *   |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  69 |     | 
  70 | *   |         if (sqrtRatioX96 <= sqrtRatioAX96) {
  71 | *   |             liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
  72 | *   |         } else if (sqrtRatioX96 < sqrtRatioBX96) {
  73 | *   |             uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
  74 | *   |             uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
  75 |     | 
  76 | *   |             liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
  77 |     |         } else {
  78 | *   |             liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
  79 |     |         }
  80 |     |     }
  81 |     | 
  82 |     |     /// @notice Computes the amount of token0 for a given amount of liquidity and a price range
  83 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  84 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
  85 |     |     /// @param liquidity The liquidity being valued
  86 |     |     /// @return amount0 The amount of token0
  87 |     |     function getAmount0ForLiquidity(
  88 |     |         uint160 sqrtRatioAX96,
  89 |     |         uint160 sqrtRatioBX96,
  90 |     |         uint128 liquidity
  91 |     |     ) internal pure returns (uint256 amount0) {
  92 |     |         unchecked {
  93 |     |             if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  94 |     | 
  95 |     |             return
  96 |     |                 FullMath.mulDiv(
  97 |     |                     uint256(liquidity) << FixedPoint96.RESOLUTION,
  98 |     |                     sqrtRatioBX96 - sqrtRatioAX96,
  99 |     |                     sqrtRatioBX96
 100 |     |                 ) / sqrtRatioAX96;
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     /// @notice Computes the amount of token1 for a given amount of liquidity and a price range
 105 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
 106 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
 107 |     |     /// @param liquidity The liquidity being valued
 108 |     |     /// @return amount1 The amount of token1
 109 |     |     function getAmount1ForLiquidity(
 110 |     |         uint160 sqrtRatioAX96,
 111 |     |         uint160 sqrtRatioBX96,
 112 |     |         uint128 liquidity
 113 |     |     ) internal pure returns (uint256 amount1) {
 114 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 115 |     | 
 116 |     |         unchecked {
 117 |     |             return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
 118 |     |         }
 119 |     |     }
 120 |     | 
 121 |     |     /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current
 122 |     |     /// pool prices and the prices at the tick boundaries
 123 |     |     /// @param sqrtRatioX96 A sqrt price representing the current pool prices
 124 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
 125 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
 126 |     |     /// @param liquidity The liquidity being valued
 127 |     |     /// @return amount0 The amount of token0
 128 |     |     /// @return amount1 The amount of token1
 129 |     |     function getAmountsForLiquidity(
 130 |     |         uint160 sqrtRatioX96,
 131 |     |         uint160 sqrtRatioAX96,
 132 |     |         uint160 sqrtRatioBX96,
 133 |     |         uint128 liquidity
 134 |     |     ) internal pure returns (uint256 amount0, uint256 amount1) {
 135 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 136 |     | 
 137 |     |         if (sqrtRatioX96 <= sqrtRatioAX96) {
 138 |     |             amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
 139 |     |         } else if (sqrtRatioX96 < sqrtRatioBX96) {
 140 |     |             amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
 141 |     |             amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
 142 |     |         } else {
 143 |     |             amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
 144 |     |         }
 145 |     |     }
 146 |     | }
 147 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/libraries/LowGasSafeMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Optimized overflow and underflow safe math operations
  5 |     | /// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost
  6 |     | library LowGasSafeMath {
  7 |     |     /// @notice Returns x + y, reverts if sum overflows uint256
  8 |     |     /// @param x The augend
  9 |     |     /// @param y The addend
 10 |     |     /// @return z The sum of x and y
 11 |     |     function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
 12 |     |         require((z = x + y) >= x);
 13 |     |     }
 14 |     | 
 15 |     |     /// @notice Returns x - y, reverts if underflows
 16 |     |     /// @param x The minuend
 17 |     |     /// @param y The subtrahend
 18 |     |     /// @return z The difference of x and y
 19 |     |     function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
 20 |     |         require((z = x - y) <= x);
 21 |     |     }
 22 |     | 
 23 |     |     /// @notice Returns x * y, reverts if overflows
 24 |     |     /// @param x The multiplicand
 25 |     |     /// @param y The multiplier
 26 |     |     /// @return z The product of x and y
 27 |     |     function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
 28 |     |         require(x == 0 || (z = x * y) / x == y);
 29 |     |     }
 30 |     | 
 31 |     |     /// @notice Returns x + y, reverts if overflows or underflows
 32 |     |     /// @param x The augend
 33 |     |     /// @param y The addend
 34 |     |     /// @return z The sum of x and y
 35 |     |     function add(int256 x, int256 y) internal pure returns (int256 z) {
 36 |     |         require((z = x + y) >= x == (y >= 0));
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Returns x - y, reverts if overflows or underflows
 40 |     |     /// @param x The minuend
 41 |     |     /// @param y The subtrahend
 42 |     |     /// @return z The difference of x and y
 43 |     |     function sub(int256 x, int256 y) internal pure returns (int256 z) {
 44 |     |         require((z = x - y) <= x == (y >= 0));
 45 |     |     }
 46 |     | }
 47 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/libraries/OracleLibrary.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0 <0.9.0;
   3 |     | 
   4 |     | import "uniswapv3/v3-core/libraries/FullMath.sol";
   5 |     | import "uniswapv3/v3-core/libraries/TickMath.sol";
   6 |     | import "uniswapv3/v3-core/interfaces/IUniswapV3Pool.sol";
   7 |     | 
   8 |     | /// @title Oracle library
   9 |     | /// @notice Provides functions to integrate with V3 pool oracle
  10 |     | library OracleLibrary {
  11 |     |     /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool
  12 |     |     /// @param pool Address of the pool that we want to observe
  13 |     |     /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means
  14 |     |     /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp
  15 |     |     /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp
  16 |     |     function consult(
  17 |     |         address pool,
  18 |     |         uint32 secondsAgo
  19 |     |     ) internal view returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity) {
  20 |     |         require(secondsAgo != 0, "BP");
  21 |     | 
  22 |     |         uint32[] memory secondsAgos = new uint32[](2);
  23 |     |         secondsAgos[0] = secondsAgo;
  24 |     |         secondsAgos[1] = 0;
  25 |     | 
  26 |     |         (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) = IUniswapV3Pool(pool)
  27 |     |             .observe(secondsAgos);
  28 |     | 
  29 |     |         int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];
  30 |     |         uint160 secondsPerLiquidityCumulativesDelta = secondsPerLiquidityCumulativeX128s[1] -
  31 |     |             secondsPerLiquidityCumulativeX128s[0];
  32 |     | 
  33 |     |         arithmeticMeanTick = int24(tickCumulativesDelta / int56(uint56(secondsAgo)));
  34 |     |         // Always round to negative infinity
  35 |     |         if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(secondsAgo)) != 0)) arithmeticMeanTick--;
  36 |     | 
  37 |     |         // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128
  38 |     |         uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;
  39 |     |         harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));
  40 |     |     }
  41 |     | 
  42 |     |     /// @notice Given a tick and a token amount, calculates the amount of token received in exchange
  43 |     |     /// @param tick Tick value used to calculate the quote
  44 |     |     /// @param baseAmount Amount of token to be converted
  45 |     |     /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination
  46 |     |     /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination
  47 |     |     /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken
  48 |     |     function getQuoteAtTick(
  49 |     |         int24 tick,
  50 |     |         uint128 baseAmount,
  51 |     |         address baseToken,
  52 |     |         address quoteToken
  53 |     |     ) internal pure returns (uint256 quoteAmount) {
  54 |     |         uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);
  55 |     | 
  56 |     |         // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself
  57 |     |         if (sqrtRatioX96 <= type(uint128).max) {
  58 |     |             uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;
  59 |     |             quoteAmount = baseToken < quoteToken
  60 |     |                 ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)
  61 |     |                 : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);
  62 |     |         } else {
  63 |     |             uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);
  64 |     |             quoteAmount = baseToken < quoteToken
  65 |     |                 ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)
  66 |     |                 : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 |     |     /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation
  71 |     |     /// @param pool Address of Uniswap V3 pool that we want to observe
  72 |     |     /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool
  73 |     |     function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {
  74 |     |         (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();
  75 |     |         require(observationCardinality > 0, "NI");
  76 |     | 
  77 |     |         (uint32 observationTimestamp, , , bool initialized) = IUniswapV3Pool(pool).observations(
  78 |     |             (observationIndex + 1) % observationCardinality
  79 |     |         );
  80 |     | 
  81 |     |         // The next index might not be initialized if the cardinality is in the process of increasing
  82 |     |         // In this case the oldest observation is always in index 0
  83 |     |         if (!initialized) {
  84 |     |             (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);
  85 |     |         }
  86 |     | 
  87 |     |         unchecked {
  88 |     |             secondsAgo = uint32(block.timestamp) - observationTimestamp;
  89 |     |         }
  90 |     |     }
  91 |     | 
  92 |     |     /// @notice Given a pool, it returns the tick value as of the start of the current block
  93 |     |     /// @param pool Address of Uniswap V3 pool
  94 |     |     /// @return The tick that the pool was in at the start of the current block
  95 |     |     function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {
  96 |     |         (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();
  97 |     | 
  98 |     |         // 2 observations are needed to reliably calculate the block starting tick
  99 |     |         require(observationCardinality > 1, "NEO");
 100 |     | 
 101 |     |         // If the latest observation occurred in the past, then no tick-changing trades have happened in this block
 102 |     |         // therefore the tick in `slot0` is the same as at the beginning of the current block.
 103 |     |         // We don't need to check if this observation is initialized - it is guaranteed to be.
 104 |     |         (
 105 |     |             uint32 observationTimestamp,
 106 |     |             int56 tickCumulative,
 107 |     |             uint160 secondsPerLiquidityCumulativeX128,
 108 |     | 
 109 |     |         ) = IUniswapV3Pool(pool).observations(observationIndex);
 110 |     |         if (observationTimestamp != uint32(block.timestamp)) {
 111 |     |             return (tick, IUniswapV3Pool(pool).liquidity());
 112 |     |         }
 113 |     | 
 114 |     |         uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;
 115 |     |         (
 116 |     |             uint32 prevObservationTimestamp,
 117 |     |             int56 prevTickCumulative,
 118 |     |             uint160 prevSecondsPerLiquidityCumulativeX128,
 119 |     |             bool prevInitialized
 120 |     |         ) = IUniswapV3Pool(pool).observations(prevIndex);
 121 |     | 
 122 |     |         require(prevInitialized, "ONI");
 123 |     | 
 124 |     |         uint32 delta = observationTimestamp - prevObservationTimestamp;
 125 |     |         tick = int24((tickCumulative - int56(uint56(prevTickCumulative))) / int56(uint56(delta)));
 126 |     |         uint128 liquidity = uint128(
 127 |     |             (uint192(delta) * type(uint160).max) /
 128 |     |                 (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)
 129 |     |         );
 130 |     |         return (tick, liquidity);
 131 |     |     }
 132 |     | 
 133 |     |     /// @notice Information for calculating a weighted arithmetic mean tick
 134 |     |     struct WeightedTickData {
 135 |     |         int24 tick;
 136 |     |         uint128 weight;
 137 |     |     }
 138 |     | 
 139 |     |     /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick
 140 |     |     /// @param weightedTickData An array of ticks and weights
 141 |     |     /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick
 142 |     |     /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,
 143 |     |     /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).
 144 |     |     /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.
 145 |     |     function getWeightedArithmeticMeanTick(
 146 |     |         WeightedTickData[] memory weightedTickData
 147 |     |     ) internal pure returns (int24 weightedArithmeticMeanTick) {
 148 |     |         // Accumulates the sum of products between each tick and its weight
 149 |     |         int256 numerator;
 150 |     | 
 151 |     |         // Accumulates the sum of the weights
 152 |     |         uint256 denominator;
 153 |     | 
 154 |     |         // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic
 155 |     |         for (uint256 i; i < weightedTickData.length; i++) {
 156 |     |             numerator += weightedTickData[i].tick * int256(uint256(weightedTickData[i].weight));
 157 |     |             denominator += weightedTickData[i].weight;
 158 |     |         }
 159 |     | 
 160 |     |         weightedArithmeticMeanTick = int24(numerator / int256(denominator));
 161 |     |         // Always round to negative infinity
 162 |     |         if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;
 163 |     |     }
 164 |     | 
 165 |     |     /// @notice Returns the "synthetic" tick which represents the price of the first entry in `tokens` in terms of the last
 166 |     |     /// @dev Useful for calculating relative prices along routes.
 167 |     |     /// @dev There must be one tick for each pairwise set of tokens.
 168 |     |     /// @param tokens The token contract addresses
 169 |     |     /// @param ticks The ticks, representing the price of each token pair in `tokens`
 170 |     |     /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`
 171 |     |     function getChainedPrice(
 172 |     |         address[] memory tokens,
 173 |     |         int24[] memory ticks
 174 |     |     ) internal pure returns (int256 syntheticTick) {
 175 |     |         require(tokens.length - 1 == ticks.length, "DL");
 176 |     |         for (uint256 i = 1; i <= ticks.length; i++) {
 177 |     |             // check the tokens for address sort order, then accumulate the
 178 |     |             // ticks into the running synthetic tick, ensuring that intermediate tokens "cancel out"
 179 |     |             tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];
 180 |     |         }
 181 |     |     }
 182 |     | }
 183 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/libraries/Path.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./BytesLib.sol";
  5 |     | 
  6 |     | /// @title Functions for manipulating path data for multihop swaps
  7 |     | library Path {
  8 |     |     using BytesLib for bytes;
  9 |     | 
 10 |     |     /// @dev The length of the bytes encoded address
 11 | *   |     uint256 private constant ADDR_SIZE = 20;
 12 |     |     /// @dev The length of the bytes encoded fee
 13 | *   |     uint256 private constant FEE_SIZE = 3;
 14 |     | 
 15 |     |     /// @dev The offset of a single token address and pool fee
 16 | *   |     uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;
 17 |     |     /// @dev The offset of an encoded pool key
 18 | *   |     uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;
 19 |     |     /// @dev The minimum length of an encoding that contains 2 or more pools
 20 | *   |     uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;
 21 |     | 
 22 |     |     /// @notice Returns true iff the path contains two or more pools
 23 |     |     /// @param path The encoded swap path
 24 |     |     /// @return True if path contains two or more pools, otherwise false
 25 | *   |     function hasMultiplePools(bytes memory path) internal pure returns (bool) {
 26 | *   |         return path.length >= MULTIPLE_POOLS_MIN_LENGTH;
 27 |     |     }
 28 |     | 
 29 |     |     /// @notice Returns the number of pools in the path
 30 |     |     /// @param path The encoded swap path
 31 |     |     /// @return The number of pools in the path
 32 |     |     function numPools(bytes memory path) internal pure returns (uint256) {
 33 |     |         // Ignore the first token address. From then on every fee and token offset indicates a pool.
 34 |     |         return ((path.length - ADDR_SIZE) / NEXT_OFFSET);
 35 |     |     }
 36 |     | 
 37 |     |     /// @notice Decodes the first pool in path
 38 |     |     /// @param path The bytes encoded swap path
 39 |     |     /// @return tokenA The first token of the given pool
 40 |     |     /// @return tokenB The second token of the given pool
 41 |     |     /// @return fee The fee level of the pool
 42 | *   |     function decodeFirstPool(bytes memory path)
 43 |     |         internal
 44 |     |         pure
 45 | *   |         returns (address tokenA, address tokenB, uint24 fee)
 46 |     |     {
 47 | *   |         tokenA = path.toAddress(0);
 48 | *   |         fee = path.toUint24(ADDR_SIZE);
 49 | *   |         tokenB = path.toAddress(NEXT_OFFSET);
 50 |     |     }
 51 |     | 
 52 |     |     /// @notice Gets the segment corresponding to the first pool in the path
 53 |     |     /// @param path The bytes encoded swap path
 54 |     |     /// @return The segment containing all data necessary to target the first pool in the path
 55 | *   |     function getFirstPool(bytes memory path) internal pure returns (bytes memory) {
 56 | *   |         return path.slice(0, POP_OFFSET);
 57 |     |     }
 58 |     | 
 59 |     |     /// @notice Skips a token + fee element from the buffer and returns the remainder
 60 |     |     /// @param path The swap path
 61 |     |     /// @return The remaining token + fee elements in the path
 62 |     |     function skipToken(bytes memory path) internal pure returns (bytes memory) {
 63 |     |         return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);
 64 |     |     }
 65 |     | }
 66 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/libraries/PoolAddress.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Provides functions for deriving a pool address from the factory, tokens, and the fee
  5 |     | library PoolAddress {
  6 |     |     // bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;
  7 |     |     // bytes32 internal constant POOL_INIT_CODE_HASH = 0xb12379ea71c3597247e852cb52b22aeda26bcd6d1a3592d19694759922192775;
  8 |     |     // bytes32 internal constant POOL_INIT_CODE_HASH = 0xfd1e5c92e9606efffd8781db6f1612b9a00a59fe80bd5bbe0f0f5802416e9fc0;
  9 | *   |     bytes32 internal constant POOL_INIT_CODE_HASH = 0xe2a979c1fd1b1910bcb2193f485a22f88f72aa93fa2f5d97d796d19fd21822b0;
 10 |     | 
 11 |     |     /// @notice The identifying key of the pool
 12 |     |     struct PoolKey {
 13 |     |         address token0;
 14 |     |         address token1;
 15 |     |         uint24 fee;
 16 |     |     }
 17 |     | 
 18 |     |     /// @notice Returns PoolKey: the ordered tokens with the matched fee levels
 19 |     |     /// @param tokenA The first token of a pool, unsorted
 20 |     |     /// @param tokenB The second token of a pool, unsorted
 21 |     |     /// @param fee The fee level of the pool
 22 |     |     /// @return Poolkey The pool details with ordered token0 and token1 assignments
 23 | *   |     function getPoolKey(address tokenA, address tokenB, uint24 fee) internal pure returns (PoolKey memory) {
 24 | *   |         if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);
 25 | *   |         return PoolKey({ token0: tokenA, token1: tokenB, fee: fee });
 26 |     |     }
 27 |     | 
 28 |     |     /// @notice Deterministically computes the pool address given the factory and PoolKey
 29 |     |     /// @param factory The Uniswap V3 factory contract address
 30 |     |     /// @param key The PoolKey
 31 |     |     /// @return pool The contract address of the V3 pool
 32 | *   |     function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {
 33 | *   |         require(key.token0 < key.token1);
 34 | *   |         pool = address(
 35 |     |             uint160(
 36 | *   |                 uint256(
 37 | *   |                     keccak256(
 38 | *   |                         abi.encodePacked(
 39 |     |                             hex"ff",
 40 | *   |                             factory,
 41 | *   |                             keccak256(abi.encode(key.token0, key.token1, key.fee)),
 42 | *   |                             POOL_INIT_CODE_HASH
 43 |     |                         )
 44 |     |                     )
 45 |     |                 )
 46 |     |             )
 47 |     |         );
 48 |     |     }
 49 |     | }
 50 |     | 

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/libraries/PositionKey.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | library PositionKey {
  5 |     |     /// @dev Returns the key of the position in the core library
  6 | *   |     function compute(
  7 |     |         address owner,
  8 |     |         int24 tickLower,
  9 |     |         int24 tickUpper
 10 | *   |     ) internal pure returns (bytes32) {
 11 | *   |         return keccak256(abi.encodePacked(owner, tickLower, tickUpper));
 12 |     |     }
 13 |     | }

/Users/markjonathas/Desktop/test_changes/evm-m-extensions/uniswapv3/v3-periphery/libraries/TransferHelper.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | library TransferHelper {
  7 |     |     /// @notice Transfers tokens from the targeted address to the given destination
  8 |     |     /// @notice Errors with 'STF' if transfer fails
  9 |     |     /// @param token The contract address of the token to be transferred
 10 |     |     /// @param from The originating address from which the tokens will be transferred
 11 |     |     /// @param to The destination address of the transfer
 12 |     |     /// @param value The amount to be transferred
 13 | *   |     function safeTransferFrom(address token, address from, address to, uint256 value) internal {
 14 | *   |         (bool success, bytes memory data) = token.call(
 15 | *   |             abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)
 16 |     |         );
 17 | *   |         require(success && (data.length == 0 || abi.decode(data, (bool))), "STF");
 18 |     |     }
 19 |     | 
 20 |     |     /// @notice Transfers tokens from msg.sender to a recipient
 21 |     |     /// @dev Errors with ST if transfer fails
 22 |     |     /// @param token The contract address of the token which will be transferred
 23 |     |     /// @param to The recipient of the transfer
 24 |     |     /// @param value The value of the transfer
 25 |     |     function safeTransfer(address token, address to, uint256 value) internal {
 26 |     |         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
 27 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "ST");
 28 |     |     }
 29 |     | 
 30 |     |     /// @notice Approves the stipulated contract to spend the given allowance in the given token
 31 |     |     /// @dev Errors with 'SA' if transfer fails
 32 |     |     /// @param token The contract address of the token to be approved
 33 |     |     /// @param to The target of the approval
 34 |     |     /// @param value The amount of the given token the target will be allowed to spend
 35 |     |     function safeApprove(address token, address to, uint256 value) internal {
 36 |     |         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));
 37 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "SA");
 38 |     |     }
 39 |     | 
 40 |     |     /// @notice Transfers ETH to the recipient address
 41 |     |     /// @dev Fails with `STE`
 42 |     |     /// @param to The destination of the transfer
 43 |     |     /// @param value The value to be transferred
 44 |     |     function safeTransferETH(address to, uint256 value) internal {
 45 |     |         (bool success, ) = to.call{ value: value }(new bytes(0));
 46 |     |         require(success, "STE");
 47 |     |     }
 48 |     | }
 49 |     | 

